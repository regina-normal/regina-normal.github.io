<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: regina::LPInitialTableaux&lt; LPConstraint &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1LPInitialTableaux-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::LPInitialTableaux&lt; LPConstraint &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation, in sparse form.  
 <a href="classregina_1_1LPInitialTableaux.html#details">More...</a></p>

<p><code>#include &lt;enumerate/treelp.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::LPInitialTableaux&lt; LPConstraint &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1LPInitialTableaux.png" usemap="#regina::LPInitialTableaux_3C_20LPConstraint_20_3E_map" alt=""/>
  <map id="regina::LPInitialTableaux_3C_20LPConstraint_20_3E_map" name="regina::LPInitialTableaux_3C_20LPConstraint_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; LPInitialTableaux&lt; LPConstraint &gt; &gt;" shape="rect" coords="0,0,306,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a376abe90fa884f2e7a3dab0e58dc5a5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a376abe90fa884f2e7a3dab0e58dc5a5c">LPInitialTableaux</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="classregina_1_1LPInitialTableaux.html#a1a21a4078687d6733e8fd4e78639a05e">tri</a>, <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc, bool enumeration=true)</td></tr>
<tr class="memdesc:a376abe90fa884f2e7a3dab0e58dc5a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construts this adjusted sparse matrix of matching equations.  <a href="classregina_1_1LPInitialTableaux.html#a376abe90fa884f2e7a3dab0e58dc5a5c">More...</a><br /></td></tr>
<tr class="separator:a376abe90fa884f2e7a3dab0e58dc5a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eed6f31cb2e3e5e165676d709b60b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#ac2eed6f31cb2e3e5e165676d709b60b5">LPInitialTableaux</a> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;src)</td></tr>
<tr class="memdesc:ac2eed6f31cb2e3e5e165676d709b60b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given matrix.  <a href="classregina_1_1LPInitialTableaux.html#ac2eed6f31cb2e3e5e165676d709b60b5">More...</a><br /></td></tr>
<tr class="separator:ac2eed6f31cb2e3e5e165676d709b60b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bd9e4bc3cc074767c5bfae665aafc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a35bd9e4bc3cc074767c5bfae665aafc8">LPInitialTableaux</a> (<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a35bd9e4bc3cc074767c5bfae665aafc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given matrix into this new matrix.  <a href="classregina_1_1LPInitialTableaux.html#a35bd9e4bc3cc074767c5bfae665aafc8">More...</a><br /></td></tr>
<tr class="separator:a35bd9e4bc3cc074767c5bfae665aafc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9e1d9717a1363524eb40fd75f81f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a6d9e1d9717a1363524eb40fd75f81f23">~LPInitialTableaux</a> ()</td></tr>
<tr class="memdesc:a6d9e1d9717a1363524eb40fd75f81f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix.  <a href="classregina_1_1LPInitialTableaux.html#a6d9e1d9717a1363524eb40fd75f81f23">More...</a><br /></td></tr>
<tr class="separator:a6d9e1d9717a1363524eb40fd75f81f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cec08a9d320c2a2dd6a813763ded61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#ac7cec08a9d320c2a2dd6a813763ded61">operator=</a> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;src)</td></tr>
<tr class="memdesc:ac7cec08a9d320c2a2dd6a813763ded61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given matrix.  <a href="classregina_1_1LPInitialTableaux.html#ac7cec08a9d320c2a2dd6a813763ded61">More...</a><br /></td></tr>
<tr class="separator:ac7cec08a9d320c2a2dd6a813763ded61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc758d4e3c43cbd267d5553db5760c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#afbc758d4e3c43cbd267d5553db5760c6">operator=</a> (<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:afbc758d4e3c43cbd267d5553db5760c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given matrix into this matrix.  <a href="classregina_1_1LPInitialTableaux.html#afbc758d4e3c43cbd267d5553db5760c6">More...</a><br /></td></tr>
<tr class="separator:afbc758d4e3c43cbd267d5553db5760c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4ed55cd5a1c7fbc81d98e6d602ebad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a0c4ed55cd5a1c7fbc81d98e6d602ebad">swap</a> (<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a0c4ed55cd5a1c7fbc81d98e6d602ebad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given matrix.  <a href="classregina_1_1LPInitialTableaux.html#a0c4ed55cd5a1c7fbc81d98e6d602ebad">More...</a><br /></td></tr>
<tr class="separator:a0c4ed55cd5a1c7fbc81d98e6d602ebad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a21a4078687d6733e8fd4e78639a05e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a1a21a4078687d6733e8fd4e78639a05e">tri</a> () const</td></tr>
<tr class="memdesc:a1a21a4078687d6733e8fd4e78639a05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the underlying 3-manifold triangulation from which the matching equations were derived.  <a href="classregina_1_1LPInitialTableaux.html#a1a21a4078687d6733e8fd4e78639a05e">More...</a><br /></td></tr>
<tr class="separator:a1a21a4078687d6733e8fd4e78639a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aef0ef2a99d691fc4b8ebbfe23e9f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPSystem.html">LPSystem</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a49aef0ef2a99d691fc4b8ebbfe23e9f6">system</a> () const</td></tr>
<tr class="memdesc:a49aef0ef2a99d691fc4b8ebbfe23e9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the broad class of vector encodings that this tableaux works with.  <a href="classregina_1_1LPInitialTableaux.html#a49aef0ef2a99d691fc4b8ebbfe23e9f6">More...</a><br /></td></tr>
<tr class="separator:a49aef0ef2a99d691fc4b8ebbfe23e9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade09da239057ab7584f24c8e0195f291"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#ade09da239057ab7584f24c8e0195f291">rank</a> () const</td></tr>
<tr class="memdesc:ade09da239057ab7584f24c8e0195f291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of this matrix.  <a href="classregina_1_1LPInitialTableaux.html#ade09da239057ab7584f24c8e0195f291">More...</a><br /></td></tr>
<tr class="separator:ade09da239057ab7584f24c8e0195f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fa83992953d2470850e6f12669a83c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a97fa83992953d2470850e6f12669a83c">columns</a> () const</td></tr>
<tr class="memdesc:a97fa83992953d2470850e6f12669a83c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in this matrix.  <a href="classregina_1_1LPInitialTableaux.html#a97fa83992953d2470850e6f12669a83c">More...</a><br /></td></tr>
<tr class="separator:a97fa83992953d2470850e6f12669a83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a101977c5c890592c918ed09aef0206"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a8a101977c5c890592c918ed09aef0206">coordinateColumns</a> () const</td></tr>
<tr class="memdesc:a8a101977c5c890592c918ed09aef0206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns that correspond to normal coordinates or angle structure coordinates.  <a href="classregina_1_1LPInitialTableaux.html#a8a101977c5c890592c918ed09aef0206">More...</a><br /></td></tr>
<tr class="separator:a8a101977c5c890592c918ed09aef0206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc77746df273b961112f2bc0cbb9e75c"><td class="memItemLeft" align="right" valign="top">const size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#abc77746df273b961112f2bc0cbb9e75c">columnPerm</a> () const</td></tr>
<tr class="memdesc:abc77746df273b961112f2bc0cbb9e75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permutation that describes how the columns of the matching equation matrix were reordered.  <a href="classregina_1_1LPInitialTableaux.html#abc77746df273b961112f2bc0cbb9e75c">More...</a><br /></td></tr>
<tr class="separator:abc77746df273b961112f2bc0cbb9e75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64610165b26c8d05964c177c9f38ca82"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a64610165b26c8d05964c177c9f38ca82"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a64610165b26c8d05964c177c9f38ca82">multColByRow</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, size_t mRow, size_t thisCol) const</td></tr>
<tr class="memdesc:a64610165b26c8d05964c177c9f38ca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix.  <a href="classregina_1_1LPInitialTableaux.html#a64610165b26c8d05964c177c9f38ca82">More...</a><br /></td></tr>
<tr class="separator:a64610165b26c8d05964c177c9f38ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab543ef7c7814951b81a7804e15e9c0d6"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:ab543ef7c7814951b81a7804e15e9c0d6"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#ab543ef7c7814951b81a7804e15e9c0d6">multColByRowOct</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, size_t mRow, size_t thisCol) const</td></tr>
<tr class="memdesc:ab543ef7c7814951b81a7804e15e9c0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="classregina_1_1LPInitialTableaux.html#a64610165b26c8d05964c177c9f38ca82" title="Computes the inner product of (i) the given row of the given matrix with (ii) the given column of thi...">multColByRow()</a> that takes into account any adjustments to the tableaux that are required when this is a quadrilateral column being used to represent an octagon type.  <a href="classregina_1_1LPInitialTableaux.html#ab543ef7c7814951b81a7804e15e9c0d6">More...</a><br /></td></tr>
<tr class="separator:ab543ef7c7814951b81a7804e15e9c0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16772af7dc89a65a3547bab10c4e6b1"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:aa16772af7dc89a65a3547bab10c4e6b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#aa16772af7dc89a65a3547bab10c4e6b1">fillInitialTableaux</a> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m) const</td></tr>
<tr class="memdesc:aa16772af7dc89a65a3547bab10c4e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given matrix with the contents of this matrix.  <a href="classregina_1_1LPInitialTableaux.html#aa16772af7dc89a65a3547bab10c4e6b1">More...</a><br /></td></tr>
<tr class="separator:aa16772af7dc89a65a3547bab10c4e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcea40843146d02a3c7bd2ece9347a89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#adcea40843146d02a3c7bd2ece9347a89">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:adcea40843146d02a3c7bd2ece9347a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1LPInitialTableaux.html#adcea40843146d02a3c7bd2ece9347a89">More...</a><br /></td></tr>
<tr class="separator:adcea40843146d02a3c7bd2ece9347a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a3beff1fa8e9dd2f8d55c7bdd3b99b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a95a3beff1fa8e9dd2f8d55c7bdd3b99b">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a95a3beff1fa8e9dd2f8d55c7bdd3b99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1LPInitialTableaux.html#a95a3beff1fa8e9dd2f8d55c7bdd3b99b">More...</a><br /></td></tr>
<tr class="separator:a95a3beff1fa8e9dd2f8d55c7bdd3b99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class LPConstraint&gt;<br />
class regina::LPInitialTableaux&lt; LPConstraint &gt;</div><p >Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation, in sparse form. </p>
<p >Typically these will be the normal surface matching equations in some coordinate system, or the angle structure equations.</p>
<p >This class forms part of the tree traversal algorithms for enumerating and locating normal surfaces, as described in "A tree traversal algorithm
for decision problems in knot theory and 3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801, and "A fast branching algorithm for unknot recognition with
experimental polynomial-time behaviour", Burton and Ozlen, arXiv:1211.1079. It is also used for locating a single strict angle structure, and for enumerating all taut angle structures.</p>
<p >The adjustments (which are all carried out in the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> class constructor) are as follows:</p>
<ul>
<li>the rows of the matching equation matrix have been reordered so that the first <a class="el" href="classregina_1_1LPInitialTableaux.html#ade09da239057ab7584f24c8e0195f291" title="Returns the rank of this matrix.">rank()</a> rows are full rank;</li>
<li>the columns of the matching equation matrix have been reordered according to the permutation returned by <a class="el" href="classregina_1_1LPInitialTableaux.html#abc77746df273b961112f2bc0cbb9e75c" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">columnPerm()</a>. This is a heuristic reordering designed to improve the performance of the tree traversal algorithm; see <a class="el" href="classregina_1_1LPInitialTableaux.html#abc77746df273b961112f2bc0cbb9e75c" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">columnPerm()</a> for a list of constraints that such a reordering must satisfy.</li>
</ul>
<p >There is also optional support for adding extra linear constraints (such as a constraint on Euler characteristic for normal surfaces). These extra constraints are supplied by the template parameter <em>LPConstraint</em>, and will generate LPConstraint::nConstraints additional rows and columns (used by the additional variables that evaluate the corresponding linear functions). If there are no additional constraints, simply use the template parameter <a class="el" href="classregina_1_1LPConstraintNone.html" title="A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or...">LPConstraintNone</a>.</p>
<p >For some <em>LPConstraint</em> template arguments, Regina may discover at runtime that it is impossible to add the corresponding extra linear constraints (e.g., the constraints might require some preconditions on the underlying triangulation that are not met). In this case, the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> class constructor will throw an exception, as noted in the constructor documentation below.</p>
<p >This class is optimised for working with <em>columns</em> of the matrix (in particular, multiplying columns of this matrix by rows of some other matrix).</p>
<p >This class works with a broad class of vector encodings for normal surfaces or angle structures, as described by the <a class="el" href="classregina_1_1LPSystem.html" title="Indicates which broad class of vector encodings a particular tableaux is designed to work with.">LPSystem</a> class, and within that broad class it does not know <em>which</em> particular encoding or underlying coordinate system is being used. In particular, the matching equations it uses will <em>always</em> be one of the standard tri-quad normal matching equations (if <a class="el" href="classregina_1_1LPSystem.html#a5b34c60723a239b4d9e59d95484721e7" title="Identifies whether this is the class of standard encodings.">LPSystem::standard()</a> is <code>true</code>), the quad normal matching equations (if <a class="el" href="classregina_1_1LPSystem.html#af1e9446ea914edbd57ab720fd093b973" title="Identifies whether this is the class of quad encodings.">LPSystem::quad()</a> is <code>true</code>), or the homogeneous angle equations (if LPSystem::angles() is true). If you need to add extra matching equations beyond these, use the LPConstraint template argument as outlined above. If you need to support more exotic vector encodings (e.g., for octagonal almost normal surfaces), you will need to find a way to represent it using one of these three broad classes; see the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for how this is done with octagons.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this class relies on the fact that the sum of <em>absolute values</em> of all coefficients in each column is at most four (not counting the rows for any optional extra constraints). If you are extending this class to work with more general matching equation matrices, you may need to change the implementation accordingly.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The template parameter LPConstraint must be one of the subclasses of <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a>. See the <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> class notes for further details.</dd></dl>
<dl class="section user"><dt>Headers</dt><dd>Parts of this template class are implemented in a separate header (treelp-impl.h), which is not included automatically by this file. Most end users should not need this extra header, since Regina's calculation engine already includes explicit instantiations for common combinations of template arguments.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This is a heavily templated class; nevertheless, many variants are now made available to Python users. Each class name is of the form LPInitialTableaux_<em>LPConstraint</em>, where the suffix <em>LPConstraint</em> is an abbreviated version of the <em>LPConstraint</em> template parameter; this suffix is omitted entirely for the common case <a class="el" href="classregina_1_1LPConstraintNone.html" title="A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or...">LPConstraintNone</a>. An example of such a Python class name is <code>LPInitialTableaux_NonSpun</code>. You are encouraged to look through the Regina namespace to see which constraint classes are supported under Python.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a376abe90fa884f2e7a3dab0e58dc5a5c" name="a376abe90fa884f2e7a3dab0e58dc5a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376abe90fa884f2e7a3dab0e58dc5a5c">&#9670;&nbsp;</a></span>LPInitialTableaux() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::LPInitialTableaux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enumeration</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construts this adjusted sparse matrix of matching equations. </p>
<p >Note that <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> does not copy the given triangulation; it merely keeps a reference to it. The triangulation should not change during the lifespan of this object.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>it was not possible to add the extra constraints from the LPConstraint template argument, due to an error which should have been preventable with the right checks in advance. Such exceptions are generated by the <em>LPConstraint</em> class, and so you should consult the class documentation for your chosen <em>LPConstraint</em> template argument to see if this is a possibility.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>it was not possible to add the extra constraints from the LPConstraint template argument, due to an error that was "genuinely" unforseeable. Again, such exceptions are generated by your chosen <em>LPConstraint</em> class, and you should consult its documentation to see if this is a possibility.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the underlying 3-manifold triangulation. </td></tr>
    <tr><td class="paramname">enc</td><td>the normal surface vector encoding that we are using for our enumeration task. This may be any valid <a class="el" href="classregina_1_1NormalEncoding.html" title="Indicates precisely how a normal surface is encoded by an integer vector.">NormalEncoding</a> object, including the special angle structure encoding. </td></tr>
    <tr><td class="paramname">enumeration</td><td><code>true</code> if we should optimise the tableaux for a full enumeration of vertex surfaces or taut angle structures, or <code>false</code> if we should optimise the tableaux for an existence test (such as searching for a non-trivial normal disc or sphere, or a strict angle structure). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2eed6f31cb2e3e5e165676d709b60b5" name="ac2eed6f31cb2e3e5e165676d709b60b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eed6f31cb2e3e5e165676d709b60b5">&#9670;&nbsp;</a></span>LPInitialTableaux() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::LPInitialTableaux </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35bd9e4bc3cc074767c5bfae665aafc8" name="a35bd9e4bc3cc074767c5bfae665aafc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bd9e4bc3cc074767c5bfae665aafc8">&#9670;&nbsp;</a></span>LPInitialTableaux() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::LPInitialTableaux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given matrix into this new matrix. </p>
<p >This is a fast (constant time) operation.</p>
<p >The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9e1d9717a1363524eb40fd75f81f23" name="a6d9e1d9717a1363524eb40fd75f81f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9e1d9717a1363524eb40fd75f81f23">&#9670;&nbsp;</a></span>~LPInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::~<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abc77746df273b961112f2bc0cbb9e75c" name="abc77746df273b961112f2bc0cbb9e75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc77746df273b961112f2bc0cbb9e75c">&#9670;&nbsp;</a></span>columnPerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t * <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::columnPerm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the permutation that describes how the columns of the matching equation matrix were reordered. </p>
<p >This permutation maps column numbers in this adjusted matching equation matrix to column numbers in the original (unmodified) matching equation matrix that was originally derived from the triangulation.</p>
<p >The permutation is returned as an array of <a class="el" href="classregina_1_1LPInitialTableaux.html#a97fa83992953d2470850e6f12669a83c" title="Returns the number of columns in this matrix.">columns()</a> integers, such that column <em>i</em> of this adjusted matrix corresponds to column <code><a class="el" href="classregina_1_1LPInitialTableaux.html#abc77746df273b961112f2bc0cbb9e75c" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">columnPerm()</a>[i]</code> of the original matrix.</p>
<p >If you are imposing additional constraints through the template parameter LPConstraint, then the corresponding extra variables will be included in the permutation; however, these are never moved and will always remain the rightmost variables in this system (i.e., the columns of highest index).</p>
<p >As well as the requirement that this is a genuine permutation of 0,...,<a class="el" href="classregina_1_1LPInitialTableaux.html#a97fa83992953d2470850e6f12669a83c" title="Returns the number of columns in this matrix.">columns()</a>-1, this array will also adhere to the following constraints. In the following discussion, <em>n</em> refers to the number of tetrahedra in the underlying triangulation.</p>
<ul>
<li>The quadrilateral coordinate columns must appear as the first 3<em>n</em> columns of the adjusted matrix. In particular, when working in the 7<em>n</em>-dimensional standard normal coordinate system, the remaining 4<em>n</em> triangle coordinate columns must appear last.</li>
<li>The quadrilateral coordinate columns must be grouped by tetrahedron and ordered by quadrilateral type. In other words, for each <em>i</em> = 0,...,<em>n-1</em>, there will be some tetrahedron <em>j</em> for which the three columns 3<em>i</em>, 3<em>i</em>+1 and 3<em>i</em>+2 refer to the quadrilaterals in tetrahedron <em>j</em> of types 0, 1 and 2 respectively. Phrased loosely, we are allowed to reorder the tetrahedra, but not the quadrilateral coordinates within each tetrahedron.</li>
<li>The triangle coordinate columns (if we are working in standard normal coordinates) must likewise be grouped by tetrahedron, and these tetrahedra must appear in the same order as for the quadrilateral types. In other words, for each <em>i</em> = 0,...,<em>n-1</em>, the quadrilateral columns 3<em>i</em>, 3<em>i</em>+1 and 3<em>i</em>+2 and the triangle columns 3<em>n</em>+4<em>i</em>, 3<em>n</em>+4<em>i</em>+1, 3<em>n</em>+4<em>i</em>+2 and 3<em>n</em>+4<em>i</em>+3 all refer to the same tetrahedron.</li>
<li>For angle structure coordinates, the constraints are analogous to those for quadrilateral coordinates: the angle coordinates must be grouped by tetrahedron and ordered by angle type, and the final scaling coordinate must remain last.</li>
</ul>
<dl class="section user"><dt>Python</dt><dd>This routine returns a Python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>details of the permutation describing how columns were reordered. </dd></dl>

</div>
</div>
<a id="a97fa83992953d2470850e6f12669a83c" name="a97fa83992953d2470850e6f12669a83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fa83992953d2470850e6f12669a83c">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in this matrix. </p>
<p >Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the number of columns will be larger than in the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="a8a101977c5c890592c918ed09aef0206" name="a8a101977c5c890592c918ed09aef0206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a101977c5c890592c918ed09aef0206">&#9670;&nbsp;</a></span>coordinateColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::coordinateColumns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns that correspond to normal coordinates or angle structure coordinates. </p>
<p >This is precisely the number of columns in the original matrix of matching equations.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of normal or angle structure coordinate columns. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="aa16772af7dc89a65a3547bab10c4e6b1" name="aa16772af7dc89a65a3547bab10c4e6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16772af7dc89a65a3547bab10c4e6b1">&#9670;&nbsp;</a></span>fillInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::fillInitialTableaux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given matrix with the contents of this matrix. </p>
<p >This effectively copies this sparse but highly specialised matrix representation into a dense but more flexible matrix representation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix has already been initialised to size <a class="el" href="classregina_1_1LPInitialTableaux.html#ade09da239057ab7584f24c8e0195f291" title="Returns the rank of this matrix.">rank()</a> * <a class="el" href="classregina_1_1LPInitialTableaux.html#a97fa83992953d2470850e6f12669a83c" title="Returns the number of columns in this matrix.">columns()</a>, and all of its elements have already been set to zero. Note that this can all be arranged by calling the constructor <a class="el" href="classregina_1_1LPMatrix.html#aae21a0adb49c6d959bf6935f7348a300" title="Creates a fully initialised rows by cols matrix with all elements set to zero.">LPMatrix::LPMatrix(size_t, size_t)</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64610165b26c8d05964c177c9f38ca82" name="a64610165b26c8d05964c177c9f38ca82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64610165b26c8d05964c177c9f38ca82">&#9670;&nbsp;</a></span>multColByRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::multColByRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thisCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix. </p>
<p >This routine is optimised to use the sparse representation of columns in this matrix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix <em>m</em> has precisely <a class="el" href="classregina_1_1LPInitialTableaux.html#ade09da239057ab7584f24c8e0195f291" title="Returns the rank of this matrix.">rank()</a> columns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the inner product. </td></tr>
    <tr><td class="paramname">thisCol</td><td>the column of this matrix to use in the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting inner product. </dd></dl>

</div>
</div>
<a id="ab543ef7c7814951b81a7804e15e9c0d6" name="ab543ef7c7814951b81a7804e15e9c0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab543ef7c7814951b81a7804e15e9c0d6">&#9670;&nbsp;</a></span>multColByRowOct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::multColByRowOct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thisCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="classregina_1_1LPInitialTableaux.html#a64610165b26c8d05964c177c9f38ca82" title="Computes the inner product of (i) the given row of the given matrix with (ii) the given column of thi...">multColByRow()</a> that takes into account any adjustments to the tableaux that are required when this is a quadrilateral column being used to represent an octagon type. </p>
<p >The <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class offers support for octagonal almost normal surfaces, in which exactly one tetrahedron is allowed to have exactly one octagon type. We represent such an octagon as a <em>pair</em> of incompatible quadrilaterals within the same tetrahedron. See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details on how this works.</p>
<p >In some settings where we are using additional constraints through the template parameter LPConstraint, these extra constraints behave differently in the presence of octagons (i.e., the coefficient of the octagon type is not just the sum of coefficients of the two constituent quadrilateral types). This routine effectively allows us to adjust the tableaux accordingly.</p>
<p >Specifically: this routine computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix. We assume that the given column of this matrix describes one of the two quadrilateral coordinates in some tetrahedron that together form an octagon type, and (via the information given by LPConstraint::octAdjustment) we implicitly adjust the coefficients of our extra constraints accordingly.</p>
<p >This routine is optimised to use the sparse representation of columns in this matrix.</p>
<p >This routine is not used with angle structure coordinates.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix <em>m</em> has precisely <a class="el" href="classregina_1_1LPInitialTableaux.html#ade09da239057ab7584f24c8e0195f291" title="Returns the rank of this matrix.">rank()</a> columns.</dd>
<dd>
Column <em>thisCol</em> of this matrix describes one of the two quadrilateral coordinates that are being combined to form an octagon type within some tetrahedron.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the adjusted inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the adjusted inner product. </td></tr>
    <tr><td class="paramname">thisCol</td><td>the column of this matrix to use in the adjusted inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting adjusted inner product. </dd></dl>

</div>
</div>
<a id="ac7cec08a9d320c2a2dd6a813763ded61" name="ac7cec08a9d320c2a2dd6a813763ded61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7cec08a9d320c2a2dd6a813763ded61">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp; <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given matrix. </p>
<p >It does not matter if this and the given matrix have different sizes and/or work with different vector encodings; if so then these properties will be copied across also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this matrix. </dd></dl>

</div>
</div>
<a id="afbc758d4e3c43cbd267d5553db5760c6" name="afbc758d4e3c43cbd267d5553db5760c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc758d4e3c43cbd267d5553db5760c6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp; <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given matrix into this matrix. </p>
<p >This is a fast (constant time) operation.</p>
<p >It does not matter if this and the given matrix have different sizes and/or work with different vector encodings; if so then these properties will be moved across also.</p>
<p >The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this matrix. </dd></dl>

</div>
</div>
<a id="ade09da239057ab7584f24c8e0195f291" name="ade09da239057ab7584f24c8e0195f291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade09da239057ab7584f24c8e0195f291">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::rank</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of this matrix. </p>
<p >Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the rank will be larger than the rank of the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix rank. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a0c4ed55cd5a1c7fbc81d98e6d602ebad" name="a0c4ed55cd5a1c7fbc81d98e6d602ebad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c4ed55cd5a1c7fbc81d98e6d602ebad">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given matrix. </p>
<p >It does not matter if the two matrices have different sizes, and/or work with different vector encodings; if so then these properties will be swapped also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49aef0ef2a99d691fc4b8ebbfe23e9f6" name="a49aef0ef2a99d691fc4b8ebbfe23e9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49aef0ef2a99d691fc4b8ebbfe23e9f6">&#9670;&nbsp;</a></span>system()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPSystem.html">LPSystem</a> <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::system</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the broad class of vector encodings that this tableaux works with. </p>
<p >This broad class is deduced from the vector encoding that was passed to the class constructor, and it completely determines which matching equations were generated as a result.</p>
<p >See the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> class notes for more information on these three broad classes and how they affect the tableaux.</p>
<dl class="section return"><dt>Returns</dt><dd>the class of vector encodings used by this tableaux. </dd></dl>

</div>
</div>
<a id="a1a21a4078687d6733e8fd4e78639a05e" name="a1a21a4078687d6733e8fd4e78639a05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a21a4078687d6733e8fd4e78639a05e">&#9670;&nbsp;</a></span>tri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp; <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::tri</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the underlying 3-manifold triangulation from which the matching equations were derived. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; LPConstraint &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a95a3beff1fa8e9dd2f8d55c7bdd3b99b" name="a95a3beff1fa8e9dd2f8d55c7bdd3b99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a3beff1fa8e9dd2f8d55c7bdd3b99b">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcea40843146d02a3c7bd2ece9347a89" name="adcea40843146d02a3c7bd2ece9347a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcea40843146d02a3c7bd2ece9347a89">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>enumerate/<a class="el" href="treeconstraint_8h.html">treeconstraint.h</a></li>
<li>enumerate/<a class="el" href="treelp_8h.html">treelp.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
