<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: regina::PacketChildren&lt; const_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1PacketChildren-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::PacketChildren&lt; const_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__packet.html">Basic Packet Types</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A lightweight object that gives access to all immediate children of a given packet.  
 <a href="classregina_1_1PacketChildren.html#details">More...</a></p>

<p><code>#include &lt;packet/packet.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a504cd2c92ba12dd8d1593524f7a45fa2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#a504cd2c92ba12dd8d1593524f7a45fa2">packet_type</a> = std::conditional_t&lt; const_, const <a class="el" href="classregina_1_1Packet.html">Packet</a>, <a class="el" href="classregina_1_1Packet.html">Packet</a> &gt;</td></tr>
<tr class="memdesc:a504cd2c92ba12dd8d1593524f7a45fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either <code><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code> or <code>const <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code>, according to the template argument <em>const_</em>.  <a href="classregina_1_1PacketChildren.html#a504cd2c92ba12dd8d1593524f7a45fa2">More...</a><br /></td></tr>
<tr class="separator:a504cd2c92ba12dd8d1593524f7a45fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abbd1d4e4654d3d79b3c32a2234e2dedc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#abbd1d4e4654d3d79b3c32a2234e2dedc">PacketChildren</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:abbd1d4e4654d3d79b3c32a2234e2dedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="classregina_1_1PacketChildren.html#abbd1d4e4654d3d79b3c32a2234e2dedc">More...</a><br /></td></tr>
<tr class="separator:abbd1d4e4654d3d79b3c32a2234e2dedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9177080f8db5b4abbb8d4c15f0304db"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#af9177080f8db5b4abbb8d4c15f0304db">PacketChildren</a> (std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketChildren.html#a504cd2c92ba12dd8d1593524f7a45fa2">packet_type</a> &gt; parent)</td></tr>
<tr class="memdesc:af9177080f8db5b4abbb8d4c15f0304db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the immediate children of the given packet.  <a href="classregina_1_1PacketChildren.html#af9177080f8db5b4abbb8d4c15f0304db">More...</a><br /></td></tr>
<tr class="separator:af9177080f8db5b4abbb8d4c15f0304db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4129cb0664d21c30704a083fe8c971d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#ab4129cb0664d21c30704a083fe8c971d">operator=</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:ab4129cb0664d21c30704a083fe8c971d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="classregina_1_1PacketChildren.html#ab4129cb0664d21c30704a083fe8c971d">More...</a><br /></td></tr>
<tr class="separator:ab4129cb0664d21c30704a083fe8c971d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7416da234efb37de5ac06ed0a27719ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#a7416da234efb37de5ac06ed0a27719ef">begin</a> () const</td></tr>
<tr class="memdesc:a7416da234efb37de5ac06ed0a27719ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator at the beginning of the range of children.  <a href="classregina_1_1PacketChildren.html#a7416da234efb37de5ac06ed0a27719ef">More...</a><br /></td></tr>
<tr class="separator:a7416da234efb37de5ac06ed0a27719ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8028a5779a3216d31c4c573cebd728"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#a6d8028a5779a3216d31c4c573cebd728">end</a> () const</td></tr>
<tr class="memdesc:a6d8028a5779a3216d31c4c573cebd728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator at the end of the range of children.  <a href="classregina_1_1PacketChildren.html#a6d8028a5779a3216d31c4c573cebd728">More...</a><br /></td></tr>
<tr class="separator:a6d8028a5779a3216d31c4c573cebd728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423c41d132bcf252452a4007bd754bbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#a423c41d132bcf252452a4007bd754bbf">operator==</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a423c41d132bcf252452a4007bd754bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object are designed to iterate over children of the same parent packet.  <a href="classregina_1_1PacketChildren.html#a423c41d132bcf252452a4007bd754bbf">More...</a><br /></td></tr>
<tr class="separator:a423c41d132bcf252452a4007bd754bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2601db337e6fb3a7c4ab832758f19c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html#a4e2601db337e6fb3a7c4ab832758f19c">operator!=</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a4e2601db337e6fb3a7c4ab832758f19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object are designed to iterate over children of different parent packets.  <a href="classregina_1_1PacketChildren.html#a4e2601db337e6fb3a7c4ab832758f19c">More...</a><br /></td></tr>
<tr class="separator:a4e2601db337e6fb3a7c4ab832758f19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;bool const_&gt;<br />
class regina::PacketChildren&lt; const_ &gt;</div><p >A lightweight object that gives access to all immediate children of a given packet. </p>
<p >The purpose of this class is to support iteration through all children of a packet <em>p</em> using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;Packet&gt; parent = ...;</div>
<div class="line"><span class="keywordflow">for</span> (Packet&amp; child : parent-&gt;children()) { ... }</div>
</div><!-- fragment --><p >In Python, <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> is an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div>
<div class="line"><span class="keywordflow">for</span> child <span class="keywordflow">in</span> parent.children():</div>
<div class="line">    ...</div>
</div><!-- fragment --><p >Each object of this class will hold a std::shared_ptr to the packet whose children it gives access to. This guarantees that the packet will not be destroyed during iteration, but it also means that you must ensure that you dispose of these objects once you are finished with them.</p>
<p >These are lightweight objects, small enough to pass by value and swap with <a class="el" href="group__algebra.html#ga3d2f68e8a75ce7b663269c104346f937" title="Swaps the contents of the two given abelian groups.">std::swap()</a>, with no need for any specialised move operations or swap functions. Copies of a <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> will iterate over the children of the same underlying packet.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">const_</td><td>Indicates whether this iterator should offer const or non-const access to the child packets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of the C++ interface described here, in Python the classes <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> and <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> together implement the Python iterable/iterator interface. The class <a class="el" href="classregina_1_1PacketChildren.html" title="A lightweight object that gives access to all immediate children of a given packet.">PacketChildren</a> has just the single function <code><b>iter</b>()</code>, which returns a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a>; then <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> implements <code>next()</code>, which either returns the next child packet in the iteration or else throws a <code>StopException</code> if there are no more children to return. All iteration in Python is non-const (i.e., Python exclusively uses the classes where <em>const_</em> is <code>false</code>). </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a504cd2c92ba12dd8d1593524f7a45fa2" name="a504cd2c92ba12dd8d1593524f7a45fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504cd2c92ba12dd8d1593524f7a45fa2">&#9670;&nbsp;</a></span>packet_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::packet_type =  std::conditional_t&lt;const_, const <a class="el" href="classregina_1_1Packet.html">Packet</a>, <a class="el" href="classregina_1_1Packet.html">Packet</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Either <code><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code> or <code>const <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a></code>, according to the template argument <em>const_</em>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abbd1d4e4654d3d79b3c32a2234e2dedc" name="abbd1d4e4654d3d79b3c32a2234e2dedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd1d4e4654d3d79b3c32a2234e2dedc">&#9670;&nbsp;</a></span>PacketChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="af9177080f8db5b4abbb8d4c15f0304db" name="af9177080f8db5b4abbb8d4c15f0304db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9177080f8db5b4abbb8d4c15f0304db">&#9670;&nbsp;</a></span>PacketChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketChildren.html#a504cd2c92ba12dd8d1593524f7a45fa2">packet_type</a> &gt;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the immediate children of the given packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the packet whose children we will iterate through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7416da234efb37de5ac06ed0a27719ef" name="a7416da234efb37de5ac06ed0a27719ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7416da234efb37de5ac06ed0a27719ef">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt; <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator at the beginning of the range of children. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code><b>iter</b>()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning iterator. </dd></dl>

</div>
</div>
<a id="a6d8028a5779a3216d31c4c573cebd728" name="a6d8028a5779a3216d31c4c573cebd728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8028a5779a3216d31c4c573cebd728">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&lt; const_ &gt; <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator at the end of the range of children. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code><b>iter</b>()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the past-the-end iterator. </dd></dl>

</div>
</div>
<a id="a4e2601db337e6fb3a7c4ab832758f19c" name="a4e2601db337e6fb3a7c4ab832758f19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2601db337e6fb3a7c4ab832758f19c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object are designed to iterate over children of different parent packets. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object and <em>rhs</em> iterate over children of different packets. </dd></dl>

</div>
</div>
<a id="ab4129cb0664d21c30704a083fe8c971d" name="ab4129cb0664d21c30704a083fe8c971d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4129cb0664d21c30704a083fe8c971d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp; <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="a423c41d132bcf252452a4007bd754bbf" name="a423c41d132bcf252452a4007bd754bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423c41d132bcf252452a4007bd754bbf">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool const_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a>&lt; const_ &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&lt; const_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object are designed to iterate over children of the same parent packet. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object and <em>rhs</em> iterate over children of the same packet. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packet/<a class="el" href="packet_8h.html">packet.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
