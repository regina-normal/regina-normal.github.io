<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1TreeEnumeration-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal surfaces in a 3-manifold triangulation.  
 <a href="classregina_1_1TreeEnumeration.html#details">More...</a></p>

<p><code>#include &lt;enumerate/treetraversal.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1TreeEnumeration.png" usemap="#regina::TreeEnumeration_3C_20LPConstraint_2C_20BanConstraint_2C_20IntType_20_3E_map" alt=""/>
  <map id="regina::TreeEnumeration_3C_20LPConstraint_2C_20BanConstraint_2C_20IntType_20_3E_map" name="regina::TreeEnumeration_3C_20LPConstraint_2C_20BanConstraint_2C_20IntType_20_3E_map">
<area href="classregina_1_1TreeTraversal.html" alt="regina::TreeTraversal&lt; LPConstraintNone, BanNone, Integer &gt;" shape="rect" coords="0,112,466,136"/>
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; TreeTraversal&lt; LPConstraintNone, BanNone, Integer &gt; &gt;" shape="rect" coords="0,56,466,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; TreeTraversal&lt; LPConstraintNone, BanNone, Integer &gt;, false &gt;" shape="rect" coords="0,0,466,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2616b3a27325869dde2e05e703b50e6f"><td class="memTemplParams" colspan="2">template&lt;typename... BanArgs&gt; </td></tr>
<tr class="memitem:a2616b3a27325869dde2e05e703b50e6f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeEnumeration.html#a2616b3a27325869dde2e05e703b50e6f">TreeEnumeration</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri, <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc, BanArgs &amp;&amp;... banArgs)</td></tr>
<tr class="memdesc:a2616b3a27325869dde2e05e703b50e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for running the tree traversal algorithm.  <a href="classregina_1_1TreeEnumeration.html#a2616b3a27325869dde2e05e703b50e6f">More...</a><br /></td></tr>
<tr class="separator:a2616b3a27325869dde2e05e703b50e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab5a429b783d4be21f34e5fa234cbd6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeEnumeration.html#aaab5a429b783d4be21f34e5fa234cbd6">solutions</a> () const</td></tr>
<tr class="memdesc:aaab5a429b783d4be21f34e5fa234cbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of vertex normal or almost normal surfaces found thus far in the tree traversal search.  <a href="classregina_1_1TreeEnumeration.html#aaab5a429b783d4be21f34e5fa234cbd6">More...</a><br /></td></tr>
<tr class="separator:aaab5a429b783d4be21f34e5fa234cbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041c6fa36dcdd0153b821e3719faa3a8"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a041c6fa36dcdd0153b821e3719faa3a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8">run</a> (Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a041c6fa36dcdd0153b821e3719faa3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.  <a href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8">More...</a><br /></td></tr>
<tr class="separator:a041c6fa36dcdd0153b821e3719faa3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8894b5e9db9134b4f9fc09b4b8ffc9a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0">next</a> (<a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a8894b5e9db9134b4f9fc09b4b8ffc9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An incremental step in the tree traversal algorithm that runs forward until it finds the next solution.  <a href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0">More...</a><br /></td></tr>
<tr class="separator:a8894b5e9db9134b4f9fc09b4b8ffc9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42382c8a0ed8babd5f25f85619957a29"><td class="memItemLeft" align="right" valign="top"><a id="a42382c8a0ed8babd5f25f85619957a29" name="a42382c8a0ed8babd5f25f85619957a29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TreeEnumeration</b> (const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;)=delete</td></tr>
<tr class="separator:a42382c8a0ed8babd5f25f85619957a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52bb894cb194cff8a9e16ead7ba06b1"><td class="memItemLeft" align="right" valign="top"><a id="ad52bb894cb194cff8a9e16ead7ba06b1" name="ad52bb894cb194cff8a9e16ead7ba06b1"></a>
<a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;)=delete</td></tr>
<tr class="separator:ad52bb894cb194cff8a9e16ead7ba06b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ed3d9cadd9cc11c6f3a29a8011d731"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#af6ed3d9cadd9cc11c6f3a29a8011d731">visited</a> () const</td></tr>
<tr class="memdesc:af6ed3d9cadd9cc11c6f3a29a8011d731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of nodes in the search tree that we have visited thus far in the tree traversal.  <a href="classregina_1_1TreeTraversal.html#af6ed3d9cadd9cc11c6f3a29a8011d731">More...</a><br /></td></tr>
<tr class="separator:af6ed3d9cadd9cc11c6f3a29a8011d731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17103e248164f04e3b5d50b322cf772e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a17103e248164f04e3b5d50b322cf772e">dumpTypes</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a17103e248164f04e3b5d50b322cf772e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the current type vector to the given output stream.  <a href="classregina_1_1TreeTraversal.html#a17103e248164f04e3b5d50b322cf772e">More...</a><br /></td></tr>
<tr class="separator:a17103e248164f04e3b5d50b322cf772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f72b79d6334325190f788bec757f44"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a05f72b79d6334325190f788bec757f44">typeString</a> () const</td></tr>
<tr class="memdesc:a05f72b79d6334325190f788bec757f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current type vector in string form.  <a href="classregina_1_1TreeTraversal.html#a05f72b79d6334325190f788bec757f44">More...</a><br /></td></tr>
<tr class="separator:a05f72b79d6334325190f788bec757f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5502207d74053d407db4bef998dfc160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a5502207d74053d407db4bef998dfc160">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a5502207d74053d407db4bef998dfc160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1TreeTraversal.html#a5502207d74053d407db4bef998dfc160">More...</a><br /></td></tr>
<tr class="separator:a5502207d74053d407db4bef998dfc160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad867086232db92f412c4f803a681a319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#ad867086232db92f412c4f803a681a319">buildSurface</a> () const</td></tr>
<tr class="memdesc:ad867086232db92f412c4f803a681a319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the full normal surface that is represented by the type vector at the current stage of the search.  <a href="classregina_1_1TreeTraversal.html#ad867086232db92f412c4f803a681a319">More...</a><br /></td></tr>
<tr class="separator:ad867086232db92f412c4f803a681a319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea610f6ed825f1050e0bc84d0513d75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#adea610f6ed825f1050e0bc84d0513d75">buildStructure</a> () const</td></tr>
<tr class="memdesc:adea610f6ed825f1050e0bc84d0513d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the full taut angle structure that is represented by the type vector at the current stage of the search.  <a href="classregina_1_1TreeTraversal.html#adea610f6ed825f1050e0bc84d0513d75">More...</a><br /></td></tr>
<tr class="separator:adea610f6ed825f1050e0bc84d0513d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5641da38d1775c4d40cc0d56cec31896"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeEnumeration.html#a5641da38d1775c4d40cc0d56cec31896">writeTypes</a> (const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;tree)</td></tr>
<tr class="memdesc:a5641da38d1775c4d40cc0d56cec31896"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that writes to standard output the type vector at the current point in the given tree traversal search.  <a href="classregina_1_1TreeEnumeration.html#a5641da38d1775c4d40cc0d56cec31896">More...</a><br /></td></tr>
<tr class="separator:a5641da38d1775c4d40cc0d56cec31896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19d14f8b6c96f91a6e3f3bb6fa8951b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeEnumeration.html#af19d14f8b6c96f91a6e3f3bb6fa8951b">writeSurface</a> (const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a> &amp;tree)</td></tr>
<tr class="memdesc:af19d14f8b6c96f91a6e3f3bb6fa8951b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback function that writes to standard output the full triangle-quadrilateral coordinates of the vertex normal or almost normal surface at the current point in the given tree traversal search.  <a href="classregina_1_1TreeEnumeration.html#af19d14f8b6c96f91a6e3f3bb6fa8951b">More...</a><br /></td></tr>
<tr class="separator:af19d14f8b6c96f91a6e3f3bb6fa8951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22527577d895f00e9d5f1db85c7960e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#aa22527577d895f00e9d5f1db85c7960e">supported</a> (<a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> enc)</td></tr>
<tr class="memdesc:aa22527577d895f00e9d5f1db85c7960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the given normal surface or angle structure vector encoding is supported by this tree traversal infrastructure.  <a href="classregina_1_1TreeTraversal.html#aa22527577d895f00e9d5f1db85c7960e">More...</a><br /></td></tr>
<tr class="separator:aa22527577d895f00e9d5f1db85c7960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeedf584e81fe0fba353218dd983f9bd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#aeedf584e81fe0fba353218dd983f9bd5">setNext</a> (size_t nextType)</td></tr>
<tr class="memdesc:aeedf584e81fe0fba353218dd983f9bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearranges the search tree so that <em>nextType</em> becomes the next type that we process.  <a href="classregina_1_1TreeTraversal.html#aeedf584e81fe0fba353218dd983f9bd5">More...</a><br /></td></tr>
<tr class="separator:aeedf584e81fe0fba353218dd983f9bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3cc8277d3cf275eb878ef9157f209b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a7e3cc8277d3cf275eb878ef9157f209b">nextUnmarkedTriangleType</a> (size_t startFrom)</td></tr>
<tr class="memdesc:a7e3cc8277d3cf275eb878ef9157f209b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the next unmarked triangle type from a given starting point.  <a href="classregina_1_1TreeTraversal.html#a7e3cc8277d3cf275eb878ef9157f209b">More...</a><br /></td></tr>
<tr class="separator:a7e3cc8277d3cf275eb878ef9157f209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3a3a9cb225c25026bd0fc46615b54e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a6f3a3a9cb225c25026bd0fc46615b54e">feasibleBranches</a> (size_t quadType)</td></tr>
<tr class="memdesc:a6f3a3a9cb225c25026bd0fc46615b54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines how many different values we could assign to the given quadrilateral or angle type and still obtain a feasible system.  <a href="classregina_1_1TreeTraversal.html#a6f3a3a9cb225c25026bd0fc46615b54e">More...</a><br /></td></tr>
<tr class="separator:a6f3a3a9cb225c25026bd0fc46615b54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b02f4672e87c516777b146ab70bd5fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a0b02f4672e87c516777b146ab70bd5fa">percent</a> () const</td></tr>
<tr class="memdesc:a0b02f4672e87c516777b146ab70bd5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a rough estimate as to what percentage of the way the current type vector is through a full enumeration of the search tree.  <a href="classregina_1_1TreeTraversal.html#a0b02f4672e87c516777b146ab70bd5fa">More...</a><br /></td></tr>
<tr class="separator:a0b02f4672e87c516777b146ab70bd5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a883cfd719b17e7ddde2093019e8213d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a883cfd719b17e7ddde2093019e8213d4">origTableaux_</a></td></tr>
<tr class="memdesc:a883cfd719b17e7ddde2093019e8213d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm begins.  <a href="classregina_1_1TreeTraversal.html#a883cfd719b17e7ddde2093019e8213d4">More...</a><br /></td></tr>
<tr class="separator:a883cfd719b17e7ddde2093019e8213d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00dd879e1473ca168fbdfcda0f4d3091"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a00dd879e1473ca168fbdfcda0f4d3091">enc_</a></td></tr>
<tr class="memdesc:a00dd879e1473ca168fbdfcda0f4d3091"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normal surface or angle structure vector encoding that we are using for our enumeration task.  <a href="classregina_1_1TreeTraversal.html#a00dd879e1473ca168fbdfcda0f4d3091">More...</a><br /></td></tr>
<tr class="separator:a00dd879e1473ca168fbdfcda0f4d3091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe120ba227cec8d77a8909a1f137ba0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1BanNone.html">BanNone</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a9fe120ba227cec8d77a8909a1f137ba0">ban_</a></td></tr>
<tr class="memdesc:a9fe120ba227cec8d77a8909a1f137ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of any banning/marking constraints that are in use.  <a href="classregina_1_1TreeTraversal.html#a9fe120ba227cec8d77a8909a1f137ba0">More...</a><br /></td></tr>
<tr class="separator:a9fe120ba227cec8d77a8909a1f137ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeff696b969d4a5908cc3deb21d4022"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#aefeff696b969d4a5908cc3deb21d4022">nTets_</a></td></tr>
<tr class="memdesc:aefeff696b969d4a5908cc3deb21d4022"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of tetrahedra in the underlying triangulation.  <a href="classregina_1_1TreeTraversal.html#aefeff696b969d4a5908cc3deb21d4022">More...</a><br /></td></tr>
<tr class="separator:aefeff696b969d4a5908cc3deb21d4022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936bcc7664f344467cdf812f52c0f32f"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a936bcc7664f344467cdf812f52c0f32f">nTypes_</a></td></tr>
<tr class="memdesc:a936bcc7664f344467cdf812f52c0f32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total length of a type vector.  <a href="classregina_1_1TreeTraversal.html#a936bcc7664f344467cdf812f52c0f32f">More...</a><br /></td></tr>
<tr class="separator:a936bcc7664f344467cdf812f52c0f32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e564a26df7f0b882c80027e90a69fe"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#af5e564a26df7f0b882c80027e90a69fe">nTableaux_</a></td></tr>
<tr class="memdesc:af5e564a26df7f0b882c80027e90a69fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of tableaux that we need to keep in memory at any given time during the backtracking search.  <a href="classregina_1_1TreeTraversal.html#af5e564a26df7f0b882c80027e90a69fe">More...</a><br /></td></tr>
<tr class="separator:af5e564a26df7f0b882c80027e90a69fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f957a2834e470907a883c15694bff3d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a9f957a2834e470907a883c15694bff3d">type_</a></td></tr>
<tr class="memdesc:a9f957a2834e470907a883c15694bff3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current working type vector.  <a href="classregina_1_1TreeTraversal.html#a9f957a2834e470907a883c15694bff3d">More...</a><br /></td></tr>
<tr class="separator:a9f957a2834e470907a883c15694bff3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0ef50bcc59b6a650246d9e251974c7"><td class="memItemLeft" align="right" valign="top">size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a7c0ef50bcc59b6a650246d9e251974c7">typeOrder_</a></td></tr>
<tr class="memdesc:a7c0ef50bcc59b6a650246d9e251974c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A permutation of 0,...,<em>nTypes_-1</em> that indicates in which order we select types: the first type we select (at the root of the tree) is type_[typeOrder_[0]], and the last type we select (at the leaves of the tree) is type_[typeOrder_[nTypes_-1]].  <a href="classregina_1_1TreeTraversal.html#a7c0ef50bcc59b6a650246d9e251974c7">More...</a><br /></td></tr>
<tr class="separator:a7c0ef50bcc59b6a650246d9e251974c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01ab20444808396ff3164419d093735"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#ab01ab20444808396ff3164419d093735">level_</a></td></tr>
<tr class="memdesc:ab01ab20444808396ff3164419d093735"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current level in the search tree.  <a href="classregina_1_1TreeTraversal.html#ab01ab20444808396ff3164419d093735">More...</a><br /></td></tr>
<tr class="separator:ab01ab20444808396ff3164419d093735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b0346b05ea5dedf2466215261ae938"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a85b0346b05ea5dedf2466215261ae938">octLevel_</a></td></tr>
<tr class="memdesc:a85b0346b05ea5dedf2466215261ae938"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level at which we are enforcing an octagon type (with a strictly positive number of octagons).  <a href="classregina_1_1TreeTraversal.html#a85b0346b05ea5dedf2466215261ae938">More...</a><br /></td></tr>
<tr class="separator:a85b0346b05ea5dedf2466215261ae938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399bdd3aa3c2aad75d17b65c3b81715c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a399bdd3aa3c2aad75d17b65c3b81715c">lp_</a></td></tr>
<tr class="memdesc:a399bdd3aa3c2aad75d17b65c3b81715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores tableaux for linear programming at various nodes in the search tree.  <a href="classregina_1_1TreeTraversal.html#a399bdd3aa3c2aad75d17b65c3b81715c">More...</a><br /></td></tr>
<tr class="separator:a399bdd3aa3c2aad75d17b65c3b81715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16999f1b18c4f3738fc78ab7230c46c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a16999f1b18c4f3738fc78ab7230c46c0">lpSlot_</a></td></tr>
<tr class="memdesc:a16999f1b18c4f3738fc78ab7230c46c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recall from above that the array <em>lp_</em> stores tableaux for the current node in the search tree and all of its ancestors.  <a href="classregina_1_1TreeTraversal.html#a16999f1b18c4f3738fc78ab7230c46c0">More...</a><br /></td></tr>
<tr class="separator:a16999f1b18c4f3738fc78ab7230c46c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63265bf71e0086a5ad1e47657550a521"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a63265bf71e0086a5ad1e47657550a521">nextSlot_</a></td></tr>
<tr class="memdesc:a63265bf71e0086a5ad1e47657550a521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to the next available tableaux in lp_ that is free to use at each level of the search tree.  <a href="classregina_1_1TreeTraversal.html#a63265bf71e0086a5ad1e47657550a521">More...</a><br /></td></tr>
<tr class="separator:a63265bf71e0086a5ad1e47657550a521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9553478bfe132c76f31849b28e43d383"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#a9553478bfe132c76f31849b28e43d383">nVisited_</a></td></tr>
<tr class="memdesc:a9553478bfe132c76f31849b28e43d383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the total number of nodes in the search tree that we have visited thus far.  <a href="classregina_1_1TreeTraversal.html#a9553478bfe132c76f31849b28e43d383">More...</a><br /></td></tr>
<tr class="separator:a9553478bfe132c76f31849b28e43d383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae041b264994cb18b5dcae4ebafff7f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeTraversal.html#ae041b264994cb18b5dcae4ebafff7f16">tmpLP_</a> [4]</td></tr>
<tr class="memdesc:ae041b264994cb18b5dcae4ebafff7f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Temporary tableaux used by the function <a class="el" href="classregina_1_1TreeTraversal.html#a6f3a3a9cb225c25026bd0fc46615b54e" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> to determine which quadrilateral types or angle types have good potential for pruning the search tree.  <a href="classregina_1_1TreeTraversal.html#ae041b264994cb18b5dcae4ebafff7f16">More...</a><br /></td></tr>
<tr class="separator:ae041b264994cb18b5dcae4ebafff7f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class LPConstraint = LPConstraintNone, typename BanConstraint = BanNone, typename IntType = Integer&gt;<br />
class regina::TreeEnumeration&lt; LPConstraint, BanConstraint, IntType &gt;</div><p >The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal surfaces in a 3-manifold triangulation. </p>
<p >For the analogous algorithm to enumerate taut angle structures, see the class <a class="el" href="classregina_1_1TautEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all taut angle structures in a 3-m...">TautEnumeration</a> instead.</p>
<p >This class essentially implements the algorithm from "A tree traversal
algorithm for decision problems in knot theory and 3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801.</p>
<p >To enumerate all vertex surfaces for a given 3-manifold triangulation, simply construct a <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a> object and call <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>.</p>
<p >Alternatively, you can have more fine-grained control over the search. Instead of calling <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>, you can construct a <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a> object and repeatedly call <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> to step through each vertex surface one at a time. This allows you to pause and resume the search as you please.</p>
<p >If you simply wish to detect a single non-trivial solution under additional constraints (such as positive Euler characteristic), then use the class <a class="el" href="classregina_1_1TreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">TreeSingleSoln</a> instead, which is optimised for this purpose.</p>
<p >This tree traversal can only enumerate surfaces in quadrilateral normal coordinates (NS_QUAD), standard normal coordinates (NS_STANDARD), quadrilateral-octagon almost normal coordinates (NS_AN_QUAD_OCT), or standard almost normal coordinates (NS_AN_STANDARD). For almost normal surfaces, we allow any number of octagons (including zero), but we only allow at most one octagon <em>type</em> in the entire triangulation. No coordinate systems other than these are supported.</p>
<p >By using appropriate template parameters <em>LPConstraint</em> and/or <em>BanConstraint</em>, it is possible to impose additional linear constraints on the normal surface solution cone, and/or explicitly force particular normal coordinates to zero. In this case, the notion of "vertex surface" is modified to mean a normal surface whose coordinates lie on an extreme ray of the restricted solution cone under these additional constraints (and whose coordinates are integers with no common divisor). See the <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> and <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> class notes for details.</p>
<p >Note that some constraint classes may cause the <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a> class constructor to throw an exception; see the constructor documentation for details.</p>
<p >The template argument <em>IntType</em> indicates the integer type that will be used throughout the underlying linear programming machinery. Unless you have a good reason to do otherwise, you should use the arbitrary-precision Integer class (in which integers can grow arbitrarily large, and overflow can never occur).</p>
<p >This class is designed to manage the execution of a significant enumeration operation, and so it does not support copying, moving or swapping.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The parameter LPConstraint must be a subclass of <a class="el" href="classregina_1_1LPConstraintSubspace.html" title="A subclass of LPConstraintBase used for constraints defined entirely by homogeneous linear equations.">LPConstraintSubspace</a>, and BanConstraint must be either <a class="el" href="classregina_1_1BanNone.html" title="A do-nothing class that bans no coordinates and marks no coordinates.">BanNone</a> or a subclass of <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a>. Note in particular that the base class <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> is not enough here. See the <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a>, <a class="el" href="classregina_1_1LPConstraintSubspace.html" title="A subclass of LPConstraintBase used for constraints defined entirely by homogeneous linear equations.">LPConstraintSubspace</a> and <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> class notes for further details.</dd>
<dd>
The default constructor for the template class IntType must intialise each new integer to zero. The classes Integer and <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>, for instance, have this property.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Although the tree traversal algorithm can run in standard normal or almost normal coordinates, this is not recommended: it is likely to be <em>much</em> slower than in quadrilateral or quadrilateral-octagon coordinates respectively. Instead you should enumerate vertex solutions using quadrilateral or quadrilateral-octagon coordinates, and then use the "transform constructor" <code>NormalSurfaces(..., NS_CONV_REDUCED_TO_STD)</code>.</dd></dl>
<dl class="section user"><dt>Headers</dt><dd>Parts of this template class are implemented in a separate header (treetraversal-impl.h), which is not included automatically by this file. Most end users should not need this extra header, since Regina's calculation engine already includes explicit instantiations for common combinations of template arguments.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This is a heavily templated class; nevertheless, many variants are now made available to Python users. Each class name is of the form TreeEnumeration_<em>LPConstraint</em>_<em>BanConstraint</em>, where the suffixes <em>LPConstraint</em> and <em>BanConstraint</em> are abbreviated versions of the corresponding template parameters; these suffixes are omitted entirely for the common cases <a class="el" href="classregina_1_1LPConstraintNone.html" title="A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or...">LPConstraintNone</a> and <a class="el" href="classregina_1_1BanNone.html" title="A do-nothing class that bans no coordinates and marks no coordinates.">BanNone</a>. As an example, to enumerate non-spun normal surfaces in an ideal 3-manifold triangulation, you would use the Python class <code>TreeEnumeration_NonSpun</code>. You are encouraged to look through the Regina namespace to see which combinations of constraint classes are supported under Python. In all cases, the IntType parameter is taken to be <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2616b3a27325869dde2e05e703b50e6f" name="a2616b3a27325869dde2e05e703b50e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2616b3a27325869dde2e05e703b50e6f">&#9670;&nbsp;</a></span>TreeEnumeration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<div class="memtemplate">
template&lt;typename... BanArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::TreeEnumeration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td>
          <td class="paramname"><em>enc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BanArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>banArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for running the tree traversal algorithm. </p>
<p >This prepares the algorithm; in order to run the algorithm and enumerate vertex surfaces, you can either:</p>
<ul>
<li>call <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>, which enumerates all vertex surfaces with a single function call;</li>
<li>repeatedly call <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a>, which will step to the next vertex surface each time you call it.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Although it is supported, it is highly recommended that you do <em>not</em> run a full vertex enumeration in standard normal or almost normal coordinates (this is for performance reasons). See the class notes for further discussion and better alternatives. In normal circumstances you should run a full vertex enumeration in quadrilateral or quadrilateral-octagon coordinates only.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd>
<dd>
Both the trianglation and the given vector encoding adhere to any preconditions required by the template parameters LPConstraint and BanConstraint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>it was not possible to add the extra constraints from the LPConstraint template argument, due to an error which should have been preventable with the right checks in advance. Such exceptions are generated by the <em>LPConstraint</em> class, and so you should consult the class documentation for your chosen <em>LPConstraint</em> template argument to see if this is a possibility.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>it was not possible to add the extra constraints from the LPConstraint template argument, due to an error that was "genuinely" unforseeable. Again, such exceptions are generated by your chosen <em>LPConstraint</em> class, and you should consult its documentation to see if this is a possibility.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation in which we wish to enumerate vertex surfaces. </td></tr>
    <tr><td class="paramname">enc</td><td>the normal (or almost normal) surface vector encoding that we are working with. </td></tr>
    <tr><td class="paramname">banArgs</td><td>any additional arguments to be passed to the BanConstraint constructor, after the initial starting tableaux. For most ban constrainst classes, this list of arguments is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adea610f6ed825f1050e0bc84d0513d75" name="adea610f6ed825f1050e0bc84d0513d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea610f6ed825f1050e0bc84d0513d75">&#9670;&nbsp;</a></span>buildStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::buildStructure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs the full taut angle structure that is represented by the type vector at the current stage of the search. </p>
<p >This routine is for use only with taut angle structures, not normal or almost normal surfaces.</p>
<p >There will always be a unique taut angle structure corresponding to this type vector (this follows from the preconditions below).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This tree traversal is at a point in the search where it has found a feasible solution that represents a taut angle structure. This condition is always true after <a class="el" href="classregina_1_1TautEnumeration.html#afc24dad42490f627aa50ce6744388d09" title="An incremental step in the enumeration algorithm that runs forward until it finds the next solution.">TautEnumeration::next()</a> returns <code>true</code>, or any time that <a class="el" href="classregina_1_1TautEnumeration.html#a659b0082875d38afdef7f4fc02fa0b29" title="Runs the complete tree traversal algorithm to enumerate all taut angle structures.">TautEnumeration::run()</a> calls its callback function.</dd>
<dd>
We are working with angle structure coordinates. This will be checked (see the exception details below).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>we are not working with angle structure coordinates (i.e., the coordinate system passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor was not NS_ANGLE).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the taut angle structure that has been found at the current stage of the search. </dd></dl>

</div>
</div>
<a id="ad867086232db92f412c4f803a681a319" name="ad867086232db92f412c4f803a681a319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad867086232db92f412c4f803a681a319">&#9670;&nbsp;</a></span>buildSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::buildSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs the full normal surface that is represented by the type vector at the current stage of the search. </p>
<p >This routine is for use only with normal (or almost normal) surfaces, not taut angle structures.</p>
<p >If the current type vector does not represent a <em>vertex</em> normal surface (which may be the case when calling <a class="el" href="classregina_1_1TreeSingleSoln.html#af6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">TreeSingleSoln::find()</a>), then there may be many normal surfaces all represented by the same type vector; in this case there are no further guarantees about <em>which</em> of these normal surfaces you will get.</p>
<p >The surface that is returned will use the same vector encoding that was passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> class constructor.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This tree traversal is at a point in the search where it has found a feasible solution that represents a normal surface (though this need not be a vertex surface). This condition is always true after <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> or <a class="el" href="classregina_1_1TreeSingleSoln.html#af6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">TreeSingleSoln::find()</a> returns <code>true</code>, or any time that <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">TreeEnumeration::run()</a> calls its callback function.</dd>
<dd>
We are working with normal or almost normal surfaces. This will be checked (see the exception details below).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>we are not working with normal or almost normal surfaces (i.e., the coordinate system passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor was NS_ANGLE).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a normal surface that has been found at the current stage of the search. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="classregina_1_1BanNone.html">BanNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a17103e248164f04e3b5d50b322cf772e" name="a17103e248164f04e3b5d50b322cf772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17103e248164f04e3b5d50b322cf772e">&#9670;&nbsp;</a></span>dumpTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::dumpTypes </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the current type vector to the given output stream. </p>
<p >There will be no spaces between the types, and there will be no final newline.</p>
<p >This routine outputs the same information that <a class="el" href="classregina_1_1TreeTraversal.html#a05f72b79d6334325190f788bec757f44" title="Returns the current type vector in string form.">typeString()</a> returns.</p>
<dl class="section user"><dt>Python</dt><dd>Not rpesent; instead use <a class="el" href="classregina_1_1TreeTraversal.html#a05f72b79d6334325190f788bec757f44" title="Returns the current type vector in string form.">typeString()</a>, which returns this same information as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f3a3a9cb225c25026bd0fc46615b54e" name="a6f3a3a9cb225c25026bd0fc46615b54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3a3a9cb225c25026bd0fc46615b54e">&#9670;&nbsp;</a></span>feasibleBranches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::feasibleBranches </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>quadType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines how many different values we could assign to the given quadrilateral or angle type and still obtain a feasible system. </p>
<p >This will involve solving three or four linear programs, all based on the current state of the tableaux at the current level of the search tree. These assign 0, 1, 2 and 3 to the given quadrilateral or angle type in turn (here 0 is not used for angle types), and then enforce the corresponding constraints. For quadrilateral types, we count types 0 and 1 separately as in <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a>, not merged together as in <a class="el" href="classregina_1_1TreeSingleSoln.html" title="The main entry point for the tree traversal / branching algorithm to locate a single non-trivial norm...">TreeSingleSoln</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given quadrilateral or angle type has not yet been processed in the search tree (i.e., it has not had an explicit value selected).</dd>
<dd>
When using angle structure coordinates, the final scaling coordinate has already been enforced as positive. (This is because, for angle structures, this routine does nothing to eliminate the zero solution.)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quadType</td><td>the quadrilateral or angle type to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of type values 0, 1, 2 or 3 that yield a feasible system; this will be between 0 and 4 inclusive for quadrilateral types, or between 0 and 3 inclusive for angle types. </dd></dl>

</div>
</div>
<a id="a8894b5e9db9134b4f9fc09b4b8ffc9a0" name="a8894b5e9db9134b4f9fc09b4b8ffc9a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8894b5e9db9134b4f9fc09b4b8ffc9a0">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint  = LPConstraintNone, typename BanConstraint  = BanNone, typename IntType  = Integer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An incremental step in the tree traversal algorithm that runs forward until it finds the next solution. </p>
<p >Specifically: this continues the tree traversal from the current point until either it finds the next vertex normal or almost normal surface (in which case it returns <code>true</code>), or until the tree traversal is completely finished with no more solutions to be found (in which case it returns <code>false</code>).</p>
<p >If you simply wish to find and process all vertex surfaces, you may wish to consider the all-in-one routine <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> instead. By using <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> to step through one solution at a time however, you obtain more fine-grained control: for instance, you can "pause" and restart the search, or have tighter control over multithreading.</p>
<p >If <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> does return <code>true</code> because it found a solution, you can extract details of the solution directly from this tree enumeration object: for instance, you can dump the type vector using <a class="el" href="classregina_1_1TreeTraversal.html#a17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a>, or you can reconstruct the full normal or almost normal surface using <a class="el" href="classregina_1_1TreeTraversal.html#ad867086232db92f412c4f803a681a319" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a> and perform some other operations upon it.</p>
<p >An optional progress tracker may be passed. If so, this routine will update the percentage progress and poll for cancellation requests. It will be assumed that an appropriate stage has already been declared via <a class="el" href="classregina_1_1ProgressTracker.html#a8314e4ebdf310557b2bf1360ea0aa930" title="Used by the writing thread to indicate that it has moved on to a new stage of processing.">ProgressTracker::newStage()</a> before this routine is called, and that <a class="el" href="classregina_1_1ProgressTracker.html#a1be2435ff4be81c75730a5fb64bea54d" title="Used by the writing thread to indicate that it has finished all processing.">ProgressTracker::setFinished()</a> will be called after this routine returns (and presumably not until the entire search tree is exhausted). The percentage progress will be given in the context of a complete enumeration of the entire search tree (i.e., it will typically start at a percentage greater than 0, and end at a percentage less than 100).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tree traversal algorithm has not yet finished. That is, you have not called <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> before, and if you have called <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> then it has always returned <code>true</code> (indicating that it has not yet finished the search).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this function runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if we found another vertex surface, or <code>false</code> if the search has now finished and no more vertex surfaces were found. </dd></dl>

</div>
</div>
<a id="a7e3cc8277d3cf275eb878ef9157f209b" name="a7e3cc8277d3cf275eb878ef9157f209b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3cc8277d3cf275eb878ef9157f209b">&#9670;&nbsp;</a></span>nextUnmarkedTriangleType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::nextUnmarkedTriangleType </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startFrom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the next unmarked triangle type from a given starting point. </p>
<p >Specifically, this routine returns the first unmarked triangle type whose type number is greater than or equal to <em>startFrom</em>. For more information on marking, see the <a class="el" href="classregina_1_1BanConstraintBase.html" title="A base class for additional banning and marking constraints that we can place on tree traversal algor...">BanConstraintBase</a> class notes.</p>
<p >This routine simply searches through types by increasing index into the type vector; in particular, it does <em>not</em> make any use of the reordering defined by the <em>typeOrder_</em> array.</p>
<dl class="section pre"><dt>Precondition</dt><dd>We are working in standard normal or almost normal coordinates. That is, the coordinate system passed to the <a class="el" href="classregina_1_1TreeTraversal.html" title="A base class for searches that employ the tree traversal algorithm for enumerating and locating verte...">TreeTraversal</a> constructor was one of NS_STANDARD or NS_AN_STANDARD.</dd>
<dd>
The argument <em>startFrom</em> is at least <em>nTets_</em> (i.e., it is at least as large as the index of the first triangle type).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startFrom</td><td>the index into the type vector of the triangle type from which we begin searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into the type vector of the next unmarked triangle type from <em>startFrom</em> onwards, or -1 if there are no more remaining. </dd></dl>

</div>
</div>
<a id="a0b02f4672e87c516777b146ab70bd5fa" name="a0b02f4672e87c516777b146ab70bd5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b02f4672e87c516777b146ab70bd5fa">&#9670;&nbsp;</a></span>percent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::percent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives a rough estimate as to what percentage of the way the current type vector is through a full enumeration of the search tree. </p>
<p >This is useful for progress tracking.</p>
<p >This routine only attemps to determine the percentage within a reasonable range of error (at the time of writing, 0.01%). This allows it to be more efficient (in particular, by only examining the branches closest to the root of the search tree).</p>
<dl class="section return"><dt>Returns</dt><dd>the percentage, as a number between 0 and 100 inclusive. </dd></dl>

</div>
</div>
<a id="a041c6fa36dcdd0153b821e3719faa3a8" name="a041c6fa36dcdd0153b821e3719faa3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041c6fa36dcdd0153b821e3719faa3a8">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::run </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces. </p>
<p >For each vertex surface that is found, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be a const reference to a <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a> object (which will be this object).</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li>The tree traversal algorithm will block until <em>action</em> returns.</li>
<li><em>action</em> must return a <code>bool</code>. A return value of <code>false</code> indicates that <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> should continue the tree traversal, and a return value of <code>true</code> indicates that <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> should terminate the search immediately.</li>
</ul>
<p >Your action can extract details of the solution directly from the tree enumeration object: for instance, it can dump the type vector using <a class="el" href="classregina_1_1TreeTraversal.html#a17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a>, or it can reconstruct the full normal or almost normal surface using <a class="el" href="classregina_1_1TreeTraversal.html#ad867086232db92f412c4f803a681a319" title="Reconstructs the full normal surface that is represented by the type vector at the current stage of t...">buildSurface()</a> and perform some other operations upon it.</p>
<p >The usual way of using this routine is to construct a <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a> object and then immediately call <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>. However, if you prefer, you may call <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> after one or more calls to <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a>. In this case, <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> will continue the search from the current point and run it to its completion. In other words, <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> will locate and call <em>action</em> for all vertex surfaces that had not yet been found, but it will not call <em>action</em> on those surfaces that had previously been found during earlier calls to <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tree traversal algorithm has not yet finished. That is, you have not called <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> before, and if you have called <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> then it has always returned <code>true</code> (indicating that it has not yet finished the search).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the initial <a class="el" href="classregina_1_1TreeEnumeration.html" title="The main entry point for the tree traversal algorithm to enumerate all vertex normal or almost normal...">TreeEnumeration</a> object (and therefore the additional <em>args</em> list is omitted here).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a function (or some other callable object) to call for each vertex surface that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial tree enumeration argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>action</em> ever terminated the search by returning <code>true</code>, or <code>false</code> if the search was allowed to run to completion. </dd></dl>

</div>
</div>
<a id="aeedf584e81fe0fba353218dd983f9bd5" name="aeedf584e81fe0fba353218dd983f9bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedf584e81fe0fba353218dd983f9bd5">&#9670;&nbsp;</a></span>setNext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::setNext </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nextType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rearranges the search tree so that <em>nextType</em> becomes the next type that we process. </p>
<p >Specifically, this routine will set typeOrder_[level_ + 1] to <em>nextType_</em>, and will move other elements of typeOrder_ back by one position to make space as required.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>nextType</em> is in the range 0,...,<em>nTypes-1</em> inclusive. </dd>
<dd>
<em>nextType</em> is still waiting to be processed; that is, <em>nextType</em> does not appear in the list typeOrder_[0,...,level_].</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nextType</td><td>the next type to process. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaab5a429b783d4be21f34e5fa234cbd6" name="aaab5a429b783d4be21f34e5fa234cbd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab5a429b783d4be21f34e5fa234cbd6">&#9670;&nbsp;</a></span>solutions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::solutions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of vertex normal or almost normal surfaces found thus far in the tree traversal search. </p>
<p >If you called <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>, then this will simply be the total number of vertex surfaces that were found. If you are calling <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> one surface at time, this will be the partial count of how many vertex surfaces have been found until now.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of solutions found so far. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="classregina_1_1BanNone.html">BanNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa22527577d895f00e9d5f1db85c7960e" name="aa22527577d895f00e9d5f1db85c7960e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22527577d895f00e9d5f1db85c7960e">&#9670;&nbsp;</a></span>supported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::supported </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a>&#160;</td>
          <td class="paramname"><em>enc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the given normal surface or angle structure vector encoding is supported by this tree traversal infrastructure. </p>
<p >Any restrictions imposed by LPConstraint and BanConstraint will be taken into account.</p>
<p >Note that, even if an encoding is supported, this does not mean that the underlying tableaux will use the same encoding internally. See <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> for more details on this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enc</td><td>the vector encoding being queried. In particular, this may be the special angle structure encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given vector encoding is supported. </dd></dl>

</div>
</div>
<a id="a05f72b79d6334325190f788bec757f44" name="a05f72b79d6334325190f788bec757f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f72b79d6334325190f788bec757f44">&#9670;&nbsp;</a></span>typeString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::typeString</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current type vector in string form. </p>
<p >There will be no spaces between the types.</p>
<p >This routine returns the same information that <a class="el" href="classregina_1_1TreeTraversal.html#a17103e248164f04e3b5d50b322cf772e" title="Writes the current type vector to the given output stream.">dumpTypes()</a> writes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>type vector in string form. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="classregina_1_1BanNone.html">BanNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="af6ed3d9cadd9cc11c6f3a29a8011d731" name="af6ed3d9cadd9cc11c6f3a29a8011d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ed3d9cadd9cc11c6f3a29a8011d731">&#9670;&nbsp;</a></span>visited()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::visited</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of nodes in the search tree that we have visited thus far in the tree traversal. </p>
<p >This figure might grow much faster than the number of solutions, since it also counts traversals through "dead ends" in the search tree.</p>
<p >This counts all nodes that we visit, including those that fail any or all of the domination, feasibility and zero tests. The precise way that this number is calculated is subject to change in future versions of Regina.</p>
<p >If you called an "all at once" routine such as <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">TreeEnumeration::run()</a> or <a class="el" href="classregina_1_1TreeSingleSoln.html#af6434978ea0aac9ffb43bdcbd26da214" title="Runs the tree traversal algorithm until it finds some non-trivial surface that satisfies the chosen c...">TreeSingleSoln::find()</a>, then this will be the total number of nodes that were visited in the entire tree traversal. If you are calling an "incremental" routine such as <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> (i.e., you are generating one solution at time), then this will be the partial count of how many nodes have been visited so far.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes visited so far. </dd></dl>

</div>
</div>
<a id="af19d14f8b6c96f91a6e3f3bb6fa8951b" name="af19d14f8b6c96f91a6e3f3bb6fa8951b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19d14f8b6c96f91a6e3f3bb6fa8951b">&#9670;&nbsp;</a></span>writeSurface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::writeSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A callback function that writes to standard output the full triangle-quadrilateral coordinates of the vertex normal or almost normal surface at the current point in the given tree traversal search. </p>
<p >You can use this as the callback <em>action</em> that is passed to <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>.</p>
<p >The normal surface coordinates will be written on a single line, with spaces and punctuation separating them, a prefix indicating which solution we are up to, and a final newline appended. This output format is subject to change in future versions of Regina.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tree traversal is at a point in the search where it has reached the deepest level of the search tree and found a feasible solution that represents a vertex normal or almost normal surface. This is always the case any time after <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> returns <code>true</code>, or any time that <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> calls its callback function.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available and can be used directly, but you should not use it as a callback with <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>. Currently this causes a crash in Python, most likely coming from some confusion in passing a C++ function as a C++ callback via a Python wrapper. Instead you can use a pure python function <em>f</em> as a callback, where <code>f(tree)</code> just calls <code>tree.writeSurface()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree traversal object from which we are extracting the current vertex normal or almost normal surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> (which indicates to <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> that we should continue the tree traversal). </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1TreeTraversal.html">TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a>, <a class="el" href="classregina_1_1BanNone.html">BanNone</a>, <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5502207d74053d407db4bef998dfc160" name="a5502207d74053d407db4bef998dfc160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5502207d74053d407db4bef998dfc160">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5641da38d1775c4d40cc0d56cec31896" name="a5641da38d1775c4d40cc0d56cec31896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5641da38d1775c4d40cc0d56cec31896">&#9670;&nbsp;</a></span>writeTypes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint , typename BanConstraint , typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TreeEnumeration.html">regina::TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt;::writeTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeEnumeration.html">TreeEnumeration</a>&lt; LPConstraint, BanConstraint, IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A callback function that writes to standard output the type vector at the current point in the given tree traversal search. </p>
<p >You can use this as the callback <em>action</em> that is passed to <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a>.</p>
<p >The type vector will be written on a single line, with no spaces between types, with a prefix indicating which solution we are up to, and with a final newline appended. This output format is subject to change in future versions of Regina.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tree traversal is at a point in the search where it has reached the deepest level of the search tree and found a feasible solution that represents a vertex normal or almost normal surface. This is always the case any time after <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">next()</a> returns <code>true</code>, or any time that <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> calls its callback function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the tree traversal object from which we are extracting the current type vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> (which indicates to <a class="el" href="classregina_1_1TreeEnumeration.html#a041c6fa36dcdd0153b821e3719faa3a8" title="Runs the complete tree traversal algorithm to enumerate vertex normal or almost normal surfaces.">run()</a> that we should continue the tree traversal). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9fe120ba227cec8d77a8909a1f137ba0" name="a9fe120ba227cec8d77a8909a1f137ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe120ba227cec8d77a8909a1f137ba0">&#9670;&nbsp;</a></span>ban_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1BanNone.html">BanNone</a>  <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::ban_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Details of any banning/marking constraints that are in use. </p>

</div>
</div>
<a id="a00dd879e1473ca168fbdfcda0f4d3091" name="a00dd879e1473ca168fbdfcda0f4d3091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00dd879e1473ca168fbdfcda0f4d3091">&#9670;&nbsp;</a></span>enc_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalEncoding.html">NormalEncoding</a> <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::enc_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The normal surface or angle structure vector encoding that we are using for our enumeration task. </p>
<p >Note that the tableaux will <em>not</em> necessarily use this same encoding; see <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> for details. </p>

</div>
</div>
<a id="ab01ab20444808396ff3164419d093735" name="ab01ab20444808396ff3164419d093735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01ab20444808396ff3164419d093735">&#9670;&nbsp;</a></span>level_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::level_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current level in the search tree. </p>
<p >As the search runs, this holds the index into typeOrder_ corresponding to the last type that we chose. </p>

</div>
</div>
<a id="a399bdd3aa3c2aad75d17b65c3b81715c" name="a399bdd3aa3c2aad75d17b65c3b81715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399bdd3aa3c2aad75d17b65c3b81715c">&#9670;&nbsp;</a></span>lp_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;<a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::lp_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores tableaux for linear programming at various nodes in the search tree. </p>
<p >We only store a limited number of tableaux at any given time, and as the search progresses we overwrite old tableaux with new tableaux.</p>
<p >More precisely, we store a linear number of tableaux, essentially corresponding to the current node in the search tree and all of its ancestores, all the way up to the root node. In addition to these tableaux, we also store other immediate children of these ancestores that we have pre-prepared for future processing. See the documentation within routines such as <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> for details of when and how these tableaux are constructed. </p>

</div>
</div>
<a id="a16999f1b18c4f3738fc78ab7230c46c0" name="a16999f1b18c4f3738fc78ab7230c46c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16999f1b18c4f3738fc78ab7230c46c0">&#9670;&nbsp;</a></span>lpSlot_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;<a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;** <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::lpSlot_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recall from above that the array <em>lp_</em> stores tableaux for the current node in the search tree and all of its ancestors. </p>
<p >This means we have one tableaux for the root node, as well as additional tableaux at each level 0,1,...,<em>level_</em>.</p>
<p >The array lpSlot_ indicates which element of the array <em>lp_</em> holds each of these tableaux. Specifically: lpSlot_[0] points to the tableaux for the root node, and for each level <em>i</em> in the range 0,...,<em>level_</em>, the corresponding tableaux is *lpSlot_[i+1]. Again, see the documentation within routines such as <a class="el" href="classregina_1_1TreeEnumeration.html#a8894b5e9db9134b4f9fc09b4b8ffc9a0" title="An incremental step in the tree traversal algorithm that runs forward until it finds the next solutio...">TreeEnumeration::next()</a> for details of when and how these tableaux are constructed and later overwritten. </p>

</div>
</div>
<a id="a63265bf71e0086a5ad1e47657550a521" name="a63265bf71e0086a5ad1e47657550a521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63265bf71e0086a5ad1e47657550a521">&#9670;&nbsp;</a></span>nextSlot_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;<a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;** <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::nextSlot_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Points to the next available tableaux in lp_ that is free to use at each level of the search tree. </p>
<p >Specifically: nextSlot_[0] points to the next free tableaux at the root node, and for each level <em>i</em> in the range 0,...,<em>level_</em>, the corresponding next free tableaux is *nextSlot_[i+1].</p>
<p >The precise layout of the nextSlot_ array depends on the order in which we process quadrilateral, triangle and/or angle types. </p>

</div>
</div>
<a id="af5e564a26df7f0b882c80027e90a69fe" name="af5e564a26df7f0b882c80027e90a69fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e564a26df7f0b882c80027e90a69fe">&#9670;&nbsp;</a></span>nTableaux_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::nTableaux_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of tableaux that we need to keep in memory at any given time during the backtracking search. </p>

</div>
</div>
<a id="aefeff696b969d4a5908cc3deb21d4022" name="aefeff696b969d4a5908cc3deb21d4022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeff696b969d4a5908cc3deb21d4022">&#9670;&nbsp;</a></span>nTets_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::nTets_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of tetrahedra in the underlying triangulation. </p>

</div>
</div>
<a id="a936bcc7664f344467cdf812f52c0f32f" name="a936bcc7664f344467cdf812f52c0f32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936bcc7664f344467cdf812f52c0f32f">&#9670;&nbsp;</a></span>nTypes_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::nTypes_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total length of a type vector. </p>

</div>
</div>
<a id="a9553478bfe132c76f31849b28e43d383" name="a9553478bfe132c76f31849b28e43d383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9553478bfe132c76f31849b28e43d383">&#9670;&nbsp;</a></span>nVisited_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::nVisited_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the total number of nodes in the search tree that we have visited thus far. </p>
<p >This may grow much faster than the number of solutions, since it also counts traversals through "dead ends" in the search tree. </p>

</div>
</div>
<a id="a85b0346b05ea5dedf2466215261ae938" name="a85b0346b05ea5dedf2466215261ae938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b0346b05ea5dedf2466215261ae938">&#9670;&nbsp;</a></span>octLevel_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::octLevel_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The level at which we are enforcing an octagon type (with a strictly positive number of octagons). </p>
<p >If we are working with angle structures or normal surfaces only (and so we do not allow octagons at all), then <em>octLevel_</em> = <em>nTypes_</em>. If we are allowing almost normal surfaces but we have not yet chosen an octagon type, then <em>octLevel_</em> = -1. </p>

</div>
</div>
<a id="a883cfd719b17e7ddde2093019e8213d4" name="a883cfd719b17e7ddde2093019e8213d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883cfd719b17e7ddde2093019e8213d4">&#9670;&nbsp;</a></span>origTableaux_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a>&lt;<a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> &gt; <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::origTableaux_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The original starting tableaux that holds the adjusted matrix of matching equations, before the tree traversal algorithm begins. </p>

</div>
</div>
<a id="ae041b264994cb18b5dcae4ebafff7f16" name="ae041b264994cb18b5dcae4ebafff7f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae041b264994cb18b5dcae4ebafff7f16">&#9670;&nbsp;</a></span>tmpLP_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPData.html">LPData</a>&lt;<a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::tmpLP_[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Temporary tableaux used by the function <a class="el" href="classregina_1_1TreeTraversal.html#a6f3a3a9cb225c25026bd0fc46615b54e" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> to determine which quadrilateral types or angle types have good potential for pruning the search tree. </p>
<p >Other routines are welcome to use these temporary tableaux also (as "scratch space"); however, be aware that any call to <a class="el" href="classregina_1_1TreeTraversal.html#a6f3a3a9cb225c25026bd0fc46615b54e" title="Determines how many different values we could assign to the given quadrilateral or angle type and sti...">feasibleBranches()</a> will overwrite them. </p>

</div>
</div>
<a id="a9f957a2834e470907a883c15694bff3d" name="a9f957a2834e470907a883c15694bff3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f957a2834e470907a883c15694bff3d">&#9670;&nbsp;</a></span>type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The current working type vector. </p>
<p >As the search runs, we modify this type vector in-place. Any types beyond the current level in the search tree will always be set to zero. </p>

</div>
</div>
<a id="a7c0ef50bcc59b6a650246d9e251974c7" name="a7c0ef50bcc59b6a650246d9e251974c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0ef50bcc59b6a650246d9e251974c7">&#9670;&nbsp;</a></span>typeOrder_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t* <a class="el" href="classregina_1_1TreeTraversal.html">regina::TreeTraversal</a>&lt; <a class="el" href="classregina_1_1LPConstraintNone.html">LPConstraintNone</a> , <a class="el" href="classregina_1_1BanNone.html">BanNone</a> , <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>  &gt;::typeOrder_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A permutation of 0,...,<em>nTypes_-1</em> that indicates in which order we select types: the first type we select (at the root of the tree) is type_[typeOrder_[0]], and the last type we select (at the leaves of the tree) is type_[typeOrder_[nTypes_-1]]. </p>
<p >This permutation is allowed to change as the algorithm runs (though of course you can only change sections of the permutation that correspond to types not yet selected). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>enumerate/<a class="el" href="treetraversal_8h.html">treetraversal.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
