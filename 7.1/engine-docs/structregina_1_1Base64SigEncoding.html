<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: regina::Base64SigEncoding Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="structregina_1_1Base64SigEncoding.html">Base64SigEncoding</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structregina_1_1Base64SigEncoding-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Base64SigEncoding Struct Reference<div class="ingroups"><a class="el" href="group__utilities.html">Miscellaneous Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>General helper tools for signatures that use base64 encodings.  
 <a href="structregina_1_1Base64SigEncoding.html#details">More...</a></p>

<p><code>#include &lt;utilities/sigutils.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Base64SigEncoding:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structregina_1_1Base64SigEncoding.png" usemap="#regina::Base64SigEncoding_map" alt=""/>
  <map id="regina::Base64SigEncoding_map" name="regina::Base64SigEncoding_map">
<area href="classregina_1_1IsoSigPrintable.html" title="The default encoding to use for isomorphism signatures." alt="regina::IsoSigPrintable&lt; dim &gt;" shape="rect" coords="0,56,181,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5ac15ef071302c1b7a0271bc0c28fa28"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#a5ac15ef071302c1b7a0271bc0c28fa28">decodeSingle</a> (char c)</td></tr>
<tr class="memdesc:a5ac15ef071302c1b7a0271bc0c28fa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the integer value represented by the given base64 character.  <a href="structregina_1_1Base64SigEncoding.html#a5ac15ef071302c1b7a0271bc0c28fa28">More...</a><br /></td></tr>
<tr class="separator:a5ac15ef071302c1b7a0271bc0c28fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2b13a21680419355b03137420f6ee0"><td class="memItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#a1a2b13a21680419355b03137420f6ee0">encodeSingle</a> (unsigned c)</td></tr>
<tr class="memdesc:a1a2b13a21680419355b03137420f6ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the base64 character that represents the given integer value.  <a href="structregina_1_1Base64SigEncoding.html#a1a2b13a21680419355b03137420f6ee0">More...</a><br /></td></tr>
<tr class="separator:a1a2b13a21680419355b03137420f6ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5846f05ad69074b5db91ccbff8e26b3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#ae5846f05ad69074b5db91ccbff8e26b3">isValid</a> (char c)</td></tr>
<tr class="memdesc:ae5846f05ad69074b5db91ccbff8e26b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given character a valid base64 character?  <a href="structregina_1_1Base64SigEncoding.html#ae5846f05ad69074b5db91ccbff8e26b3">More...</a><br /></td></tr>
<tr class="separator:ae5846f05ad69074b5db91ccbff8e26b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8abe0d03b277346bfbfbbb60130a71"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:afd8abe0d03b277346bfbfbbb60130a71"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#afd8abe0d03b277346bfbfbbb60130a71">encodeInt</a> (std::string &amp;s, IntType val, unsigned nChars)</td></tr>
<tr class="memdesc:afd8abe0d03b277346bfbfbbb60130a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a base64 encoding of the given integer to the given string.  <a href="structregina_1_1Base64SigEncoding.html#afd8abe0d03b277346bfbfbbb60130a71">More...</a><br /></td></tr>
<tr class="separator:afd8abe0d03b277346bfbfbbb60130a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0cfdf4f9b2b8220bd1395d3e96f629"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a2e0cfdf4f9b2b8220bd1395d3e96f629"><td class="memTemplItemLeft" align="right" valign="top">static IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#a2e0cfdf4f9b2b8220bd1395d3e96f629">decodeInt</a> (const char *s, unsigned nChars)</td></tr>
<tr class="memdesc:a2e0cfdf4f9b2b8220bd1395d3e96f629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the integer that is encoded at the beginning of the given base64 string.  <a href="structregina_1_1Base64SigEncoding.html#a2e0cfdf4f9b2b8220bd1395d3e96f629">More...</a><br /></td></tr>
<tr class="separator:a2e0cfdf4f9b2b8220bd1395d3e96f629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce969a47729775c5021199e6c4c9d9d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a5ce969a47729775c5021199e6c4c9d9d"><td class="memTemplItemLeft" align="right" valign="top">static char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#a5ce969a47729775c5021199e6c4c9d9d">encodeTrits</a> (InputIterator trits, unsigned nTrits)</td></tr>
<tr class="memdesc:a5ce969a47729775c5021199e6c4c9d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single base64 character that encodes up to three trits, given using an input iterator.  <a href="structregina_1_1Base64SigEncoding.html#a5ce969a47729775c5021199e6c4c9d9d">More...</a><br /></td></tr>
<tr class="separator:a5ce969a47729775c5021199e6c4c9d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b93f07c739b06a9d164393eb1d73ff"><td class="memTemplParams" colspan="2">template&lt;int nTrits&gt; </td></tr>
<tr class="memitem:a46b93f07c739b06a9d164393eb1d73ff"><td class="memTemplItemLeft" align="right" valign="top">static constexpr char&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#a46b93f07c739b06a9d164393eb1d73ff">encodeTrits</a> (const std::array&lt; uint8_t, nTrits &gt; &amp;trits)</td></tr>
<tr class="memdesc:a46b93f07c739b06a9d164393eb1d73ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single base64 character that encodes up to three trits, given using a fixed-size array.  <a href="structregina_1_1Base64SigEncoding.html#a46b93f07c739b06a9d164393eb1d73ff">More...</a><br /></td></tr>
<tr class="separator:a46b93f07c739b06a9d164393eb1d73ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b32a7405052e8f5a130b55525bd789d"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:a7b32a7405052e8f5a130b55525bd789d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#a7b32a7405052e8f5a130b55525bd789d">decodeTrits</a> (char c, OutputIterator result)</td></tr>
<tr class="memdesc:a7b32a7405052e8f5a130b55525bd789d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a single base64 character into three trits, and returns these using an output iterator.  <a href="structregina_1_1Base64SigEncoding.html#a7b32a7405052e8f5a130b55525bd789d">More...</a><br /></td></tr>
<tr class="separator:a7b32a7405052e8f5a130b55525bd789d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea453b02c8f11e412c97aeec3c6c854"><td class="memItemLeft" align="right" valign="top">static constexpr std::array&lt; uint8_t, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html#a7ea453b02c8f11e412c97aeec3c6c854">decodeTrits</a> (char c)</td></tr>
<tr class="memdesc:a7ea453b02c8f11e412c97aeec3c6c854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a single base64 character into three trits, and returns these as a fixed-size array.  <a href="structregina_1_1Base64SigEncoding.html#a7ea453b02c8f11e412c97aeec3c6c854">More...</a><br /></td></tr>
<tr class="separator:a7ea453b02c8f11e412c97aeec3c6c854"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >General helper tools for signatures that use base64 encodings. </p>
<p >These are (in particular) used in the default encodings for Regina's own isomorphism signatures and knot signatures.</p>
<p >This base64 encoding uses the characters: <code>a..zA..Z0..9+-</code></p>
<dl class="section warning"><dt>Warning</dt><dd>Note that this base64 encoding uses a different set of printable symbols from the encoding used in <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">utilities/base64.h</a>. This should not be a problem: Regina uses this encoding exclusively for signatures, and uses <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">utilities/base64.h</a> exclusively for encoding files. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a2e0cfdf4f9b2b8220bd1395d3e96f629" name="a2e0cfdf4f9b2b8220bd1395d3e96f629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0cfdf4f9b2b8220bd1395d3e96f629">&#9670;&nbsp;</a></span>decodeInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static IntType regina::Base64SigEncoding::decodeInt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nChars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the integer that is encoded at the beginning of the given base64 string. </p>
<p >It will be assumed that the integer is encoded using <em>nChars</em> base64 characters, each containing 6 bits of the integer, with the lowest-significance bits encoded in the first characters.</p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#afd8abe0d03b277346bfbfbbb60130a71" title="Append a base64 encoding of the given integer to the given string.">encodeInt()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given string contains at least <em>nChars</em> characters.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The template argument <em>IntType</em> is taken to be a native C++ <code>long</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>a native C++ integer type, such as <code>uint8_t</code>, or <code>unsigned</code>, or <code>long long</code>. The result will be assembled using bitwise OR and bitwise shift lefts, and it is assumed that the programmer has chosen an integer type large enough to contain whatever values they expect to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string from which the encoded base64 characters should be read. </td></tr>
    <tr><td class="paramname">nChars</td><td>the number of base64 characters to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the native integer that was encoded. </dd></dl>

</div>
</div>
<a id="a5ac15ef071302c1b7a0271bc0c28fa28" name="a5ac15ef071302c1b7a0271bc0c28fa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac15ef071302c1b7a0271bc0c28fa28">&#9670;&nbsp;</a></span>decodeSingle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned regina::Base64SigEncoding::decodeSingle </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the integer value represented by the given base64 character. </p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#a1a2b13a21680419355b03137420f6ee0" title="Determine the base64 character that represents the given integer value.">encodeSingle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>a base64 character, which must be one of the 64 printable characters described in the class notes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding integer, which will be between 0 and 63 inclusive. </dd></dl>

</div>
</div>
<a id="a7ea453b02c8f11e412c97aeec3c6c854" name="a7ea453b02c8f11e412c97aeec3c6c854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea453b02c8f11e412c97aeec3c6c854">&#9670;&nbsp;</a></span>decodeTrits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::array&lt; uint8_t, 3 &gt; regina::Base64SigEncoding::decodeTrits </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a single base64 character into three trits, and returns these as a fixed-size array. </p>
<p >A <em>trit</em> is either 0, 1 or 2.</p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#a5ce969a47729775c5021199e6c4c9d9d" title="Returns a single base64 character that encodes up to three trits, given using an input iterator.">encodeTrits()</a>; see that routine for details of the encoding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the base64 character to decode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the three trits that had been encoded in the given base64 character. </dd></dl>

</div>
</div>
<a id="a7b32a7405052e8f5a130b55525bd789d" name="a7b32a7405052e8f5a130b55525bd789d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b32a7405052e8f5a130b55525bd789d">&#9670;&nbsp;</a></span>decodeTrits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::Base64SigEncoding::decodeTrits </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a single base64 character into three trits, and returns these using an output iterator. </p>
<p >A <em>trit</em> is either 0, 1 or 2.</p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#a5ce969a47729775c5021199e6c4c9d9d" title="Returns a single base64 character that encodes up to three trits, given using an input iterator.">encodeTrits()</a>; see that routine for details of the encoding.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can use the variant of this routine that takes one argument and returns a fixed-size array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>the base64 character to decode. </td></tr>
    <tr><td class="paramname">result</td><td>an output iterator pointing to the location where the resulting trits will be stored; it must be possible to write and advance this iterator at least three times. Each trit will be written as a <code>uint8_t</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd8abe0d03b277346bfbfbbb60130a71" name="afd8abe0d03b277346bfbfbbb60130a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8abe0d03b277346bfbfbbb60130a71">&#9670;&nbsp;</a></span>encodeInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::Base64SigEncoding::encodeInt </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nChars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a base64 encoding of the given integer to the given string. </p>
<p >The integer will be broken into <em>nChars</em> distinct 6-bit blocks, and the lowest-significance blocks will be written first.</p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#a2e0cfdf4f9b2b8220bd1395d3e96f629" title="Read the integer that is encoded at the beginning of the given base64 string.">decodeInt()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given integer <em>val</em> is non-negative, and fits within 6<em>nChars</em> bits.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The template argument <em>IntType</em> is taken to be a native C++ <code>long</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>a native C++ integer type, such as <code>uint8_t</code>, or <code>unsigned</code>, or <code>long long</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the string that resulting characters should be appended to. </td></tr>
    <tr><td class="paramname">val</td><td>the integer to encode. </td></tr>
    <tr><td class="paramname">nChars</td><td>the number of base64 characters to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a2b13a21680419355b03137420f6ee0" name="a1a2b13a21680419355b03137420f6ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2b13a21680419355b03137420f6ee0">&#9670;&nbsp;</a></span>encodeSingle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr char regina::Base64SigEncoding::encodeSingle </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the base64 character that represents the given integer value. </p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#a5ac15ef071302c1b7a0271bc0c28fa28" title="Determine the integer value represented by the given base64 character.">decodeSingle()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>an integer between 0 and 63 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding printable base64 character. </dd></dl>

</div>
</div>
<a id="a46b93f07c739b06a9d164393eb1d73ff" name="a46b93f07c739b06a9d164393eb1d73ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b93f07c739b06a9d164393eb1d73ff">&#9670;&nbsp;</a></span>encodeTrits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int nTrits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr char regina::Base64SigEncoding::encodeTrits </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; uint8_t, nTrits &gt; &amp;&#160;</td>
          <td class="paramname"><em>trits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a single base64 character that encodes up to three trits, given using a fixed-size array. </p>
<p >A <em>trit</em> is either 0, 1 or 2.</p>
<p >The given trits will be packed into a single base64 character, with the first trit representing the lowest-significance bits of the underlying integer and so on.</p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#a7b32a7405052e8f5a130b55525bd789d" title="Decodes a single base64 character into three trits, and returns these using an output iterator.">decodeTrits()</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">nTrits</td><td>the number of trits to encode; this must be between 0 and 3 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trits</td><td>the array of trits to encode. Each trit must take the value 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting printable base64 character. </dd></dl>

</div>
</div>
<a id="a5ce969a47729775c5021199e6c4c9d9d" name="a5ce969a47729775c5021199e6c4c9d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce969a47729775c5021199e6c4c9d9d">&#9670;&nbsp;</a></span>encodeTrits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char regina::Base64SigEncoding::encodeTrits </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>trits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nTrits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a single base64 character that encodes up to three trits, given using an input iterator. </p>
<p >A <em>trit</em> is either 0, 1 or 2.</p>
<p >The given trits will be packed into a single base64 character, with the first trit representing the lowest-significance bits of the underlying integer and so on.</p>
<p >The inverse to this routine is <a class="el" href="structregina_1_1Base64SigEncoding.html#a7b32a7405052e8f5a130b55525bd789d" title="Decodes a single base64 character into three trits, and returns these using an output iterator.">decodeTrits()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can use the variant of this routine that takes the trits as a fixed-size array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trits</td><td>an input iterator pointing to the first trit to encode; it must be possible to read and advance this iterator at least <em>nTrits</em> times. Each trit will be cast to a <code>uint8_t</code>, and must take the value 0, 1 or 2. </td></tr>
    <tr><td class="paramname">nTrits</td><td>the number of trits to encode; this must be at most 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting printable base64 character. </dd></dl>

</div>
</div>
<a id="ae5846f05ad69074b5db91ccbff8e26b3" name="ae5846f05ad69074b5db91ccbff8e26b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5846f05ad69074b5db91ccbff8e26b3">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool regina::Base64SigEncoding::isValid </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the given character a valid base64 character? </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given character is one of the 64 printable characters described in the class notes. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>utilities/<a class="el" href="sigutils_8h.html">sigutils.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
