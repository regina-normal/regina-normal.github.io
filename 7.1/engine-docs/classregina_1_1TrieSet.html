<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: regina::TrieSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1TrieSet-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::TrieSet Class Reference<div class="ingroups"><a class="el" href="group__utilities.html">Miscellaneous Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A trie-like data structure for storing and retriving sets.  
 <a href="classregina_1_1TrieSet.html#details">More...</a></p>

<p><code>#include &lt;utilities/trieset.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::TrieSet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1TrieSet.png" usemap="#regina::TrieSet_map" alt=""/>
  <map id="regina::TrieSet_map" name="regina::TrieSet_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; TrieSet &gt;" shape="rect" coords="0,0,155,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad1f28df3afa19a1c2cdde9bad6e15dfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#ad1f28df3afa19a1c2cdde9bad6e15dfe">TrieSet</a> ()=default</td></tr>
<tr class="memdesc:ad1f28df3afa19a1c2cdde9bad6e15dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty collection of sets.  <a href="classregina_1_1TrieSet.html#ad1f28df3afa19a1c2cdde9bad6e15dfe">More...</a><br /></td></tr>
<tr class="separator:ad1f28df3afa19a1c2cdde9bad6e15dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc5253bd75270bcea9fcbaa40fe62b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#aebc5253bd75270bcea9fcbaa40fe62b3">TrieSet</a> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;src)</td></tr>
<tr class="memdesc:aebc5253bd75270bcea9fcbaa40fe62b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given collection.  <a href="classregina_1_1TrieSet.html#aebc5253bd75270bcea9fcbaa40fe62b3">More...</a><br /></td></tr>
<tr class="separator:aebc5253bd75270bcea9fcbaa40fe62b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b369ea5e4f352db27d483a675e077a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#ae6b369ea5e4f352db27d483a675e077a">TrieSet</a> (<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ae6b369ea5e4f352db27d483a675e077a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given collection into this new collection.  <a href="classregina_1_1TrieSet.html#ae6b369ea5e4f352db27d483a675e077a">More...</a><br /></td></tr>
<tr class="separator:ae6b369ea5e4f352db27d483a675e077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e064e36d7d929017c73754ced235e56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a8e064e36d7d929017c73754ced235e56">operator=</a> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;src)</td></tr>
<tr class="memdesc:a8e064e36d7d929017c73754ced235e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given collection.  <a href="classregina_1_1TrieSet.html#a8e064e36d7d929017c73754ced235e56">More...</a><br /></td></tr>
<tr class="separator:a8e064e36d7d929017c73754ced235e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d9af0297e4a50374b30ed0a1d4b770"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#af6d9af0297e4a50374b30ed0a1d4b770">operator=</a> (<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:af6d9af0297e4a50374b30ed0a1d4b770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given collection into this collection.  <a href="classregina_1_1TrieSet.html#af6d9af0297e4a50374b30ed0a1d4b770">More...</a><br /></td></tr>
<tr class="separator:af6d9af0297e4a50374b30ed0a1d4b770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476da95934bb79278c6da766a03799e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a476da95934bb79278c6da766a03799e9">swap</a> (<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a476da95934bb79278c6da766a03799e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given collection.  <a href="classregina_1_1TrieSet.html#a476da95934bb79278c6da766a03799e9">More...</a><br /></td></tr>
<tr class="separator:a476da95934bb79278c6da766a03799e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6341866bc6b1617cc3f1975a87dc43c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#ae6341866bc6b1617cc3f1975a87dc43c">operator==</a> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;other) const</td></tr>
<tr class="memdesc:ae6341866bc6b1617cc3f1975a87dc43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given collection store exactly the same sets.  <a href="classregina_1_1TrieSet.html#ae6341866bc6b1617cc3f1975a87dc43c">More...</a><br /></td></tr>
<tr class="separator:ae6341866bc6b1617cc3f1975a87dc43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be0aa445de9ff50333e3fb5e4765fb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a9be0aa445de9ff50333e3fb5e4765fb3">operator!=</a> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;other) const</td></tr>
<tr class="memdesc:a9be0aa445de9ff50333e3fb5e4765fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given collection do not store exactly the same sets.  <a href="classregina_1_1TrieSet.html#a9be0aa445de9ff50333e3fb5e4765fb3">More...</a><br /></td></tr>
<tr class="separator:a9be0aa445de9ff50333e3fb5e4765fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450ce1c108d7662ccd347979f79ea609"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a450ce1c108d7662ccd347979f79ea609"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a450ce1c108d7662ccd347979f79ea609">insert</a> (const T &amp;entry)</td></tr>
<tr class="memdesc:a450ce1c108d7662ccd347979f79ea609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given set into this collection.  <a href="classregina_1_1TrieSet.html#a450ce1c108d7662ccd347979f79ea609">More...</a><br /></td></tr>
<tr class="separator:a450ce1c108d7662ccd347979f79ea609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae479cb9edddd2836fe32525bcb9b54fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae479cb9edddd2836fe32525bcb9b54fb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#ae479cb9edddd2836fe32525bcb9b54fb">hasSubset</a> (const T &amp;superset, size_t universeSize) const</td></tr>
<tr class="memdesc:ae479cb9edddd2836fe32525bcb9b54fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this collection of sets contains any subset of the argument <em>superset</em>.  <a href="classregina_1_1TrieSet.html#ae479cb9edddd2836fe32525bcb9b54fb">More...</a><br /></td></tr>
<tr class="separator:ae479cb9edddd2836fe32525bcb9b54fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb391ca3be22131f80586886fcd3d1b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fb391ca3be22131f80586886fcd3d1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a8fb391ca3be22131f80586886fcd3d1b">hasExtraSuperset</a> (const T &amp;subset, const T &amp;exc1, const T &amp;exc2, size_t universeSize) const</td></tr>
<tr class="memdesc:a8fb391ca3be22131f80586886fcd3d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the particular superset search required by the double description method.  <a href="classregina_1_1TrieSet.html#a8fb391ca3be22131f80586886fcd3d1b">More...</a><br /></td></tr>
<tr class="separator:a8fb391ca3be22131f80586886fcd3d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63e8cd237f35145f7512c68b811517d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#ab63e8cd237f35145f7512c68b811517d">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ab63e8cd237f35145f7512c68b811517d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1TrieSet.html#ab63e8cd237f35145f7512c68b811517d">More...</a><br /></td></tr>
<tr class="separator:ab63e8cd237f35145f7512c68b811517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e992d2ab76ac5698d74dbb4867ac437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a9e992d2ab76ac5698d74dbb4867ac437">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a9e992d2ab76ac5698d74dbb4867ac437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1TrieSet.html#a9e992d2ab76ac5698d74dbb4867ac437">More...</a><br /></td></tr>
<tr class="separator:a9e992d2ab76ac5698d74dbb4867ac437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A trie-like data structure for storing and retriving sets. </p>
<p >This class is useful when the <em>elements</em> of these sets are taken from a fairly small universe, but where the <em>number</em> of sets being stored can be extremely large.</p>
<p >For simplicity, let the universe consist of the integers 0,...,(<em>n</em>-1). Sets are represented as bitmasks of length <em>n</em> (using one of Regina's bitmask types, such as <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>). The <em>i</em>th bit of a bitmask indicates whether the integer <em>i</em> belongs to the corresponding set.</p>
<p >To construct an empty trie, simply call the default constructor. To insert a new set into the trie, call <a class="el" href="classregina_1_1TrieSet.html#a450ce1c108d7662ccd347979f79ea609" title="Insert the given set into this collection.">insert()</a> (whose running time is linear in <em>n</em>). You can insert the same set into the trie multiple times and the trie will record the number of times that it occurs.</p>
<p >Currently the only searching operations are <a class="el" href="classregina_1_1TrieSet.html#ae479cb9edddd2836fe32525bcb9b54fb" title="Determines whether this collection of sets contains any subset of the argument superset.">hasSubset()</a> and <a class="el" href="classregina_1_1TrieSet.html#a8fb391ca3be22131f80586886fcd3d1b" title="Performs the particular superset search required by the double description method.">hasExtraSuperset()</a>. These operations are slow, but still much faster than searching through a linear list; see the <a class="el" href="classregina_1_1TrieSet.html#ae479cb9edddd2836fe32525bcb9b54fb" title="Determines whether this collection of sets contains any subset of the argument superset.">hasSubset()</a> and <a class="el" href="classregina_1_1TrieSet.html#a8fb391ca3be22131f80586886fcd3d1b" title="Performs the particular superset search required by the double description method.">hasExtraSuperset()</a> documentation for details.</p>
<p >The implementation of this data structure uses a binary tree with depth levels 0,...,<em>n</em>, where each node at level <em>i</em> represents a potential length-<em>i</em> prefix for a bitmask. So, for instance, the root node represents the empty prefix, its children represent prefixes 0 and 1, their children represent prefixes 00, 01, 10 and 11, and so on.</p>
<p >Internally, a set is "stored" at the first node whose prefix in fact describes the entire set. For instance, the bitmask 101100 is stored at the node corresponding to the prefix 1011, which occurs at level 3 of the tree. Regions of the tree that do not store any sets are never explicitly constructed in memory.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad1f28df3afa19a1c2cdde9bad6e15dfe" name="ad1f28df3afa19a1c2cdde9bad6e15dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f28df3afa19a1c2cdde9bad6e15dfe">&#9670;&nbsp;</a></span>TrieSet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TrieSet::TrieSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty collection of sets. </p>

</div>
</div>
<a id="aebc5253bd75270bcea9fcbaa40fe62b3" name="aebc5253bd75270bcea9fcbaa40fe62b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc5253bd75270bcea9fcbaa40fe62b3">&#9670;&nbsp;</a></span>TrieSet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TrieSet::TrieSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given collection. </p>
<p >This will induce a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the collection of sets to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6b369ea5e4f352db27d483a675e077a" name="ae6b369ea5e4f352db27d483a675e077a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b369ea5e4f352db27d483a675e077a">&#9670;&nbsp;</a></span>TrieSet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TrieSet::TrieSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given collection into this new collection. </p>
<p >This is a fast (constant time) operation.</p>
<p >The collection that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the collection of sets whose contents should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a8fb391ca3be22131f80586886fcd3d1b" name="a8fb391ca3be22131f80586886fcd3d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb391ca3be22131f80586886fcd3d1b">&#9670;&nbsp;</a></span>hasExtraSuperset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TrieSet::hasExtraSuperset </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>exc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>exc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>universeSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the particular superset search required by the double description method. </p>
<p >This routine asks the following question: In this collection of sets, is there any superset of the argument <em>subset</em> <em>other</em> than <em>exc1</em> or <em>exc2</em>? Here the sets <em>exc1</em> and <em>exc2</em> are explicitly excluded from our search. Supersets need not be <em>proper</em> supersets (so if an exact copy of <em>subset</em> is found in the tree then this will suffice).</p>
<p >This routine has a slow running time, which in pathological cases can grow to either <code>2^n</code> (where <em>n</em> is the bitmask length) or the number of sets stored in this collection, whichever is smaller. However, for "typical" searches in the context of normal surface enumeration, the running time is often significantly faster.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The sets <em>exc1</em> and <em>exc2</em> are distinct, and each is contained in this collection precisely once.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>One of Regina's bitmask types, such as <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subset</td><td>the object of the query: we are searching this collection for a (non-strict) superset of this argument. </td></tr>
    <tr><td class="paramname">exc1</td><td>the first set in the collection to be excluded from this search. </td></tr>
    <tr><td class="paramname">exc2</td><td>the second set in the collection to be excluded from this search. </td></tr>
    <tr><td class="paramname">universeSize</td><td>the number of elements in the underlying universe (and therefore the lowest possible level in the search tree). This must be less than or equal to the number of bits that the underlying bitmask type <em>T</em> can support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a superset with the required properties was found, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ae479cb9edddd2836fe32525bcb9b54fb" name="ae479cb9edddd2836fe32525bcb9b54fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae479cb9edddd2836fe32525bcb9b54fb">&#9670;&nbsp;</a></span>hasSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TrieSet::hasSubset </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>superset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>universeSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this collection of sets contains any subset of the argument <em>superset</em>. </p>
<p >Subsets need not be <em>proper</em> subsets (so if an exact copy of <em>superset</em> is found in the tree then this will suffice).</p>
<p >This routine has a slow running time, which in pathological cases can grow to either <code>2^n</code> (where <em>n</em> is the bitmask length) or the number of sets stored in this collection, whichever is smaller. However, for "typical" searches in the context of normal surface enumeration, the running time is often significantly faster.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>One of Regina's bitmask types, such as <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">superset</td><td>the object of the query: we are searching this collection for a (non-strict) subset of this argument. </td></tr>
    <tr><td class="paramname">universeSize</td><td>the number of elements in the underlying universe (and therefore the lowest possible level in the search tree). This must be less than or equal to the number of bits that the underlying bitmask type <em>T</em> can support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a subset was found, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a450ce1c108d7662ccd347979f79ea609" name="a450ce1c108d7662ccd347979f79ea609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450ce1c108d7662ccd347979f79ea609">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::TrieSet::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the given set into this collection. </p>
<p >The same set may be insert into this collection multiple times (and this multiplicity will be recorded correctly).</p>
<p >Running time for insertion is O(<em>n</em>), where <em>n</em> is the bitmask length.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>One of Regina's bitmask types, such as <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the new set to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9be0aa445de9ff50333e3fb5e4765fb3" name="a9be0aa445de9ff50333e3fb5e4765fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be0aa445de9ff50333e3fb5e4765fb3">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TrieSet::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given collection do not store exactly the same sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the collection to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both collections do not store the same sets. </dd></dl>

</div>
</div>
<a id="a8e064e36d7d929017c73754ced235e56" name="a8e064e36d7d929017c73754ced235e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e064e36d7d929017c73754ced235e56">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp; regina::TrieSet::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given collection. </p>
<p >This will induce a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the collection of sets to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this collection. </dd></dl>

</div>
</div>
<a id="af6d9af0297e4a50374b30ed0a1d4b770" name="af6d9af0297e4a50374b30ed0a1d4b770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d9af0297e4a50374b30ed0a1d4b770">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp; regina::TrieSet::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given collection into this collection. </p>
<p >This is a fast (constant time) operation.</p>
<p >The collection that was passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the collection of sets whose contents should be moved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this collection. </dd></dl>

</div>
</div>
<a id="ae6341866bc6b1617cc3f1975a87dc43c" name="ae6341866bc6b1617cc3f1975a87dc43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6341866bc6b1617cc3f1975a87dc43c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TrieSet::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given collection store exactly the same sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the collection to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both collections store the same sets. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a476da95934bb79278c6da766a03799e9" name="a476da95934bb79278c6da766a03799e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476da95934bb79278c6da766a03799e9">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TrieSet::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the collection whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a9e992d2ab76ac5698d74dbb4867ac437" name="a9e992d2ab76ac5698d74dbb4867ac437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e992d2ab76ac5698d74dbb4867ac437">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TrieSet::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab63e8cd237f35145f7512c68b811517d" name="ab63e8cd237f35145f7512c68b811517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63e8cd237f35145f7512c68b811517d">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TrieSet::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>utilities/<a class="el" href="trieset_8h.html">trieset.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
