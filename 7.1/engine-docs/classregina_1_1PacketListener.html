<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: regina::PacketListener Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classregina_1_1PacketListener-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::PacketListener Class Reference<div class="ingroups"><a class="el" href="group__packet.html">Basic Packet Types</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An object that can be registered to listen for packet events.  
 <a href="classregina_1_1PacketListener.html#details">More...</a></p>

<p><code>#include &lt;packet/packet.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:ad38a8027de705c45ecf5d10b864624fe"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ad38a8027de705c45ecf5d10b864624fe">~PacketListener</a> ()</td></tr>
<tr class="memdesc:ad38a8027de705c45ecf5d10b864624fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this listener.  <a href="classregina_1_1PacketListener.html#ad38a8027de705c45ecf5d10b864624fe">More...</a><br /></td></tr>
<tr class="separator:ad38a8027de705c45ecf5d10b864624fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Packet Listener Interface</h2></td></tr>
<tr class="memitem:ae51cb555166657e5996a76768db998e3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ae51cb555166657e5996a76768db998e3">Packet</a></td></tr>
<tr class="memdesc:ae51cb555166657e5996a76768db998e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow packets to automatically deregister listeners as they are destroyed.  <a href="classregina_1_1PacketListener.html#ae51cb555166657e5996a76768db998e3">More...</a><br /></td></tr>
<tr class="separator:ae51cb555166657e5996a76768db998e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d7005779c81d3b09f04111bc6d1ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ace9d7005779c81d3b09f04111bc6d1ae">isListening</a> () const</td></tr>
<tr class="memdesc:ace9d7005779c81d3b09f04111bc6d1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this object is listening for events on any packets at all.  <a href="classregina_1_1PacketListener.html#ace9d7005779c81d3b09f04111bc6d1ae">More...</a><br /></td></tr>
<tr class="separator:ace9d7005779c81d3b09f04111bc6d1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5f0f937aaed7a7b2cd615e861668e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#aac5f0f937aaed7a7b2cd615e861668e2">unlisten</a> ()</td></tr>
<tr class="memdesc:aac5f0f937aaed7a7b2cd615e861668e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters this listener from all packets to which it is currently listening.  <a href="classregina_1_1PacketListener.html#aac5f0f937aaed7a7b2cd615e861668e2">More...</a><br /></td></tr>
<tr class="separator:aac5f0f937aaed7a7b2cd615e861668e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b3ba238a00f5c13fd9bca2b9db21db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ac3b3ba238a00f5c13fd9bca2b9db21db">packetToBeChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="memdesc:ac3b3ba238a00f5c13fd9bca2b9db21db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the contents of the packet are to be changed.  <a href="classregina_1_1PacketListener.html#ac3b3ba238a00f5c13fd9bca2b9db21db">More...</a><br /></td></tr>
<tr class="separator:ac3b3ba238a00f5c13fd9bca2b9db21db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af302a5875214631b50b05c62cd6ef17c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#af302a5875214631b50b05c62cd6ef17c">packetWasChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="memdesc:af302a5875214631b50b05c62cd6ef17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the contents of the packet have been changed.  <a href="classregina_1_1PacketListener.html#af302a5875214631b50b05c62cd6ef17c">More...</a><br /></td></tr>
<tr class="separator:af302a5875214631b50b05c62cd6ef17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0336eec77b7d7e5f272db798ab39a6d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a0336eec77b7d7e5f272db798ab39a6d7">packetToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="memdesc:a0336eec77b7d7e5f272db798ab39a6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet label or tags are to be changed.  <a href="classregina_1_1PacketListener.html#a0336eec77b7d7e5f272db798ab39a6d7">More...</a><br /></td></tr>
<tr class="separator:a0336eec77b7d7e5f272db798ab39a6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe6ee72cf2a7c639d4f26bb25d321b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a9fe6ee72cf2a7c639d4f26bb25d321b7">packetWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="memdesc:a9fe6ee72cf2a7c639d4f26bb25d321b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the packet label or tags have been changed.  <a href="classregina_1_1PacketListener.html#a9fe6ee72cf2a7c639d4f26bb25d321b7">More...</a><br /></td></tr>
<tr class="separator:a9fe6ee72cf2a7c639d4f26bb25d321b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d0f54089c4acd49b49276a3473fff2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ab3d0f54089c4acd49b49276a3473fff2">packetBeingDestroyed</a> (<a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> packet)</td></tr>
<tr class="memdesc:ab3d0f54089c4acd49b49276a3473fff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called as the packet is being destroyed.  <a href="classregina_1_1PacketListener.html#ab3d0f54089c4acd49b49276a3473fff2">More...</a><br /></td></tr>
<tr class="separator:ab3d0f54089c4acd49b49276a3473fff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0030f7954c7debeefcd86db91bee1ef1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a0030f7954c7debeefcd86db91bee1ef1">childToBeAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;child)</td></tr>
<tr class="memdesc:a0030f7954c7debeefcd86db91bee1ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be inserted directly beneath the packet.  <a href="classregina_1_1PacketListener.html#a0030f7954c7debeefcd86db91bee1ef1">More...</a><br /></td></tr>
<tr class="separator:a0030f7954c7debeefcd86db91bee1ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac614869cdea45a7f9ba6830367f4c88e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ac614869cdea45a7f9ba6830367f4c88e">childWasAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;child)</td></tr>
<tr class="memdesc:ac614869cdea45a7f9ba6830367f4c88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been inserted directly beneath the packet.  <a href="classregina_1_1PacketListener.html#ac614869cdea45a7f9ba6830367f4c88e">More...</a><br /></td></tr>
<tr class="separator:ac614869cdea45a7f9ba6830367f4c88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf5452243f27123731863cb3bebad7d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a8bf5452243f27123731863cb3bebad7d">childToBeRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;child)</td></tr>
<tr class="memdesc:a8bf5452243f27123731863cb3bebad7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be removed from directly beneath the packet.  <a href="classregina_1_1PacketListener.html#a8bf5452243f27123731863cb3bebad7d">More...</a><br /></td></tr>
<tr class="separator:a8bf5452243f27123731863cb3bebad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9045603ed29821d36c95e377787cb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ace9045603ed29821d36c95e377787cb9">childWasRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;child)</td></tr>
<tr class="memdesc:ace9045603ed29821d36c95e377787cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been removed from directly beneath the packet.  <a href="classregina_1_1PacketListener.html#ace9045603ed29821d36c95e377787cb9">More...</a><br /></td></tr>
<tr class="separator:ace9045603ed29821d36c95e377787cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020fd05f6d0869047cc7a33660d1a20a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a020fd05f6d0869047cc7a33660d1a20a">childrenToBeReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="memdesc:a020fd05f6d0869047cc7a33660d1a20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the child packets directly beneath the packet are to be reordered.  <a href="classregina_1_1PacketListener.html#a020fd05f6d0869047cc7a33660d1a20a">More...</a><br /></td></tr>
<tr class="separator:a020fd05f6d0869047cc7a33660d1a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333b345e780dc87080576848485395b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a333b345e780dc87080576848485395b0">childrenWereReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet)</td></tr>
<tr class="memdesc:a333b345e780dc87080576848485395b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the child packets directly beneath the packet have been reordered.  <a href="classregina_1_1PacketListener.html#a333b345e780dc87080576848485395b0">More...</a><br /></td></tr>
<tr class="separator:a333b345e780dc87080576848485395b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15da77574a5a1ac0af1a635b3bf0553"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ac15da77574a5a1ac0af1a635b3bf0553">childToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;child)</td></tr>
<tr class="memdesc:ac15da77574a5a1ac0af1a635b3bf0553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before one of this packet's immediate children has its label or tags changed.  <a href="classregina_1_1PacketListener.html#ac15da77574a5a1ac0af1a635b3bf0553">More...</a><br /></td></tr>
<tr class="separator:ac15da77574a5a1ac0af1a635b3bf0553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c4ddc6af52648935d3ba7a1fcdda93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ad0c4ddc6af52648935d3ba7a1fcdda93">childWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;child)</td></tr>
<tr class="memdesc:ad0c4ddc6af52648935d3ba7a1fcdda93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after one of this packet's immediate children has its label or tags changed.  <a href="classregina_1_1PacketListener.html#ad0c4ddc6af52648935d3ba7a1fcdda93">More...</a><br /></td></tr>
<tr class="separator:ad0c4ddc6af52648935d3ba7a1fcdda93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcc31e05fca376f94d2b49adc183cfb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a4dcc31e05fca376f94d2b49adc183cfb">packetToBeChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:a4dcc31e05fca376f94d2b49adc183cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#a4dcc31e05fca376f94d2b49adc183cfb">More...</a><br /></td></tr>
<tr class="separator:a4dcc31e05fca376f94d2b49adc183cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f077e629a0ec6ec7df4de4fb487fffa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a2f077e629a0ec6ec7df4de4fb487fffa">packetWasChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:a2f077e629a0ec6ec7df4de4fb487fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#a2f077e629a0ec6ec7df4de4fb487fffa">More...</a><br /></td></tr>
<tr class="separator:a2f077e629a0ec6ec7df4de4fb487fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a92f55ecf23879dffa1b14924463ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ab9a92f55ecf23879dffa1b14924463ed">packetToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:ab9a92f55ecf23879dffa1b14924463ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#ab9a92f55ecf23879dffa1b14924463ed">More...</a><br /></td></tr>
<tr class="separator:ab9a92f55ecf23879dffa1b14924463ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e2e4d18d9a359097c9d8b0ee848f21"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a51e2e4d18d9a359097c9d8b0ee848f21">packetWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:a51e2e4d18d9a359097c9d8b0ee848f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#a51e2e4d18d9a359097c9d8b0ee848f21">More...</a><br /></td></tr>
<tr class="separator:a51e2e4d18d9a359097c9d8b0ee848f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa75c1a6f772c7193bfe0839b325c45d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#afa75c1a6f772c7193bfe0839b325c45d">packetToBeDestroyed</a> (<a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>) final</td></tr>
<tr class="memdesc:afa75c1a6f772c7193bfe0839b325c45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#afa75c1a6f772c7193bfe0839b325c45d">More...</a><br /></td></tr>
<tr class="separator:afa75c1a6f772c7193bfe0839b325c45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af756bd415cd7a89c6b3d063ead14f8f5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#af756bd415cd7a89c6b3d063ead14f8f5">childToBeAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *, <a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:af756bd415cd7a89c6b3d063ead14f8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#af756bd415cd7a89c6b3d063ead14f8f5">More...</a><br /></td></tr>
<tr class="separator:af756bd415cd7a89c6b3d063ead14f8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24870a8c87b17da58495803a0e35aa9d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a24870a8c87b17da58495803a0e35aa9d">childWasAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *, <a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:a24870a8c87b17da58495803a0e35aa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#a24870a8c87b17da58495803a0e35aa9d">More...</a><br /></td></tr>
<tr class="separator:a24870a8c87b17da58495803a0e35aa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac652cfd2e0003b4c42316ab559995d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#adac652cfd2e0003b4c42316ab559995d">childToBeRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *, <a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:adac652cfd2e0003b4c42316ab559995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#adac652cfd2e0003b4c42316ab559995d">More...</a><br /></td></tr>
<tr class="separator:adac652cfd2e0003b4c42316ab559995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e5804f18f416cd82f774ba0a824f9a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a60e5804f18f416cd82f774ba0a824f9a">childWasRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *, <a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:a60e5804f18f416cd82f774ba0a824f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#a60e5804f18f416cd82f774ba0a824f9a">More...</a><br /></td></tr>
<tr class="separator:a60e5804f18f416cd82f774ba0a824f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b6690cbb4019c142f7fd4341e9fbf7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#af1b6690cbb4019c142f7fd4341e9fbf7">childrenToBeReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:af1b6690cbb4019c142f7fd4341e9fbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#af1b6690cbb4019c142f7fd4341e9fbf7">More...</a><br /></td></tr>
<tr class="separator:af1b6690cbb4019c142f7fd4341e9fbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec19c973d9aeb7403d6490f65bd35d2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#aec19c973d9aeb7403d6490f65bd35d2f">childrenWereReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:aec19c973d9aeb7403d6490f65bd35d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#aec19c973d9aeb7403d6490f65bd35d2f">More...</a><br /></td></tr>
<tr class="separator:aec19c973d9aeb7403d6490f65bd35d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8306a212dfe42e436ad7d4c4ae1d743"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#af8306a212dfe42e436ad7d4c4ae1d743">childToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *, <a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:af8306a212dfe42e436ad7d4c4ae1d743"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#af8306a212dfe42e436ad7d4c4ae1d743">More...</a><br /></td></tr>
<tr class="separator:af8306a212dfe42e436ad7d4c4ae1d743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7d0c9d7ab1444524b4795a55ac2caa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#aec7d0c9d7ab1444524b4795a55ac2caa">childWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *, <a class="el" href="classregina_1_1Packet.html">Packet</a> *) final</td></tr>
<tr class="memdesc:aec7d0c9d7ab1444524b4795a55ac2caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for an old form of a callback function that is no longer used.  <a href="classregina_1_1PacketListener.html#aec7d0c9d7ab1444524b4795a55ac2caa">More...</a><br /></td></tr>
<tr class="separator:aec7d0c9d7ab1444524b4795a55ac2caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869caf59c0e19e27006cb67d5742977"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ac869caf59c0e19e27006cb67d5742977">PacketListener</a> ()=default</td></tr>
<tr class="memdesc:ac869caf59c0e19e27006cb67d5742977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classregina_1_1PacketListener.html#ac869caf59c0e19e27006cb67d5742977">More...</a><br /></td></tr>
<tr class="separator:ac869caf59c0e19e27006cb67d5742977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90df3882efa159820a94c428908dba43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#a90df3882efa159820a94c428908dba43">PacketListener</a> (const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;src)</td></tr>
<tr class="memdesc:a90df3882efa159820a94c428908dba43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classregina_1_1PacketListener.html#a90df3882efa159820a94c428908dba43">More...</a><br /></td></tr>
<tr class="separator:a90df3882efa159820a94c428908dba43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24adde68b0429937878e2c51bbb7142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#ae24adde68b0429937878e2c51bbb7142">operator=</a> (const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;src)</td></tr>
<tr class="memdesc:ae24adde68b0429937878e2c51bbb7142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classregina_1_1PacketListener.html#ae24adde68b0429937878e2c51bbb7142">More...</a><br /></td></tr>
<tr class="separator:ae24adde68b0429937878e2c51bbb7142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe098b8de7d86b24bf41391d3c40bfdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html#abe098b8de7d86b24bf41391d3c40bfdb">swapListeners</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;other)</td></tr>
<tr class="memdesc:abe098b8de7d86b24bf41391d3c40bfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap operation.  <a href="classregina_1_1PacketListener.html#abe098b8de7d86b24bf41391d3c40bfdb">More...</a><br /></td></tr>
<tr class="separator:abe098b8de7d86b24bf41391d3c40bfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An object that can be registered to listen for packet events. </p>
<p >A packet listener can be registered to listen for events on a packet by calling <a class="el" href="classregina_1_1Packet.html#aa504cfa813a3190c00337743915ffef5" title="Registers the given packet listener to listen for events on this packet.">Packet::listen()</a>.</p>
<p >Each time that one of the events listed in this class occurs, the packet will call the appropriate callback routine for all registered listeners.</p>
<p >These events come in future/past pairs: <a class="el" href="classregina_1_1PacketListener.html#ac3b3ba238a00f5c13fd9bca2b9db21db" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> and <a class="el" href="classregina_1_1PacketListener.html#af302a5875214631b50b05c62cd6ef17c" title="Called after the contents of the packet have been changed.">packetWasChanged()</a>, <a class="el" href="classregina_1_1PacketListener.html#a0030f7954c7debeefcd86db91bee1ef1" title="Called before a child packet is to be inserted directly beneath the packet.">childToBeAdded()</a> and <a class="el" href="classregina_1_1PacketListener.html#ac614869cdea45a7f9ba6830367f4c88e" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a>, and so on. These event pairs are mutually exclusive: any event will cause at most one pair of callback routines to be called for each (packet, listener) pair. For instance, if a packet is renamed then <a class="el" href="classregina_1_1PacketListener.html#a0336eec77b7d7e5f272db798ab39a6d7" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> and <a class="el" href="classregina_1_1PacketListener.html#a9fe6ee72cf2a7c639d4f26bb25d321b7" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> will be called but <a class="el" href="classregina_1_1PacketListener.html#ac3b3ba238a00f5c13fd9bca2b9db21db" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> and <a class="el" href="classregina_1_1PacketListener.html#af302a5875214631b50b05c62cd6ef17c" title="Called after the contents of the packet have been changed.">packetWasChanged()</a> will not.</p>
<p >As a special case, when a packet is destroyed there is only the one event <a class="el" href="classregina_1_1PacketListener.html#ab3d0f54089c4acd49b49276a3473fff2" title="Called as the packet is being destroyed.">packetBeingDestroyed()</a>, since this is called <em>during</em> the packet destructor (at a time when the set of listeners is still available, but some of the other packet data may have already been destroyed).</p>
<p >No guarantees are made as to the order in which the different packet listeners are notified of an event.</p>
<p >When a listener is destroyed, it is automatically unregistered from any packets to which it is currently listening. Similarly, when a packet is destroyed all listeners are automatically unregistered.</p>
<p >To listen for packet events using your own callback routines, you would typically implement a subclass of <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> that overrides only those callbacks that you are interested in. Be aware that:</p>
<ul>
<li>Callbacks are called for each listener, one at a time, in the same thread in which the event occurred.</li>
<li>Callbacks can safely add new packet listeners, but there is no guarantee as to whether or not the new listeners will be notified of the specific event currently being processed.</li>
<li>Callbacks can safely remove other listeners, but they must <em>not</em> remove the listener whose callback is currently being called. The one exception to this is <a class="el" href="classregina_1_1PacketListener.html#ab3d0f54089c4acd49b49276a3473fff2" title="Called as the packet is being destroyed.">packetBeingDestroyed()</a>, which will explicitly remove each listener <em>before</em> its callback is called (which means, for example, the listener can safely delete itself).</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Subclass authors should be aware of the default copy semantics that this base class provides. In particular, this base class provides a protected copy constructor and copy assignment operator that will change which packets are being listened to (in the "obvious" way). As a subclass author, you should understand this inherited behaviour if your subclass constructors and/or assignment operators use these base class operations implicitly.</dd>
<dd>
At the time of writing (admittedly long ago now), Qt has only limited support for multithreading. When working with an existing packet tree in a new thread (not the main thread), the <em>only</em> modification that you may make is to insert new packets. Modifications of any other type (such as changing, renaming, deleting or reordering existing packets) could lead to a crash within Qt or Xlib when running the GUI. Of course, a new thread may create, modify and delete its own temporary packet trees as it chooses (and it may in fact insert them into a pre-existing packet tree once all modifications are completed). Assuming these restrictions are respected, packet listeners may assume that no routines other than <a class="el" href="classregina_1_1PacketListener.html#ac614869cdea45a7f9ba6830367f4c88e" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a> will be called from a non-main thread.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>You can happily make a pure Python subclass of <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a>, and packets will call whichever functions you override when events occur, just as they would for a native C++ subclass. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad38a8027de705c45ecf5d10b864624fe" name="ad38a8027de705c45ecf5d10b864624fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38a8027de705c45ecf5d10b864624fe">&#9670;&nbsp;</a></span>~PacketListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketListener::~PacketListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this listener. </p>
<p >This listener will be unregistered from any packets to which it is currently listening. </p>

</div>
</div>
<a id="ac869caf59c0e19e27006cb67d5742977" name="ac869caf59c0e19e27006cb67d5742977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac869caf59c0e19e27006cb67d5742977">&#9670;&nbsp;</a></span>PacketListener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketListener::PacketListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p >The new listener will not be listening to any packets. </p>

</div>
</div>
<a id="a90df3882efa159820a94c428908dba43" name="a90df3882efa159820a94c428908dba43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90df3882efa159820a94c428908dba43">&#9670;&nbsp;</a></span>PacketListener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketListener::PacketListener </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p >The new listener will be registered as listening to the same packets as <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the listener to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a020fd05f6d0869047cc7a33660d1a20a" name="a020fd05f6d0869047cc7a33660d1a20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020fd05f6d0869047cc7a33660d1a20a">&#9670;&nbsp;</a></span>childrenToBeReordered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childrenToBeReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the child packets directly beneath the packet are to be reordered. </p>
<p >Once the reordering is done, <a class="el" href="classregina_1_1PacketListener.html#a333b345e780dc87080576848485395b0" title="Called after the child packets directly beneath the packet have been reordered.">childrenWereReordered()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1b6690cbb4019c142f7fd4341e9fbf7" name="af1b6690cbb4019c142f7fd4341e9fbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b6690cbb4019c142f7fd4341e9fbf7">&#9670;&nbsp;</a></span>childrenToBeReordered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childrenToBeReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#a020fd05f6d0869047cc7a33660d1a20a" title="Called before the child packets directly beneath the packet are to be reordered.">childrenToBeReordered()</a> callback now takes its argument by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#a020fd05f6d0869047cc7a33660d1a20a" title="Called before the child packets directly beneath the packet are to be reordered.">childrenToBeReordered()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="a333b345e780dc87080576848485395b0" name="a333b345e780dc87080576848485395b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333b345e780dc87080576848485395b0">&#9670;&nbsp;</a></span>childrenWereReordered() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childrenWereReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the child packets directly beneath the packet have been reordered. </p>
<p >Before this reordering is done, <a class="el" href="classregina_1_1PacketListener.html#a020fd05f6d0869047cc7a33660d1a20a" title="Called before the child packets directly beneath the packet are to be reordered.">childrenToBeReordered()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec19c973d9aeb7403d6490f65bd35d2f" name="aec19c973d9aeb7403d6490f65bd35d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec19c973d9aeb7403d6490f65bd35d2f">&#9670;&nbsp;</a></span>childrenWereReordered() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childrenWereReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#a333b345e780dc87080576848485395b0" title="Called after the child packets directly beneath the packet have been reordered.">childrenWereReordered()</a> callback now takes its argument by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#a333b345e780dc87080576848485395b0" title="Called after the child packets directly beneath the packet have been reordered.">childrenWereReordered()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="a0030f7954c7debeefcd86db91bee1ef1" name="a0030f7954c7debeefcd86db91bee1ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0030f7954c7debeefcd86db91bee1ef1">&#9670;&nbsp;</a></span>childToBeAdded() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childToBeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be inserted directly beneath the packet. </p>
<p >Once the child is inserted, <a class="el" href="classregina_1_1PacketListener.html#ac614869cdea45a7f9ba6830367f4c88e" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af756bd415cd7a89c6b3d063ead14f8f5" name="af756bd415cd7a89c6b3d063ead14f8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af756bd415cd7a89c6b3d063ead14f8f5">&#9670;&nbsp;</a></span>childToBeAdded() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childToBeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#a0030f7954c7debeefcd86db91bee1ef1" title="Called before a child packet is to be inserted directly beneath the packet.">childToBeAdded()</a> callback now takes its arguments by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#a0030f7954c7debeefcd86db91bee1ef1" title="Called before a child packet is to be inserted directly beneath the packet.">childToBeAdded()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="a8bf5452243f27123731863cb3bebad7d" name="a8bf5452243f27123731863cb3bebad7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf5452243f27123731863cb3bebad7d">&#9670;&nbsp;</a></span>childToBeRemoved() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childToBeRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be removed from directly beneath the packet. </p>
<p >Once the child is removed, <a class="el" href="classregina_1_1PacketListener.html#ace9045603ed29821d36c95e377787cb9" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called also.</p>
<p >Since Regina 7.0, this routine is no longer called from within either the parent or child packet's destructor. In particular, when a parent packet is destroyed, although it orphans all of its children as part of the destruction process, it does not call <a class="el" href="classregina_1_1PacketListener.html#a8bf5452243f27123731863cb3bebad7d" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> or childWasRemoved when this happens.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to, or <code>null</code> if this routine is being called from within this packet's destructor. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adac652cfd2e0003b4c42316ab559995d" name="adac652cfd2e0003b4c42316ab559995d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac652cfd2e0003b4c42316ab559995d">&#9670;&nbsp;</a></span>childToBeRemoved() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childToBeRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#a8bf5452243f27123731863cb3bebad7d" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> callback now takes its arguments by reference, not by pointer, and is no longer called from within either the child or parent destructor.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#a8bf5452243f27123731863cb3bebad7d" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="ac15da77574a5a1ac0af1a635b3bf0553" name="ac15da77574a5a1ac0af1a635b3bf0553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15da77574a5a1ac0af1a635b3bf0553">&#9670;&nbsp;</a></span>childToBeRenamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before one of this packet's immediate children has its label or tags changed. </p>
<p >Before this change, <a class="el" href="classregina_1_1PacketListener.html#ac15da77574a5a1ac0af1a635b3bf0553" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1PacketListener.html#a0336eec77b7d7e5f272db798ab39a6d7" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> </dd></dl>

</div>
</div>
<a id="af8306a212dfe42e436ad7d4c4ae1d743" name="af8306a212dfe42e436ad7d4c4ae1d743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8306a212dfe42e436ad7d4c4ae1d743">&#9670;&nbsp;</a></span>childToBeRenamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#ac15da77574a5a1ac0af1a635b3bf0553" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> callback now takes its arguments by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#ac15da77574a5a1ac0af1a635b3bf0553" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="ac614869cdea45a7f9ba6830367f4c88e" name="ac614869cdea45a7f9ba6830367f4c88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac614869cdea45a7f9ba6830367f4c88e">&#9670;&nbsp;</a></span>childWasAdded() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childWasAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been inserted directly beneath the packet. </p>
<p >Before this child is added, <a class="el" href="classregina_1_1PacketListener.html#a0030f7954c7debeefcd86db91bee1ef1" title="Called before a child packet is to be inserted directly beneath the packet.">childToBeAdded()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24870a8c87b17da58495803a0e35aa9d" name="a24870a8c87b17da58495803a0e35aa9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24870a8c87b17da58495803a0e35aa9d">&#9670;&nbsp;</a></span>childWasAdded() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childWasAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#ac614869cdea45a7f9ba6830367f4c88e" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a> callback now takes its arguments by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#ac614869cdea45a7f9ba6830367f4c88e" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="ace9045603ed29821d36c95e377787cb9" name="ace9045603ed29821d36c95e377787cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9045603ed29821d36c95e377787cb9">&#9670;&nbsp;</a></span>childWasRemoved() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childWasRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been removed from directly beneath the packet. </p>
<p >Before the child is removed, <a class="el" href="classregina_1_1PacketListener.html#a8bf5452243f27123731863cb3bebad7d" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> will be called also.</p>
<p >Since Regina 7.0, this routine is no longer called from within either the parent or child packet's destructor. In particular, when a parent packet is destroyed, although it orphans all of its children as part of the destruction process, it does not call <a class="el" href="classregina_1_1PacketListener.html#a8bf5452243f27123731863cb3bebad7d" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> or childWasRemoved when this happens.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to, or <code>null</code> if this routine is being called from within this packet's destructor. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e5804f18f416cd82f774ba0a824f9a" name="a60e5804f18f416cd82f774ba0a824f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e5804f18f416cd82f774ba0a824f9a">&#9670;&nbsp;</a></span>childWasRemoved() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childWasRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#ace9045603ed29821d36c95e377787cb9" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> callback now takes its arguments by reference, not by pointer, and is no longer called from within either the child or parent destructor.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#ace9045603ed29821d36c95e377787cb9" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="ad0c4ddc6af52648935d3ba7a1fcdda93" name="ad0c4ddc6af52648935d3ba7a1fcdda93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c4ddc6af52648935d3ba7a1fcdda93">&#9670;&nbsp;</a></span>childWasRenamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after one of this packet's immediate children has its label or tags changed. </p>
<p >Before this change, <a class="el" href="classregina_1_1PacketListener.html#ac15da77574a5a1ac0af1a635b3bf0553" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1PacketListener.html#a9fe6ee72cf2a7c639d4f26bb25d321b7" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> </dd></dl>

</div>
</div>
<a id="aec7d0c9d7ab1444524b4795a55ac2caa" name="aec7d0c9d7ab1444524b4795a55ac2caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7d0c9d7ab1444524b4795a55ac2caa">&#9670;&nbsp;</a></span>childWasRenamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::childWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#ad0c4ddc6af52648935d3ba7a1fcdda93" title="Called after one of this packet&#39;s immediate children has its label or tags changed.">childWasRenamed()</a> callback now takes its arguments by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#ad0c4ddc6af52648935d3ba7a1fcdda93" title="Called after one of this packet&#39;s immediate children has its label or tags changed.">childWasRenamed()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="ace9d7005779c81d3b09f04111bc6d1ae" name="ace9d7005779c81d3b09f04111bc6d1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9d7005779c81d3b09f04111bc6d1ae">&#9670;&nbsp;</a></span>isListening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketListener::isListening </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this object is listening for events on any packets at all. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this object is listening on at least one packet. </dd></dl>

</div>
</div>
<a id="ae24adde68b0429937878e2c51bbb7142" name="ae24adde68b0429937878e2c51bbb7142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24adde68b0429937878e2c51bbb7142">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp; regina::PacketListener::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<p >This listener will be unregistered from whatever packets it is currently listening to, and instead will be registered as listening to the same packets as <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the listener to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this packet listener. </dd></dl>

</div>
</div>
<a id="ab3d0f54089c4acd49b49276a3473fff2" name="ab3d0f54089c4acd49b49276a3473fff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d0f54089c4acd49b49276a3473fff2">&#9670;&nbsp;</a></span>packetBeingDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetBeingDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called as the packet is being destroyed. </p>
<p >By the time this function is called, we are already inside the <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> destructor, and so most <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> member functions are no longer safe to call. Therefore the argument that is passed to this routine is a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>, which exposes only those member functions of <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> that are still safe to call at this time. Importantly, you can safely compare a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> against a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> pointer, in case you need to identify which particular packet is being destroyed.</p>
<p >When a packet is destroyed, it will automatically unregister each listener <em>before</em> calling <a class="el" href="classregina_1_1PacketListener.html#ab3d0f54089c4acd49b49276a3473fff2" title="Called as the packet is being destroyed.">packetBeingDestroyed()</a> on that listener. Therefore, for this (and only this) callback, it is safe for a listener to unregister itself (since this will be a harmless operation that does nothing). In particular, this makes it safe for a listener to delete itself during this callback.</p>
<p >When an entire packet subtree is to be destroyed, child packets will notify their listeners of the impending destruction before parent packets will.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>gives access to the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3b3ba238a00f5c13fd9bca2b9db21db" name="ac3b3ba238a00f5c13fd9bca2b9db21db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b3ba238a00f5c13fd9bca2b9db21db">&#9670;&nbsp;</a></span>packetToBeChanged() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetToBeChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the contents of the packet are to be changed. </p>
<p >Once the contents are changed, <a class="el" href="classregina_1_1PacketListener.html#af302a5875214631b50b05c62cd6ef17c" title="Called after the contents of the packet have been changed.">packetWasChanged()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dcc31e05fca376f94d2b49adc183cfb" name="a4dcc31e05fca376f94d2b49adc183cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcc31e05fca376f94d2b49adc183cfb">&#9670;&nbsp;</a></span>packetToBeChanged() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetToBeChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#ac3b3ba238a00f5c13fd9bca2b9db21db" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> callback now takes its argument by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#ac3b3ba238a00f5c13fd9bca2b9db21db" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="afa75c1a6f772c7193bfe0839b325c45d" name="afa75c1a6f772c7193bfe0839b325c45d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa75c1a6f772c7193bfe0839b325c45d">&#9670;&nbsp;</a></span>packetToBeDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetToBeDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >This callback has been renamed to <a class="el" href="classregina_1_1PacketListener.html#ab3d0f54089c4acd49b49276a3473fff2" title="Called as the packet is being destroyed.">packetBeingDestroyed()</a>, to emphasise the fact that we are already well inside the packet destructor when this is called.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, since Python does not provide a mechanism such as <code>final</code> to prevent subclasses from overriding a function. </dd></dl>

</div>
</div>
<a id="a0336eec77b7d7e5f272db798ab39a6d7" name="a0336eec77b7d7e5f272db798ab39a6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0336eec77b7d7e5f272db798ab39a6d7">&#9670;&nbsp;</a></span>packetToBeRenamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet label or tags are to be changed. </p>
<p >Once the label or tags are changed, <a class="el" href="classregina_1_1PacketListener.html#a9fe6ee72cf2a7c639d4f26bb25d321b7" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1PacketListener.html#ac15da77574a5a1ac0af1a635b3bf0553" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> </dd></dl>

</div>
</div>
<a id="ab9a92f55ecf23879dffa1b14924463ed" name="ab9a92f55ecf23879dffa1b14924463ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a92f55ecf23879dffa1b14924463ed">&#9670;&nbsp;</a></span>packetToBeRenamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#a0336eec77b7d7e5f272db798ab39a6d7" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> callback now takes its argument by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#a0336eec77b7d7e5f272db798ab39a6d7" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="af302a5875214631b50b05c62cd6ef17c" name="af302a5875214631b50b05c62cd6ef17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af302a5875214631b50b05c62cd6ef17c">&#9670;&nbsp;</a></span>packetWasChanged() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetWasChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the contents of the packet have been changed. </p>
<p >Before the contents are changed, <a class="el" href="classregina_1_1PacketListener.html#ac3b3ba238a00f5c13fd9bca2b9db21db" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f077e629a0ec6ec7df4de4fb487fffa" name="a2f077e629a0ec6ec7df4de4fb487fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f077e629a0ec6ec7df4de4fb487fffa">&#9670;&nbsp;</a></span>packetWasChanged() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetWasChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#af302a5875214631b50b05c62cd6ef17c" title="Called after the contents of the packet have been changed.">packetWasChanged()</a> callback now takes its argument by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#af302a5875214631b50b05c62cd6ef17c" title="Called after the contents of the packet have been changed.">packetWasChanged()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="a9fe6ee72cf2a7c639d4f26bb25d321b7" name="a9fe6ee72cf2a7c639d4f26bb25d321b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe6ee72cf2a7c639d4f26bb25d321b7">&#9670;&nbsp;</a></span>packetWasRenamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the packet label or tags have been changed. </p>
<p >Before the label or tags are changed, <a class="el" href="classregina_1_1PacketListener.html#a0336eec77b7d7e5f272db798ab39a6d7" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> will be called also.</p>
<p >The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classregina_1_1PacketListener.html#ad0c4ddc6af52648935d3ba7a1fcdda93" title="Called after one of this packet&#39;s immediate children has its label or tags changed.">childWasRenamed()</a> </dd></dl>

</div>
</div>
<a id="a51e2e4d18d9a359097c9d8b0ee848f21" name="a51e2e4d18d9a359097c9d8b0ee848f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e2e4d18d9a359097c9d8b0ee848f21">&#9670;&nbsp;</a></span>packetWasRenamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PacketListener::packetWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A placeholder for an old form of a callback function that is no longer used. </p>
<p >This has been kept but marked <code>final</code> to force a compile error if any subclass attempts to remimplement it.</p>
<p >The new form of the <a class="el" href="classregina_1_1PacketListener.html#a9fe6ee72cf2a7c639d4f26bb25d321b7" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> callback now takes its argument by reference, not by pointer.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, <a class="el" href="classregina_1_1PacketListener.html#a9fe6ee72cf2a7c639d4f26bb25d321b7" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> refers to the new (reference-based) form of this callback. </dd></dl>

</div>
</div>
<a id="abe098b8de7d86b24bf41391d3c40bfdb" name="abe098b8de7d86b24bf41391d3c40bfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe098b8de7d86b24bf41391d3c40bfdb">&#9670;&nbsp;</a></span>swapListeners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::swapListeners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap operation. </p>
<p >This listener will be unregistered from whatever packets it is currently listening to and instead will be registered as listening to the same packets that <em>src</em> was originally listening to, and vice versa.</p>
<p >This operation is <em>not</em> constant time, since it needs to perform an internal adjustment for each packet that is affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the listener to swap with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac5f0f937aaed7a7b2cd615e861668e2" name="aac5f0f937aaed7a7b2cd615e861668e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5f0f937aaed7a7b2cd615e861668e2">&#9670;&nbsp;</a></span>unlisten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::unlisten </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters this listener from all packets to which it is currently listening. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae51cb555166657e5996a76768db998e3" name="ae51cb555166657e5996a76768db998e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51cb555166657e5996a76768db998e3">&#9670;&nbsp;</a></span>Packet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classregina_1_1Packet.html">Packet</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow packets to automatically deregister listeners as they are destroyed. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packet/<a class="el" href="packet_8h.html">packet.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
