<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: regina::Matrix&lt; T, ring &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Matrix&lt; T, ring &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a matrix of elements of the given type <em>T</em>.  
 <a href="classregina_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;maths/matrix.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Matrix&lt; T, ring &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Matrix.png" usemap="#regina::Matrix_3C_20T_2C_20ring_20_3E_map" alt=""/>
  <map id="regina::Matrix_3C_20T_2C_20ring_20_3E_map" name="regina::Matrix_3C_20T_2C_20ring_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Matrix&lt; T &gt; &gt;" shape="rect" coords="0,0,181,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aefedfdea91d3e31ed1b7ced9af726abd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aefedfdea91d3e31ed1b7ced9af726abd">value_type</a> = T</td></tr>
<tr class="memdesc:aefedfdea91d3e31ed1b7ced9af726abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of element that is stored in this matrix.  <a href="classregina_1_1Matrix.html#aefedfdea91d3e31ed1b7ced9af726abd">More...</a><br /></td></tr>
<tr class="separator:aefedfdea91d3e31ed1b7ced9af726abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aedf0d718cd5d7adc81fbd8122debd119"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aedf0d718cd5d7adc81fbd8122debd119">Matrix</a> ()</td></tr>
<tr class="memdesc:aedf0d718cd5d7adc81fbd8122debd119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised matrix.  <a href="classregina_1_1Matrix.html#aedf0d718cd5d7adc81fbd8122debd119">More...</a><br /></td></tr>
<tr class="separator:aedf0d718cd5d7adc81fbd8122debd119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfa057c41bb358842aab315cece429a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a4cfa057c41bb358842aab315cece429a">Matrix</a> (size_t size)</td></tr>
<tr class="memdesc:a4cfa057c41bb358842aab315cece429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new square matrix of the given size.  <a href="classregina_1_1Matrix.html#a4cfa057c41bb358842aab315cece429a">More...</a><br /></td></tr>
<tr class="separator:a4cfa057c41bb358842aab315cece429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeb6d444423f578c9d02b5e71485cdc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#acbeb6d444423f578c9d02b5e71485cdc">Matrix</a> (size_t <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427">rows</a>, size_t cols)</td></tr>
<tr class="memdesc:acbeb6d444423f578c9d02b5e71485cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix of the given size.  <a href="classregina_1_1Matrix.html#acbeb6d444423f578c9d02b5e71485cdc">More...</a><br /></td></tr>
<tr class="separator:acbeb6d444423f578c9d02b5e71485cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10810e0dd409b083f1d690015936ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a0c10810e0dd409b083f1d690015936ce">Matrix</a> (std::initializer_list&lt; std::initializer_list&lt; T &gt; &gt; data)</td></tr>
<tr class="memdesc:a0c10810e0dd409b083f1d690015936ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix containing the given hard-coded entries.  <a href="classregina_1_1Matrix.html#a0c10810e0dd409b083f1d690015936ce">More...</a><br /></td></tr>
<tr class="separator:a0c10810e0dd409b083f1d690015936ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dfe46d992a2cdec7ac48032ec0de3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a78dfe46d992a2cdec7ac48032ec0de3f">Matrix</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;src)</td></tr>
<tr class="memdesc:a78dfe46d992a2cdec7ac48032ec0de3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix that is a clone of the given matrix.  <a href="classregina_1_1Matrix.html#a78dfe46d992a2cdec7ac48032ec0de3f">More...</a><br /></td></tr>
<tr class="separator:a78dfe46d992a2cdec7ac48032ec0de3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402006c9b71e99ffe86ee809af492383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a402006c9b71e99ffe86ee809af492383">Matrix</a> (<a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a402006c9b71e99ffe86ee809af492383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given matrix into this new matrix.  <a href="classregina_1_1Matrix.html#a402006c9b71e99ffe86ee809af492383">More...</a><br /></td></tr>
<tr class="separator:a402006c9b71e99ffe86ee809af492383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0626c71c7a3d36bbd6223b4b8ddff81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ad0626c71c7a3d36bbd6223b4b8ddff81">~Matrix</a> ()</td></tr>
<tr class="memdesc:ad0626c71c7a3d36bbd6223b4b8ddff81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix.  <a href="classregina_1_1Matrix.html#ad0626c71c7a3d36bbd6223b4b8ddff81">More...</a><br /></td></tr>
<tr class="separator:ad0626c71c7a3d36bbd6223b4b8ddff81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff786d9337892a42cd91f9da3f9a73e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aaff786d9337892a42cd91f9da3f9a73e">operator=</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;src)</td></tr>
<tr class="memdesc:aaff786d9337892a42cd91f9da3f9a73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given matrix into this matrix.  <a href="classregina_1_1Matrix.html#aaff786d9337892a42cd91f9da3f9a73e">More...</a><br /></td></tr>
<tr class="separator:aaff786d9337892a42cd91f9da3f9a73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c13f42101e2fa07d92b1203b64d3968"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a8c13f42101e2fa07d92b1203b64d3968">operator=</a> (<a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a8c13f42101e2fa07d92b1203b64d3968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given matrix into this matrix.  <a href="classregina_1_1Matrix.html#a8c13f42101e2fa07d92b1203b64d3968">More...</a><br /></td></tr>
<tr class="separator:a8c13f42101e2fa07d92b1203b64d3968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f3cbb6b3a5eece191d00ec6966ac6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a11f3cbb6b3a5eece191d00ec6966ac6a">initialise</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a11f3cbb6b3a5eece191d00ec6966ac6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets every entry in the matrix to the given value.  <a href="classregina_1_1Matrix.html#a11f3cbb6b3a5eece191d00ec6966ac6a">More...</a><br /></td></tr>
<tr class="separator:a11f3cbb6b3a5eece191d00ec6966ac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa799270c3d4946df63351dc5061a4912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aa799270c3d4946df63351dc5061a4912">swap</a> (<a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aa799270c3d4946df63351dc5061a4912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given matrix.  <a href="classregina_1_1Matrix.html#aa799270c3d4946df63351dc5061a4912">More...</a><br /></td></tr>
<tr class="separator:aa799270c3d4946df63351dc5061a4912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e69464e370a0972e130a46471443427"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427">rows</a> () const</td></tr>
<tr class="memdesc:a3e69464e370a0972e130a46471443427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in this matrix.  <a href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427">More...</a><br /></td></tr>
<tr class="separator:a3e69464e370a0972e130a46471443427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71c152cfddb303186dd7933e09895ed"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed">columns</a> () const</td></tr>
<tr class="memdesc:ab71c152cfddb303186dd7933e09895ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in this matrix.  <a href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed">More...</a><br /></td></tr>
<tr class="separator:ab71c152cfddb303186dd7933e09895ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2da0556fc0cca839600774daa06e61"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#abb2da0556fc0cca839600774daa06e61">entry</a> (size_t row, size_t column)</td></tr>
<tr class="memdesc:abb2da0556fc0cca839600774daa06e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entry at the given row and column.  <a href="classregina_1_1Matrix.html#abb2da0556fc0cca839600774daa06e61">More...</a><br /></td></tr>
<tr class="separator:abb2da0556fc0cca839600774daa06e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63596218ab52feb147657460edc5d3f2"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a63596218ab52feb147657460edc5d3f2">entry</a> (size_t row, size_t column) const</td></tr>
<tr class="memdesc:a63596218ab52feb147657460edc5d3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entry at the given row and column.  <a href="classregina_1_1Matrix.html#a63596218ab52feb147657460edc5d3f2">More...</a><br /></td></tr>
<tr class="separator:a63596218ab52feb147657460edc5d3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff87e39b79eae639934133eb6b536e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a6ff87e39b79eae639934133eb6b536e7">transpose</a> () const</td></tr>
<tr class="memdesc:a6ff87e39b79eae639934133eb6b536e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of this matrix.  <a href="classregina_1_1Matrix.html#a6ff87e39b79eae639934133eb6b536e7">More...</a><br /></td></tr>
<tr class="separator:a6ff87e39b79eae639934133eb6b536e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91205870817a52b6729fac999907422e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a91205870817a52b6729fac999907422e">operator==</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a91205870817a52b6729fac999907422e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given matrix are identical.  <a href="classregina_1_1Matrix.html#a91205870817a52b6729fac999907422e">More...</a><br /></td></tr>
<tr class="separator:a91205870817a52b6729fac999907422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f834c0262697474d1f765b1f26b35e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a0f834c0262697474d1f765b1f26b35e1">operator!=</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a0f834c0262697474d1f765b1f26b35e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given matrix are different.  <a href="classregina_1_1Matrix.html#a0f834c0262697474d1f765b1f26b35e1">More...</a><br /></td></tr>
<tr class="separator:a0f834c0262697474d1f765b1f26b35e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae0bb7163ff7eed6f7433548e55abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ab4ae0bb7163ff7eed6f7433548e55abb">swapRows</a> (size_t first, size_t second)</td></tr>
<tr class="memdesc:ab4ae0bb7163ff7eed6f7433548e55abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the elements of the two given rows in the matrix.  <a href="classregina_1_1Matrix.html#ab4ae0bb7163ff7eed6f7433548e55abb">More...</a><br /></td></tr>
<tr class="separator:ab4ae0bb7163ff7eed6f7433548e55abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe148a1efe475d5a03acd1e827195d11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#abe148a1efe475d5a03acd1e827195d11">swapCols</a> (size_t first, size_t second, size_t fromRow=0)</td></tr>
<tr class="memdesc:abe148a1efe475d5a03acd1e827195d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the elements of the two given columns in the matrix.  <a href="classregina_1_1Matrix.html#abe148a1efe475d5a03acd1e827195d11">More...</a><br /></td></tr>
<tr class="separator:abe148a1efe475d5a03acd1e827195d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fd05050d69382c1f07de6b3a8a7d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a51fd05050d69382c1f07de6b3a8a7d91">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a51fd05050d69382c1f07de6b3a8a7d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1Matrix.html#a51fd05050d69382c1f07de6b3a8a7d91">More...</a><br /></td></tr>
<tr class="separator:a51fd05050d69382c1f07de6b3a8a7d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48476f1ac9ac9d9731f0074277ed59c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a48476f1ac9ac9d9731f0074277ed59c0">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a48476f1ac9ac9d9731f0074277ed59c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1Matrix.html#a48476f1ac9ac9d9731f0074277ed59c0">More...</a><br /></td></tr>
<tr class="separator:a48476f1ac9ac9d9731f0074277ed59c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f6a9a4b5966864ce3028f02ba8852d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ab4f6a9a4b5966864ce3028f02ba8852d">makeIdentity</a> ()</td></tr>
<tr class="memdesc:ab4f6a9a4b5966864ce3028f02ba8852d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns this matrix into an identity matrix.  <a href="classregina_1_1Matrix.html#ab4f6a9a4b5966864ce3028f02ba8852d">More...</a><br /></td></tr>
<tr class="separator:ab4f6a9a4b5966864ce3028f02ba8852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae416e03031ead4e9047fb02476ab3c1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ae416e03031ead4e9047fb02476ab3c1f">isIdentity</a> () const</td></tr>
<tr class="memdesc:ae416e03031ead4e9047fb02476ab3c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this matrix is a square identity matrix.  <a href="classregina_1_1Matrix.html#ae416e03031ead4e9047fb02476ab3c1f">More...</a><br /></td></tr>
<tr class="separator:ae416e03031ead4e9047fb02476ab3c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e3e87586de21b6ad443eb156fc026b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a57e3e87586de21b6ad443eb156fc026b">isZero</a> () const</td></tr>
<tr class="memdesc:a57e3e87586de21b6ad443eb156fc026b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the zero matrix.  <a href="classregina_1_1Matrix.html#a57e3e87586de21b6ad443eb156fc026b">More...</a><br /></td></tr>
<tr class="separator:a57e3e87586de21b6ad443eb156fc026b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf13f6378460f1fa3184b1f485b9193"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a0cf13f6378460f1fa3184b1f485b9193">addRow</a> (size_t source, size_t dest)</td></tr>
<tr class="memdesc:a0cf13f6378460f1fa3184b1f485b9193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given source row to the given destination row.  <a href="classregina_1_1Matrix.html#a0cf13f6378460f1fa3184b1f485b9193">More...</a><br /></td></tr>
<tr class="separator:a0cf13f6378460f1fa3184b1f485b9193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ec2d9b2f5069c221457f5dc528a462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ac7ec2d9b2f5069c221457f5dc528a462">addRowFrom</a> (size_t source, size_t dest, size_t fromCol)</td></tr>
<tr class="memdesc:ac7ec2d9b2f5069c221457f5dc528a462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a portion of the given source row to the given destination row.  <a href="classregina_1_1Matrix.html#ac7ec2d9b2f5069c221457f5dc528a462">More...</a><br /></td></tr>
<tr class="separator:ac7ec2d9b2f5069c221457f5dc528a462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5670b51d3fc2953f3b811b9b2008d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ab5670b51d3fc2953f3b811b9b2008d3d">addRow</a> (size_t source, size_t dest, T copies, size_t fromCol=0)</td></tr>
<tr class="memdesc:ab5670b51d3fc2953f3b811b9b2008d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given number of copies of the given source row to the given destination row.  <a href="classregina_1_1Matrix.html#ab5670b51d3fc2953f3b811b9b2008d3d">More...</a><br /></td></tr>
<tr class="separator:ab5670b51d3fc2953f3b811b9b2008d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96d1acd7a2c83bec64b8f4233467957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aa96d1acd7a2c83bec64b8f4233467957">addCol</a> (size_t source, size_t dest)</td></tr>
<tr class="memdesc:aa96d1acd7a2c83bec64b8f4233467957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given source column to the given destination column.  <a href="classregina_1_1Matrix.html#aa96d1acd7a2c83bec64b8f4233467957">More...</a><br /></td></tr>
<tr class="separator:aa96d1acd7a2c83bec64b8f4233467957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab750f11442b88e0cec641e1cb2337fe2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ab750f11442b88e0cec641e1cb2337fe2">addColFrom</a> (size_t source, size_t dest, size_t fromRow=0)</td></tr>
<tr class="memdesc:ab750f11442b88e0cec641e1cb2337fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a portion of the given source column to the given destination column.  <a href="classregina_1_1Matrix.html#ab750f11442b88e0cec641e1cb2337fe2">More...</a><br /></td></tr>
<tr class="separator:ab750f11442b88e0cec641e1cb2337fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5088a445184d3fa9273e4f41fd276d5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a5088a445184d3fa9273e4f41fd276d5e">addCol</a> (size_t source, size_t dest, T copies, size_t fromRow=0)</td></tr>
<tr class="memdesc:a5088a445184d3fa9273e4f41fd276d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given number of copies of the given source column to the given destination column.  <a href="classregina_1_1Matrix.html#a5088a445184d3fa9273e4f41fd276d5e">More...</a><br /></td></tr>
<tr class="separator:a5088a445184d3fa9273e4f41fd276d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa383b224020122f38a3c9251d6ad9e3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aa383b224020122f38a3c9251d6ad9e3a">multRow</a> (size_t row, T factor, size_t fromCol=0)</td></tr>
<tr class="memdesc:aa383b224020122f38a3c9251d6ad9e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given row by the given factor.  <a href="classregina_1_1Matrix.html#aa383b224020122f38a3c9251d6ad9e3a">More...</a><br /></td></tr>
<tr class="separator:aa383b224020122f38a3c9251d6ad9e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d37c4067ed3b2dffe1a94f9c5b50e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a2b2d37c4067ed3b2dffe1a94f9c5b50e">multCol</a> (size_t column, T factor, size_t fromRow=0)</td></tr>
<tr class="memdesc:a2b2d37c4067ed3b2dffe1a94f9c5b50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given column by the given factor.  <a href="classregina_1_1Matrix.html#a2b2d37c4067ed3b2dffe1a94f9c5b50e">More...</a><br /></td></tr>
<tr class="separator:a2b2d37c4067ed3b2dffe1a94f9c5b50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7d4c4cbd59527ceee226e8c269a2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a6f7d4c4cbd59527ceee226e8c269a2d2">combRows</a> (size_t row1, size_t row2, T coeff11, T coeff12, T coeff21, T coeff22, size_t fromCol=0)</td></tr>
<tr class="memdesc:a6f7d4c4cbd59527ceee226e8c269a2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites two rows as linear combinations of those two rows.  <a href="classregina_1_1Matrix.html#a6f7d4c4cbd59527ceee226e8c269a2d2">More...</a><br /></td></tr>
<tr class="separator:a6f7d4c4cbd59527ceee226e8c269a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862c4789db2b75c1fd453d9d12b676bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a862c4789db2b75c1fd453d9d12b676bc">combCols</a> (size_t col1, size_t col2, T coeff11, T coeff12, T coeff21, T coeff22, size_t fromRow=0)</td></tr>
<tr class="memdesc:a862c4789db2b75c1fd453d9d12b676bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites two columns as linear combinations of those two columns.  <a href="classregina_1_1Matrix.html#a862c4789db2b75c1fd453d9d12b676bc">More...</a><br /></td></tr>
<tr class="separator:a862c4789db2b75c1fd453d9d12b676bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab74978d323eb06a69d1187396df9771"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aab74978d323eb06a69d1187396df9771"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; decltype(T() *U())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aab74978d323eb06a69d1187396df9771">operator*</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; U, true &gt; &amp;other) const</td></tr>
<tr class="memdesc:aab74978d323eb06a69d1187396df9771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by the given matrix, and returns the result.  <a href="classregina_1_1Matrix.html#aab74978d323eb06a69d1187396df9771">More...</a><br /></td></tr>
<tr class="separator:aab74978d323eb06a69d1187396df9771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c216e222e0ae397b98003455c48ca81"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0c216e222e0ae397b98003455c48ca81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; decltype(T() *U())&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a0c216e222e0ae397b98003455c48ca81">operator*</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;other) const</td></tr>
<tr class="memdesc:a0c216e222e0ae397b98003455c48ca81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this matrix by the given vector, and returns the result.  <a href="classregina_1_1Matrix.html#a0c216e222e0ae397b98003455c48ca81">More...</a><br /></td></tr>
<tr class="separator:a0c216e222e0ae397b98003455c48ca81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa3eb129b7d41b09cf883490e548a0d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a1fa3eb129b7d41b09cf883490e548a0d">det</a> () const</td></tr>
<tr class="memdesc:a1fa3eb129b7d41b09cf883490e548a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the determinant of the matrix.  <a href="classregina_1_1Matrix.html#a1fa3eb129b7d41b09cf883490e548a0d">More...</a><br /></td></tr>
<tr class="separator:a1fa3eb129b7d41b09cf883490e548a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9defc597d619b72f45e8bade0ef33727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a9defc597d619b72f45e8bade0ef33727">divRowExact</a> (size_t row, const T &amp;divBy)</td></tr>
<tr class="memdesc:a9defc597d619b72f45e8bade0ef33727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all elements of the given row by the given integer.  <a href="classregina_1_1Matrix.html#a9defc597d619b72f45e8bade0ef33727">More...</a><br /></td></tr>
<tr class="separator:a9defc597d619b72f45e8bade0ef33727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88368278ee9bf1c2b915d1030302b566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a88368278ee9bf1c2b915d1030302b566">divColExact</a> (size_t col, const T &amp;divBy)</td></tr>
<tr class="memdesc:a88368278ee9bf1c2b915d1030302b566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all elements of the given column by the given integer.  <a href="classregina_1_1Matrix.html#a88368278ee9bf1c2b915d1030302b566">More...</a><br /></td></tr>
<tr class="separator:a88368278ee9bf1c2b915d1030302b566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df3dbdc66802a94d4ca358ad08f0bc2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a4df3dbdc66802a94d4ca358ad08f0bc2">gcdRow</a> (size_t row)</td></tr>
<tr class="memdesc:a4df3dbdc66802a94d4ca358ad08f0bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of all elements of the given row.  <a href="classregina_1_1Matrix.html#a4df3dbdc66802a94d4ca358ad08f0bc2">More...</a><br /></td></tr>
<tr class="separator:a4df3dbdc66802a94d4ca358ad08f0bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb740ee25e753baf25da43a5a001079d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#abb740ee25e753baf25da43a5a001079d">gcdCol</a> (size_t col)</td></tr>
<tr class="memdesc:abb740ee25e753baf25da43a5a001079d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of all elements of the given column.  <a href="classregina_1_1Matrix.html#abb740ee25e753baf25da43a5a001079d">More...</a><br /></td></tr>
<tr class="separator:abb740ee25e753baf25da43a5a001079d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee67ed3468c5f38544c9770f826ab5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a9ee67ed3468c5f38544c9770f826ab5b">reduceRow</a> (size_t row)</td></tr>
<tr class="memdesc:a9ee67ed3468c5f38544c9770f826ab5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the given row by dividing all its elements by their greatest common divisor.  <a href="classregina_1_1Matrix.html#a9ee67ed3468c5f38544c9770f826ab5b">More...</a><br /></td></tr>
<tr class="separator:a9ee67ed3468c5f38544c9770f826ab5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c1925b72886bcb02a297a319897853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ad2c1925b72886bcb02a297a319897853">reduceCol</a> (size_t col)</td></tr>
<tr class="memdesc:ad2c1925b72886bcb02a297a319897853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the given column by dividing all its elements by their greatest common divisor.  <a href="classregina_1_1Matrix.html#ad2c1925b72886bcb02a297a319897853">More...</a><br /></td></tr>
<tr class="separator:ad2c1925b72886bcb02a297a319897853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8695a1faf047455570c573e32fc14766"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a8695a1faf047455570c573e32fc14766">rowEchelonForm</a> ()</td></tr>
<tr class="memdesc:a8695a1faf047455570c573e32fc14766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms this matrix into row echelon form.  <a href="classregina_1_1Matrix.html#a8695a1faf047455570c573e32fc14766">More...</a><br /></td></tr>
<tr class="separator:a8695a1faf047455570c573e32fc14766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893265d660bfd0d234e3105e0d4d85a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a893265d660bfd0d234e3105e0d4d85a7">columnEchelonForm</a> ()</td></tr>
<tr class="memdesc:a893265d660bfd0d234e3105e0d4d85a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms this matrix into column echelon form.  <a href="classregina_1_1Matrix.html#a893265d660bfd0d234e3105e0d4d85a7">More...</a><br /></td></tr>
<tr class="separator:a893265d660bfd0d234e3105e0d4d85a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad48e5b8e2736121acc242b6c7379ec79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ad48e5b8e2736121acc242b6c7379ec79">identity</a> (size_t size)</td></tr>
<tr class="memdesc:ad48e5b8e2736121acc242b6c7379ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity matrix of the given size.  <a href="classregina_1_1Matrix.html#ad48e5b8e2736121acc242b6c7379ec79">More...</a><br /></td></tr>
<tr class="separator:ad48e5b8e2736121acc242b6c7379ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt;<br />
class regina::Matrix&lt; T, ring &gt;</div><p >Represents a matrix of elements of the given type <em>T</em>. </p>
<p >As of Regina 5.96, the old subclasses of <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> have now been merged into a single <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> class. The additional member functions that the old subclasses MatrixRing and MatrixIntDomain used to provide are now part of <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a>, and are enabled or disabled according to the <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> template parameters.</p>
<p >It is generally safe to just use the type Matrix&lt;T&gt;, since the <code>ring</code> argument has a sensible default. At present, <code>ring</code> defaults to <code>true</code> (thereby enabling member functions designed for matrices over rings) when <em>T</em> is one of the following types:</p>
<ul>
<li>native C++ integer types (i.e., where std::is_integral_v&lt;T&gt; is <code>true</code> and <em>T</em> is not bool); or</li>
<li>Regina's own types Integer, LargeInteger, NativeInteger&lt;...&gt;, and <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a>.</li>
</ul>
<p >Other types may be added to this list in future versions of Regina.</p>
<p >There are several requirements for the underlying type <em>T</em>. For all matrix types:</p>
<ul>
<li><em>T</em> must have a default constructor and an assignment operator.</li>
<li>An element <em>t</em> of type <em>T</em> must be writable to an output stream using the standard stream operator <code>&lt;&lt;</code>.</li>
</ul>
<p >If <em>ring</em> is <code>true</code>, then in addition to this:</p>
<ul>
<li><em>T</em> must support binary operators <code>+</code>, <code>-</code> and <code>*</code>, and unary operators <code>+=</code>, <code>-=</code> and <code>*=</code>.</li>
<li><em>T</em> must be able to be constructed or assigned to from the integers 0 and 1 (representing the additive and multiplicative identities in the ring respectively). Likewise, <em>T</em> must be able to be tested for equality or inequality against 0 or 1 also.</li>
</ul>
<p >In particular, all of Regina's integer and rational types (Integer, LargeInteger, NativeInteger&lt;...&gt; and <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a>) satisfy all of these requirements, and will set <em>ring</em> to <code>true</code> by default.</p>
<p >The header <a class="el" href="matrixops_8h.html" title="Provides various complex matrix calculations.">maths/matrixops.h</a> contains several other algorithms that work with the specific class Matrix&lt;Integer&gt;.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section user"><dt>Python</dt><dd>Not present in general, although the specific types Matrix&lt;Integer&gt; and Matrix&lt;bool&gt; are available under the names MatrixInt and MatrixBool respectively.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of each individual matrix element. </td></tr>
    <tr><td class="paramname">ring</td><td><code>true</code> if we should enable member functions that only work when T represents an element of a ring. This has a sensible default; see above in the class documentation for details. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aefedfdea91d3e31ed1b7ced9af726abd" name="aefedfdea91d3e31ed1b7ced9af726abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefedfdea91d3e31ed1b7ced9af726abd">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of element that is stored in this matrix. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aedf0d718cd5d7adc81fbd8122debd119" name="aedf0d718cd5d7adc81fbd8122debd119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf0d718cd5d7adc81fbd8122debd119">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::Matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised matrix. </p>
<p >You <em>must</em> initialise this matrix using the assignment operator before you can use it for any purpose. The only exceptions are:</p>
<ul>
<li>you can safely destroy an uninitialised matrix;</li>
<li>you can safely assign an uninitialised matrix to another matrix (either via an assignment operator or copy constructor), in which case the other matrix will become uninitialised also and subject to similar constraints.</li>
</ul>
<dl class="section user"><dt>Python</dt><dd>Not present, since the C++ assignment operators are not accessible to Python. </dd></dl>

</div>
</div>
<a id="a4cfa057c41bb358842aab315cece429a" name="a4cfa057c41bb358842aab315cece429a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfa057c41bb358842aab315cece429a">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new square matrix of the given size. </p>
<p >Both the number of rows and the number of columns will be set to <em>size</em>.</p>
<p >All entries will be initialised using their default constructors. In particular, this means that for Regina's own integer classes (Integer, LargeInteger and <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>), all entries will be initialised to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>T</em> is a native C++ integer type (such as <code>int</code> or <code>long</code>), then the matrix elements will not be initialised to any particular value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given size is strictly positive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of rows and columns in the new matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbeb6d444423f578c9d02b5e71485cdc" name="acbeb6d444423f578c9d02b5e71485cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbeb6d444423f578c9d02b5e71485cdc">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new matrix of the given size. </p>
<p >All entries will be initialised using their default constructors. In particular, this means that for Regina's own integer classes (Integer, LargeInteger and <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>), all entries will be initialised to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>T</em> is a native C++ integer type (such as <code>int</code> or <code>long</code>), then the matrix elements will not be initialised to any particular value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of rows and columns are both strictly positive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>the number of columns in the new matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c10810e0dd409b083f1d690015936ce" name="a0c10810e0dd409b083f1d690015936ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c10810e0dd409b083f1d690015936ce">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new matrix containing the given hard-coded entries. </p>
<p >This constructor can be used (for example) to create hard-coded examples directly in C++ code.</p>
<p >Each element of the initialiser list <em>data</em> describes a single row of the matrix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The list <em>data</em> is non-empty (i.e., the number of rows is positive), and each of its elements is non-empty (i.e., the number of columns is positive).</dd>
<dd>
All elements of <em>data</em> (representing the rows of the matrix) are lists of the same size.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The argument <em>data</em> should be a Python list of Python lists.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the rows of the matrix, each given as a list of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78dfe46d992a2cdec7ac48032ec0de3f" name="a78dfe46d992a2cdec7ac48032ec0de3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dfe46d992a2cdec7ac48032ec0de3f">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new matrix that is a clone of the given matrix. </p>
<p >This constructor induces a deep copy of <em>src</em>.</p>
<p >This routine is safe to call even if <em>src</em> is uninitialised (in which case this matrix will become uninitialised also).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a402006c9b71e99ffe86ee809af492383" name="a402006c9b71e99ffe86ee809af492383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402006c9b71e99ffe86ee809af492383">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given matrix into this new matrix. </p>
<p >This is a fast (constant time) operation.</p>
<p >The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<p >This routine is safe to call even if <em>src</em> is uninitialised (in which case this matrix will become uninitialised also).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0626c71c7a3d36bbd6223b4b8ddff81" name="ad0626c71c7a3d36bbd6223b4b8ddff81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0626c71c7a3d36bbd6223b4b8ddff81">&#9670;&nbsp;</a></span>~Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::~<a class="el" href="classregina_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix. </p>
<p >This destructor is safe to call even if <em>src</em> is uninitialised. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa96d1acd7a2c83bec64b8f4233467957" name="aa96d1acd7a2c83bec64b8f4233467957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96d1acd7a2c83bec64b8f4233467957">&#9670;&nbsp;</a></span>addCol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addCol </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given source column to the given destination column. </p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you only wish to add a portion of a column, be careful: you cannot just pass the usual <em>fromRow</em> argument, since this will be interpreted as a coefficient to be used with the other version of <a class="el" href="classregina_1_1Matrix.html#aa96d1acd7a2c83bec64b8f4233467957" title="Adds the given source column to the given destination column.">addCol()</a> that adds <em>several</em> copies of the source column. Instead you will need to call <a class="el" href="classregina_1_1Matrix.html#ab750f11442b88e0cec641e1cb2337fe2" title="Adds a portion of the given source column to the given destination column.">addColFrom()</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the columns to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the column that will be added to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5088a445184d3fa9273e4f41fd276d5e" name="a5088a445184d3fa9273e4f41fd276d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5088a445184d3fa9273e4f41fd276d5e">&#9670;&nbsp;</a></span>addCol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addCol </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>copies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromRow</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given number of copies of the given source column to the given destination column. </p>
<p >Note that <em>copies</em> is passed by value in case it is an element of the row to be changed.</p>
<p >If the optional argument <em>fromRow</em> is passed, then the operation will only be performed for the elements from that row down to the bottom of the column (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromRow</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the columns to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the column that will be added to. </td></tr>
    <tr><td class="paramname">copies</td><td>the number of copies of <em>source</em> to add to <em>dest</em>. </td></tr>
    <tr><td class="paramname">fromRow</td><td>the starting point in the column from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab750f11442b88e0cec641e1cb2337fe2" name="ab750f11442b88e0cec641e1cb2337fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab750f11442b88e0cec641e1cb2337fe2">&#9670;&nbsp;</a></span>addColFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addColFrom </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromRow</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a portion of the given source column to the given destination column. </p>
<p >This is similar to <a class="el" href="classregina_1_1Matrix.html#aa96d1acd7a2c83bec64b8f4233467957" title="Adds the given source column to the given destination column.">addCol()</a>, except that the operation will only be performed for the elements from the row <em>fromRow</em> down to the bottom of the column (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromRow</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the columns to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the column that will be added to. </td></tr>
    <tr><td class="paramname">fromRow</td><td>the starting point in the column from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf13f6378460f1fa3184b1f485b9193" name="a0cf13f6378460f1fa3184b1f485b9193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf13f6378460f1fa3184b1f485b9193">&#9670;&nbsp;</a></span>addRow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given source row to the given destination row. </p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you only wish to add a portion of a row, be careful: you cannot just pass the usual <em>fromCol</em> argument, since this will be interpreted as a coefficient to be used with the other version of <a class="el" href="classregina_1_1Matrix.html#a0cf13f6378460f1fa3184b1f485b9193" title="Adds the given source row to the given destination row.">addRow()</a> that adds <em>several</em> copies of the source row. Instead you will need to call <a class="el" href="classregina_1_1Matrix.html#ac7ec2d9b2f5069c221457f5dc528a462" title="Adds a portion of the given source row to the given destination row.">addRowFrom()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the row to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the row that will be added to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5670b51d3fc2953f3b811b9b2008d3d" name="ab5670b51d3fc2953f3b811b9b2008d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5670b51d3fc2953f3b811b9b2008d3d">&#9670;&nbsp;</a></span>addRow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>copies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromCol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given number of copies of the given source row to the given destination row. </p>
<p >Note that <em>copies</em> is passed by value in case it is an element of the row to be changed.</p>
<p >If the optional argument <em>fromCol</em> is passed, then the operation will only be performed for the elements from that column to the rightmost end of the row (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromCol</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the row to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the row that will be added to. </td></tr>
    <tr><td class="paramname">copies</td><td>the number of copies of <em>source</em> to add to <em>dest</em>. </td></tr>
    <tr><td class="paramname">fromCol</td><td>the starting point in the row from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7ec2d9b2f5069c221457f5dc528a462" name="ac7ec2d9b2f5069c221457f5dc528a462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ec2d9b2f5069c221457f5dc528a462">&#9670;&nbsp;</a></span>addRowFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addRowFrom </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a portion of the given source row to the given destination row. </p>
<p >This is similar to <a class="el" href="classregina_1_1Matrix.html#a0cf13f6378460f1fa3184b1f485b9193" title="Adds the given source row to the given destination row.">addRow()</a>, except that the operation will only be performed for the elements from the column <em>fromCol</em> to the rightmost end of the row (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromCol</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the row to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the row that will be added to. </td></tr>
    <tr><td class="paramname">fromCol</td><td>the starting point in the row from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a893265d660bfd0d234e3105e0d4d85a7" name="a893265d660bfd0d234e3105e0d4d85a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893265d660bfd0d234e3105e0d4d85a7">&#9670;&nbsp;</a></span>columnEchelonForm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::columnEchelonForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms this matrix into column echelon form. </p>
<p >The transformation will perform only column operations.</p>
<p >This is simpler than the global routine <a class="el" href="group__maths.html#gac0f2049e1c9f66f9de3bcaeb386890ce" title="Transforms a given matrix into column echelon form with respect to a collection of rows.">regina::columnEchelonForm()</a>: it does not return the change of basis matrices, and it processes all rows in order from left to right (instead of passing a custom row list).</p>
<p >Our convention is that a matrix is in column echelon form if:</p>
<ol type="1">
<li>each column is either zero or there is a first non-zero entry which is positive;</li>
<li>moving from the left column to the right, these first non-zero entries have strictly increasing row indices;</li>
<li>for each first non-zero column entry, in that row all the elements to the left are smaller and non-negative (and all elements to the right are already zero by the previous condition);</li>
<li>all the zero columns are at the right hand end of the matrix.</li>
</ol>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of this matrix, i.e., the number of non-zero columns remaining. </dd></dl>

</div>
</div>
<a id="ab71c152cfddb303186dd7933e09895ed" name="ab71c152cfddb303186dd7933e09895ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71c152cfddb303186dd7933e09895ed">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in this matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="a862c4789db2b75c1fd453d9d12b676bc" name="a862c4789db2b75c1fd453d9d12b676bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862c4789db2b75c1fd453d9d12b676bc">&#9670;&nbsp;</a></span>combCols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::combCols </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromRow</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrites two columns as linear combinations of those two columns. </p>
<p >Specifically, if <em>C1</em> and <em>C2</em> are the original values of columns <em>col1</em> and <em>col2</em> respectively, then:</p>
<ul>
<li>Column <em>col1</em> will become <code>coeff11 * C1 + coeff12 * C2</code>;</li>
<li>Column <em>col2</em> will become <code>coeff21 * C1 + coeff22 * C2</code>.</li>
</ul>
<p >The four coefficients are passed by value, in case they are elements of the columns to be changed.</p>
<p >If the optional argument <em>fromRow</em> is passed, then the operation will only be performed for the elements from that column down to the bottom of each column (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromCol</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col1</td><td>the first column to operate on. </td></tr>
    <tr><td class="paramname">col2</td><td>the second column to operate on. </td></tr>
    <tr><td class="paramname">coeff11</td><td>the coefficient of column <em>col1</em> to use when rewriting column <em>col1</em>. </td></tr>
    <tr><td class="paramname">coeff12</td><td>the coefficient of column <em>col2</em> to use when rewriting column <em>col1</em>. </td></tr>
    <tr><td class="paramname">coeff21</td><td>the coefficient of column <em>col1</em> to use when rewriting column <em>col2</em>. </td></tr>
    <tr><td class="paramname">coeff22</td><td>the coefficient of column <em>col2</em> to use when rewriting column <em>col2</em>. </td></tr>
    <tr><td class="paramname">fromRow</td><td>the starting point in the columns from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f7d4c4cbd59527ceee226e8c269a2d2" name="a6f7d4c4cbd59527ceee226e8c269a2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7d4c4cbd59527ceee226e8c269a2d2">&#9670;&nbsp;</a></span>combRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::combRows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>coeff22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromCol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rewrites two rows as linear combinations of those two rows. </p>
<p >Specifically, if <em>R1</em> and <em>R2</em> are the original values of rows <em>row1</em> and <em>row2</em> respectively, then:</p>
<ul>
<li>Row <em>row1</em> will become <code>coeff11 * R1 + coeff12 * R2</code>;</li>
<li>Row <em>row2</em> will become <code>coeff21 * R1 + coeff22 * R2</code>.</li>
</ul>
<p >The four coefficients are passed by value, in case they are elements of the rows to be changed.</p>
<p >If the optional argument <em>fromCol</em> is passed, then the operation will only be performed for the elements from that column to the rightmost end of each row (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromCol</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row1</td><td>the first row to operate on. </td></tr>
    <tr><td class="paramname">row2</td><td>the second row to operate on. </td></tr>
    <tr><td class="paramname">coeff11</td><td>the coefficient of row <em>row1</em> to use when rewriting row <em>row1</em>. </td></tr>
    <tr><td class="paramname">coeff12</td><td>the coefficient of row <em>row2</em> to use when rewriting row <em>row1</em>. </td></tr>
    <tr><td class="paramname">coeff21</td><td>the coefficient of row <em>row1</em> to use when rewriting row <em>row2</em>. </td></tr>
    <tr><td class="paramname">coeff22</td><td>the coefficient of row <em>row2</em> to use when rewriting row <em>row2</em>. </td></tr>
    <tr><td class="paramname">fromCol</td><td>the starting point in the rows from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fa3eb129b7d41b09cf883490e548a0d" name="a1fa3eb129b7d41b09cf883490e548a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa3eb129b7d41b09cf883490e548a0d">&#9670;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::det </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the determinant of the matrix. </p>
<p >This algorithm has quartic complexity, and uses the dynamic programming approach of Mahajan and Vinay. For further details, see Meena Mahajan and V. Vinay, "Determinant:
Combinatorics, algorithms, and complexity", Chicago J. Theor. Comput. Sci., Vol. 1997, Article 5.</p>
<p >Although the <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> class does not formally support empty matrices, if this <em>is</em> found to be a 0-by-0 matrix then the determinant returned will be 1.</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is a square matrix.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>this matrix is not square.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the determinant of this matrix. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a88368278ee9bf1c2b915d1030302b566" name="a88368278ee9bf1c2b915d1030302b566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88368278ee9bf1c2b915d1030302b566">&#9670;&nbsp;</a></span>divColExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::divColExact </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>divBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides all elements of the given column by the given integer. </p>
<p >This can only be used when the given integer divides into all column elements exactly (with no remainder). For the Integer class, this may be much faster than ordinary division.</p>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>divBy</em> is neither zero nor infinity, and none of the elements of the given column are infinity. </dd>
<dd>
The argument <em>divBy</em> divides exactly into every element of the given column (i.e., it leaves no remainder). </dd>
<dd>
The given column number is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the index of the column whose elements should be divided by <em>divBy</em>. </td></tr>
    <tr><td class="paramname">divBy</td><td>the integer to divide each column element by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9defc597d619b72f45e8bade0ef33727" name="a9defc597d619b72f45e8bade0ef33727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9defc597d619b72f45e8bade0ef33727">&#9670;&nbsp;</a></span>divRowExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::divRowExact </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>divBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides all elements of the given row by the given integer. </p>
<p >This can only be used when the given integer divides into all row elements exactly (with no remainder). For the Integer class, this may be much faster than ordinary division.</p>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>divBy</em> is neither zero nor infinity, and none of the elements of the given row are infinity. </dd>
<dd>
The argument <em>divBy</em> divides exactly into every element of the given row (i.e., it leaves no remainder). </dd>
<dd>
The given row number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the index of the row whose elements should be divided by <em>divBy</em>. </td></tr>
    <tr><td class="paramname">divBy</td><td>the integer to divide each row element by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb2da0556fc0cca839600774daa06e61" name="abb2da0556fc0cca839600774daa06e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2da0556fc0cca839600774daa06e61">&#9670;&nbsp;</a></span>entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entry at the given row and column. </p>
<p >Rows and columns are numbered beginning at zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>row</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
<em>column</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The <a class="el" href="classregina_1_1Matrix.html#abb2da0556fc0cca839600774daa06e61" title="Returns the entry at the given row and column.">entry()</a> routine gives direct read-write access to matrix elements, but does not allow them to be set using the assignment operator. In other words, code such as <code>matrix.entry(r, c).negate()</code> will work, but <code>matrix.entry(r, c) = value</code> will not. To assign values to matrix elements, you should instead use the syntax <code>matrix.set(row, column, value)</code>. This set() routine returns nothing, and is provided for python only (i.e., it is not part of the C++ calculation engine).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the desired entry. </td></tr>
    <tr><td class="paramname">column</td><td>the column of the desired entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the entry in the given row and column. </dd></dl>

</div>
</div>
<a id="a63596218ab52feb147657460edc5d3f2" name="a63596218ab52feb147657460edc5d3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63596218ab52feb147657460edc5d3f2">&#9670;&nbsp;</a></span>entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entry at the given row and column. </p>
<p >Rows and columns are numbered beginning at zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>row</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
<em>column</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the desired entry. </td></tr>
    <tr><td class="paramname">column</td><td>the column of the desired entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the entry in the given row and column. </dd></dl>

</div>
</div>
<a id="abb740ee25e753baf25da43a5a001079d" name="abb740ee25e753baf25da43a5a001079d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb740ee25e753baf25da43a5a001079d">&#9670;&nbsp;</a></span>gcdCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::gcdCol </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of all elements of the given column. </p>
<p >The value returned is guaranteed to be non-negative.</p>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given column number is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the index of the column whose gcd should be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor of all elements of this column. </dd></dl>

</div>
</div>
<a id="a4df3dbdc66802a94d4ca358ad08f0bc2" name="a4df3dbdc66802a94d4ca358ad08f0bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df3dbdc66802a94d4ca358ad08f0bc2">&#9670;&nbsp;</a></span>gcdRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::gcdRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of all elements of the given row. </p>
<p >The value returned is guaranteed to be non-negative.</p>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given row number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the index of the row whose gcd should be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor of all elements of this row. </dd></dl>

</div>
</div>
<a id="ad48e5b8e2736121acc242b6c7379ec79" name="ad48e5b8e2736121acc242b6c7379ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48e5b8e2736121acc242b6c7379ec79">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Matrix.html">Matrix</a> <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::identity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity matrix of the given size. </p>
<p >The matrix returned will have <em>size</em> rows and <em>size</em> columns.</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of rows and columns of the matrix to build. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an identity matrix of the given size. </dd></dl>

</div>
</div>
<a id="a11f3cbb6b3a5eece191d00ec6966ac6a" name="a11f3cbb6b3a5eece191d00ec6966ac6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f3cbb6b3a5eece191d00ec6966ac6a">&#9670;&nbsp;</a></span>initialise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::initialise </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets every entry in the matrix to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to assign to each entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae416e03031ead4e9047fb02476ab3c1f" name="ae416e03031ead4e9047fb02476ab3c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae416e03031ead4e9047fb02476ab3c1f">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this matrix is a square identity matrix. </p>
<p >If this matrix is square, <a class="el" href="classregina_1_1Matrix.html#ae416e03031ead4e9047fb02476ab3c1f" title="Determines whether this matrix is a square identity matrix.">isIdentity()</a> will return <code>true</code> if and only if the matrix has ones in the main diagonal and zeroes everywhere else.</p>
<p >If this matrix is not square, <a class="el" href="classregina_1_1Matrix.html#ae416e03031ead4e9047fb02476ab3c1f" title="Determines whether this matrix is a square identity matrix.">isIdentity()</a> will always return <code>false</code> (even if <a class="el" href="classregina_1_1Matrix.html#ab4f6a9a4b5966864ce3028f02ba8852d" title="Turns this matrix into an identity matrix.">makeIdentity()</a> was called earlier).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a square identity matrix. </dd></dl>

</div>
</div>
<a id="a57e3e87586de21b6ad443eb156fc026b" name="a57e3e87586de21b6ad443eb156fc026b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e3e87586de21b6ad443eb156fc026b">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::isZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the zero matrix. </p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all entries in the matrix are zero. </dd></dl>

</div>
</div>
<a id="ab4f6a9a4b5966864ce3028f02ba8852d" name="ab4f6a9a4b5966864ce3028f02ba8852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f6a9a4b5966864ce3028f02ba8852d">&#9670;&nbsp;</a></span>makeIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::makeIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns this matrix into an identity matrix. </p>
<p >This matrix need not be square; after this routine it will have <code>entry(r,c)</code> equal to 1 if <code>r == c</code> and 0 otherwise.</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>. </p>

</div>
</div>
<a id="a2b2d37c4067ed3b2dffe1a94f9c5b50e" name="a2b2d37c4067ed3b2dffe1a94f9c5b50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d37c4067ed3b2dffe1a94f9c5b50e">&#9670;&nbsp;</a></span>multCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::multCol </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromRow</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given column by the given factor. </p>
<p >Note that <em>factor</em> is passed by value in case it is an element of the row to be changed.</p>
<p >If the optional argument <em>fromRow</em> is passed, then the operation will only be performed for the elements from that row down to the bottom of the column (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given column is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromRow</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>the column to work with. </td></tr>
    <tr><td class="paramname">factor</td><td>the factor by which to multiply the given column. </td></tr>
    <tr><td class="paramname">fromRow</td><td>the starting point in the column from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa383b224020122f38a3c9251d6ad9e3a" name="aa383b224020122f38a3c9251d6ad9e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa383b224020122f38a3c9251d6ad9e3a">&#9670;&nbsp;</a></span>multRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::multRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromCol</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given row by the given factor. </p>
<p >Note that <em>factor</em> is passed by value in case it is an element of the row to be changed.</p>
<p >If the optional argument <em>fromCol</em> is passed, then the operation will only be performed for the elements from that column to the rightmost end of the row (inclusive).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given row is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromCol</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row to work with. </td></tr>
    <tr><td class="paramname">factor</td><td>the factor by which to multiply the given row. </td></tr>
    <tr><td class="paramname">fromCol</td><td>the starting point in the row from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f834c0262697474d1f765b1f26b35e1" name="a0f834c0262697474d1f765b1f26b35e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f834c0262697474d1f765b1f26b35e1">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given matrix are different. </p>
<p >Two matrices are different if either (i) their dimensions differ, or (ii) the corresponding elements of each matrix differ in at least one location.</p>
<p >Note that this routine can happily deal with two matrices of different dimensions (in which case it will always return <code>true</code>).</p>
<p >This routine returns <code>true</code> if and only if the equality operator (==) returns <code>false</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> provides an equality operator (==).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrices are different as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aab74978d323eb06a69d1187396df9771" name="aab74978d323eb06a69d1187396df9771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab74978d323eb06a69d1187396df9771">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; decltype(T() *U())&gt; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; U, true &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this by the given matrix, and returns the result. </p>
<p >This matrix is not changed.</p>
<p >The two matrices being multiplied may use different underlying types (e.g., you can multiply a matrix of LargeInteger objects with a matrix of native C++ long integers). The type of object that is stored in the resulting matrix will be deduced accordingly (specifically, it will be the type obtained by multiplying objects of types <em>T</em> and <em>U</em> using the binary multiplication operator).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The number of columns in this matrix equals the number of rows in the given matrix.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other matrix to multiply this matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product matrix <code>this * other</code>. </dd></dl>

</div>
</div>
<a id="a0c216e222e0ae397b98003455c48ca81" name="a0c216e222e0ae397b98003455c48ca81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c216e222e0ae397b98003455c48ca81">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; decltype(T() *U())&gt; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this matrix by the given vector, and returns the result. </p>
<p >The given vector is treated as a column vector.</p>
<p >The matrix and vector may use different underlying types (e.g., you can multiply a matrix of LargeInteger objects with a vector of native C++ long integers). The type of object that is stored in the resulting vector will be deduced accordingly (specifically, it will be the type obtained by multiplying objects of types <em>T</em> and <em>U</em> using the binary multiplication operator).</p>
<p >This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The length of the given vector is precisely the number of columns in this matrix.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to multiply this matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product <code>this * other</code>, which will be a vector whose length is the number of rows in this matrix. </dd></dl>

</div>
</div>
<a id="aaff786d9337892a42cd91f9da3f9a73e" name="aaff786d9337892a42cd91f9da3f9a73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff786d9337892a42cd91f9da3f9a73e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given matrix into this matrix. </p>
<p >It does not matter if this and the given matrix have different sizes; if they do then this matrix will be resized as a result.</p>
<p >This operator induces a deep copy of <em>src</em>.</p>
<p >This routine is safe to call even if <em>src</em> is uninitialised (in which case this matrix will become uninitialised also).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this matrix. </dd></dl>

</div>
</div>
<a id="a8c13f42101e2fa07d92b1203b64d3968" name="a8c13f42101e2fa07d92b1203b64d3968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c13f42101e2fa07d92b1203b64d3968">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given matrix into this matrix. </p>
<p >This is a fast (constant time) operation.</p>
<p >It does not matter if this and the given matrix have different sizes; if they do then this matrix will be resized as a result.</p>
<p >The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<p >This routine is safe to call even if <em>src</em> is uninitialised (in which case this matrix will become uninitialised also).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this matrix. </dd></dl>

</div>
</div>
<a id="a91205870817a52b6729fac999907422e" name="a91205870817a52b6729fac999907422e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91205870817a52b6729fac999907422e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given matrix are identical. </p>
<p >Two matrices are identical if and only if (i) their dimensions are the same, and (ii) the corresponding elements of each matrix are equal.</p>
<p >Note that this routine can happily deal with two matrices of different dimensions (in which case it will always return <code>false</code>).</p>
<p >This routine returns <code>true</code> if and only if the inequality operator (!=) returns <code>false</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> provides an equality operator (==).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrices are equal as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ad2c1925b72886bcb02a297a319897853" name="ad2c1925b72886bcb02a297a319897853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c1925b72886bcb02a297a319897853">&#9670;&nbsp;</a></span>reduceCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::reduceCol </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the given column by dividing all its elements by their greatest common divisor. </p>
<p >It is guaranteed that, if the column is changed at all, it will be divided by a <em>positive</em> integer.</p>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given column number is between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the index of the column to reduce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ee67ed3468c5f38544c9770f826ab5b" name="a9ee67ed3468c5f38544c9770f826ab5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee67ed3468c5f38544c9770f826ab5b">&#9670;&nbsp;</a></span>reduceRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::reduceRow </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the given row by dividing all its elements by their greatest common divisor. </p>
<p >It is guaranteed that, if the row is changed at all, it will be divided by a <em>positive</em> integer.</p>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given row number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the index of the row to reduce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8695a1faf047455570c573e32fc14766" name="a8695a1faf047455570c573e32fc14766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8695a1faf047455570c573e32fc14766">&#9670;&nbsp;</a></span>rowEchelonForm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::rowEchelonForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms this matrix into row echelon form. </p>
<p >The transformation will perform only row operations.</p>
<p >This is simpler than the global routine <a class="el" href="group__maths.html#gac0f2049e1c9f66f9de3bcaeb386890ce" title="Transforms a given matrix into column echelon form with respect to a collection of rows.">regina::columnEchelonForm()</a>: it does not return the change of basis matrices, and it processes all columns in order from left to right (instead of passing a custom column list).</p>
<p >Our convention is that a matrix is in row echelon form if:</p>
<ol type="1">
<li>each row is either zero or there is a first non-zero entry which is positive;</li>
<li>moving from the top row to the bottom, these first non-zero entries have strictly increasing column indices;</li>
<li>for each first non-zero row entry, in that column all the elements above are smaller and non-negative (and all elements below are already zero by the previous condition);</li>
<li>all the zero rows are at the bottom of the matrix.</li>
</ol>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of this matrix, i.e., the number of non-zero rows remaining. </dd></dl>

</div>
</div>
<a id="a3e69464e370a0972e130a46471443427" name="a3e69464e370a0972e130a46471443427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e69464e370a0972e130a46471443427">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in this matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of rows. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa799270c3d4946df63351dc5061a4912" name="aa799270c3d4946df63351dc5061a4912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa799270c3d4946df63351dc5061a4912">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe148a1efe475d5a03acd1e827195d11" name="abe148a1efe475d5a03acd1e827195d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe148a1efe475d5a03acd1e827195d11">&#9670;&nbsp;</a></span>swapCols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::swapCols </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fromRow</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the elements of the two given columns in the matrix. </p>
<p >This operation is linear time (unlike swapping rows, which is constant time).</p>
<p >If the optional argument <em>fromRow</em> is passed, then the operation will only be performed for the elements from that row down to the bottom of each column (inclusive).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are between 0 and <a class="el" href="classregina_1_1Matrix.html#ab71c152cfddb303186dd7933e09895ed" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </dd>
<dd>
If passed, <em>fromRow</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a> -1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first column to swap. </td></tr>
    <tr><td class="paramname">second</td><td>the second column to swap. </td></tr>
    <tr><td class="paramname">fromRow</td><td>the starting point in each column from which the operation will be performed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4ae0bb7163ff7eed6f7433548e55abb" name="ab4ae0bb7163ff7eed6f7433548e55abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ae0bb7163ff7eed6f7433548e55abb">&#9670;&nbsp;</a></span>swapRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::swapRows </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the elements of the two given rows in the matrix. </p>
<p >This operation is constant time (unlike swapping columns, which is linear time).</p>
<p >Unlike <a class="el" href="classregina_1_1Matrix.html#abe148a1efe475d5a03acd1e827195d11" title="Swaps the elements of the two given columns in the matrix.">swapCols()</a>, this operation does not take a <em>fromCol</em> argument. This is because swapping rows is already as fast possible (internally, just a single pointer swap), and so iterating along only part of the row would slow the routine down considerably.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are between 0 and <a class="el" href="classregina_1_1Matrix.html#a3e69464e370a0972e130a46471443427" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first row to swap. </td></tr>
    <tr><td class="paramname">second</td><td>the second row to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ff87e39b79eae639934133eb6b536e7" name="a6ff87e39b79eae639934133eb6b536e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff87e39b79eae639934133eb6b536e7">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transpose of this matrix. </p>
<p >This matrix is not changed.</p>
<dl class="section return"><dt>Returns</dt><dd>the transpose. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a48476f1ac9ac9d9731f0074277ed59c0" name="a48476f1ac9ac9d9731f0074277ed59c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48476f1ac9ac9d9731f0074277ed59c0">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51fd05050d69382c1f07de6b3a8a7d91" name="a51fd05050d69382c1f07de6b3a8a7d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fd05050d69382c1f07de6b3a8a7d91">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool ring = ((std::is_integral_v&lt;T&gt; &amp;&amp; ! std::is_same_v&lt;T, bool&gt;) ||        IsReginaInteger&lt;T&gt;::value || std::is_same_v&lt;T, Rational&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>algebra/<a class="el" href="abeliangroup_8h.html">abeliangroup.h</a></li>
<li>maths/<a class="el" href="matrix_8h.html">matrix.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
