<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.1 Calculation Engine: Miscellaneous Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.1 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Miscellaneous Utilities</div></div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous helper classes and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulatorByType.html">regina::BitManipulatorByType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details for <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a> where we optimise according to the underlying data type.  <a href="classregina_1_1BitManipulatorByType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html">regina::Bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask that can store arbitrarily many true-or-false bits.  <a href="classregina_1_1Bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) true-or-false bits.  <a href="classregina_1_1Bitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) true-or-false bits.  <a href="classregina_1_1Bitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BoolSet.html">regina::BoolSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of booleans.  <a href="classregina_1_1BoolSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ReginaException.html">regina::ReginaException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for all of the exceptions that are thrown by Regina's native mathematical code.  <a href="classregina_1_1ReginaException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FailedPrecondition.html">regina::FailedPrecondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when a function detects that its preconditions have been violated.  <a href="classregina_1_1FailedPrecondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1InvalidArgument.html">regina::InvalidArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when invalid or unsupported arguments are passed into a function.  <a href="classregina_1_1InvalidArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1InvalidInput.html">regina::InvalidInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when a function reads unexpected or incomplete data from an input stream.  <a href="classregina_1_1InvalidInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NotImplemented.html">regina::NotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when some functionality is not yet implemented.  <a href="classregina_1_1NotImplemented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FileError.html">regina::FileError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when trying to access data from the filesystem.  <a href="classregina_1_1FileError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NoSolution.html">regina::NoSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when Regina has certified that a mathematical problem has no solution.  <a href="classregina_1_1NoSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1UnsolvedCase.html">regina::UnsolvedCase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when a mathematical function is not able to solve a particular instance of a problem.  <a href="classregina_1_1UnsolvedCase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Flags.html">regina::Flags&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a bitwise combination of flags defined by an enumeration type.  <a href="classregina_1_1Flags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1Locale.html">regina::i18n::Locale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class with static routines for querying information about the current locale.  <a href="classregina_1_1i18n_1_1Locale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">regina::i18n::IConvStreamBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream buffer that translates between character encodings.  <a href="classregina_1_1i18n_1_1IConvStreamBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStream.html">regina::i18n::IConvStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream that converts between character encodings.  <a href="classregina_1_1i18n_1_1IConvStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IsReginaInteger.html">regina::IsReginaInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the type <em>T</em> is one of Regina's own integer types (either arbitrary precision or fixed size).  <a href="structregina_1_1IsReginaInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IsReginaArbitraryPrecisionInteger.html">regina::IsReginaArbitraryPrecisionInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the type <em>T</em> is one of Regina's arbitrary precision integer types.  <a href="structregina_1_1IsReginaArbitraryPrecisionInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfSize.html">regina::IntOfSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>exactly</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfMinSize.html">regina::IntOfMinSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>at least</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfMinSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FaithfulAssignment.html">regina::FaithfulAssignment&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an integer of type <em>From</em> can always be assigned to an integer of type <em>To</em> with no loss of information.  <a href="structregina_1_1FaithfulAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ListView.html">regina::ListView&lt; Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight object that can be used for iteration and random access to all elements of a given list.  <a href="classregina_1_1ListView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ListView_3_01Element_01_5_01_4.html">regina::ListView&lt; Element * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialisation of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a> for working with lists stored in a C-style array.  <a href="classregina_1_1ListView_3_01Element_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html">regina::MarkedElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for elements of <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="classregina_1_1MarkedElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of objects with fast, space-efficient reverse lookup of array indices.  <a href="classregina_1_1MarkedVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__istream.html">regina::mem_istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input stream that reads an array of characters in memory.  <a href="classregina_1_1mem__istream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__streambuf.html">regina::mem_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream buffer that provides the implementation details for <a class="el" href="classregina_1_1mem__istream.html" title="An input stream that reads an array of characters in memory.">mem_istream</a>.  <a href="classregina_1_1mem__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1RandomEngine.html">regina::RandomEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers threadsafe access to Regina's global uniform random bit generator.  <a href="classregina_1_1RandomEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight class for storing a random-access sequence of objects.  <a href="classregina_1_1LightweightSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ShortArray.html">regina::ShortArray&lt; T, maxSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A short stack-based array of bounded size.  <a href="classregina_1_1ShortArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html">regina::Base64SigEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General helper tools for signatures that use base64 encodings.  <a href="structregina_1_1Base64SigEncoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotWriteError.html">regina::SnapshotWriteError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when someone tries to modify the read-only deep copy taken by a snapshot.  <a href="classregina_1_1SnapshotWriteError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshot.html">regina::Snapshot&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps a snapshot of an object of type <em>T</em> as it was at a particular moment in time.  <a href="classregina_1_1Snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for images of type <em>T</em> that can be snapshotted at a particular moment in time.  <a href="classregina_1_1Snapshottable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to an image of type <em>T</em> that has been snapshotted at a particular moment in time.  <a href="classregina_1_1SnapshotRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TightEncodable.html">regina::TightEncodable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class that assists with support for tight encodings and corresponding decodings.  <a href="structregina_1_1TightEncodable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trie-like data structure for storing and retriving sets.  <a href="classregina_1_1TrieSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1EnableIf.html">regina::EnableIf&lt; condition, T, defaultValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that holds either a single value of type <em>T</em> or nothing at all, depending on whether the given compile-time condition holds.  <a href="structregina_1_1EnableIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad9e0856df6a522ff8035873cb0571776"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad9e0856df6a522ff8035873cb0571776">ENABLE_MEMBER_FOR_REGINA_INTEGER</a>(T,  returnType)</td></tr>
<tr class="memdesc:gad9e0856df6a522ff8035873cb0571776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally enables a member function for a template class only when the type <em>T</em> is one of Regina's own integer classes.  <a href="group__utilities.html#gad9e0856df6a522ff8035873cb0571776">More...</a><br /></td></tr>
<tr class="separator:gad9e0856df6a522ff8035873cb0571776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">regina::base64Length</a> (size_t bytes)</td></tr>
<tr class="memdesc:gaa8d632b73943b5c52e395d56f8e03af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of base64 characters required to encode the given number of bytes.  <a href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">More...</a><br /></td></tr>
<tr class="separator:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">regina::isBase64</a> (char ch)</td></tr>
<tr class="memdesc:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given character is a base64 printable character as used by the base64 routines in Regina.  <a href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">More...</a><br /></td></tr>
<tr class="separator:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081d322bec8070a889aba14d5988ae80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">regina::base64Encode</a> (const char *in, size_t inlen, char *out, size_t outlen)</td></tr>
<tr class="memdesc:ga081d322bec8070a889aba14d5988ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer.  <a href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">More...</a><br /></td></tr>
<tr class="separator:ga081d322bec8070a889aba14d5988ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541f612d6bb0f94db16da14169813e29"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">regina::base64Encode</a> (const char *in, size_t inlen, char **out)</td></tr>
<tr class="memdesc:ga541f612d6bb0f94db16da14169813e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">More...</a><br /></td></tr>
<tr class="separator:ga541f612d6bb0f94db16da14169813e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">regina::base64Decode</a> (const char *in, size_t inlen, char *out, size_t *outlen)</td></tr>
<tr class="memdesc:ga6811ec511cb61bfc071467ba5d0e8076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer.  <a href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">More...</a><br /></td></tr>
<tr class="separator:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d6c710ee070d88c4b670b48bec3878"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">regina::base64Decode</a> (const char *in, size_t inlen, char **out, size_t *outlen)</td></tr>
<tr class="memdesc:ga47d6c710ee070d88c4b670b48bec3878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">More...</a><br /></td></tr>
<tr class="separator:ga47d6c710ee070d88c4b670b48bec3878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242c17df8901ed6224a6741ad945cf46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga242c17df8901ed6224a6741ad945cf46">regina::swap</a> (<a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;a, <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga242c17df8901ed6224a6741ad945cf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given bitmasks.  <a href="group__utilities.html#ga242c17df8901ed6224a6741ad945cf46">More...</a><br /></td></tr>
<tr class="separator:ga242c17df8901ed6224a6741ad945cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687edae41955adbcf9e58c8cce90ea68"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;mask)</td></tr>
<tr class="memdesc:ga687edae41955adbcf9e58c8cce90ea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">More...</a><br /></td></tr>
<tr class="separator:ga687edae41955adbcf9e58c8cce90ea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2309e18138c1e4d8166a47a4408bdc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae2309e18138c1e4d8166a47a4408bdc4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae2309e18138c1e4d8166a47a4408bdc4">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:gae2309e18138c1e4d8166a47a4408bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#gae2309e18138c1e4d8166a47a4408bdc4">More...</a><br /></td></tr>
<tr class="separator:gae2309e18138c1e4d8166a47a4408bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a859bcdb5958b927015eed8e033527"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab3a859bcdb5958b927015eed8e033527"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab3a859bcdb5958b927015eed8e033527">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:gab3a859bcdb5958b927015eed8e033527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#gab3a859bcdb5958b927015eed8e033527">More...</a><br /></td></tr>
<tr class="separator:gab3a859bcdb5958b927015eed8e033527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b5c83676706821d636840cc976aecf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga53b5c83676706821d636840cc976aecf">regina::operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> set)</td></tr>
<tr class="memdesc:ga53b5c83676706821d636840cc976aecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given boolean set to the given output stream.  <a href="group__utilities.html#ga53b5c83676706821d636840cc976aecf">More...</a><br /></td></tr>
<tr class="separator:ga53b5c83676706821d636840cc976aecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3439925c61c42453159e0b50bdff960"><td class="memItemLeft" align="right" valign="top">std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">regina::i18n::utf8ValidTo</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gad3439925c61c42453159e0b50bdff960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">More...</a><br /></td></tr>
<tr class="separator:gad3439925c61c42453159e0b50bdff960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91eb70b23252b007d149e269b1afb973"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga91eb70b23252b007d149e269b1afb973">regina::i18n::utf8ValidTo</a> (const char *s)</td></tr>
<tr class="memdesc:ga91eb70b23252b007d149e269b1afb973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#ga91eb70b23252b007d149e269b1afb973">More...</a><br /></td></tr>
<tr class="separator:ga91eb70b23252b007d149e269b1afb973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">regina::bitsRequired</a> (IntType n)</td></tr>
<tr class="memdesc:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits required to store integers in the range 0,...,<em>n</em>-1.  <a href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">More...</a><br /></td></tr>
<tr class="separator:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">regina::nextPowerOfTwo</a> (IntType n)</td></tr>
<tr class="memdesc:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest integer power of two that is greater than or equal to the given argument <em>n</em>.  <a href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">More...</a><br /></td></tr>
<tr class="separator:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cb08c9668a04e355a26fd30afdeb52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97cb08c9668a04e355a26fd30afdeb52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga97cb08c9668a04e355a26fd30afdeb52">regina::swap</a> (<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga97cb08c9668a04e355a26fd30afdeb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given vectors.  <a href="group__utilities.html#ga97cb08c9668a04e355a26fd30afdeb52">More...</a><br /></td></tr>
<tr class="separator:ga97cb08c9668a04e355a26fd30afdeb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcd763de878bdad5baf8c67406e0236"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; unsigned long, unsigned long, unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6fcd763de878bdad5baf8c67406e0236">regina::resUsage</a> ()</td></tr>
<tr class="memdesc:ga6fcd763de878bdad5baf8c67406e0236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns time and memory usage for the current process, for use on Linux systems.  <a href="group__utilities.html#ga6fcd763de878bdad5baf8c67406e0236">More...</a><br /></td></tr>
<tr class="separator:ga6fcd763de878bdad5baf8c67406e0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b4d5d732453f12f636c552435e605d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga45b4d5d732453f12f636c552435e605d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga45b4d5d732453f12f636c552435e605d">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga45b4d5d732453f12f636c552435e605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#ga45b4d5d732453f12f636c552435e605d">More...</a><br /></td></tr>
<tr class="separator:ga45b4d5d732453f12f636c552435e605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31ecb27359bcdae0607c56c834f5269"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae31ecb27359bcdae0607c56c834f5269"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae31ecb27359bcdae0607c56c834f5269">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:gae31ecb27359bcdae0607c56c834f5269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#gae31ecb27359bcdae0607c56c834f5269">More...</a><br /></td></tr>
<tr class="separator:gae31ecb27359bcdae0607c56c834f5269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:gaa0c5c9157147686a6bfc401312b8d90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given sequence to the given output stream.  <a href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">More...</a><br /></td></tr>
<tr class="separator:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7c2e72a3a85bfa1503a0e934497dca69">regina::swap</a> (<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given sequences.  <a href="group__utilities.html#ga7c2e72a3a85bfa1503a0e934497dca69">More...</a><br /></td></tr>
<tr class="separator:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga66f73edd06b7cc0e066e11c1d8ea35c8">regina::swap</a> (<a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the given references so that they refer to each others' snapshots.  <a href="group__utilities.html#ga66f73edd06b7cc0e066e11c1d8ea35c8">More...</a><br /></td></tr>
<tr class="separator:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4056bad007750e92b40959aca2c4f987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">regina::startsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ga4056bad007750e92b40959aca2c4f987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given C++ string begins with the given prefix.  <a href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">More...</a><br /></td></tr>
<tr class="separator:ga4056bad007750e92b40959aca2c4f987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa678d35fabfebccce72406d01076829c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">regina::stripWhitespace</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa678d35fabfebccce72406d01076829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips all whitespace from the beginning and end of the given C++ string.  <a href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">More...</a><br /></td></tr>
<tr class="separator:gaa678d35fabfebccce72406d01076829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c2e62bf0908919834ea10762def19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">regina::valueOf</a> (const std::string &amp;str, int8_t &amp;dest)</td></tr>
<tr class="memdesc:gae40c2e62bf0908919834ea10762def19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">More...</a><br /></td></tr>
<tr class="separator:gae40c2e62bf0908919834ea10762def19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">regina::valueOf</a> (const std::string &amp;str, uint8_t &amp;dest)</td></tr>
<tr class="memdesc:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">More...</a><br /></td></tr>
<tr class="separator:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga384de19626353085bf20eedc89c3c30a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">regina::valueOf</a> (const std::string &amp;str, short &amp;dest)</td></tr>
<tr class="memdesc:ga384de19626353085bf20eedc89c3c30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">More...</a><br /></td></tr>
<tr class="separator:ga384de19626353085bf20eedc89c3c30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183ba5dd849f33e9153c3363323abf5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">regina::valueOf</a> (const std::string &amp;str, unsigned short &amp;dest)</td></tr>
<tr class="memdesc:ga183ba5dd849f33e9153c3363323abf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">More...</a><br /></td></tr>
<tr class="separator:ga183ba5dd849f33e9153c3363323abf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">regina::valueOf</a> (const std::string &amp;str, int &amp;dest)</td></tr>
<tr class="memdesc:ga896ae2c6783d6d6dc4081bddabb22518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">More...</a><br /></td></tr>
<tr class="separator:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974a77f98013a0274540b1d0b06519f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">regina::valueOf</a> (const std::string &amp;str, unsigned &amp;dest)</td></tr>
<tr class="memdesc:ga974a77f98013a0274540b1d0b06519f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">More...</a><br /></td></tr>
<tr class="separator:ga974a77f98013a0274540b1d0b06519f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">regina::valueOf</a> (const std::string &amp;str, long &amp;dest)</td></tr>
<tr class="memdesc:gaad0bb367f8c8f4172e6a979751907c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">More...</a><br /></td></tr>
<tr class="separator:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007abfa18426eedc6277f644ded3e068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">regina::valueOf</a> (const std::string &amp;str, unsigned long &amp;dest)</td></tr>
<tr class="memdesc:ga007abfa18426eedc6277f644ded3e068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">More...</a><br /></td></tr>
<tr class="separator:ga007abfa18426eedc6277f644ded3e068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5eebbe6059d16231b0e41966e2056a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">regina::valueOf</a> (const std::string &amp;str, long long &amp;dest)</td></tr>
<tr class="memdesc:gacd5eebbe6059d16231b0e41966e2056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">More...</a><br /></td></tr>
<tr class="separator:gacd5eebbe6059d16231b0e41966e2056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0bc034686407302e3ad597e39933a99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">regina::valueOf</a> (const std::string &amp;str, unsigned long long &amp;dest)</td></tr>
<tr class="memdesc:gad0bc034686407302e3ad597e39933a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">More...</a><br /></td></tr>
<tr class="separator:gad0bc034686407302e3ad597e39933a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">regina::valueOf</a> (const std::string &amp;str, double &amp;dest)</td></tr>
<tr class="memdesc:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a double precision real number and reports whether this conversion was successful.  <a href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">More...</a><br /></td></tr>
<tr class="separator:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e706f7f722922798776b74f9933bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">regina::valueOf</a> (const std::string &amp;str, bool &amp;dest)</td></tr>
<tr class="memdesc:ga17e706f7f722922798776b74f9933bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a boolean and reports whether this conversion was successful.  <a href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">More...</a><br /></td></tr>
<tr class="separator:ga17e706f7f722922798776b74f9933bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">regina::valueOf</a> (const std::string &amp;str, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;dest)</td></tr>
<tr class="memdesc:ga6083d66d2dcac7dce8637e6282c6c679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a set of booleans and reports whether this conversion was successful.  <a href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">More...</a><br /></td></tr>
<tr class="separator:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829779c4fa33b63924f584c933314229"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga829779c4fa33b63924f584c933314229">regina::basicTokenise</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga829779c4fa33b63924f584c933314229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes the given string into tokens.  <a href="group__utilities.html#ga829779c4fa33b63924f584c933314229">More...</a><br /></td></tr>
<tr class="separator:ga829779c4fa33b63924f584c933314229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5114cac055c590a0239b7b34b94458d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae5114cac055c590a0239b7b34b94458d">regina::stringToToken</a> (std::string str)</td></tr>
<tr class="memdesc:gae5114cac055c590a0239b7b34b94458d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a token derived from the given string.  <a href="group__utilities.html#gae5114cac055c590a0239b7b34b94458d">More...</a><br /></td></tr>
<tr class="separator:gae5114cac055c590a0239b7b34b94458d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">regina::superscript</a> (T value)</td></tr>
<tr class="memdesc:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode superscript string.  <a href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">More...</a><br /></td></tr>
<tr class="separator:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">regina::subscript</a> (T value)</td></tr>
<tr class="memdesc:ga61ea966075c340b411ef07cc5aee1213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode subscript string.  <a href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">More...</a><br /></td></tr>
<tr class="separator:ga61ea966075c340b411ef07cc5aee1213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3071be3bed13d0057ebe344aab4ed4ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3071be3bed13d0057ebe344aab4ed4ef">regina::tightEncode</a> (std::ostream &amp;out, int value)</td></tr>
<tr class="memdesc:ga3071be3bed13d0057ebe344aab4ed4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given signed integer to the given output stream.  <a href="group__utilities.html#ga3071be3bed13d0057ebe344aab4ed4ef">More...</a><br /></td></tr>
<tr class="separator:ga3071be3bed13d0057ebe344aab4ed4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04ee6a550c68d8d29b2c1eb35d4bc82"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82">regina::tightEncoding</a> (int value)</td></tr>
<tr class="memdesc:gad04ee6a550c68d8d29b2c1eb35d4bc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given signed integer.  <a href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82">More...</a><br /></td></tr>
<tr class="separator:gad04ee6a550c68d8d29b2c1eb35d4bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc77642572c2f8eea1818db38b28de2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafc77642572c2f8eea1818db38b28de2b">regina::tightEncode</a> (std::ostream &amp;out, long value)</td></tr>
<tr class="memdesc:gafc77642572c2f8eea1818db38b28de2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given signed long integer to the given output stream.  <a href="group__utilities.html#gafc77642572c2f8eea1818db38b28de2b">More...</a><br /></td></tr>
<tr class="separator:gafc77642572c2f8eea1818db38b28de2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d43fc580edb50fb9a0756a1ffedb58"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58">regina::tightEncoding</a> (long value)</td></tr>
<tr class="memdesc:gae5d43fc580edb50fb9a0756a1ffedb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given signed long integer.  <a href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58">More...</a><br /></td></tr>
<tr class="separator:gae5d43fc580edb50fb9a0756a1ffedb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db618c87ebf51d61009cc98c3cef150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3db618c87ebf51d61009cc98c3cef150">regina::tightEncode</a> (std::ostream &amp;out, long long value)</td></tr>
<tr class="memdesc:ga3db618c87ebf51d61009cc98c3cef150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given signed long long integer to the given output stream.  <a href="group__utilities.html#ga3db618c87ebf51d61009cc98c3cef150">More...</a><br /></td></tr>
<tr class="separator:ga3db618c87ebf51d61009cc98c3cef150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac847807974dbe589cfc57056a236cd46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac847807974dbe589cfc57056a236cd46">regina::tightEncoding</a> (long long value)</td></tr>
<tr class="memdesc:gac847807974dbe589cfc57056a236cd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given signed long long integer.  <a href="group__utilities.html#gac847807974dbe589cfc57056a236cd46">More...</a><br /></td></tr>
<tr class="separator:gac847807974dbe589cfc57056a236cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00bbae1e4f050d67575a68752b4018f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf00bbae1e4f050d67575a68752b4018f">regina::tightEncode</a> (std::ostream &amp;out, unsigned value)</td></tr>
<tr class="memdesc:gaf00bbae1e4f050d67575a68752b4018f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given unsigned integer to the given output stream.  <a href="group__utilities.html#gaf00bbae1e4f050d67575a68752b4018f">More...</a><br /></td></tr>
<tr class="separator:gaf00bbae1e4f050d67575a68752b4018f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd29cdddc4af9b3dbd98fd08badbc2a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5dd29cdddc4af9b3dbd98fd08badbc2a">regina::tightEncoding</a> (unsigned value)</td></tr>
<tr class="memdesc:ga5dd29cdddc4af9b3dbd98fd08badbc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given unsigned integer.  <a href="group__utilities.html#ga5dd29cdddc4af9b3dbd98fd08badbc2a">More...</a><br /></td></tr>
<tr class="separator:ga5dd29cdddc4af9b3dbd98fd08badbc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56176c1b2cedb9dcf027c7cf88907806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga56176c1b2cedb9dcf027c7cf88907806">regina::tightEncode</a> (std::ostream &amp;out, unsigned long value)</td></tr>
<tr class="memdesc:ga56176c1b2cedb9dcf027c7cf88907806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given unsigned long integer to the given output stream.  <a href="group__utilities.html#ga56176c1b2cedb9dcf027c7cf88907806">More...</a><br /></td></tr>
<tr class="separator:ga56176c1b2cedb9dcf027c7cf88907806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c703c35095c4407b987054ec056cc7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf1c703c35095c4407b987054ec056cc7">regina::tightEncoding</a> (unsigned long value)</td></tr>
<tr class="memdesc:gaf1c703c35095c4407b987054ec056cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given unsigned long integer.  <a href="group__utilities.html#gaf1c703c35095c4407b987054ec056cc7">More...</a><br /></td></tr>
<tr class="separator:gaf1c703c35095c4407b987054ec056cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfd99d3c0d21833b55a4af77736092d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaadfd99d3c0d21833b55a4af77736092d">regina::tightEncode</a> (std::ostream &amp;out, unsigned long long value)</td></tr>
<tr class="memdesc:gaadfd99d3c0d21833b55a4af77736092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given unsigned long long integer to the given output stream.  <a href="group__utilities.html#gaadfd99d3c0d21833b55a4af77736092d">More...</a><br /></td></tr>
<tr class="separator:gaadfd99d3c0d21833b55a4af77736092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ddfa37a33307ca03dcb087da759280"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab1ddfa37a33307ca03dcb087da759280">regina::tightEncoding</a> (unsigned long long value)</td></tr>
<tr class="memdesc:gab1ddfa37a33307ca03dcb087da759280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given unsigned long long integer.  <a href="group__utilities.html#gab1ddfa37a33307ca03dcb087da759280">More...</a><br /></td></tr>
<tr class="separator:gab1ddfa37a33307ca03dcb087da759280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga588cb4d07d97f9a53e86859e4e233aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga588cb4d07d97f9a53e86859e4e233aab">regina::tightEncode</a> (std::ostream &amp;out, bool value)</td></tr>
<tr class="memdesc:ga588cb4d07d97f9a53e86859e4e233aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given boolean to the given output stream.  <a href="group__utilities.html#ga588cb4d07d97f9a53e86859e4e233aab">More...</a><br /></td></tr>
<tr class="separator:ga588cb4d07d97f9a53e86859e4e233aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483daa45b68925495da3367619d8a7e9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga483daa45b68925495da3367619d8a7e9">regina::tightEncoding</a> (bool value)</td></tr>
<tr class="memdesc:ga483daa45b68925495da3367619d8a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given boolean.  <a href="group__utilities.html#ga483daa45b68925495da3367619d8a7e9">More...</a><br /></td></tr>
<tr class="separator:ga483daa45b68925495da3367619d8a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12ac49ef48ad51831f09c40a326fcce9"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ga12ac49ef48ad51831f09c40a326fcce9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga12ac49ef48ad51831f09c40a326fcce9">regina::detail::tightEncodeInteger</a> (std::ostream &amp;out, Int value)</td></tr>
<tr class="memdesc:ga12ac49ef48ad51831f09c40a326fcce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that writes the tight encoding of the given integer to the given output stream.  <a href="group__utilities.html#ga12ac49ef48ad51831f09c40a326fcce9">More...</a><br /></td></tr>
<tr class="separator:ga12ac49ef48ad51831f09c40a326fcce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76f60a3e48eb2ee106947ca5b898e8cf"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename iterator &gt; </td></tr>
<tr class="memitem:ga76f60a3e48eb2ee106947ca5b898e8cf"><td class="memTemplItemLeft" align="right" valign="top">Int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga76f60a3e48eb2ee106947ca5b898e8cf">regina::detail::tightDecodeInteger</a> (iterator start, iterator limit, bool noTrailingData)</td></tr>
<tr class="memdesc:ga76f60a3e48eb2ee106947ca5b898e8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that reconstructs an integer from its given tight encoding.  <a href="group__utilities.html#ga76f60a3e48eb2ee106947ca5b898e8cf">More...</a><br /></td></tr>
<tr class="separator:ga76f60a3e48eb2ee106947ca5b898e8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a95c510b293956bbf9fc66cfe763eda"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ga8a95c510b293956bbf9fc66cfe763eda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8a95c510b293956bbf9fc66cfe763eda">regina::detail::tightEncodeIndex</a> (std::ostream &amp;out, Int value)</td></tr>
<tr class="memdesc:ga8a95c510b293956bbf9fc66cfe763eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that writes the tight encoding of an integer whose value is either non-negative or -1.  <a href="group__utilities.html#ga8a95c510b293956bbf9fc66cfe763eda">More...</a><br /></td></tr>
<tr class="separator:ga8a95c510b293956bbf9fc66cfe763eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38bc82f94369fd15b4897468293d5bee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga38bc82f94369fd15b4897468293d5bee">regina::detail::tightEncodeNoIndex</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:ga38bc82f94369fd15b4897468293d5bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that writes the tight encoding of -1, using an encoding that is compatible with <a class="el" href="group__utilities.html#ga8a95c510b293956bbf9fc66cfe763eda" title="Internal function that writes the tight encoding of an integer whose value is either non-negative or ...">tightEncodeIndex()</a>.  <a href="group__utilities.html#ga38bc82f94369fd15b4897468293d5bee">More...</a><br /></td></tr>
<tr class="separator:ga38bc82f94369fd15b4897468293d5bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac347aec77131ddc5de3eceece273afe4"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:gac347aec77131ddc5de3eceece273afe4"><td class="memTemplItemLeft" align="right" valign="top">Int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac347aec77131ddc5de3eceece273afe4">regina::detail::tightDecodeIndex</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:gac347aec77131ddc5de3eceece273afe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that reconstructs an integer that was encoded using <a class="el" href="group__utilities.html#ga8a95c510b293956bbf9fc66cfe763eda" title="Internal function that writes the tight encoding of an integer whose value is either non-negative or ...">tightEncodeIndex()</a>.  <a href="group__utilities.html#gac347aec77131ddc5de3eceece273afe4">More...</a><br /></td></tr>
<tr class="separator:gac347aec77131ddc5de3eceece273afe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4edb9a7b2681015b7a294f9f323c30b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4edb9a7b2681015b7a294f9f323c30b1">regina::swap</a> (<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;a, <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga4edb9a7b2681015b7a294f9f323c30b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given collections.  <a href="group__utilities.html#ga4edb9a7b2681015b7a294f9f323c30b1">More...</a><br /></td></tr>
<tr class="separator:ga4edb9a7b2681015b7a294f9f323c30b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d21160d4bdcd9170589b19ad5b5d82"><td class="memTemplParams" colspan="2">template&lt;int from, int to, class Action &gt; </td></tr>
<tr class="memitem:gad2d21160d4bdcd9170589b19ad5b5d82"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad2d21160d4bdcd9170589b19ad5b5d82">regina::for_constexpr</a> (Action &amp;&amp;action)</td></tr>
<tr class="memdesc:gad2d21160d4bdcd9170589b19ad5b5d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a compile-time <code>for</code> loop over a range of integers.  <a href="group__utilities.html#gad2d21160d4bdcd9170589b19ad5b5d82">More...</a><br /></td></tr>
<tr class="separator:gad2d21160d4bdcd9170589b19ad5b5d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e04d706783afe3f971b95f1fbe5d97c"><td class="memTemplParams" colspan="2">template&lt;int from, int to, typename Return , class Action &gt; </td></tr>
<tr class="memitem:ga8e04d706783afe3f971b95f1fbe5d97c"><td class="memTemplItemLeft" align="right" valign="top">constexpr Return&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga8e04d706783afe3f971b95f1fbe5d97c">regina::select_constexpr</a> (int value, Action &amp;&amp;action)</td></tr>
<tr class="memdesc:ga8e04d706783afe3f971b95f1fbe5d97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a compile-time selection, where the runtime argument must belong to a compile-time range of integers, and the value of the argument determines what is returned.  <a href="group__utilities.html#ga8e04d706783afe3f971b95f1fbe5d97c">More...</a><br /></td></tr>
<tr class="separator:ga8e04d706783afe3f971b95f1fbe5d97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc6fe844079b0a5d1b340f63a3e79b8"><td class="memTemplParams" colspan="2">template&lt;int from, int to, class Action &gt; </td></tr>
<tr class="memitem:ga5cc6fe844079b0a5d1b340f63a3e79b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5cc6fe844079b0a5d1b340f63a3e79b8">regina::select_constexpr_as_variant</a> (int value, Action &amp;&amp;action)</td></tr>
<tr class="memdesc:ga5cc6fe844079b0a5d1b340f63a3e79b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="group__utilities.html#ga8e04d706783afe3f971b95f1fbe5d97c" title="Implements a compile-time selection, where the runtime argument must belong to a compile-time range o...">select_constexpr()</a> where the return type is a variant, built from the return types for all integers in the given compile-time range.  <a href="group__utilities.html#ga5cc6fe844079b0a5d1b340f63a3e79b8">More...</a><br /></td></tr>
<tr class="separator:ga5cc6fe844079b0a5d1b340f63a3e79b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">regina::xml::xmlEncodeSpecialChars</a> (const std::string &amp;original)</td></tr>
<tr class="memdesc:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given string with special characters converted to XML entities.  <a href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">More...</a><br /></td></tr>
<tr class="separator:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">regina::xml::xmlEncodeComment</a> (const std::string &amp;comment)</td></tr>
<tr class="memdesc:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given string encoded so it is suitable for use inside an XML comment.  <a href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">More...</a><br /></td></tr>
<tr class="separator:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">regina::xml::xmlValueTag</a> (const std::string &amp;tagName, const T &amp;value)</td></tr>
<tr class="memdesc:gacb9d9d42e182de0dc67e4176414cb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an XML tag with a single property containing the given value.  <a href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">More...</a><br /></td></tr>
<tr class="separator:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5616d8b8cc6091811f09782f0dad6449"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5616d8b8cc6091811f09782f0dad6449">regina::base64Table</a> []</td></tr>
<tr class="memdesc:ga5616d8b8cc6091811f09782f0dad6449"><td class="mdescLeft">&#160;</td><td class="mdescRight">The table of all base64 printable characters, as used by the base64 routines in Regina.  <a href="group__utilities.html#ga5616d8b8cc6091811f09782f0dad6449">More...</a><br /></td></tr>
<tr class="separator:ga5616d8b8cc6091811f09782f0dad6449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3657172c4ecb2d7217bd5220b83cf41f"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3657172c4ecb2d7217bd5220b83cf41f">regina::base64Spare</a> [] = &quot;_-.&quot;</td></tr>
<tr class="memdesc:ga3657172c4ecb2d7217bd5220b83cf41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of printable characters that are <em>not</em> amongst the base64 printable characters used by Regina.  <a href="group__utilities.html#ga3657172c4ecb2d7217bd5220b83cf41f">More...</a><br /></td></tr>
<tr class="separator:ga3657172c4ecb2d7217bd5220b83cf41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111f0463a59ed427c782ac3df1d39f7a"><td class="memTemplParams" colspan="2">template&lt;typename IntType , IntType coeff&gt; </td></tr>
<tr class="memitem:ga111f0463a59ed427c782ac3df1d39f7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga111f0463a59ed427c782ac3df1d39f7a">regina::maxSafeFactor</a></td></tr>
<tr class="memdesc:ga111f0463a59ed427c782ac3df1d39f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest integer of the given type that can be multiplied by <em>coeff</em> without overflowing.  <a href="group__utilities.html#ga111f0463a59ed427c782ac3df1d39f7a">More...</a><br /></td></tr>
<tr class="separator:ga111f0463a59ed427c782ac3df1d39f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd0e3d57fb0834f9cfff7b13e7528466"><td class="memTemplParams" colspan="2">template&lt;typename IntType , IntType coeff&gt; </td></tr>
<tr class="memitem:gafd0e3d57fb0834f9cfff7b13e7528466"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafd0e3d57fb0834f9cfff7b13e7528466">regina::minSafeFactor</a></td></tr>
<tr class="memdesc:gafd0e3d57fb0834f9cfff7b13e7528466"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest integer of the given type that can be multiplied by <em>coeff</em> without overflowing.  <a href="group__utilities.html#gafd0e3d57fb0834f9cfff7b13e7528466">More...</a><br /></td></tr>
<tr class="separator:gafd0e3d57fb0834f9cfff7b13e7528466"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Miscellaneous helper classes and functions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad9e0856df6a522ff8035873cb0571776" name="gad9e0856df6a522ff8035873cb0571776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e0856df6a522ff8035873cb0571776">&#9670;&nbsp;</a></span>ENABLE_MEMBER_FOR_REGINA_INTEGER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENABLE_MEMBER_FOR_REGINA_INTEGER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">returnType&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args, <span class="keyword">typename</span> Return = returnType&gt; \</div>
<div class="line">    std::enable_if_t&lt;IsReginaInteger&lt;T&gt;::value, Return&gt;</div>
</div><!-- fragment -->
<p>Conditionally enables a member function for a template class only when the type <em>T</em> is one of Regina's own integer classes. </p>
<p >This macro should be used as the return type for such a member function. If <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger or NativeInteger), then the actual return type for the member function will be the argument <em>returnType</em>. Otherwise the member function will be disabled, will not appear in the class at all, and will not generate compile errors if it uses operations that <em>T</em> does not support.</p>
<p >The implementation uses SFINAE to remove the member function without compile errors. A side-effect of this is that the member function will now be a <em>template</em> member function. The user should never specify their own template arguments, and indeed the template parameter pack <em>Args</em> in the implementation is there precisely to stop users from doing this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The member function this macro is applied to is <em>not</em> a template member function (though, as noted above, this macro will silently make it one).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga47d6c710ee070d88c4b670b48bec3878" name="ga47d6c710ee070d88c4b670b48bec3878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d6c710ee070d88c4b670b48bec3878">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results. </p>
<p >The <em>out</em> pointer will be set to this new array, and <em>outlen</em> will be set to the number of raw bytes in this output array. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p >The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p >The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found or the output buffer is exhausted, this routine will return <code>false</code>, set <em>out</em> to <code>null</code>, and leave <em>outlen</em> undefined. Otherwise (on success) it will return <code>true</code> and set <em>outlen</em> to the total number of output bytes.</p>
<p >If the user is not interested in the length of the output array, a null pointer may be passed in the <em>outlen</em> argument. Note however that the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 decoding routines are made available to Python in the form <code>base64Decode(input_string)</code>, where <em>input_string</em> is a base64 string, and the return value is a Python <code>bytes</code> object. You do not need to supply any input or output buffer lengths. If the decoding is unsuccessful, this routine will return <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of raw bytes (or which will be set to <code>null</code> on failure). </td></tr>
    <tr><td class="paramname">outlen</td><td>the address of an integer which will be set to the length of the output array (or which will be left undefined on failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if an unexpected input character was found or some other error occurred.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga6811ec511cb61bfc071467ba5d0e8076" name="ga6811ec511cb61bfc071467ba5d0e8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6811ec511cb61bfc071467ba5d0e8076">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer. </p>
<p >The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p >The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found, or the output buffer is exhausted, this routine will write as many output bytes as it can and then return <code>false</code>. Otherwise (on success) it will return <code>true</code>. Either way, it will reset <em>outlen</em> to the total number of bytes that were written.</p>
<p >The total number of output bytes is important to know, since the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 decoding routines are made available to Python in the form <code>base64Decode(input_string)</code>, where <em>input_string</em> is a base64 string, and the return value is a Python <code>bytes</code> object. You do not need to supply any input or output buffer lengths. If the decoding is unsuccessful, this routine will return <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting raw bytes will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>must contain the length of the output buffer on entry, and on exit contains the number of output bytes that were successfully written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if the output buffer was exhausted or an unexpected input character was found.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga541f612d6bb0f94db16da14169813e29" name="ga541f612d6bb0f94db16da14169813e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541f612d6bb0f94db16da14169813e29">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results. </p>
<p >The <em>out</em> pointer will be set to this new array, which will be null-terminated. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p >If the output array is too large (in particular, the expected size will overflow a <code>size_t</code>), the <em>out</em> pointer will be set to <code>null</code>.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 encoding routines are made available to Python in the form <code>base64Encode(input_bytes)</code>, where <em>input_bytes</em> is a a Python <code>bytes</code> object, and the return value is a Python string. You do not need to supply any input or output buffer lengths.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of base64 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the output array, not counting the terminating null.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga081d322bec8070a889aba14d5988ae80" name="ga081d322bec8070a889aba14d5988ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081d322bec8070a889aba14d5988ae80">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer. </p>
<p >The length of the output buffer is passed as the argument <em>outlen</em>. If the number of base64 characters required is less than <em>outlen</em>, a terminating <code>null</code> will be written to the end of the output sequence. If the number of base64 characters is <em>outlen</em> or greater, this routine will output as many base64 characters as possible, up to a maximum of <em>outlen</em>.</p>
<p >The routine <a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2" title="Returns the number of base64 characters required to encode the given number of bytes.">base64Length()</a> can be used to precalculate precisely how many output characters will be required.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 encoding routines are made available to Python in the form <code>base64Encode(input_bytes)</code>, where <em>input_bytes</em> is a a Python <code>bytes</code> object, and the return value is a Python string. You do not need to supply any input or output buffer lengths.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting base64 characters will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>the length of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="gaa8d632b73943b5c52e395d56f8e03af2" name="gaa8d632b73943b5c52e395d56f8e03af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d632b73943b5c52e395d56f8e03af2">&#9670;&nbsp;</a></span>base64Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of base64 characters required to encode the given number of bytes. </p>
<p >This is the number of characters used (excluding the null terminator) by the routine <a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29" title="Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing...">base64Encode(const char*, size_t, char**)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the number of raw input bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding number of base64 printable output characters. </dd></dl>

</div>
</div>
<a id="ga829779c4fa33b63924f584c933314229" name="ga829779c4fa33b63924f584c933314229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829779c4fa33b63924f584c933314229">&#9670;&nbsp;</a></span>basicTokenise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; regina::basicTokenise </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes the given string into tokens. </p>
<p >This is an extremely simple tokeniser; tokens are defined to be separated by arbitrary blocks of whitespace. Any leading or trailing whitespace will be ignored.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to decompose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting list of tokens. </dd></dl>

</div>
</div>
<a id="gaf3cfd88109df8473b8ae9647ff96d35a" name="gaf3cfd88109df8473b8ae9647ff96d35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3cfd88109df8473b8ae9647ff96d35a">&#9670;&nbsp;</a></span>bitsRequired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int regina::bitsRequired </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bits required to store integers in the range 0,...,<em>n</em>-1. </p>
<p >This is simply the number of bits in the binary expansion of <em>n</em>-1.</p>
<p >If <em>n</em> is non-positive then this function will return 0.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bits required to store 0,...,<em>n</em>-1.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2d21160d4bdcd9170589b19ad5b5d82" name="gad2d21160d4bdcd9170589b19ad5b5d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d21160d4bdcd9170589b19ad5b5d82">&#9670;&nbsp;</a></span>for_constexpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int from, int to, class Action &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void regina::for_constexpr </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a compile-time <code>for</code> loop over a range of integers. </p>
<p >This function will call <em>action</em> for each integer <em>i</em> in the range <em>from</em>, ..., (<em>to</em>-1) inclusive.</p>
<p >The action should be a templated callable object (e.g., a generic lambda) that takes a single argument whose type depends on the value of <em>i</em>. Any return value will be ignored. For each integer <em>i</em>, the argument will be of type <code>std::integral_constant&lt;int, i&gt;</code>, which means that <em>i</em> is accessible as a compile-time constant.</p>
<p >If <em>from</em> is not less than <em>to</em>, then this routine safely does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>the body of the <code>for</code> loop; that is, the action to perform for each integer <em>i</em>. See above for the interface that <em>action</em> should adhere to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga231a1c1fdf6cc37e09fbc77ea2cf14ce" name="ga231a1c1fdf6cc37e09fbc77ea2cf14ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">&#9670;&nbsp;</a></span>isBase64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given character is a base64 printable character as used by the base64 routines in Regina. </p>
<p >The base64 printable characters are the letters (both upper-case and lower-case), digits, plus (+), and forward slash (/).</p>
<p >Note that the equals sign (=) is padding, and is not considered by this routine to be a base64 printable character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>any character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given character is one of the base64 printable characters used in Regina, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="gaf8ad7790348b617ffd8fdf50736cd9cf" name="gaf8ad7790348b617ffd8fdf50736cd9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ad7790348b617ffd8fdf50736cd9cf">&#9670;&nbsp;</a></span>nextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntType regina::nextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest integer power of two that is greater than or equal to the given argument <em>n</em>. </p>
<p >If <em>n</em> is non-positive then this function will return 1.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Even though the return value is the same type as the argument <em>n</em>, this routine may still overflow. For example, if <em>IntType</em> is a signed char then nextPowerOfTwo(127) will return -128, and if <em>IntType</em> is an unsigned char then nextPowerOfTwo(255) will return 0. Be sure that <em>IntType</em> is large enough for your requirements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest integer power of two that is &ge; <em>n</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53b5c83676706821d636840cc976aecf" name="ga53b5c83676706821d636840cc976aecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b5c83676706821d636840cc976aecf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given boolean set to the given output stream. </p>
<p >The set will be written in the form <code>{ true, false }</code>, <code>{ true }</code>, <code>{ false }</code> or <code>{ }</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">set</td><td>the boolean set to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga687edae41955adbcf9e58c8cce90ea68" name="ga687edae41955adbcf9e58c8cce90ea68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687edae41955adbcf9e58c8cce90ea68">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p >Since the length of the bitmask is not stored, the number of bits written might be greater than the length initially assigned to this bitmask (specifically, the length will be rounded up to the next "raw
unit of storage").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gae2309e18138c1e4d8166a47a4408bdc4" name="gae2309e18138c1e4d8166a47a4408bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2309e18138c1e4d8166a47a4408bdc4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p >Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gab3a859bcdb5958b927015eed8e033527" name="gab3a859bcdb5958b927015eed8e033527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a859bcdb5958b927015eed8e033527">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p >Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gaa0c5c9157147686a6bfc401312b8d90c" name="gaa0c5c9157147686a6bfc401312b8d90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c5c9157147686a6bfc401312b8d90c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given sequence to the given output stream. </p>
<p >No newline will be written.</p>
<p >The sequence will be written in the form <code>(a, b, c, ...)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An object <em>x</em> of type <em>T</em> can be written to an output stream using the syntax <code>out &lt;&lt; x</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">s</td><td>the sequence to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga45b4d5d732453f12f636c552435e605d" name="ga45b4d5d732453f12f636c552435e605d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45b4d5d732453f12f636c552435e605d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p >Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gae31ecb27359bcdae0607c56c834f5269" name="gae31ecb27359bcdae0607c56c834f5269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31ecb27359bcdae0607c56c834f5269">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p >Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga6fcd763de878bdad5baf8c67406e0236" name="ga6fcd763de878bdad5baf8c67406e0236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fcd763de878bdad5baf8c67406e0236">&#9670;&nbsp;</a></span>resUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; unsigned long, unsigned long, unsigned long &gt; regina::resUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns time and memory usage for the current process, for use on Linux systems. </p>
<p >Information is gathered from the <code>/proc</code> filesystem; if this is run on a non-Linux system (or a Linux system where <code>/proc</code> is not mounted), then this routine will throw an exception.</p>
<p >More precisely, this routine reads information on the running process from <code>/proc/self/stat</code>, and returns a tuple (<em>utime</em>, <em>stime</em>, <em>vsize</em>). These three fields reperesent:</p>
<ul>
<li>the number jiffies that this process has been scheduled in user mode (the <em>utime</em> field);</li>
<li>the number jiffies that this process has been scheduled in kernel mode (the <em>stime</em> field);</li>
<li>the the virtual memory size in bytes (the <em>vsize</em> field).</li>
</ul>
<p >The description of these three fields is taken directly from the <code>proc(5)</code> manpage. Note that the length of a jiffy can differ from system to system; see the <code>time(7)</code> manpage for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FileError.html" title="An exception thrown when trying to access data from the filesystem.">FileError</a></td><td>Either <code>/proc/self/stat</code> cannot be read, or it contains unexpected information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently this routine allows at most 255 characters for the <em>comm</em> field in <code>/proc/self/stat</code> (which stores the executable filename along with surrounding parentheses). If the <em>comm</em> field is too long (i.e., the executable filename is too long), then this routine will not be able to parse <code>/proc/self/stat</code>, and will throw an exception. If you encounter this problem, you should be able to fix it by renaming your executable to something shorter. </dd></dl>

</div>
</div>
<a id="ga8e04d706783afe3f971b95f1fbe5d97c" name="ga8e04d706783afe3f971b95f1fbe5d97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e04d706783afe3f971b95f1fbe5d97c">&#9670;&nbsp;</a></span>select_constexpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int from, int to, typename Return , class Action &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Return regina::select_constexpr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a compile-time selection, where the runtime argument must belong to a compile-time range of integers, and the value of the argument determines what is returned. </p>
<p >The action should be a templated callable object (e.g., a generic lambda) that takes a single argument. If <em>value</em> is equal to the integer <em>i</em>, for some <em>i</em> in the range <em>from</em>, ..., (<em>to</em>-1) inclusive, then this function will return <code>action(i)</code>. The argument <em>i</em> will be passed using the type <code>std::integral_constant&lt;int, i&gt;</code>, which means that the value of <em>i</em> will be accessible to <em>action</em> as a compile-time constant.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>the given runtime value is not within the range <em>from</em>, ..., (<em>to</em>-1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Return</td><td>the type to be returned from this function. Typically this will be the same as the return type from <em>action</em>, but it may differ (particuarly if the return type of <em>action</em> depends upon its integer argument).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the runtime value that determines the selection; that is, the argument that will be passed to the given action as a compile-time constant. </td></tr>
    <tr><td class="paramname">action</td><td>the action to perform for whichever integer <em>i</em> matches the given runtime value. See above for the interface that <em>action</em> should adhere to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned from <em>action</em>. </dd></dl>

</div>
</div>
<a id="ga5cc6fe844079b0a5d1b340f63a3e79b8" name="ga5cc6fe844079b0a5d1b340f63a3e79b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc6fe844079b0a5d1b340f63a3e79b8">&#9670;&nbsp;</a></span>select_constexpr_as_variant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int from, int to, class Action &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto regina::select_constexpr_as_variant </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="group__utilities.html#ga8e04d706783afe3f971b95f1fbe5d97c" title="Implements a compile-time selection, where the runtime argument must belong to a compile-time range o...">select_constexpr()</a> where the return type is a variant, built from the return types for all integers in the given compile-time range. </p>
<p >See <a class="el" href="group__utilities.html#ga8e04d706783afe3f971b95f1fbe5d97c" title="Implements a compile-time selection, where the runtime argument must belong to a compile-time range o...">select_constexpr()</a> for an overview of how Regina's compile-time selection function works. This routine behaves exactly the same as <a class="el" href="group__utilities.html#ga8e04d706783afe3f971b95f1fbe5d97c" title="Implements a compile-time selection, where the runtime argument must belong to a compile-time range o...">select_constexpr()</a>, except that you do not need to explicitly give the return type. Instead, the return type will be <code>std::variant&lt;R(from), R(from+1), ..., R(to-1)&gt;</code>, where each <code>R(i)</code> denotes the type returned by the corresponding call to <code>action(i)</code>.</p>
<p >This is useful when the return <em>type</em> from <em>action</em> (not just the return value) depends on <em>i</em>. An example of this is <code>Triangulation::face(subdim, index)</code>, whose return type would normally be <code>Face&lt;subdim&gt;*</code>, except for the fact that <em>subdim</em> is not known until runtime. Therefore this function needs to return a std::variant, and so <a class="el" href="group__utilities.html#ga5cc6fe844079b0a5d1b340f63a3e79b8" title="A variant of select_constexpr() where the return type is a variant, built from the return types for a...">select_constexpr_as_variant()</a> can be used for its internal implementation.</p>
<p >See <a class="el" href="group__utilities.html#ga8e04d706783afe3f971b95f1fbe5d97c" title="Implements a compile-time selection, where the runtime argument must belong to a compile-time range o...">select_constexpr()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>All of the possible return types <code>R(from)</code>, <code>R(from+1)</code>, ..., <code>R(to-1)</code> are different.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>the given runtime value is not within the range <em>from</em>, ..., (<em>to</em>-1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the runtime value that determines the selection; that is, the argument that will be passed to the given action as a compile-time constant. </td></tr>
    <tr><td class="paramname">action</td><td>the action to perform for whichever integer <em>i</em> matches the given runtime value. See above for the interface that <em>action</em> should adhere to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value returned from <em>action</em>, given as a variant that encapsulates all (<em>to</em> - <em>from</em>) possible return types. </dd></dl>

</div>
</div>
<a id="ga4056bad007750e92b40959aca2c4f987" name="ga4056bad007750e92b40959aca2c4f987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4056bad007750e92b40959aca2c4f987">&#9670;&nbsp;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given C++ string begins with the given prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the full C++ string to examine. </td></tr>
    <tr><td class="paramname">prefix</td><td>the prefix whose presence we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>str</em> begins with <em>prefix</em>. </dd></dl>

</div>
</div>
<a id="gae5114cac055c590a0239b7b34b94458d" name="gae5114cac055c590a0239b7b34b94458d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5114cac055c590a0239b7b34b94458d">&#9670;&nbsp;</a></span>stringToToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a token derived from the given string. </p>
<p >All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a id="gaa678d35fabfebccce72406d01076829c" name="gaa678d35fabfebccce72406d01076829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa678d35fabfebccce72406d01076829c">&#9670;&nbsp;</a></span>stripWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stripWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips all whitespace from the beginning and end of the given C++ string. </p>
<p >The new stripped string is returned; the original string is not altered.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to be stripped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting stripped string. </dd></dl>

</div>
</div>
<a id="ga61ea966075c340b411ef07cc5aee1213" name="ga61ea966075c340b411ef07cc5aee1213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ea966075c340b411ef07cc5aee1213">&#9670;&nbsp;</a></span>subscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::subscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode subscript string. </p>
<p >The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="ga92f5f4f8be21a36101e67ed4b461ba19" name="ga92f5f4f8be21a36101e67ed4b461ba19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f5f4f8be21a36101e67ed4b461ba19">&#9670;&nbsp;</a></span>superscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::superscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode superscript string. </p>
<p >The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="ga242c17df8901ed6224a6741ad945cf46" name="ga242c17df8901ed6224a6741ad945cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242c17df8901ed6224a6741ad945cf46">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given bitmasks. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1Bitmask.html#a3d96fef8bfbe92fc6574be2b741143fb" title="Swaps the contents of this and the given bitmask.">Bitmask::swap()</a>; it is provided so that <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first bitmask whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second bitmask whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c2e72a3a85bfa1503a0e934497dca69" name="ga7c2e72a3a85bfa1503a0e934497dca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c2e72a3a85bfa1503a0e934497dca69">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given sequences. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1LightweightSequence.html#a4b58379dc15318fef2effed7ec54a256" title="Swaps the contents of this and the given sequence.">LightweightSequence&lt;T&gt;::swap()</a>; it is provided so that LightweightSequence&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first sequence whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second sequence whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97cb08c9668a04e355a26fd30afdeb52" name="ga97cb08c9668a04e355a26fd30afdeb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97cb08c9668a04e355a26fd30afdeb52">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given vectors. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1MarkedVector.html#a1dd05a3f81ded7aa92ee43d062f9dd03" title="Swaps the contents of this and the given vector.">MarkedVector&lt;T&gt;::swap()</a>; it is provided so that MarkedVector&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first vector whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second vector whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66f73edd06b7cc0e066e11c1d8ea35c8" name="ga66f73edd06b7cc0e066e11c1d8ea35c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66f73edd06b7cc0e066e11c1d8ea35c8">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the given references so that they refer to each others' snapshots. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1SnapshotRef.html#a6be79e7f767935ecbb71de226b63049a" title="Swaps this and the given reference so that they refer to each others&#39; snapshots.">SnapshotRef&lt;T&gt;::swap()</a>; it is provided so that SnapshotRef&lt;T&gt; meets the C++ Swappable requirements.</p>
<p >See the <a class="el" href="classregina_1_1Snapshot.html" title="Keeps a snapshot of an object of type T as it was at a particular moment in time.">Snapshot</a> documentation for a full explanation of how Regina's snapshotting machinery works.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first snapshot reference to swap. </td></tr>
    <tr><td class="paramname">b</td><td>the second snapshot reference to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4edb9a7b2681015b7a294f9f323c30b1" name="ga4edb9a7b2681015b7a294f9f323c30b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4edb9a7b2681015b7a294f9f323c30b1">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given collections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first collection of sets whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second collection of sets whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac347aec77131ddc5de3eceece273afe4" name="gac347aec77131ddc5de3eceece273afe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac347aec77131ddc5de3eceece273afe4">&#9670;&nbsp;</a></span>tightDecodeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Int regina::detail::tightDecodeIndex </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function that reconstructs an integer that was encoded using <a class="el" href="group__utilities.html#ga8a95c510b293956bbf9fc66cfe763eda" title="Internal function that writes the tight encoding of an integer whose value is either non-negative or ...">tightEncodeIndex()</a>. </p>
<p >This encoding method is used for integers that are either non-negative or -1, and is not compatible with Regina's general integer encodings.</p>
<p >The tight encoding will be read from the given input stream. If the input stream contains leading whitespace then it will be treated as an invalid encoding (i.e., this routine will throw an exception). The input routine <em>may</em> contain further data: if this routine is successful then the input stream will be left positioned immediately after the encoding, without skipping any trailing whitespace.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>the given input stream does not begin with a tight encoding of an integer of type <em>Int</em> using the encoding scheme defined by <a class="el" href="group__utilities.html#ga8a95c510b293956bbf9fc66cfe763eda" title="Internal function that writes the tight encoding of an integer whose value is either non-negative or ...">tightEncodeIndex()</a>. This includes the case where the encoding <em>is</em> a valid non-negative integer encoding but the integer itself is outside the allowed range for the <em>Int</em> type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The type of integer to reconstruct. Currently this must be either <code>ssize_t</code> (the only allowed signed type), or one of the unsigned native C++ integer types that holds at least 16 bits. This list of types may be expanded in future versions of Regina.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input stream that begins with a tight encoding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="ga76f60a3e48eb2ee106947ca5b898e8cf" name="ga76f60a3e48eb2ee106947ca5b898e8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76f60a3e48eb2ee106947ca5b898e8cf">&#9670;&nbsp;</a></span>tightDecodeInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Int regina::detail::tightDecodeInteger </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noTrailingData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function that reconstructs an integer from its given tight encoding. </p>
<p >This should not be called directly; its purpose is to provide a common implementation for <a class="el" href="namespaceregina.html#a968e5525b0b7c5e65b14b70ae12f8377" title="Reconstructs an integer or boolean from its given tight encoding.">tightDecoding()</a> and <a class="el" href="namespaceregina.html#a03d089296cd6b213d90442e262fffa9f" title="Reconstructs an integer or boolean from its given tight encoding.">tightDecode()</a> for all integer types.</p>
<p >The tight encoding will be extracted one character at a time beginning with the iterator <em>start</em>, in a single pass, without skipping any leading whitespace. If the iterator ever reaches <em>limit</em> before the encoding is complete then the encoding is treated as invalid (i.e., this routine will throw an exception).</p>
<p >If <em>noTrailingData</em> is <code>true</code> then the iterator is required to <em>finish</em> at <em>limit</em>, or else the encoding will be considered invalid also; if <em>noTrailingData</em> is <code>false</code> then there is no constraint on the final state of the iterator.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a></td><td>the given iterator does not point to a tight encoding of an integer of type <em>Int</em>. This includes the case where the encoding <em>is</em> a valid integer encoding but the integer itself is outside the allowed range for the <em>Int</em> type.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine does recognise infinity in the case where <em>Int</em> is the type <a class="el" href="group__maths.html#ga952eff9b22eb6c0f2b1d8a5f6d2a3b76" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="namespaceregina.html#a968e5525b0b7c5e65b14b70ae12f8377" title="Reconstructs an integer or boolean from its given tight encoding.">regina::tightDecoding()</a> instead.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The type of integer to reconstruct; this must be either (i) a native C++ integer type, or (ii) one of Regina's arbitrary precision integer types (i.e., <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a> or <a class="el" href="group__maths.html#ga952eff9b22eb6c0f2b1d8a5f6d2a3b76" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>). In particular, <code>bool</code> is not allowed here.</td></tr>
    <tr><td class="paramname">iterator</td><td>an input iterator type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>an iterator that points to the beginning of a tight encoding. </td></tr>
    <tr><td class="paramname">limit</td><td>an iterator that, if reached, indicates that no more characters are available. </td></tr>
    <tr><td class="paramname">noTrailingData</td><td><code>true</code> if iteration should reach <em>limit</em> immediately after the encoding is read, or <code>false</code> if there is allowed to be additional unread data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer represented by the given tight encoding. </dd></dl>

</div>
</div>
<a id="ga588cb4d07d97f9a53e86859e4e233aab" name="ga588cb4d07d97f9a53e86859e4e233aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga588cb4d07d97f9a53e86859e4e233aab">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given boolean to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The booleans <code>true</code> and <code>false</code> are guaranteed to have the same tight encodings as the integers 1 and 0 respectively.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#ga483daa45b68925495da3367619d8a7e9" title="Returns the tight encoding of the given boolean.">regina::tightEncoding(bool)</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the boolean to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3071be3bed13d0057ebe344aab4ed4ef" name="ga3071be3bed13d0057ebe344aab4ed4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3071be3bed13d0057ebe344aab4ed4ef">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given signed integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82" title="Returns the tight encoding of the given signed integer.">regina::tightEncoding(int)</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3db618c87ebf51d61009cc98c3cef150" name="ga3db618c87ebf51d61009cc98c3cef150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3db618c87ebf51d61009cc98c3cef150">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given signed long long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gac847807974dbe589cfc57056a236cd46" title="Returns the tight encoding of the given signed long long integer.">regina::tightEncoding(long long)</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc77642572c2f8eea1818db38b28de2b" name="gafc77642572c2f8eea1818db38b28de2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc77642572c2f8eea1818db38b28de2b">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given signed long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58" title="Returns the tight encoding of the given signed long integer.">regina::tightEncoding(long)</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadfd99d3c0d21833b55a4af77736092d" name="gaadfd99d3c0d21833b55a4af77736092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadfd99d3c0d21833b55a4af77736092d">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given unsigned long long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gac847807974dbe589cfc57056a236cd46" title="Returns the tight encoding of the given signed long long integer.">regina::tightEncoding(long long)</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56176c1b2cedb9dcf027c7cf88907806" name="ga56176c1b2cedb9dcf027c7cf88907806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56176c1b2cedb9dcf027c7cf88907806">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given unsigned long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58" title="Returns the tight encoding of the given signed long integer.">regina::tightEncoding(long)</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf00bbae1e4f050d67575a68752b4018f" name="gaf00bbae1e4f050d67575a68752b4018f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf00bbae1e4f050d67575a68752b4018f">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given unsigned integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82" title="Returns the tight encoding of the given signed integer.">regina::tightEncoding(int)</a> instead, which returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a95c510b293956bbf9fc66cfe763eda" name="ga8a95c510b293956bbf9fc66cfe763eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a95c510b293956bbf9fc66cfe763eda">&#9670;&nbsp;</a></span>tightEncodeIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::detail::tightEncodeIndex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function that writes the tight encoding of an integer whose value is either non-negative or -1. </p>
<p >This should <em>not</em> be used for encoding standalone integers, since it uses a more compact format that is not compatible with Regina's general integer encodings. Instead, it is intended to be used as part of the encoding for larger objects (e.g., triangulations or isomorphisms).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>the given integer is less than -1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The type of integer to encode. Currently this must be either <code>ssize_t</code> (the only allowed signed type), or one of the unsigned native C++ integer types that holds at least 16 bits. This list of types may be expanded in future versions of Regina.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12ac49ef48ad51831f09c40a326fcce9" name="ga12ac49ef48ad51831f09c40a326fcce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12ac49ef48ad51831f09c40a326fcce9">&#9670;&nbsp;</a></span>tightEncodeInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::detail::tightEncodeInteger </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function that writes the tight encoding of the given integer to the given output stream. </p>
<p >This should not be called directly; its purpose is to provide a common implementation for <a class="el" href="group__maths.html#gae8cd5c004f47461d75f07d3696fa855a" title="Writes the tight encoding of the given arbitrary precision integer to the given output stream.">tightEncode()</a> and <a class="el" href="group__maths.html#gaed202995c74bfebb0d60b38044dfd2b5" title="Returns the tight encoding of the given arbitrary precision integer.">tightEncoding()</a> for all integer types.</p>
<p >This routine does support passing infinity as the given value (which is only relevant when the integer type <em>Int</em> is <a class="el" href="group__maths.html#ga952eff9b22eb6c0f2b1d8a5f6d2a3b76" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use regina::tightEncoding(...) instead.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The type of integer to encode; this must be either (i) a native C++ integer type, or (ii) one of Regina's arbitrary precision integer types (i.e., <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a> or <a class="el" href="group__maths.html#ga952eff9b22eb6c0f2b1d8a5f6d2a3b76" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>). In particular, <code>bool</code> is not allowed here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38bc82f94369fd15b4897468293d5bee" name="ga38bc82f94369fd15b4897468293d5bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38bc82f94369fd15b4897468293d5bee">&#9670;&nbsp;</a></span>tightEncodeNoIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::detail::tightEncodeNoIndex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function that writes the tight encoding of -1, using an encoding that is compatible with <a class="el" href="group__utilities.html#ga8a95c510b293956bbf9fc66cfe763eda" title="Internal function that writes the tight encoding of an integer whose value is either non-negative or ...">tightEncodeIndex()</a>. </p>
<p >Note that this is <em>not</em> compatible with Regina's general integer encodings.</p>
<p >This is identical to calling <code>tightEncodeIndex&lt;ssize_t&gt;(out, -1)</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga483daa45b68925495da3367619d8a7e9" name="ga483daa45b68925495da3367619d8a7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga483daa45b68925495da3367619d8a7e9">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given boolean. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<p >The booleans <code>true</code> and <code>false</code> are guaranteed to have the same tight encodings as the integers 1 and 0 respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the boolean to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gad04ee6a550c68d8d29b2c1eb35d4bc82" name="gad04ee6a550c68d8d29b2c1eb35d4bc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04ee6a550c68d8d29b2c1eb35d4bc82">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given signed integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gac847807974dbe589cfc57056a236cd46" name="gac847807974dbe589cfc57056a236cd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac847807974dbe589cfc57056a236cd46">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given signed long long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gae5d43fc580edb50fb9a0756a1ffedb58" name="gae5d43fc580edb50fb9a0756a1ffedb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d43fc580edb50fb9a0756a1ffedb58">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given signed long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gab1ddfa37a33307ca03dcb087da759280" name="gab1ddfa37a33307ca03dcb087da759280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1ddfa37a33307ca03dcb087da759280">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given unsigned long long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gaf1c703c35095c4407b987054ec056cc7" name="gaf1c703c35095c4407b987054ec056cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c703c35095c4407b987054ec056cc7">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given unsigned long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ga5dd29cdddc4af9b3dbd98fd08badbc2a" name="ga5dd29cdddc4af9b3dbd98fd08badbc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd29cdddc4af9b3dbd98fd08badbc2a">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given unsigned integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ga91eb70b23252b007d149e269b1afb973" name="ga91eb70b23252b007d149e269b1afb973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91eb70b23252b007d149e269b1afb973">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p >The substring from <em>s</em> until just before the pointer that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return a pointer to the null terminator of <em>s</em>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="gad3439925c61c42453159e0b50bdff960" name="gad3439925c61c42453159e0b50bdff960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3439925c61c42453159e0b50bdff960">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string::const_iterator regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p >The substring from <code>s.begin()</code> to the iterator that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return <code>s.end()</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="ga17e706f7f722922798776b74f9933bd0" name="ga17e706f7f722922798776b74f9933bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e706f7f722922798776b74f9933bd0">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a boolean and reports whether this conversion was successful. </p>
<p >If the given string begins with <code>T</code>, <code>t</code> or <code>1</code>, then the string will be successfully converted to <code>true</code>. If the given string begins with <code>F</code>, <code>f</code> or <code>0</code>, then the string will be successfully converted to <code>false</code>. Otherwise the conversion will be unsuccessful and argument <em>dest</em> will be set to <code>false</code>.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6083d66d2dcac7dce8637e6282c6c679" name="ga6083d66d2dcac7dce8637e6282c6c679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6083d66d2dcac7dce8637e6282c6c679">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a set of booleans and reports whether this conversion was successful. </p>
<p >A set of booleans is represented by one of the four string codes <code>&ndash;</code>, <code>T-</code>, <code>-F</code> or <code>TF</code>, as returned by <a class="el" href="classregina_1_1BoolSet.html#a9304c4a54cdd030b77eb8a8cd283fae3" title="Returns the string code representing this boolean set.">BoolSet::stringCode()</a>. If the conversion is unsuccessful, argument <em>dest</em> will be set to the empty set and <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, since none of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are available to Python. Instead you can use <a class="el" href="classregina_1_1BoolSet.html#a6081f30003ede42f4ce3d4e053f80e74" title="Sets this to be the boolean set represented by the given string code.">BoolSet::setStringCode()</a>, which performs the same task (with the minor difference that it does not change <em>dest</em> if the conversion is unsuccessful).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting set of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6d3266c3fb5264747ed7af53464ac7a9" name="ga6d3266c3fb5264747ed7af53464ac7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d3266c3fb5264747ed7af53464ac7a9">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a double precision real number and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the real number that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting real number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga896ae2c6783d6d6dc4081bddabb22518" name="ga896ae2c6783d6d6dc4081bddabb22518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896ae2c6783d6d6dc4081bddabb22518">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gae40c2e62bf0908919834ea10762def19" name="gae40c2e62bf0908919834ea10762def19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40c2e62bf0908919834ea10762def19">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an 8-bit integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaad0bb367f8c8f4172e6a979751907c6c" name="gaad0bb367f8c8f4172e6a979751907c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad0bb367f8c8f4172e6a979751907c6c">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gacd5eebbe6059d16231b0e41966e2056a" name="gacd5eebbe6059d16231b0e41966e2056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5eebbe6059d16231b0e41966e2056a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga384de19626353085bf20eedc89c3c30a" name="ga384de19626353085bf20eedc89c3c30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga384de19626353085bf20eedc89c3c30a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a short integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaf9eaa1f183454edc0db4f915d98c0a73" name="gaf9eaa1f183454edc0db4f915d98c0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9eaa1f183454edc0db4f915d98c0a73">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga974a77f98013a0274540b1d0b06519f3" name="ga974a77f98013a0274540b1d0b06519f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974a77f98013a0274540b1d0b06519f3">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga007abfa18426eedc6277f644ded3e068" name="ga007abfa18426eedc6277f644ded3e068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007abfa18426eedc6277f644ded3e068">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad0bc034686407302e3ad597e39933a99" name="gad0bc034686407302e3ad597e39933a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0bc034686407302e3ad597e39933a99">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga183ba5dd849f33e9153c3363323abf5a" name="ga183ba5dd849f33e9153c3363323abf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga183ba5dd849f33e9153c3363323abf5a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned short integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6d9135c01a79c7fcfa32caafd8bb4652" name="ga6d9135c01a79c7fcfa32caafd8bb4652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9135c01a79c7fcfa32caafd8bb4652">&#9670;&nbsp;</a></span>xmlEncodeComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given string encoded so it is suitable for use inside an XML comment. </p>
<p >As well as converting special characters to XML entities, this routine will replace dashes with underscores to avoid double-hyphens (which are illegal in XML comments).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string converted to be usable inside an XML comment. </dd></dl>

</div>
</div>
<a id="ga3a9273b1e8e9c18b33d73012b77c1b3f" name="ga3a9273b1e8e9c18b33d73012b77c1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9273b1e8e9c18b33d73012b77c1b3f">&#9670;&nbsp;</a></span>xmlEncodeSpecialChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeSpecialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given string with special characters converted to XML entities. </p>
<p >For instance, the string <code>"a \&lt; b"</code> would be converted to <code>"a \&amp;lt; b"</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted string with special characters replaced by XML entities. </dd></dl>

</div>
</div>
<a id="gacb9d9d42e182de0dc67e4176414cb07d" name="gacb9d9d42e182de0dc67e4176414cb07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9d9d42e182de0dc67e4176414cb07d">&#9670;&nbsp;</a></span>xmlValueTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlValueTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an XML tag with a single property containing the given value. </p>
<p >The tag will be of the form <code>&lt;tagName value="..."/&gt;</code>.</p>
<p >The value itself will be written to the tag string using the standard output stream operator &lt;&lt;.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The property value when written to an output stream does not contain any special characters (such as <code>&lt;</code> or <code>&amp;</code>) that need to be encoded as XML entities.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the XML tag to create. </td></tr>
    <tr><td class="paramname">value</td><td>the value to assign to the <em>value</em> property of the tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding XML tag. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga3657172c4ecb2d7217bd5220b83cf41f" name="ga3657172c4ecb2d7217bd5220b83cf41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3657172c4ecb2d7217bd5220b83cf41f">&#9670;&nbsp;</a></span>base64Spare</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char regina::base64Spare[] = &quot;_-.&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table of printable characters that are <em>not</em> amongst the base64 printable characters used by Regina. </p>
<p >These characters could be used (for example) to mark the boundaries of base64 blocks.</p>
<p >These characters are presented as a string of length at least 3. Future versions of Regina may append new characters to the end of this string, but the existing characters base64Spare[0], base64Spare[1], etc. will not change. </p>

</div>
</div>
<a id="ga5616d8b8cc6091811f09782f0dad6449" name="ga5616d8b8cc6091811f09782f0dad6449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5616d8b8cc6091811f09782f0dad6449">&#9670;&nbsp;</a></span>base64Table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char regina::base64Table[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></div>
</div><!-- fragment -->
<p>The table of all base64 printable characters, as used by the base64 routines in Regina. </p>
<p >This is the translation table as described in RFC1113. It is presented as a string of length 64. </p>

</div>
</div>
<a id="ga111f0463a59ed427c782ac3df1d39f7a" name="ga111f0463a59ed427c782ac3df1d39f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga111f0463a59ed427c782ac3df1d39f7a">&#9670;&nbsp;</a></span>maxSafeFactor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType , IntType coeff&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntType regina::maxSafeFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::numeric_limits&lt;IntType&gt;::max() / coeff</div>
</div><!-- fragment -->
<p>The largest integer of the given type that can be multiplied by <em>coeff</em> without overflowing. </p>
<p >The template parameter <em>IntType</em> may be any native C++ integer type, such as <code>int</code>, <code>long</code>, and so on. This type may be either signed or unsigned, but it must be supported by std::numeric_limits.</p>
<p >The template parameter <em>coeff</em> can be any positive integer.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, since Python does not support templates. </dd></dl>

</div>
</div>
<a id="gafd0e3d57fb0834f9cfff7b13e7528466" name="gafd0e3d57fb0834f9cfff7b13e7528466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd0e3d57fb0834f9cfff7b13e7528466">&#9670;&nbsp;</a></span>minSafeFactor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType , IntType coeff&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntType regina::minSafeFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::numeric_limits&lt;IntType&gt;::min() / coeff</div>
</div><!-- fragment -->
<p>The largest integer of the given type that can be multiplied by <em>coeff</em> without overflowing. </p>
<p >The template parameter <em>IntType</em> may be any native C++ integer type, such as <code>int</code>, <code>long</code>, and so on. This type may be either signed or unsigned, but it must be supported by std::numeric_limits.</p>
<p >The template parameter <em>coeff</em> can be any positive integer.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, since Python does not support templates. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2022, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
