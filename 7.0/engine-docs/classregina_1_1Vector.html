<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: regina::Vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Vector&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An optimised vector class of elements from a given ring T.  
 <a href="classregina_1_1Vector.html#details">More...</a></p>

<p><code>#include &lt;maths/vector.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Vector&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Vector.png" usemap="#regina::Vector_3C_20T_20_3E_map" alt=""/>
  <map id="regina::Vector_3C_20T_20_3E_map" name="regina::Vector_3C_20T_20_3E_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; Vector&lt; T &gt; &gt;" shape="rect" coords="0,56,220,80"/>
<area href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output." alt="regina::Output&lt; T, supportsUtf8 &gt;" shape="rect" coords="0,0,220,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6b0922b4b9be4aec6cc920f888d01079"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a6b0922b4b9be4aec6cc920f888d01079">value_type</a> = T</td></tr>
<tr class="memdesc:a6b0922b4b9be4aec6cc920f888d01079"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of element that is stored in this vector.  <a href="classregina_1_1Vector.html#a6b0922b4b9be4aec6cc920f888d01079">More...</a><br /></td></tr>
<tr class="separator:a6b0922b4b9be4aec6cc920f888d01079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedaaaa33a5694d696f5447f0490ead9c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#aedaaaa33a5694d696f5447f0490ead9c">size_type</a> = size_t</td></tr>
<tr class="memdesc:aedaaaa33a5694d696f5447f0490ead9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type used for indexing into this vector.  <a href="classregina_1_1Vector.html#aedaaaa33a5694d696f5447f0490ead9c">More...</a><br /></td></tr>
<tr class="separator:aedaaaa33a5694d696f5447f0490ead9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8952ac9ae3c392cf1068aeda7740c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a6d8952ac9ae3c392cf1068aeda7740c7">reference</a> = T &amp;</td></tr>
<tr class="memdesc:a6d8952ac9ae3c392cf1068aeda7740c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to an element of this vector.  <a href="classregina_1_1Vector.html#a6d8952ac9ae3c392cf1068aeda7740c7">More...</a><br /></td></tr>
<tr class="separator:a6d8952ac9ae3c392cf1068aeda7740c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65611158d919b0740b37b14922216f96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a65611158d919b0740b37b14922216f96">const_reference</a> = const T &amp;</td></tr>
<tr class="memdesc:a65611158d919b0740b37b14922216f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const reference to an element of this vector.  <a href="classregina_1_1Vector.html#a65611158d919b0740b37b14922216f96">More...</a><br /></td></tr>
<tr class="separator:a65611158d919b0740b37b14922216f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7543d01b4eaed8a4fa2ea83fa364c222"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> = T *</td></tr>
<tr class="memdesc:a7543d01b4eaed8a4fa2ea83fa364c222"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non-const iterator type for this vector.  <a href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">More...</a><br /></td></tr>
<tr class="separator:a7543d01b4eaed8a4fa2ea83fa364c222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845301f807000ca943531c7042e23d55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a845301f807000ca943531c7042e23d55">const_iterator</a> = const T *</td></tr>
<tr class="memdesc:a845301f807000ca943531c7042e23d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The const iterator type for this vector.  <a href="classregina_1_1Vector.html#a845301f807000ca943531c7042e23d55">More...</a><br /></td></tr>
<tr class="separator:a845301f807000ca943531c7042e23d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7803f77a6dd1f583b533cc2f180c7176"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a7803f77a6dd1f583b533cc2f180c7176">Element</a> = T</td></tr>
<tr class="memdesc:a7803f77a6dd1f583b533cc2f180c7176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for the type of element that is stored in this vector.  <a href="classregina_1_1Vector.html#a7803f77a6dd1f583b533cc2f180c7176">More...</a><br /></td></tr>
<tr class="separator:a7803f77a6dd1f583b533cc2f180c7176"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7664e9efbed8e2a0f84656dfadd66489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a7664e9efbed8e2a0f84656dfadd66489">Vector</a> (size_t newVectorSize)</td></tr>
<tr class="memdesc:a7664e9efbed8e2a0f84656dfadd66489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector.  <a href="classregina_1_1Vector.html#a7664e9efbed8e2a0f84656dfadd66489">More...</a><br /></td></tr>
<tr class="separator:a7664e9efbed8e2a0f84656dfadd66489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e83c9eecd552ab24f4558dcc958d84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a45e83c9eecd552ab24f4558dcc958d84">Vector</a> (size_t newVectorSize, const T &amp;initValue)</td></tr>
<tr class="memdesc:a45e83c9eecd552ab24f4558dcc958d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector and initialises every element to the given value.  <a href="classregina_1_1Vector.html#a45e83c9eecd552ab24f4558dcc958d84">More...</a><br /></td></tr>
<tr class="separator:a45e83c9eecd552ab24f4558dcc958d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615bd51dabb597372d82bfecda61674e"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> &gt; </td></tr>
<tr class="memitem:a615bd51dabb597372d82bfecda61674e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a615bd51dabb597372d82bfecda61674e">Vector</a> (<a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e">begin</a>, <a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9">end</a>)</td></tr>
<tr class="memdesc:a615bd51dabb597372d82bfecda61674e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector containing the given sequence of elements.  <a href="classregina_1_1Vector.html#a615bd51dabb597372d82bfecda61674e">More...</a><br /></td></tr>
<tr class="separator:a615bd51dabb597372d82bfecda61674e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80421f1def30a1aa50facc88faa28ae7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a80421f1def30a1aa50facc88faa28ae7">Vector</a> (std::initializer_list&lt; T &gt; data)</td></tr>
<tr class="memdesc:a80421f1def30a1aa50facc88faa28ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector containing the given hard-coded elements.  <a href="classregina_1_1Vector.html#a80421f1def30a1aa50facc88faa28ae7">More...</a><br /></td></tr>
<tr class="separator:a80421f1def30a1aa50facc88faa28ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f73850067281be6eab224b6a632945e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a3f73850067281be6eab224b6a632945e">Vector</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:a3f73850067281be6eab224b6a632945e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="classregina_1_1Vector.html#a3f73850067281be6eab224b6a632945e">More...</a><br /></td></tr>
<tr class="separator:a3f73850067281be6eab224b6a632945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7482a1cff348adc41aaa6b32b162fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#aaa7482a1cff348adc41aaa6b32b162fa">Vector</a> (<a class="el" href="classregina_1_1Vector.html">Vector</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aaa7482a1cff348adc41aaa6b32b162fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given vector into this new vector.  <a href="classregina_1_1Vector.html#aaa7482a1cff348adc41aaa6b32b162fa">More...</a><br /></td></tr>
<tr class="separator:aaa7482a1cff348adc41aaa6b32b162fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13b652bab0b97581799178e9b15b14b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#aa13b652bab0b97581799178e9b15b14b">~Vector</a> ()</td></tr>
<tr class="memdesc:aa13b652bab0b97581799178e9b15b14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this vector.  <a href="classregina_1_1Vector.html#aa13b652bab0b97581799178e9b15b14b">More...</a><br /></td></tr>
<tr class="separator:aa13b652bab0b97581799178e9b15b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941b1a276184770321c99e11b9160dfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a941b1a276184770321c99e11b9160dfb">size</a> () const</td></tr>
<tr class="memdesc:a941b1a276184770321c99e11b9160dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the vector.  <a href="classregina_1_1Vector.html#a941b1a276184770321c99e11b9160dfb">More...</a><br /></td></tr>
<tr class="separator:a941b1a276184770321c99e11b9160dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673dd172e08ee8b07114974f78b27fb1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a673dd172e08ee8b07114974f78b27fb1">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:a673dd172e08ee8b07114974f78b27fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="classregina_1_1Vector.html#a673dd172e08ee8b07114974f78b27fb1">More...</a><br /></td></tr>
<tr class="separator:a673dd172e08ee8b07114974f78b27fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50673a36adb663fff93930a7e174370"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ae50673a36adb663fff93930a7e174370">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:ae50673a36adb663fff93930a7e174370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives write access to the element at the given index in the vector.  <a href="classregina_1_1Vector.html#ae50673a36adb663fff93930a7e174370">More...</a><br /></td></tr>
<tr class="separator:ae50673a36adb663fff93930a7e174370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da9446d04bf24cf7ed755679a6b6b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a2da9446d04bf24cf7ed755679a6b6b95">setElement</a> (size_t index, const T &amp;value)</td></tr>
<tr class="memdesc:a2da9446d04bf24cf7ed755679a6b6b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that sets the element at the given index in the vector to the given value.  <a href="classregina_1_1Vector.html#a2da9446d04bf24cf7ed755679a6b6b95">More...</a><br /></td></tr>
<tr class="separator:a2da9446d04bf24cf7ed755679a6b6b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d98d76a35eccde9ec6078b414b8023e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e">begin</a> ()</td></tr>
<tr class="memdesc:a1d98d76a35eccde9ec6078b414b8023e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beginning of a non-const iterator range that runs through all elements of this vector.  <a href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e">More...</a><br /></td></tr>
<tr class="separator:a1d98d76a35eccde9ec6078b414b8023e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45f94dfa6d86be38efc75e9f2f3ea8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html#a845301f807000ca943531c7042e23d55">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ab45f94dfa6d86be38efc75e9f2f3ea8d">begin</a> () const</td></tr>
<tr class="memdesc:ab45f94dfa6d86be38efc75e9f2f3ea8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beginning of a const iterator range that runs through all elements of this vector.  <a href="classregina_1_1Vector.html#ab45f94dfa6d86be38efc75e9f2f3ea8d">More...</a><br /></td></tr>
<tr class="separator:ab45f94dfa6d86be38efc75e9f2f3ea8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d70b1d290fdb72041677a0ae8fb73d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9">end</a> ()</td></tr>
<tr class="memdesc:a7d70b1d290fdb72041677a0ae8fb73d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end of a non-const iterator range that runs through all elements of this vector.  <a href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9">More...</a><br /></td></tr>
<tr class="separator:a7d70b1d290fdb72041677a0ae8fb73d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e13342028549428ddd63a0b4968e4eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html#a845301f807000ca943531c7042e23d55">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a2e13342028549428ddd63a0b4968e4eb">end</a> () const</td></tr>
<tr class="memdesc:a2e13342028549428ddd63a0b4968e4eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the end of a const iterator range that runs through all elements of this vector.  <a href="classregina_1_1Vector.html#a2e13342028549428ddd63a0b4968e4eb">More...</a><br /></td></tr>
<tr class="separator:a2e13342028549428ddd63a0b4968e4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a17460e605759c848cbb8c754044459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a0a17460e605759c848cbb8c754044459">operator==</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;compare) const</td></tr>
<tr class="memdesc:a0a17460e605759c848cbb8c754044459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vector is equal to the given vector.  <a href="classregina_1_1Vector.html#a0a17460e605759c848cbb8c754044459">More...</a><br /></td></tr>
<tr class="separator:a0a17460e605759c848cbb8c754044459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec4afe0ca76cf5f3012d98a9d148013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a3ec4afe0ca76cf5f3012d98a9d148013">operator!=</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;compare) const</td></tr>
<tr class="memdesc:a3ec4afe0ca76cf5f3012d98a9d148013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vector is different from the given vector.  <a href="classregina_1_1Vector.html#a3ec4afe0ca76cf5f3012d98a9d148013">More...</a><br /></td></tr>
<tr class="separator:a3ec4afe0ca76cf5f3012d98a9d148013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82359f91e85e04f413c279a57acf3f6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a82359f91e85e04f413c279a57acf3f6d">operator=</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:a82359f91e85e04f413c279a57acf3f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this vector equal to the given vector.  <a href="classregina_1_1Vector.html#a82359f91e85e04f413c279a57acf3f6d">More...</a><br /></td></tr>
<tr class="separator:a82359f91e85e04f413c279a57acf3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4210cfbbcb4a02f1eba06421c13d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a6c4210cfbbcb4a02f1eba06421c13d64">operator=</a> (<a class="el" href="classregina_1_1Vector.html">Vector</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a6c4210cfbbcb4a02f1eba06421c13d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given vector into this vector.  <a href="classregina_1_1Vector.html#a6c4210cfbbcb4a02f1eba06421c13d64">More...</a><br /></td></tr>
<tr class="separator:a6c4210cfbbcb4a02f1eba06421c13d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9cc662372fa3a48e91fe15665ae7ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a8b9cc662372fa3a48e91fe15665ae7ed">swap</a> (<a class="el" href="classregina_1_1Vector.html">Vector</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a8b9cc662372fa3a48e91fe15665ae7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given vector.  <a href="classregina_1_1Vector.html#a8b9cc662372fa3a48e91fe15665ae7ed">More...</a><br /></td></tr>
<tr class="separator:a8b9cc662372fa3a48e91fe15665ae7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6adc697d680892c5a410b3a276208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a7ae6adc697d680892c5a410b3a276208">operator+=</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a7ae6adc697d680892c5a410b3a276208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="classregina_1_1Vector.html#a7ae6adc697d680892c5a410b3a276208">More...</a><br /></td></tr>
<tr class="separator:a7ae6adc697d680892c5a410b3a276208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad872bea3a35622bb5eb063e59d5c1ae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ad872bea3a35622bb5eb063e59d5c1ae0">operator-=</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ad872bea3a35622bb5eb063e59d5c1ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given vector from this vector.  <a href="classregina_1_1Vector.html#ad872bea3a35622bb5eb063e59d5c1ae0">More...</a><br /></td></tr>
<tr class="separator:ad872bea3a35622bb5eb063e59d5c1ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68fbe269b6846cacffcf4dbce2038c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#aa68fbe269b6846cacffcf4dbce2038c4">operator*=</a> (const T &amp;factor)</td></tr>
<tr class="memdesc:aa68fbe269b6846cacffcf4dbce2038c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this vector by the given scalar.  <a href="classregina_1_1Vector.html#aa68fbe269b6846cacffcf4dbce2038c4">More...</a><br /></td></tr>
<tr class="separator:aa68fbe269b6846cacffcf4dbce2038c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1509ee583a65c4c9078041f5c9f1567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ac1509ee583a65c4c9078041f5c9f1567">operator+</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac1509ee583a65c4c9078041f5c9f1567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector, and returns the result.  <a href="classregina_1_1Vector.html#ac1509ee583a65c4c9078041f5c9f1567">More...</a><br /></td></tr>
<tr class="separator:ac1509ee583a65c4c9078041f5c9f1567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521c5661faa8b649eee7f8a27d3f6601"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a521c5661faa8b649eee7f8a27d3f6601">operator-</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a521c5661faa8b649eee7f8a27d3f6601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given vector from this vector, and returns the result.  <a href="classregina_1_1Vector.html#a521c5661faa8b649eee7f8a27d3f6601">More...</a><br /></td></tr>
<tr class="separator:a521c5661faa8b649eee7f8a27d3f6601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf90f48853bf81ab824b07181e400216"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#adf90f48853bf81ab824b07181e400216">operator*</a> (const T &amp;factor) const</td></tr>
<tr class="memdesc:adf90f48853bf81ab824b07181e400216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this vector by the given scalar, and returns the result.  <a href="classregina_1_1Vector.html#adf90f48853bf81ab824b07181e400216">More...</a><br /></td></tr>
<tr class="separator:adf90f48853bf81ab824b07181e400216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e90b3eedae0b3b3451dae8d8d187b9"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ae9e90b3eedae0b3b3451dae8d8d187b9">operator*</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:ae9e90b3eedae0b3b3451dae8d8d187b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of this vector and the given vector.  <a href="classregina_1_1Vector.html#ae9e90b3eedae0b3b3451dae8d8d187b9">More...</a><br /></td></tr>
<tr class="separator:ae9e90b3eedae0b3b3451dae8d8d187b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba80d7d2d8c8cf98aa8cdd703b805a4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#aba80d7d2d8c8cf98aa8cdd703b805a4d">negate</a> ()</td></tr>
<tr class="memdesc:aba80d7d2d8c8cf98aa8cdd703b805a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates every element of this vector.  <a href="classregina_1_1Vector.html#aba80d7d2d8c8cf98aa8cdd703b805a4d">More...</a><br /></td></tr>
<tr class="separator:aba80d7d2d8c8cf98aa8cdd703b805a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17559ecc897b92d0d1f715db4f11d8ff"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a17559ecc897b92d0d1f715db4f11d8ff">norm</a> () const</td></tr>
<tr class="memdesc:a17559ecc897b92d0d1f715db4f11d8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the norm of this vector.  <a href="classregina_1_1Vector.html#a17559ecc897b92d0d1f715db4f11d8ff">More...</a><br /></td></tr>
<tr class="separator:a17559ecc897b92d0d1f715db4f11d8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d552a18d439141b82395351947dd16"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a93d552a18d439141b82395351947dd16">elementSum</a> () const</td></tr>
<tr class="memdesc:a93d552a18d439141b82395351947dd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements of this vector.  <a href="classregina_1_1Vector.html#a93d552a18d439141b82395351947dd16">More...</a><br /></td></tr>
<tr class="separator:a93d552a18d439141b82395351947dd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae417bfb64da0cfee726b362d273fa8f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ae417bfb64da0cfee726b362d273fa8f5">addCopies</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other, const T &amp;multiple)</td></tr>
<tr class="memdesc:ae417bfb64da0cfee726b362d273fa8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given multiple of the given vector to this vector.  <a href="classregina_1_1Vector.html#ae417bfb64da0cfee726b362d273fa8f5">More...</a><br /></td></tr>
<tr class="separator:ae417bfb64da0cfee726b362d273fa8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33d4bda8da5234d23c3028e79068645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ad33d4bda8da5234d23c3028e79068645">subtractCopies</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;other, const T &amp;multiple)</td></tr>
<tr class="memdesc:ad33d4bda8da5234d23c3028e79068645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given multiple of the given vector to this vector.  <a href="classregina_1_1Vector.html#ad33d4bda8da5234d23c3028e79068645">More...</a><br /></td></tr>
<tr class="separator:ad33d4bda8da5234d23c3028e79068645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7824097a059dc1aea9e91a139752875c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a7824097a059dc1aea9e91a139752875c">isZero</a> () const</td></tr>
<tr class="memdesc:a7824097a059dc1aea9e91a139752875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the zero vector.  <a href="classregina_1_1Vector.html#a7824097a059dc1aea9e91a139752875c">More...</a><br /></td></tr>
<tr class="separator:a7824097a059dc1aea9e91a139752875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2431b2f42b5b5fe5142bc3a46a5dc73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#aa2431b2f42b5b5fe5142bc3a46a5dc73">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa2431b2f42b5b5fe5142bc3a46a5dc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1Vector.html#aa2431b2f42b5b5fe5142bc3a46a5dc73">More...</a><br /></td></tr>
<tr class="separator:aa2431b2f42b5b5fe5142bc3a46a5dc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad6db99cf59efda5b4886a5b8edbf84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a2ad6db99cf59efda5b4886a5b8edbf84">scaleDown</a> ()</td></tr>
<tr class="memdesc:a2ad6db99cf59efda5b4886a5b8edbf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="classregina_1_1Vector.html#a2ad6db99cf59efda5b4886a5b8edbf84">More...</a><br /></td></tr>
<tr class="separator:a2ad6db99cf59efda5b4886a5b8edbf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af363d28aa928a0421d516a3468bcb032"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#af363d28aa928a0421d516a3468bcb032">unit</a> (size_t dimension, size_t coordinate)</td></tr>
<tr class="memdesc:af363d28aa928a0421d516a3468bcb032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given unit vector.  <a href="classregina_1_1Vector.html#af363d28aa928a0421d516a3468bcb032">More...</a><br /></td></tr>
<tr class="separator:af363d28aa928a0421d516a3468bcb032"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3d3848a6a7707b6913f55c3e6c996835"><td class="memItemLeft" align="right" valign="top">static const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a3d3848a6a7707b6913f55c3e6c996835">zero</a></td></tr>
<tr class="memdesc:a3d3848a6a7707b6913f55c3e6c996835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero in the underlying number system.  <a href="classregina_1_1Vector.html#a3d3848a6a7707b6913f55c3e6c996835">More...</a><br /></td></tr>
<tr class="separator:a3d3848a6a7707b6913f55c3e6c996835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39611de5f0ca2f3ea00c1d85e90099d"><td class="memItemLeft" align="right" valign="top">static const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#ab39611de5f0ca2f3ea00c1d85e90099d">one</a></td></tr>
<tr class="memdesc:ab39611de5f0ca2f3ea00c1d85e90099d"><td class="mdescLeft">&#160;</td><td class="mdescRight">One in the underlying number system.  <a href="classregina_1_1Vector.html#ab39611de5f0ca2f3ea00c1d85e90099d">More...</a><br /></td></tr>
<tr class="separator:ab39611de5f0ca2f3ea00c1d85e90099d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eab6a65972f42069143504331747064"><td class="memItemLeft" align="right" valign="top">static const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a4eab6a65972f42069143504331747064">minusOne</a></td></tr>
<tr class="memdesc:a4eab6a65972f42069143504331747064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative one in the underlying number system.  <a href="classregina_1_1Vector.html#a4eab6a65972f42069143504331747064">More...</a><br /></td></tr>
<tr class="separator:a4eab6a65972f42069143504331747064"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a03c07da13bc1281efc622f38f072c72a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#a03c07da13bc1281efc622f38f072c72a">elts_</a></td></tr>
<tr class="memdesc:a03c07da13bc1281efc622f38f072c72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal array containing all vector elements.  <a href="classregina_1_1Vector.html#a03c07da13bc1281efc622f38f072c72a">More...</a><br /></td></tr>
<tr class="separator:a03c07da13bc1281efc622f38f072c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba1623c1fc22b66165e4d24266ed8e3"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Vector.html#afba1623c1fc22b66165e4d24266ed8e3">end_</a></td></tr>
<tr class="memdesc:afba1623c1fc22b66165e4d24266ed8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer just beyond the end of the internal array.  <a href="classregina_1_1Vector.html#afba1623c1fc22b66165e4d24266ed8e3">More...</a><br /></td></tr>
<tr class="separator:afba1623c1fc22b66165e4d24266ed8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class regina::Vector&lt; T &gt;</div><p >An optimised vector class of elements from a given ring T. </p>
<p >Various mathematical vector operations are available.</p>
<p >This class is intended for serious computation, and as a result it has a streamlined implementation with no virtual methods. It can be subclassed, but since there are no virtual methods, type information must generally be known at compile time. Nevertheless, in many respects, different subclasses of Vector&lt;T&gt; can happily interact with one another.</p>
<p >This class is written with bulky types in mind (such as arbitrary precision integers), and so creations and operations are kept to a minimum.</p>
<p >As of Regina 7.0, this class explicitly supports zero-length vectors.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section warning"><dt>Warning</dt><dd>As of Regina 4.90, this class merges the old functionality of NFastVector and the NVector hierarchy from Regina 4.6. As a side-effect, the hierarchy has been compressed into just one class (NVectorUnit, NVectorMatrix and NVectorDense are gone), elements are always stored as dense vectors, and functions are no longer virtual (since the storage model is now fixed). The virtual clone() method is gone completely (since there are no longer virtual functions you should use the copy constructor instead), and the old makeLinComb() method is also gone (just use operator *= and <a class="el" href="classregina_1_1Vector.html#ae417bfb64da0cfee726b362d273fa8f5" title="Adds the given multiple of the given vector to this vector.">addCopies()</a>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Type T has a copy constructor. That is, if <code>a</code> and <code>b</code> are of type T, then <code>a</code> can be initialised to the value of <code>b</code> using <code>a(b)</code>. </dd>
<dd>
Type T has a default constructor. That is, an object of type T can be declared with no arguments. No specific default value is required. </dd>
<dd>
Type T allows for operators <code>=</code>, <code>==</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>+</code>, <code>-</code> and <code>*</code>. </dd>
<dd>
Type T has an integer constructor. That is, if <code>a</code> is of type T, then <code>a</code> can be initialised to an integer <code>l</code> using <code>a(l)</code>. </dd>
<dd>
An element <code>t</code> of type T can be written to an output stream <code>out</code> using the standard expression <code>out &lt;&lt; t</code>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present in general, although the specific types Vector&lt;Integer&gt; and Vector&lt;LargeInteger&gt; are available under the names VectorInt and VectorLarge respectively. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a845301f807000ca943531c7042e23d55" name="a845301f807000ca943531c7042e23d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845301f807000ca943531c7042e23d55">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html#a845301f807000ca943531c7042e23d55">const_iterator</a> =  const T*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The const iterator type for this vector. </p>

</div>
</div>
<a id="a65611158d919b0740b37b14922216f96" name="a65611158d919b0740b37b14922216f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65611158d919b0740b37b14922216f96">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html#a65611158d919b0740b37b14922216f96">const_reference</a> =  const T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A const reference to an element of this vector. </p>

</div>
</div>
<a id="a7803f77a6dd1f583b533cc2f180c7176" name="a7803f77a6dd1f583b533cc2f180c7176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7803f77a6dd1f583b533cc2f180c7176">&#9670;&nbsp;</a></span>Element</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html#a7803f77a6dd1f583b533cc2f180c7176">Element</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for the type of element that is stored in this vector. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000115">Deprecated:</a></b></dt><dd>This has been renamed to value_type, for consistency with standard C++ container types. </dd></dl>

</div>
</div>
<a id="a7543d01b4eaed8a4fa2ea83fa364c222" name="a7543d01b4eaed8a4fa2ea83fa364c222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7543d01b4eaed8a4fa2ea83fa364c222">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> =  T*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The non-const iterator type for this vector. </p>

</div>
</div>
<a id="a6d8952ac9ae3c392cf1068aeda7740c7" name="a6d8952ac9ae3c392cf1068aeda7740c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8952ac9ae3c392cf1068aeda7740c7">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html#a6d8952ac9ae3c392cf1068aeda7740c7">reference</a> =  T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A reference to an element of this vector. </p>

</div>
</div>
<a id="aedaaaa33a5694d696f5447f0490ead9c" name="aedaaaa33a5694d696f5447f0490ead9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedaaaa33a5694d696f5447f0490ead9c">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html#aedaaaa33a5694d696f5447f0490ead9c">size_type</a> =  size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type used for indexing into this vector. </p>

</div>
</div>
<a id="a6b0922b4b9be4aec6cc920f888d01079" name="a6b0922b4b9be4aec6cc920f888d01079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0922b4b9be4aec6cc920f888d01079">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html#a6b0922b4b9be4aec6cc920f888d01079">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of element that is stored in this vector. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7664e9efbed8e2a0f84656dfadd66489" name="a7664e9efbed8e2a0f84656dfadd66489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7664e9efbed8e2a0f84656dfadd66489">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newVectorSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector. </p>
<p >All entries will be initialised using their default constructors. In particular, this means that for Regina's own integer classes (Integer, LargeInteger and <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>), all entries will be initialised to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>T</em> is a native C++ integer type (such as <code>int</code> or <code>long</code>), then the elements will not be initialised to any particular value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newVectorSize</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e83c9eecd552ab24f4558dcc958d84" name="a45e83c9eecd552ab24f4558dcc958d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e83c9eecd552ab24f4558dcc958d84">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newVectorSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector and initialises every element to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newVectorSize</td><td>the number of elements in the new vector. </td></tr>
    <tr><td class="paramname">initValue</td><td>the value to assign to every element of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a615bd51dabb597372d82bfecda61674e" name="a615bd51dabb597372d82bfecda61674e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615bd51dabb597372d82bfecda61674e">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename <a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector containing the given sequence of elements. </p>
<p >This constructor induces a deep copy of the given range.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Objects of type <em>T</em> can be assigned values from dereferenced iterators of type <em>iterator</em>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine computes the length of the given sequence by subtracting <code>end - begin</code>, and so ideally <em>iterator</em> should be a random access iterator type for which this operation is constant time.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of iterators, this routine takes a python list of coefficients.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>the beginning of the sequence of elements. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator indicating the end of the sequence of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80421f1def30a1aa50facc88faa28ae7" name="a80421f1def30a1aa50facc88faa28ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80421f1def30a1aa50facc88faa28ae7">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector containing the given hard-coded elements. </p>
<p >This constructor can be used (for example) to create hard-coded examples directly in C++ code.</p>
<dl class="section user"><dt>Python</dt><dd>Not available, but there is a Python constructor that takes a list of coefficients (which need not be constant).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the elements of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f73850067281be6eab224b6a632945e" name="a3f73850067281be6eab224b6a632945e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f73850067281be6eab224b6a632945e">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa7482a1cff348adc41aaa6b32b162fa" name="aaa7482a1cff348adc41aaa6b32b162fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7482a1cff348adc41aaa6b32b162fa">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::<a class="el" href="classregina_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given vector into this new vector. </p>
<p >This is a fast (constant time) operation.</p>
<p >The vector that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the vector to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa13b652bab0b97581799178e9b15b14b" name="aa13b652bab0b97581799178e9b15b14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13b652bab0b97581799178e9b15b14b">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::~<a class="el" href="classregina_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this vector. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae417bfb64da0cfee726b362d273fa8f5" name="ae417bfb64da0cfee726b362d273fa8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae417bfb64da0cfee726b362d273fa8f5">&#9670;&nbsp;</a></span>addCopies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::addCopies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>multiple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given multiple of the given vector to this vector. </p>
<p >This behaves correctly in the case where <em>other</em> is <code>this</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector a multiple of which will be added to this vector. </td></tr>
    <tr><td class="paramname">multiple</td><td>the multiple of <em>other</em> to be added to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d98d76a35eccde9ec6078b414b8023e" name="a1d98d76a35eccde9ec6078b414b8023e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d98d76a35eccde9ec6078b414b8023e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the beginning of a non-const iterator range that runs through all elements of this vector. </p>
<p >This is safe to use even if this vector has zero length (in which case <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a> will be equal).</p>
<dl class="section user"><dt>Python</dt><dd><a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> is an iterable object: instead of providing <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a>, it implements the Python iterable interface.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first element of this vector. </dd></dl>

</div>
</div>
<a id="ab45f94dfa6d86be38efc75e9f2f3ea8d" name="ab45f94dfa6d86be38efc75e9f2f3ea8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45f94dfa6d86be38efc75e9f2f3ea8d">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html#a845301f807000ca943531c7042e23d55">const_iterator</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the beginning of a const iterator range that runs through all elements of this vector. </p>
<p >This is safe to use even if this vector has zero length (in which case <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a> will be equal).</p>
<dl class="section user"><dt>Python</dt><dd><a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> is an iterable object: instead of providing <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a>, it implements the Python iterable interface.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first element of this vector. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a93d552a18d439141b82395351947dd16" name="a93d552a18d439141b82395351947dd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d552a18d439141b82395351947dd16">&#9670;&nbsp;</a></span>elementSum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::elementSum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of all elements of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the sum of the elements of this vector. </dd></dl>

</div>
</div>
<a id="a7d70b1d290fdb72041677a0ae8fb73d9" name="a7d70b1d290fdb72041677a0ae8fb73d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d70b1d290fdb72041677a0ae8fb73d9">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html#a7543d01b4eaed8a4fa2ea83fa364c222">iterator</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the end of a non-const iterator range that runs through all elements of this vector. </p>
<p >This is safe to use even if this vector has zero length (in which case <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a> will be equal).</p>
<dl class="section user"><dt>Python</dt><dd><a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> is an iterable object: instead of providing <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a>, it implements the Python iterable interface.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the last element of this vector. </dd></dl>

</div>
</div>
<a id="a2e13342028549428ddd63a0b4968e4eb" name="a2e13342028549428ddd63a0b4968e4eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e13342028549428ddd63a0b4968e4eb">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html#a845301f807000ca943531c7042e23d55">const_iterator</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the end of a const iterator range that runs through all elements of this vector. </p>
<p >This is safe to use even if this vector has zero length (in which case <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a> will be equal).</p>
<dl class="section user"><dt>Python</dt><dd><a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> is an iterable object: instead of providing <a class="el" href="classregina_1_1Vector.html#a1d98d76a35eccde9ec6078b414b8023e" title="Returns the beginning of a non-const iterator range that runs through all elements of this vector.">begin()</a> and <a class="el" href="classregina_1_1Vector.html#a7d70b1d290fdb72041677a0ae8fb73d9" title="Returns the end of a non-const iterator range that runs through all elements of this vector.">end()</a>, it implements the Python iterable interface.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the last element of this vector. </dd></dl>

</div>
</div>
<a id="a7824097a059dc1aea9e91a139752875c" name="a7824097a059dc1aea9e91a139752875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7824097a059dc1aea9e91a139752875c">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::isZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the zero vector. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all elements of the vector are zero. </dd></dl>

</div>
</div>
<a id="aba80d7d2d8c8cf98aa8cdd703b805a4d" name="aba80d7d2d8c8cf98aa8cdd703b805a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba80d7d2d8c8cf98aa8cdd703b805a4d">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates every element of this vector. </p>

</div>
</div>
<a id="a17559ecc897b92d0d1f715db4f11d8ff" name="a17559ecc897b92d0d1f715db4f11d8ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17559ecc897b92d0d1f715db4f11d8ff">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the norm of this vector. </p>
<p >This is the dot product of the vector with itself.</p>
<dl class="section return"><dt>Returns</dt><dd>the norm of this vector. </dd></dl>

</div>
</div>
<a id="a3ec4afe0ca76cf5f3012d98a9d148013" name="a3ec4afe0ca76cf5f3012d98a9d148013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec4afe0ca76cf5f3012d98a9d148013">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vector is different from the given vector. </p>
<p >It is safe to call this operator if this and the given vector have different sizes (in which case the return value will be <code>true</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the vector with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the this and the given vector are not equal. </dd></dl>

</div>
</div>
<a id="adf90f48853bf81ab824b07181e400216" name="adf90f48853bf81ab824b07181e400216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf90f48853bf81ab824b07181e400216">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this vector by the given scalar, and returns the result. </p>
<p >This vector will not be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>the scalar to multiply this vector by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product <code>this * factor</code>. </dd></dl>

</div>
</div>
<a id="ae9e90b3eedae0b3b3451dae8d8d187b9" name="ae9e90b3eedae0b3b3451dae8d8d187b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e90b3eedae0b3b3451dae8d8d187b9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product of this vector and the given vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector with which this will be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of this and the given vector. </dd></dl>

</div>
</div>
<a id="aa68fbe269b6846cacffcf4dbce2038c4" name="aa68fbe269b6846cacffcf4dbce2038c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68fbe269b6846cacffcf4dbce2038c4">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp; <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this vector by the given scalar. </p>
<p >This vector will be changed directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>the scalar with which this will be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this vector. </dd></dl>

</div>
</div>
<a id="ac1509ee583a65c4c9078041f5c9f1567" name="ac1509ee583a65c4c9078041f5c9f1567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1509ee583a65c4c9078041f5c9f1567">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector, and returns the result. </p>
<p >This vector will not be changed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum <code>this + other</code>. </dd></dl>

</div>
</div>
<a id="a7ae6adc697d680892c5a410b3a276208" name="a7ae6adc697d680892c5a410b3a276208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae6adc697d680892c5a410b3a276208">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp; <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p >This vector will be changed directly. This behaves correctly in the case where <em>other</em> is <code>this</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this vector. </dd></dl>

</div>
</div>
<a id="a521c5661faa8b649eee7f8a27d3f6601" name="a521c5661faa8b649eee7f8a27d3f6601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521c5661faa8b649eee7f8a27d3f6601">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given vector from this vector, and returns the result. </p>
<p >This vector will not be changed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to subtract from this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference <code>this - other</code>. </dd></dl>

</div>
</div>
<a id="ad872bea3a35622bb5eb063e59d5c1ae0" name="ad872bea3a35622bb5eb063e59d5c1ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad872bea3a35622bb5eb063e59d5c1ae0">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp; <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given vector from this vector. </p>
<p >This vector will be changed directly. This behaves correctly in the case where <em>other</em> is <code>this</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to subtract from this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this vector. </dd></dl>

</div>
</div>
<a id="a82359f91e85e04f413c279a57acf3f6d" name="a82359f91e85e04f413c279a57acf3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82359f91e85e04f413c279a57acf3f6d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this vector equal to the given vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector whose value shall be assigned to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c4210cfbbcb4a02f1eba06421c13d64" name="a6c4210cfbbcb4a02f1eba06421c13d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4210cfbbcb4a02f1eba06421c13d64">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a> &amp; <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given vector into this vector. </p>
<p >This is a fast (constant time) operation.</p>
<p >It does not matter if this and the given vector have different sizes; if they do then this vector will be resized as a result.</p>
<p >The vector that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the vector to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this vector. </dd></dl>

</div>
</div>
<a id="a0a17460e605759c848cbb8c754044459" name="a0a17460e605759c848cbb8c754044459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a17460e605759c848cbb8c754044459">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vector is equal to the given vector. </p>
<p >It is safe to call this operator if this and the given vector have different sizes (in which case the return value will be <code>false</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the vector with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the this and the given vector are equal. </dd></dl>

</div>
</div>
<a id="ae50673a36adb663fff93930a7e174370" name="ae50673a36adb663fff93930a7e174370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50673a36adb663fff93930a7e174370">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives write access to the element at the given index in the vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> is between 0 and <a class="el" href="classregina_1_1Vector.html#a941b1a276184770321c99e11b9160dfb" title="Returns the number of elements in the vector.">size()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the vector index to access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vector element at the given index. </dd></dl>

</div>
</div>
<a id="a673dd172e08ee8b07114974f78b27fb1" name="a673dd172e08ee8b07114974f78b27fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673dd172e08ee8b07114974f78b27fb1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<p >A constant reference to the element is returned; the element may not be altered.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> is between 0 and <a class="el" href="classregina_1_1Vector.html#a941b1a276184770321c99e11b9160dfb" title="Returns the number of elements in the vector.">size()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the vector index to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector element at the given index. </dd></dl>

</div>
</div>
<a id="a2ad6db99cf59efda5b4886a5b8edbf84" name="a2ad6db99cf59efda5b4886a5b8edbf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad6db99cf59efda5b4886a5b8edbf84">&#9670;&nbsp;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p >The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p >In particular, if this vector is being used to represent a ray emanating from the origin, then this routine reduces the ray to its smallest possible integer representation.</p>
<p >This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p >This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>). </p>

</div>
</div>
<a id="a2da9446d04bf24cf7ed755679a6b6b95" name="a2da9446d04bf24cf7ed755679a6b6b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da9446d04bf24cf7ed755679a6b6b95">&#9670;&nbsp;</a></span>setElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that sets the element at the given index in the vector to the given value. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000119">Deprecated:</a></b></dt><dd>Simply use the square bracker operator instead.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> is between 0 and <a class="el" href="classregina_1_1Vector.html#a941b1a276184770321c99e11b9160dfb" title="Returns the number of elements in the vector.">size()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the vector index to examine. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a941b1a276184770321c99e11b9160dfb" name="a941b1a276184770321c99e11b9160dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941b1a276184770321c99e11b9160dfb">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector size. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ad33d4bda8da5234d23c3028e79068645" name="ad33d4bda8da5234d23c3028e79068645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33d4bda8da5234d23c3028e79068645">&#9670;&nbsp;</a></span>subtractCopies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::subtractCopies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>multiple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given multiple of the given vector to this vector. </p>
<p >This behaves correctly in the case where <em>other</em> is <code>this</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector a multiple of which will be subtracted from this vector. </td></tr>
    <tr><td class="paramname">multiple</td><td>the multiple of <em>other</em> to be subtracted from this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b9cc662372fa3a48e91fe15665ae7ed" name="a8b9cc662372fa3a48e91fe15665ae7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9cc662372fa3a48e91fe15665ae7ed">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af363d28aa928a0421d516a3468bcb032" name="af363d28aa928a0421d516a3468bcb032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af363d28aa928a0421d516a3468bcb032">&#9670;&nbsp;</a></span>unit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Vector.html">Vector</a> <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::unit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>coordinate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given unit vector. </p>
<p >The vector will have length <em>dimension</em>. The element in position <em>coordinate</em> will be set to 1, and all other elements will be set to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>the number of elements in the vector. </td></tr>
    <tr><td class="paramname">coordinate</td><td>the coordinate position that should hold the value 1; this must be between 0 and (<em>dimension</em> - 1) inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested unit vector. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; T &gt; , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2431b2f42b5b5fe5142bc3a46a5dc73" name="aa2431b2f42b5b5fe5142bc3a46a5dc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2431b2f42b5b5fe5142bc3a46a5dc73">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a03c07da13bc1281efc622f38f072c72a" name="a03c07da13bc1281efc622f38f072c72a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c07da13bc1281efc622f38f072c72a">&#9670;&nbsp;</a></span>elts_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::elts_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal array containing all vector elements. </p>

</div>
</div>
<a id="afba1623c1fc22b66165e4d24266ed8e3" name="afba1623c1fc22b66165e4d24266ed8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba1623c1fc22b66165e4d24266ed8e3">&#9670;&nbsp;</a></span>end_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::end_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer just beyond the end of the internal array. </p>
<p >The size of the vector can be computed as (end_ - elts_). </p>

</div>
</div>
<a id="a4eab6a65972f42069143504331747064" name="a4eab6a65972f42069143504331747064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eab6a65972f42069143504331747064">&#9670;&nbsp;</a></span>minusOne</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::minusOne</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negative one in the underlying number system. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000118">Deprecated:</a></b></dt><dd>This constant is deprecated; just use -1 instead. </dd></dl>

</div>
</div>
<a id="ab39611de5f0ca2f3ea00c1d85e90099d" name="ab39611de5f0ca2f3ea00c1d85e90099d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39611de5f0ca2f3ea00c1d85e90099d">&#9670;&nbsp;</a></span>one</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::one</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One in the underlying number system. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000117">Deprecated:</a></b></dt><dd>This constant is deprecated; just use 1 instead. </dd></dl>

</div>
</div>
<a id="a3d3848a6a7707b6913f55c3e6c996835" name="a3d3848a6a7707b6913f55c3e6c996835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3848a6a7707b6913f55c3e6c996835">&#9670;&nbsp;</a></span>zero</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classregina_1_1Vector.html">regina::Vector</a>&lt; T &gt;::zero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero in the underlying number system. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000116">Deprecated:</a></b></dt><dd>This constant is deprecated; just use 0 instead. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>maths/<a class="el" href="matrix_8h.html">matrix.h</a></li>
<li>maths/<a class="el" href="vector_8h.html">vector.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
