<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: regina::FacetPairing&lt; 3 &gt; Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html">FacetPairing&lt; 3 &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1FacetPairing_3_013_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::FacetPairing&lt; 3 &gt; Class Reference<div class="ingroups"><a class="el" href="group__triangulation.html">Triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents the dual graph of a 3-manifold triangulation.  
 <a href="classregina_1_1FacetPairing_3_013_01_4.html#details">More...</a></p>

<p><code>#include &lt;triangulation/facetpairing3.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::FacetPairing&lt; 3 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1FacetPairing_3_013_01_4.png" usemap="#regina::FacetPairing_3C_203_20_3E_map" alt=""/>
  <map id="regina::FacetPairing_3C_203_20_3E_map" name="regina::FacetPairing_3C_203_20_3E_map">
<area href="classregina_1_1detail_1_1FacetPairingBase.html" alt="regina::detail::FacetPairingBase&lt; 3 &gt;" shape="rect" coords="0,112,294,136"/>
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; FacetPairingBase&lt; dim &gt; &gt;" shape="rect" coords="0,56,294,80"/>
<area href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output." alt="regina::Output&lt; T, supportsUtf8 &gt;" shape="rect" coords="0,0,294,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaebffa10000fb54769c4e792f7b6bba6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6">IsoList</a> = std::list&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;</td></tr>
<tr class="memdesc:aaebffa10000fb54769c4e792f7b6bba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of isomorphisms on facet pairings.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6">More...</a><br /></td></tr>
<tr class="separator:aaebffa10000fb54769c4e792f7b6bba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95ae3b9d08e12a3d0bea6674068d01e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a95ae3b9d08e12a3d0bea6674068d01e5">FacetPairing</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;src)=default</td></tr>
<tr class="memdesc:a95ae3b9d08e12a3d0bea6674068d01e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given face pairing.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a95ae3b9d08e12a3d0bea6674068d01e5">More...</a><br /></td></tr>
<tr class="separator:a95ae3b9d08e12a3d0bea6674068d01e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb04c012f3ca3775182140b3310d9624"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#adb04c012f3ca3775182140b3310d9624">FacetPairing</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:adb04c012f3ca3775182140b3310d9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given face pairing into this face pairing.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#adb04c012f3ca3775182140b3310d9624">More...</a><br /></td></tr>
<tr class="separator:adb04c012f3ca3775182140b3310d9624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb73123d32e9414cca6d7770cd2cf55f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#abb73123d32e9414cca6d7770cd2cf55f">FacetPairing</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="memdesc:abb73123d32e9414cca6d7770cd2cf55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the face pairing of the given 3-manifold triangulation.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#abb73123d32e9414cca6d7770cd2cf55f">More...</a><br /></td></tr>
<tr class="separator:abb73123d32e9414cca6d7770cd2cf55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f62e5171363fa7bbf4e25510e750de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#ad1f62e5171363fa7bbf4e25510e750de">FacetPairing</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:ad1f62e5171363fa7bbf4e25510e750de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a new facet pairing from the given input stream.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#ad1f62e5171363fa7bbf4e25510e750de">More...</a><br /></td></tr>
<tr class="separator:ad1f62e5171363fa7bbf4e25510e750de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c86cc1b09bce6acf2dd04d925a1a79c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a5c86cc1b09bce6acf2dd04d925a1a79c">operator=</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;src)=default</td></tr>
<tr class="memdesc:a5c86cc1b09bce6acf2dd04d925a1a79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given face pairing into this face pairing.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a5c86cc1b09bce6acf2dd04d925a1a79c">More...</a><br /></td></tr>
<tr class="separator:a5c86cc1b09bce6acf2dd04d925a1a79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca5c4bf5ee1afffddbfda1441529ea0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#afca5c4bf5ee1afffddbfda1441529ea0">operator=</a> (<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:afca5c4bf5ee1afffddbfda1441529ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given face pairing into this facet pairing.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#afca5c4bf5ee1afffddbfda1441529ea0">More...</a><br /></td></tr>
<tr class="separator:afca5c4bf5ee1afffddbfda1441529ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361ee550f483502a40ceed28f8ba93e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a361ee550f483502a40ceed28f8ba93e0">followChain</a> (size_t &amp;tet, <a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;faces) const</td></tr>
<tr class="memdesc:a361ee550f483502a40ceed28f8ba93e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Follows a chain as far as possible from the given point.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a361ee550f483502a40ceed28f8ba93e0">More...</a><br /></td></tr>
<tr class="separator:a361ee550f483502a40ceed28f8ba93e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde7a8ad187d9bc3492105abf93f78e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#acde7a8ad187d9bc3492105abf93f78e7">hasTripleEdge</a> () const</td></tr>
<tr class="memdesc:acde7a8ad187d9bc3492105abf93f78e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a triple edge.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#acde7a8ad187d9bc3492105abf93f78e7">More...</a><br /></td></tr>
<tr class="separator:acde7a8ad187d9bc3492105abf93f78e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bda748de730da86e2c1032b9d7c5b14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a1bda748de730da86e2c1032b9d7c5b14">hasBrokenDoubleEndedChain</a> () const</td></tr>
<tr class="memdesc:a1bda748de730da86e2c1032b9d7c5b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a broken double-ended chain.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a1bda748de730da86e2c1032b9d7c5b14">More...</a><br /></td></tr>
<tr class="separator:a1bda748de730da86e2c1032b9d7c5b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b219eac1d9a0a0495488dd5ca99e038"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a3b219eac1d9a0a0495488dd5ca99e038">hasOneEndedChainWithDoubleHandle</a> () const</td></tr>
<tr class="memdesc:a3b219eac1d9a0a0495488dd5ca99e038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a one-ended chain with a double handle.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a3b219eac1d9a0a0495488dd5ca99e038">More...</a><br /></td></tr>
<tr class="separator:a3b219eac1d9a0a0495488dd5ca99e038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827125a7939e2bf95a4cf57f02e7142c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a827125a7939e2bf95a4cf57f02e7142c">hasWedgedDoubleEndedChain</a> () const</td></tr>
<tr class="memdesc:a827125a7939e2bf95a4cf57f02e7142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a wedged double-ended chain.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a827125a7939e2bf95a4cf57f02e7142c">More...</a><br /></td></tr>
<tr class="separator:a827125a7939e2bf95a4cf57f02e7142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372e9f00039b11782a3af1638d2122fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a372e9f00039b11782a3af1638d2122fd">hasOneEndedChainWithStrayBigon</a> () const</td></tr>
<tr class="memdesc:a372e9f00039b11782a3af1638d2122fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a one-ended chain with a stray bigon.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a372e9f00039b11782a3af1638d2122fd">More...</a><br /></td></tr>
<tr class="separator:a372e9f00039b11782a3af1638d2122fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd526b75d1a1531af9a3932d4beec9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a1bd526b75d1a1531af9a3932d4beec9b">hasTripleOneEndedChain</a> () const</td></tr>
<tr class="memdesc:a1bd526b75d1a1531af9a3932d4beec9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a triple one-ended chain.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a1bd526b75d1a1531af9a3932d4beec9b">More...</a><br /></td></tr>
<tr class="separator:a1bd526b75d1a1531af9a3932d4beec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2711bf8d99861f34dd759a833e4f1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#ace2711bf8d99861f34dd759a833e4f1a">hasSingleStar</a> () const</td></tr>
<tr class="memdesc:ace2711bf8d99861f34dd759a833e4f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a single-edged star.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#ace2711bf8d99861f34dd759a833e4f1a">More...</a><br /></td></tr>
<tr class="separator:ace2711bf8d99861f34dd759a833e4f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0b3a332ec4f0f7c5646e535894a0a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#aca0b3a332ec4f0f7c5646e535894a0a5">hasDoubleStar</a> () const</td></tr>
<tr class="memdesc:aca0b3a332ec4f0f7c5646e535894a0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a double-edged star.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#aca0b3a332ec4f0f7c5646e535894a0a5">More...</a><br /></td></tr>
<tr class="separator:aca0b3a332ec4f0f7c5646e535894a0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b06b27853306a94eaf57b6ff72cdd04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a5b06b27853306a94eaf57b6ff72cdd04">hasDoubleSquare</a> () const</td></tr>
<tr class="memdesc:a5b06b27853306a94eaf57b6ff72cdd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this face pairing contains a double-edged square.  <a href="classregina_1_1FacetPairing_3_013_01_4.html#a5b06b27853306a94eaf57b6ff72cdd04">More...</a><br /></td></tr>
<tr class="separator:a5b06b27853306a94eaf57b6ff72cdd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors, Destructors and Assignment</div></td></tr>
<tr class="memitem:a88f2b377e3340f2f16e2baac92e5f904"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a88f2b377e3340f2f16e2baac92e5f904">swap</a> (<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a88f2b377e3340f2f16e2baac92e5f904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given facet pairing.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a88f2b377e3340f2f16e2baac92e5f904">More...</a><br /></td></tr>
<tr class="separator:a88f2b377e3340f2f16e2baac92e5f904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Queries</div></td></tr>
<tr class="memitem:a05fd123494c0f9d15ffed9f226728b83"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a05fd123494c0f9d15ffed9f226728b83">size</a> () const</td></tr>
<tr class="memdesc:a05fd123494c0f9d15ffed9f226728b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simplices whose facets are described by this facet pairing.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a05fd123494c0f9d15ffed9f226728b83">More...</a><br /></td></tr>
<tr class="separator:a05fd123494c0f9d15ffed9f226728b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a751dcff6edea48d5407a9de3247927"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a4a751dcff6edea48d5407a9de3247927">dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a4a751dcff6edea48d5407a9de3247927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a4a751dcff6edea48d5407a9de3247927">More...</a><br /></td></tr>
<tr class="separator:a4a751dcff6edea48d5407a9de3247927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b80d0f2604bc161b99f4faa5ac6e7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a08b80d0f2604bc161b99f4faa5ac6e7b">dest</a> (size_t simp, unsigned facet) const</td></tr>
<tr class="memdesc:a08b80d0f2604bc161b99f4faa5ac6e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a08b80d0f2604bc161b99f4faa5ac6e7b">More...</a><br /></td></tr>
<tr class="separator:a08b80d0f2604bc161b99f4faa5ac6e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012c646f9f7388f3f4379f2f3281ed69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a012c646f9f7388f3f4379f2f3281ed69">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a012c646f9f7388f3f4379f2f3281ed69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a012c646f9f7388f3f4379f2f3281ed69">More...</a><br /></td></tr>
<tr class="separator:a012c646f9f7388f3f4379f2f3281ed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c56d584b417d3fb51507fb92809721"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a86c56d584b417d3fb51507fb92809721">isUnmatched</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a86c56d584b417d3fb51507fb92809721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a86c56d584b417d3fb51507fb92809721">More...</a><br /></td></tr>
<tr class="separator:a86c56d584b417d3fb51507fb92809721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7d81f46e1382e0ab6937f410f6b230"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aed7d81f46e1382e0ab6937f410f6b230">isUnmatched</a> (size_t simp, unsigned facet) const</td></tr>
<tr class="memdesc:aed7d81f46e1382e0ab6937f410f6b230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#aed7d81f46e1382e0ab6937f410f6b230">More...</a><br /></td></tr>
<tr class="separator:aed7d81f46e1382e0ab6937f410f6b230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b81d609b3827899604f1e8a829c884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a55b81d609b3827899604f1e8a829c884">isClosed</a> () const</td></tr>
<tr class="memdesc:a55b81d609b3827899604f1e8a829c884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is closed.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a55b81d609b3827899604f1e8a829c884">More...</a><br /></td></tr>
<tr class="separator:a55b81d609b3827899604f1e8a829c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac439676d3f11103163552326f4f5c64d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ac439676d3f11103163552326f4f5c64d">operator==</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ac439676d3f11103163552326f4f5c64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given facet pairing are identical.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#ac439676d3f11103163552326f4f5c64d">More...</a><br /></td></tr>
<tr class="separator:ac439676d3f11103163552326f4f5c64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e898ff16c0b26e346a1a8f83a8b425"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a71e898ff16c0b26e346a1a8f83a8b425">operator!=</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a71e898ff16c0b26e346a1a8f83a8b425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given facet pairing are not identical.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a71e898ff16c0b26e346a1a8f83a8b425">More...</a><br /></td></tr>
<tr class="separator:a71e898ff16c0b26e346a1a8f83a8b425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Isomorphic Representations</div></td></tr>
<tr class="memitem:ad720be5515121b69f7ce62e5bbda9b5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b">isCanonical</a> () const</td></tr>
<tr class="memdesc:ad720be5515121b69f7ce62e5bbda9b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal representative of its isomorphism class.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b">More...</a><br /></td></tr>
<tr class="separator:ad720be5515121b69f7ce62e5bbda9b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4a0cf9cc419b3cb7cf1dc9d3370340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6">IsoList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a2b4a0cf9cc419b3cb7cf1dc9d3370340">findAutomorphisms</a> () const</td></tr>
<tr class="memdesc:a2b4a0cf9cc419b3cb7cf1dc9d3370340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of all combinatorial automorphisms of this facet pairing.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a2b4a0cf9cc419b3cb7cf1dc9d3370340">More...</a><br /></td></tr>
<tr class="separator:a2b4a0cf9cc419b3cb7cf1dc9d3370340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a663cb963d4d177f69ec39c7f7409d278"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a663cb963d4d177f69ec39c7f7409d278">size_</a></td></tr>
<tr class="memdesc:a663cb963d4d177f69ec39c7f7409d278"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simplices under consideration.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a663cb963d4d177f69ec39c7f7409d278">More...</a><br /></td></tr>
<tr class="separator:a663cb963d4d177f69ec39c7f7409d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aee05ce55cfad3b49aae171e5baa4a5e0">pairs_</a></td></tr>
<tr class="memdesc:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The other facet to which each simplex facet is paired.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#aee05ce55cfad3b49aae171e5baa4a5e0">More...</a><br /></td></tr>
<tr class="separator:aee05ce55cfad3b49aae171e5baa4a5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5a693e6ee9e5197cc258efca9bd1a9b7"><td class="memItemLeft" align="right" valign="top"><a id="a5a693e6ee9e5197cc258efca9bd1a9b7" name="a5a693e6ee9e5197cc258efca9bd1a9b7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::FacetPairingBase&lt; 3 &gt;</b></td></tr>
<tr class="separator:a5a693e6ee9e5197cc258efca9bd1a9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Input and Output</h2></td></tr>
<tr class="memitem:a2e3a9b5851e0f984a28cc88fa64717c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a2e3a9b5851e0f984a28cc88fa64717c1">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2e3a9b5851e0f984a28cc88fa64717c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human-readable representation of this facet pairing to the given output stream.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a2e3a9b5851e0f984a28cc88fa64717c1">More...</a><br /></td></tr>
<tr class="separator:a2e3a9b5851e0f984a28cc88fa64717c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afb56a1370b063c12c4efe634eb771b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6afb56a1370b063c12c4efe634eb771b">toTextRep</a> () const</td></tr>
<tr class="memdesc:a6afb56a1370b063c12c4efe634eb771b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a text-based representation of this facet pairing that can be used to reconstruct the facet pairing.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a6afb56a1370b063c12c4efe634eb771b">More...</a><br /></td></tr>
<tr class="separator:a6afb56a1370b063c12c4efe634eb771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862b3698780487e07b4f692639951694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694">writeDot</a> (std::ostream &amp;out, const char *prefix=nullptr, bool subgraph=false, bool labels=false) const</td></tr>
<tr class="memdesc:a862b3698780487e07b4f692639951694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the graph corresponding to this facet pairing in the Graphviz DOT language.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694">More...</a><br /></td></tr>
<tr class="separator:a862b3698780487e07b4f692639951694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8c5f6f14ae74fb740738509145643"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643">dot</a> (const char *prefix=nullptr, bool subgraph=false, bool labels=false) const</td></tr>
<tr class="memdesc:acfc8c5f6f14ae74fb740738509145643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Graphviz DOT representation of the graph that describes this facet pairing.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643">More...</a><br /></td></tr>
<tr class="separator:acfc8c5f6f14ae74fb740738509145643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beef317a48670f0a4b015b6a9677c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62">dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a6beef317a48670f0a4b015b6a9677c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62">More...</a><br /></td></tr>
<tr class="separator:a6beef317a48670f0a4b015b6a9677c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0426cec394e5b98ec2134c12dcaed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aec0426cec394e5b98ec2134c12dcaed9">dest</a> (size_t simp, unsigned facet)</td></tr>
<tr class="memdesc:aec0426cec394e5b98ec2134c12dcaed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#aec0426cec394e5b98ec2134c12dcaed9">More...</a><br /></td></tr>
<tr class="separator:aec0426cec394e5b98ec2134c12dcaed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74fc68b1801eae6f8a62220accb4c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab74fc68b1801eae6f8a62220accb4c72">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:ab74fc68b1801eae6f8a62220accb4c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the other facet to which the given simplex facet is paired.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#ab74fc68b1801eae6f8a62220accb4c72">More...</a><br /></td></tr>
<tr class="separator:ab74fc68b1801eae6f8a62220accb4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c57ad6815d5771c941ec03eeb326d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad11c57ad6815d5771c941ec03eeb326d">noDest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:ad11c57ad6815d5771c941ec03eeb326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#ad11c57ad6815d5771c941ec03eeb326d">More...</a><br /></td></tr>
<tr class="separator:ad11c57ad6815d5771c941ec03eeb326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bccd3160594ba66ba13edd3735e664b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a8bccd3160594ba66ba13edd3735e664b">noDest</a> (size_t simp, unsigned facet) const</td></tr>
<tr class="memdesc:a8bccd3160594ba66ba13edd3735e664b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a8bccd3160594ba66ba13edd3735e664b">More...</a><br /></td></tr>
<tr class="separator:a8bccd3160594ba66ba13edd3735e664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b11f9aa0e0746204354dfa13e418156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6b11f9aa0e0746204354dfa13e418156">isCanonicalInternal</a> (<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6">IsoList</a> &amp;list) const</td></tr>
<tr class="memdesc:a6b11f9aa0e0746204354dfa13e418156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a6b11f9aa0e0746204354dfa13e418156">More...</a><br /></td></tr>
<tr class="separator:a6b11f9aa0e0746204354dfa13e418156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482dbc8bae43545ca54baa9732b327bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc">fromTextRep</a> (const std::string &amp;rep)</td></tr>
<tr class="memdesc:a482dbc8bae43545ca54baa9732b327bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a facet pairing from a text-based representation.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc">More...</a><br /></td></tr>
<tr class="separator:a482dbc8bae43545ca54baa9732b327bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508aa380bbd5e52e23166a07d4087256"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256">writeDotHeader</a> (std::ostream &amp;out, const char *graphName=nullptr)</td></tr>
<tr class="memdesc:a508aa380bbd5e52e23166a07d4087256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256">More...</a><br /></td></tr>
<tr class="separator:a508aa380bbd5e52e23166a07d4087256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8dd170b533d87914f798b0e4664d02"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02">dotHeader</a> (const char *graphName=nullptr)</td></tr>
<tr class="memdesc:a1f8dd170b533d87914f798b0e4664d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02">More...</a><br /></td></tr>
<tr class="separator:a1f8dd170b533d87914f798b0e4664d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57242b47e393f1bb9a36221d6c5f5f43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43">findAllPairings</a> (size_t nSimplices, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> boundary, int nBdryFacets, Action &amp;&amp;action, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a57242b47e393f1bb9a36221d6c5f5f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible facet pairings satisfying the given constraints.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#a57242b47e393f1bb9a36221d6c5f5f43">More...</a><br /></td></tr>
<tr class="separator:a57242b47e393f1bb9a36221d6c5f5f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents the dual graph of a 3-manifold triangulation. </p>
<p >This is a specialisation of the generic <a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a> class template; see the <a class="el" href="classregina_1_1FacetPairing.html" title="Represents the dual graph of a dim-manifold triangulation; that is, the pairwise matching of facets o...">FacetPairing</a> documentation for an overview of how this class works.</p>
<p >This 3-dimensional specialisation contains some extra functionality. In particular, it provides routines for finding informative subgraphs within the dual graph.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aaebffa10000fb54769c4e792f7b6bba6" name="aaebffa10000fb54769c4e792f7b6bba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaebffa10000fb54769c4e792f7b6bba6">&#9670;&nbsp;</a></span>IsoList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6">IsoList</a> =  std::list&lt;<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt;dim&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of isomorphisms on facet pairings. </p>
<p >Such an isomorphism can be used to convert one facet pairing into another.</p>
<p >This type is used to store all <em>automorphisms</em> of a facet pairing; that is, all isomorphisms that map the facet pairing to itself. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a95ae3b9d08e12a3d0bea6674068d01e5" name="a95ae3b9d08e12a3d0bea6674068d01e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ae3b9d08e12a3d0bea6674068d01e5">&#9670;&nbsp;</a></span>FacetPairing() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given face pairing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the face pairing to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb04c012f3ca3775182140b3310d9624" name="adb04c012f3ca3775182140b3310d9624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb04c012f3ca3775182140b3310d9624">&#9670;&nbsp;</a></span>FacetPairing() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given face pairing into this face pairing. </p>
<p >This is a fast (constant time) operation.</p>
<p >The face pairing that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the face pairing to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb73123d32e9414cca6d7770cd2cf55f" name="abb73123d32e9414cca6d7770cd2cf55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb73123d32e9414cca6d7770cd2cf55f">&#9670;&nbsp;</a></span>FacetPairing() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the face pairing of the given 3-manifold triangulation. </p>
<p >This describes how the tetrahedron faces of the given triangulation are joined together in pairs.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is not empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation whose face pairing should be constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1f62e5171363fa7bbf4e25510e750de" name="ad1f62e5171363fa7bbf4e25510e750de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f62e5171363fa7bbf4e25510e750de">&#9670;&nbsp;</a></span>FacetPairing() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a new facet pairing from the given input stream. </p>
<p >This routine reads data in the format written by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6afb56a1370b063c12c4efe634eb771b" title="Returns a text-based representation of this facet pairing that can be used to reconstruct the facet p...">toTextRep()</a>.</p>
<p >This routine will skip any initial whitespace in the given input stream. Once it finds its first non-whitespace character, it will read the <em>entire</em> line from the input stream and expect that line to containin the text representation of a facet pairing.</p>
<p >If the data found in the input stream is invalid, incomplete or incorrectly formatted, this constructor will throw an <a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a> exception.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can use <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a>, which reads this same text format in string form. The main differences between this constructor and <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a> are: (i) <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a> does not skip over initial whitespace; and (ii) <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a> throws <a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a> exceptions on error (not <a class="el" href="classregina_1_1InvalidInput.html" title="An exception thrown when a function reads unexpected or incomplete data from an input stream.">InvalidInput</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6beef317a48670f0a4b015b6a9677c62" name="a6beef317a48670f0a4b015b6a9677c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6beef317a48670f0a4b015b6a9677c62">&#9670;&nbsp;</a></span>dest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p >If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a4a751dcff6edea48d5407a9de3247927" name="a4a751dcff6edea48d5407a9de3247927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a751dcff6edea48d5407a9de3247927">&#9670;&nbsp;</a></span>dest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p >If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine returns by value, not by reference, since Python cannot enforce constness otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="aec0426cec394e5b98ec2134c12dcaed9" name="aec0426cec394e5b98ec2134c12dcaed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0426cec394e5b98ec2134c12dcaed9">&#9670;&nbsp;</a></span>dest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p >If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a08b80d0f2604bc161b99f4faa5ac6e7b" name="a08b80d0f2604bc161b99f4faa5ac6e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b80d0f2604bc161b99f4faa5ac6e7b">&#9670;&nbsp;</a></span>dest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p >If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns by value, not by reference, since Python cannot enforce constness otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="acfc8c5f6f14ae74fb740738509145643" name="acfc8c5f6f14ae74fb740738509145643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc8c5f6f14ae74fb740738509145643">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subgraph</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a Graphviz DOT representation of the graph that describes this facet pairing. </p>
<p >This routine simply returns the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> as a string, instead of dumping it to an output stream.</p>
<p >All arguments are the same as for <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a>; see the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="a1f8dd170b533d87914f798b0e4664d02" name="a1f8dd170b533d87914f798b0e4664d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8dd170b533d87914f798b0e4664d02">&#9670;&nbsp;</a></span>dotHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dotHeader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>graphName</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p >This routine simply returns the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a> as a string, instead of dumping it to an output stream.</p>
<p >All arguments are the same as for <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>; see the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="a57242b47e393f1bb9a36221d6c5f5f43" name="a57242b47e393f1bb9a36221d6c5f5f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57242b47e393f1bb9a36221d6c5f5f43">&#9670;&nbsp;</a></span>findAllPairings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAllPairings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBdryFacets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible facet pairings satisfying the given constraints. </p>
<p >Only connected facet pairings (pairings in which each simplex can be reached from each other via a series of individual matched facets) will be produced.</p>
<p >Each facet pairing will be produced precisely once up to isomorphism. Facet pairings are considered isomorphic if they are related by a relabelling of the simplices and/or a renumbering of the (<em>dim</em> + 1) facets of each simplex. Each facet pairing that is generated will be a lexicographically minimal representative of its isomorphism class, i.e., will be in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">isCanonical()</a>.</p>
<p >For each facet pairing that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument to <em>action</em> must be a const reference to a FacetPairing&lt;dim&gt;. This will be the facet pairing that was found. If <em>action</em> wishes to keep the facet pairing, it should take a deep copy (not a reference), since the facet pairing may be changed and reused after <em>action</em> returns.</li>
<li>The second argument to <em>action</em> must be a <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6" title="A list of isomorphisms on facet pairings.">FacetPairing&lt;dim&gt;::IsoList</a> (this will be passed by value using move semantics). This will be the list of all automorphisms of the facet pairing that was found.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<p >Because this class cannot represent an empty facet pairing, if the argument <em>nSimplices</em> is zero then no facet pairings will be generated at all.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd><p class="startdd"><em>Optimise (long-term):</em> When generating facet pairings, do some checking to eliminate cases in which simplex (<em>k</em> &gt; 0) can be swapped with simplex 0 to produce a smaller representation of the same pairing. </p>
<p class="enddd"><em>Feature:</em> Allow cancellation of facet pairing generation.</p>
</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available, and <em>action</em> may be a pure Python function. However, <em>action</em> cannot take any additional arguments beyond the facet pairing and its automorphisms (and therefore the additional <em>args</em> list is omitted here).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices whose facets should be (potentially) matched. </td></tr>
    <tr><td class="paramname">boundary</td><td>determines whether any facets may be left unmatched. This set should contain <code>true</code> if pairings with at least one unmatched facet are to be generated, and should contain <code>false</code> if pairings with no unmatched facets are to be generated. </td></tr>
    <tr><td class="paramname">nBdryFacets</td><td>specifies the precise number of facets that should be left unmatched. If this parameter is negative, it is ignored and no additional restriction is imposed. If parameter <em>boundary</em> does not contain <code>true</code>, this parameter is likewise ignored. If parameter <em>boundary</em> does contain true and this parameter is non-negative, only pairings with precisely this many unmatched facets will be generated. In particular, if this parameter is positive then pairings with no unmatched facets will not be produced irrespective of whether <code>false</code> is contained in parameter <em>boundary</em>. Note that, in order to produce any pairings at all, this parameter must be of the same parity as <code>nSimplices * (dim+1)</code>, and can be at most <code>(dim-1) * nSimplices + 2</code>. </td></tr>
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each facet pairing that is found. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial facet pairing and automorphism arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b4a0cf9cc419b3cb7cf1dc9d3370340" name="a2b4a0cf9cc419b3cb7cf1dc9d3370340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4a0cf9cc419b3cb7cf1dc9d3370340">&#9670;&nbsp;</a></span>findAutomorphisms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6">IsoList</a> <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAutomorphisms</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of all combinatorial automorphisms of this facet pairing. </p>
<p >An automorphism is a relabelling of the simplices and/or a renumbering of the (<em>dim</em> + 1) facets of each simplex resulting in precisely the same facet pairing.</p>
<p >This routine uses optimisations that can cause unpredictable breakages if this facet pairing is not in canonical form.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs. </dd>
<dd>
This facet pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">isCanonical()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all automorphisms. </dd></dl>

</div>
</div>
<a id="a361ee550f483502a40ceed28f8ba93e0" name="a361ee550f483502a40ceed28f8ba93e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361ee550f483502a40ceed28f8ba93e0">&#9670;&nbsp;</a></span>followChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::followChain </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacePair.html">FacePair</a> &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Follows a chain as far as possible from the given point. </p>
<p >A chain is the underlying face pairing for a layered chain; specifically it involves one tetrahedron joined to a second along two faces, the remaining two faces of the second tetrahedron joined to a third and so on. A chain can involve as few as one tetrahedron or as many as we like. Note that the remaining two faces of the first tetrahedron and the remaining two faces of the final tetrahedron remain unaccounted for by this structure.</p>
<p >This routine begins with two faces of a given tetrahedron, described by parameters <em>tet</em> and <em>faces</em>. If these two faces are both joined to some different tetrahedron, parameter <em>tet</em> will be changed to this new tetrahedron and parameter <em>faces</em> will be changed to the remaining faces of this new tetrahedron (i.e., the two faces that were not joined to the original faces of the original tetrahedron).</p>
<p >This procedure is repeated as far as possible until either the two faces in question join to two different tetrahedra, the two faces join to each other, or at least one of the two faces is unmatched.</p>
<p >Thus, given one end of a chain, this procedure can be used to follow the face pairings through to the other end of the chain.</p>
<dl class="section warning"><dt>Warning</dt><dd>You must be sure when calling this routine that you are not inside a chain that loops back onto itself! If the face pairing forms a large loop with each tetrahedron joined by two faces to the next, this routine will cycle around the loop forever and never return.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the index in the underlying triangulation of the tetrahedron to begin at. This parameter will be modified directly by this routine as a way of returning the results. </td></tr>
    <tr><td class="paramname">faces</td><td>the pair of face numbers in the given tetrahedron at which we begin. This parameter will also be modified directly by this routine as a way of returning results. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a482dbc8bae43545ca54baa9732b327bc" name="a482dbc8bae43545ca54baa9732b327bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482dbc8bae43545ca54baa9732b327bc">&#9670;&nbsp;</a></span>fromTextRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::fromTextRep </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a facet pairing from a text-based representation. </p>
<p >This text-based representation must be in the format produced by routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6afb56a1370b063c12c4efe634eb771b" title="Returns a text-based representation of this facet pairing that can be used to reconstruct the facet p...">toTextRep()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>the given string was not a valid text-based representation of a facet pairing on a positive number of simplices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>a text-based representation of a facet pairing, as produced by routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6afb56a1370b063c12c4efe634eb771b" title="Returns a text-based representation of this facet pairing that can be used to reconstruct the facet p...">toTextRep()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding facet pairing. </dd></dl>

</div>
</div>
<a id="a1bda748de730da86e2c1032b9d7c5b14" name="a1bda748de730da86e2c1032b9d7c5b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bda748de730da86e2c1032b9d7c5b14">&#9670;&nbsp;</a></span>hasBrokenDoubleEndedChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasBrokenDoubleEndedChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a broken double-ended chain. </p>
<p >A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p >A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus). A double-ended chain is a chain in which the first tetrahedron is joined to itself along one face and the final tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered lens space).</p>
<p >A broken double-ended chain consists of two one-ended chains (using distinct sets of tetrahedra) joined together along one face. The remaining two faces (one from each chain) that were unaccounted for by the individual one-ended chains remain unaccounted for by this broken double-ended chain.</p>
<p >In this routine we are interested specifically in finding a broken double-ended chain that is not a part of a complete double-ended chain, i.e., the final two unaccounted faces are not joined together.</p>
<p >A face pairing containing a broken double-ended chain cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Face pairing
graphs and 3-manifold enumeration", Benjamin A. Burton, J. Knot Theory Ramifications 13 (2004), 1057&ndash;1101.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a broken double-ended chain that is not part of a complete double-ended chain. </dd></dl>

</div>
</div>
<a id="a5b06b27853306a94eaf57b6ff72cdd04" name="a5b06b27853306a94eaf57b6ff72cdd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b06b27853306a94eaf57b6ff72cdd04">&#9670;&nbsp;</a></span>hasDoubleSquare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasDoubleSquare </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a double-edged square. </p>
<p >A double-edged square involves four distinct tetrahedra that meet each other as follows. Two pairs of tetrahedra are joined along two pairs of faces each. Then each tetrahedron is joined along a single face to one tetrahedron of the other pair. The four tetrahedron faces not yet joined to anything (one from each tetrahedron) remain unaccounted for by this structure.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a double-edged square. </dd></dl>

</div>
</div>
<a id="aca0b3a332ec4f0f7c5646e535894a0a5" name="aca0b3a332ec4f0f7c5646e535894a0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0b3a332ec4f0f7c5646e535894a0a5">&#9670;&nbsp;</a></span>hasDoubleStar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasDoubleStar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a double-edged star. </p>
<p >A double-edged star involves two tetrahedra that are adjacent along two separate pairs of faces, where the four remaining faces of these tetrahedra are joined to four entirely new tetrahedra (so that none of the six tetrahedra described in this structure are the same).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a double-edged star. </dd></dl>

</div>
</div>
<a id="a3b219eac1d9a0a0495488dd5ca99e038" name="a3b219eac1d9a0a0495488dd5ca99e038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b219eac1d9a0a0495488dd5ca99e038">&#9670;&nbsp;</a></span>hasOneEndedChainWithDoubleHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasOneEndedChainWithDoubleHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a one-ended chain with a double handle. </p>
<p >A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p >A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus).</p>
<p >A one-ended chain with a double handle begins with a one-ended chain. The two faces that are unaccounted for by this one-ended chain must be joined to two different tetrahedra, and these two tetrahedra must be joined to each other along two faces. The remaining two faces of these two tetrahedra remain unaccounted for by this structure.</p>
<p >A face pairing containing a one-ended chain with a double handle cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Face pairing graphs and 3-manifold enumeration", Benjamin A. Burton, J. Knot Theory Ramifications 13 (2004), 1057&ndash;1101.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a one-ended chain with a double handle. </dd></dl>

</div>
</div>
<a id="a372e9f00039b11782a3af1638d2122fd" name="a372e9f00039b11782a3af1638d2122fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372e9f00039b11782a3af1638d2122fd">&#9670;&nbsp;</a></span>hasOneEndedChainWithStrayBigon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasOneEndedChainWithStrayBigon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a one-ended chain with a stray bigon. </p>
<p >A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p >A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus).</p>
<p >A one-ended chain with a stray bigon describes the following structure. We begin with a one-ended chain. Two new tetrahedra are added; these are joined to each other along two pairs of faces, and one of the new tetrahedra is joined to the end of the one-ended chain. We then ensure that:</p><ul>
<li>This configuration is not part of a longer one-ended chain that encompasses all of the aforementioned tetrahedra;</li>
<li>There is no extra tetrahedron that is joined to both the two new tetrahedra and the end of the chain;</li>
<li>There is no extra tetrahedron that is joined to the end of the chain along one face and the far new tetrahedron along two additional faces (where by "the far new tetrahedron" we mean the new tetrahedron that was not originally joined to the chain).</li>
</ul>
<p >Aside from these constraints, the remaining four tetrahedron faces (two faces of the far new tetrahedron, one face of the other new tetrahedron, and one face at the end of the chain) remain unaccounted for by this structure.</p>
<p >A face pairing containing a structure of this type cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Enumeration of non-orientable 3-manifolds using face-pairing
graphs and union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a one-ended chain with a stray bigon. </dd></dl>

</div>
</div>
<a id="ace2711bf8d99861f34dd759a833e4f1a" name="ace2711bf8d99861f34dd759a833e4f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2711bf8d99861f34dd759a833e4f1a">&#9670;&nbsp;</a></span>hasSingleStar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasSingleStar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a single-edged star. </p>
<p >A single-edged star involves two tetrahedra that are adjacent along a single face, where the six remaining faces of these tetrahedra are joined to six entirely new tetrahedra (so that none of the eight tetrahedra described in this structure are the same).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a single-edged star. </dd></dl>

</div>
</div>
<a id="acde7a8ad187d9bc3492105abf93f78e7" name="acde7a8ad187d9bc3492105abf93f78e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde7a8ad187d9bc3492105abf93f78e7">&#9670;&nbsp;</a></span>hasTripleEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasTripleEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a triple edge. </p>
<p >A triple edge is where two different tetrahedra are joined along three of their faces.</p>
<p >A face pairing containing a triple edge cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Face pairing graphs and 3-manifold
enumeration", Benjamin A. Burton, J. Knot Theory Ramifications 13 (2004), 1057&ndash;1101.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a triple edge. </dd></dl>

</div>
</div>
<a id="a1bd526b75d1a1531af9a3932d4beec9b" name="a1bd526b75d1a1531af9a3932d4beec9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd526b75d1a1531af9a3932d4beec9b">&#9670;&nbsp;</a></span>hasTripleOneEndedChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasTripleOneEndedChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a triple one-ended chain. </p>
<p >A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p >A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus).</p>
<p >A triple one-ended chain is created from three one-ended chains as follows. Two new tetrahedra are added, and each one-ended chain is joined to each of the new tetrahedra along a single face. The remaining two faces (one from each of the new tetrahedra) remain unaccounted for by this structure.</p>
<p >A face pairing containing a triple one-ended chain cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Enumeration of non-orientable 3-manifolds using face-pairing
graphs and union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a triple one-ended chain. </dd></dl>

</div>
</div>
<a id="a827125a7939e2bf95a4cf57f02e7142c" name="a827125a7939e2bf95a4cf57f02e7142c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827125a7939e2bf95a4cf57f02e7142c">&#9670;&nbsp;</a></span>hasWedgedDoubleEndedChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::hasWedgedDoubleEndedChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this face pairing contains a wedged double-ended chain. </p>
<p >A chain involves a sequence of tetrahedra, each joined to the next along two faces, and is described in detail in the documentation for <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a361ee550f483502a40ceed28f8ba93e0" title="Follows a chain as far as possible from the given point.">followChain()</a>.</p>
<p >A one-ended chain is a chain in which the first tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered solid torus). A double-ended chain is a chain in which the first tetrahedron is joined to itself along one face and the final tetrahedron is also joined to itself along one face (i.e., the underlying face pairing for a layered lens space).</p>
<p >A wedged double-ended chain is created from two one-ended chains as follows. Two new tetrahedra are added, and each one-ended chain is joined to each of the new tetrahedra along a single face. In addition, the two new tetrahedra are joined to each other along a single face. The remaining two faces (one from each of the new tetrahedra) remain unaccounted for by this structure.</p>
<p >An alternative way of viewing a wedged double-ended chain is as an ordinary double-ended chain, where one of the internal tetrahedra is removed and replaced with a pair of tetrahedra joined to each other. Whereas the original tetrahedron met its two neighbouring tetrahedra along two faces each (giving a total of four face identifications), the two new tetrahedra now meet each of the two neighbouring tetrahedra along a single face each (again giving four face identifications).</p>
<p >Note that if this alternate construction is used to replace one of the end tetrahedra of the double-ended chain (not an internal tetrahedron), the resulting structure will either be a triple edge or a one-ended chain with a double handle (according to whether the original chain has zero or positive length). See <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#acde7a8ad187d9bc3492105abf93f78e7" title="Determines whether this face pairing contains a triple edge.">hasTripleEdge()</a> and <a class="el" href="classregina_1_1FacetPairing_3_013_01_4.html#a3b219eac1d9a0a0495488dd5ca99e038" title="Determines whether this face pairing contains a one-ended chain with a double handle.">hasOneEndedChainWithDoubleHandle()</a> for further details.</p>
<p >A face pairing containing a wedged double-ended chain cannot model a closed minimal irreducible P^2-irreducible 3-manifold triangulation on more than two tetrahedra. See "Enumeration of non-orientable 3-manifolds using face-pairing
graphs and union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face pairing contains a wedged double-ended chain. </dd></dl>

</div>
</div>
<a id="ad720be5515121b69f7ce62e5bbda9b5b" name="ad720be5515121b69f7ce62e5bbda9b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad720be5515121b69f7ce62e5bbda9b5b">&#9670;&nbsp;</a></span>isCanonical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal representative of its isomorphism class. </p>
<p >Isomorphisms of facet pairings correspond to relabellings of simplices and relabellings of the (<em>dim</em> + 1) facets within each simplex.</p>
<p >Facet pairings are ordered by lexicographical comparison of <code>dest(0,0)</code>, <code>dest(0,1)</code>, ..., <code>dest(<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a05fd123494c0f9d15ffed9f226728b83" title="Returns the number of simplices whose facets are described by this facet pairing.">size()</a>-1,<em>dim</em>)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a id="a6b11f9aa0e0746204354dfa13e418156" name="a6b11f9aa0e0746204354dfa13e418156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b11f9aa0e0746204354dfa13e418156">&#9670;&nbsp;</a></span>isCanonicalInternal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonicalInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#aaebffa10000fb54769c4e792f7b6bba6">IsoList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions. </p>
<p >If this facet pairing is in canonical form, the given list will be filled with the set of all combinatorial automorphisms of this facet pairing. If not, the given list will be left empty.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given list is empty. </dd>
<dd>
For each simplex <em>t</em>, the only case in which <code>dest(t,i)</code> is greater than <code>dest(t,i+1)</code> is where facets <code>(t,i)</code> and <code>(t,i+1)</code> are paired together. </dd>
<dd>
For each simplex <em>t</em> &gt; 0, it is true that <code>dest(t,0).simp &lt; t</code>. </dd>
<dd>
The sequence <code>dest(1,0)</code>, <code>dest(2,0)</code>, ..., <code>dest(n-1,0)</code> is strictly increasing, where <em>n</em> is the total number of simplices under investigation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list into which automorphisms will be placed if appropriate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a id="a55b81d609b3827899604f1e8a829c884" name="a55b81d609b3827899604f1e8a829c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b81d609b3827899604f1e8a829c884">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is closed. </p>
<p >A closed facet pairing has no unmatched facets. </p>

</div>
</div>
<a id="a86c56d584b417d3fb51507fb92809721" name="a86c56d584b417d3fb51507fb92809721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c56d584b417d3fb51507fb92809721">&#9670;&nbsp;</a></span>isUnmatched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a id="aed7d81f46e1382e0ab6937f410f6b230" name="aed7d81f46e1382e0ab6937f410f6b230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7d81f46e1382e0ab6937f410f6b230">&#9670;&nbsp;</a></span>isUnmatched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a id="ad11c57ad6815d5771c941ec03eeb326d" name="ad11c57ad6815d5771c941ec03eeb326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11c57ad6815d5771c941ec03eeb326d">&#9670;&nbsp;</a></span>noDest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p >This is signalled by a facet matched to itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8bccd3160594ba66ba13edd3735e664b" name="a8bccd3160594ba66ba13edd3735e664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bccd3160594ba66ba13edd3735e664b">&#9670;&nbsp;</a></span>noDest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p >This is signalled by a facet matched to itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a71e898ff16c0b26e346a1a8f83a8b425" name="a71e898ff16c0b26e346a1a8f83a8b425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e898ff16c0b26e346a1a8f83a8b425">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given facet pairing are not identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the facet pairing to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given facet pairing are not identical. </dd></dl>

</div>
</div>
<a id="a5c86cc1b09bce6acf2dd04d925a1a79c" name="a5c86cc1b09bce6acf2dd04d925a1a79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c86cc1b09bce6acf2dd04d925a1a79c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp; <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given face pairing into this face pairing. </p>
<p >It does not matter if this and the given face pairing use different numbers of tetrahedra; if they do then this face pairing will be resized accordingly.</p>
<p >This operator induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the facet pairing to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this face pairing. </dd></dl>

</div>
</div>
<a id="afca5c4bf5ee1afffddbfda1441529ea0" name="afca5c4bf5ee1afffddbfda1441529ea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca5c4bf5ee1afffddbfda1441529ea0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a> &amp; <a class="el" href="classregina_1_1FacetPairing.html">regina::FacetPairing</a>&lt; 3 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given face pairing into this facet pairing. </p>
<p >This is a fast (constant time) operation.</p>
<p >It does not matter if this and the given face pairing use different numbers of tetrahedra; if they do then this face pairing will be resized accordingly.</p>
<p >The face pairing that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the face pairing to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this face pairing. </dd></dl>

</div>
</div>
<a id="ac439676d3f11103163552326f4f5c64d" name="ac439676d3f11103163552326f4f5c64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac439676d3f11103163552326f4f5c64d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given facet pairing are identical. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the facet pairing to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given facet pairing are identical. </dd></dl>

</div>
</div>
<a id="ab74fc68b1801eae6f8a62220accb4c72" name="ab74fc68b1801eae6f8a62220accb4c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74fc68b1801eae6f8a62220accb4c72">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p >This is a convenience operator whose behaviour is identical to that of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p >If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a012c646f9f7388f3f4379f2f3281ed69" name="a012c646f9f7388f3f4379f2f3281ed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012c646f9f7388f3f4379f2f3281ed69">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the other facet to which the given simplex facet is paired. </p>
<p >This is a convenience operator whose behaviour is identical to that of <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p >If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine returns by value, not by reference, since Python cannot enforce constness otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="a05fd123494c0f9d15ffed9f226728b83" name="a05fd123494c0f9d15ffed9f226728b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05fd123494c0f9d15ffed9f226728b83">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of simplices whose facets are described by this facet pairing. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a88f2b377e3340f2f16e2baac92e5f904" name="a88f2b377e3340f2f16e2baac92e5f904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f2b377e3340f2f16e2baac92e5f904">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given facet pairing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the facet pairing whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6afb56a1370b063c12c4efe634eb771b" name="a6afb56a1370b063c12c4efe634eb771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afb56a1370b063c12c4efe634eb771b">&#9670;&nbsp;</a></span>toTextRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::toTextRep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a text-based representation of this facet pairing that can be used to reconstruct the facet pairing. </p>
<p >This reconstruction is done through routine <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a482dbc8bae43545ca54baa9732b327bc" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a>.</p>
<p >The text produced is not particularly readable; for a human-readable text representation, see routine <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</p>
<p >The string returned will contain no newlines.</p>
<dl class="section return"><dt>Returns</dt><dd>a text-based representation of this facet pairing. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a862b3698780487e07b4f692639951694" name="a862b3698780487e07b4f692639951694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862b3698780487e07b4f692639951694">&#9670;&nbsp;</a></span>writeDot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subgraph</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the graph corresponding to this facet pairing in the Graphviz DOT language. </p>
<p >Every vertex of this graph represents a simplex, and every edge represents a pair of simplex facets that are joined together. Note that for a closed triangulation this graph will be entirely (<em>dim</em> + 1)-valent; for triangulations with boundary facets, some graph vertices will have degree <em>dim</em> or less.</p>
<p >The graph can either be written as a complete DOT graph, or as a clustered subgraph within some larger DOT graph (according to whether the argument <em>subgraph</em> is passed as <code>false</code> or <code>true</code>).</p>
<p >If a complete DOT graph is being written, the output may be used as a standalone DOT file ready for use with Graphviz.</p>
<p >If a subgraph is being written, the output will contain a single <code>subgraph</code> section that should be inserted into some larger DOT file. Note that the output generated by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a508aa380bbd5e52e23166a07d4087256" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>, followed by one or more subgraphs and then a closing curly brace will suffice. The subgraph name will begin with the string <code>pairing_</code>.</p>
<p >The argument <em>prefix</em> will be prepended to the name of each graph vertex, and will also be used in the name of the graph or subgraph. Using unique prefixes becomes important if you are calling <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> several times to generate several subgraphs for use in a single DOT file. If the <em>prefix</em> argument is null or empty then a default prefix will be used.</p>
<p >Note that this routine generates undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead use the variant <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#acfc8c5f6f14ae74fb740738509145643" title="Returns a Graphviz DOT representation of the graph that describes this facet pairing.">dot()</a> that returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">prefix</td><td>a string to prepend to the name of each graph vertex, and to include in the graph or subgraph name; see above for details. </td></tr>
    <tr><td class="paramname">subgraph</td><td><code>false</code> if a complete standalone DOT graph should be output, or <code>true</code> if a clustered subgraph should be output for use in some larger DOT file. </td></tr>
    <tr><td class="paramname">labels</td><td>indicates whether graph vertices will be labelled with the corresponding simplex numbers. This feature is currently experimental, and the default is <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="a508aa380bbd5e52e23166a07d4087256" name="a508aa380bbd5e52e23166a07d4087256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508aa380bbd5e52e23166a07d4087256">&#9670;&nbsp;</a></span>writeDotHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDotHeader </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>graphName</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p >See the <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> documentation for further information on such graphs.</p>
<p >The output will be in the Graphviz DOT language, and will include appropriate display settings for graphs, edges and nodes. The opening brace for a <code>graph</code> section of the DOT file is included.</p>
<p >This routine may be used with <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> to generate a single DOT file containing the graphs for several different facet pairings. A complete DOT file can be produced by calling this routine, then calling <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in subgraph mode for each facet pairing, then outputting a final closing curly brace.</p>
<p >Note that if you require a DOT file containing the graph for only a single facet pairing, this routine is unnecessary; you may simply call <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a862b3698780487e07b4f692639951694" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in full graph mode instead.</p>
<p >This routine is suitable for generating undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead use the variant <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a1f8dd170b533d87914f798b0e4664d02" title="Returns header information for a Graphviz DOT file that will describe the graphs for one or more face...">dotHeader()</a> that returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">graphName</td><td>the name of the graph in the DOT file. If this is null or empty then a default graph name will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#ab25433658bd4d68717bcad01614088e7">FacetPairingBase</a>&lt; dim &gt; , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e3a9b5851e0f984a28cc88fa64717c1" name="a2e3a9b5851e0f984a28cc88fa64717c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3a9b5851e0f984a28cc88fa64717c1">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a human-readable representation of this facet pairing to the given output stream. </p>
<p >The string returned will contain no newlines.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aee05ce55cfad3b49aae171e5baa4a5e0" name="aee05ce55cfad3b49aae171e5baa4a5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee05ce55cfad3b49aae171e5baa4a5e0">&#9670;&nbsp;</a></span>pairs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::pairs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The other facet to which each simplex facet is paired. </p>
<p >If a simplex facet is left unmatched, the corresponding element of this array will be boundary (as returned by <a class="el" href="structregina_1_1FacetSpec.html#aa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>). If the destination for a particular facet has not yet been decided, the facet will be paired to itself. </p>

</div>
</div>
<a id="a663cb963d4d177f69ec39c7f7409d278" name="a663cb963d4d177f69ec39c7f7409d278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663cb963d4d177f69ec39c7f7409d278">&#9670;&nbsp;</a></span>size_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of simplices under consideration. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>triangulation/<a class="el" href="facetpairing3_8h.html">facetpairing3.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
