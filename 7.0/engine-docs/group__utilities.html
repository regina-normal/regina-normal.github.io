<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: Miscellaneous Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Miscellaneous Utilities</div></div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous helper classes and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BitManipulatorByType.html">regina::BitManipulatorByType&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains implementation details for <a class="el" href="classregina_1_1BitManipulator.html" title="An optimised class for bitwise analysis and manipulation of native data types.">BitManipulator</a> where we optimise according to the underlying data type.  <a href="classregina_1_1BitManipulatorByType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html">regina::Bitmask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bitmask that can store arbitrarily many true-or-false bits.  <a href="classregina_1_1Bitmask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask1.html">regina::Bitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) true-or-false bits.  <a href="classregina_1_1Bitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask2.html">regina::Bitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast bitmask class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) true-or-false bits.  <a href="classregina_1_1Bitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1BoolSet.html">regina::BoolSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of booleans.  <a href="classregina_1_1BoolSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ReginaException.html">regina::ReginaException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for all of the exceptions that are thrown by Regina's native mathematical code.  <a href="classregina_1_1ReginaException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FailedPrecondition.html">regina::FailedPrecondition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when a function detects that its preconditions have been violated.  <a href="classregina_1_1FailedPrecondition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1InvalidArgument.html">regina::InvalidArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when invalid or unsupported arguments are passed into a function.  <a href="classregina_1_1InvalidArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1InvalidInput.html">regina::InvalidInput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when a function reads unexpected or incomplete data from an input stream.  <a href="classregina_1_1InvalidInput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NotImplemented.html">regina::NotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when some functionality is not yet implemented.  <a href="classregina_1_1NotImplemented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1FileError.html">regina::FileError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when trying to access data from the filesystem.  <a href="classregina_1_1FileError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NoSolution.html">regina::NoSolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when Regina has certified that a mathematical problem has no solution.  <a href="classregina_1_1NoSolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1UnsolvedCase.html">regina::UnsolvedCase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when a mathematical function is not able to solve a particular instance of a problem.  <a href="classregina_1_1UnsolvedCase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Flags.html">regina::Flags&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a bitwise combination of flags defined by an enumeration type.  <a href="classregina_1_1Flags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1Locale.html">regina::i18n::Locale</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class with static routines for querying information about the current locale.  <a href="classregina_1_1i18n_1_1Locale.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStreamBuffer.html">regina::i18n::IConvStreamBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream buffer that translates between character encodings.  <a href="classregina_1_1i18n_1_1IConvStreamBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1i18n_1_1IConvStream.html">regina::i18n::IConvStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output stream that converts between character encodings.  <a href="classregina_1_1i18n_1_1IConvStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IsReginaInteger.html">regina::IsReginaInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the type <em>T</em> is one of Regina's own integer types (either arbitrary precision or fixed size).  <a href="structregina_1_1IsReginaInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IsReginaArbitraryPrecisionInteger.html">regina::IsReginaArbitraryPrecisionInteger&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the type <em>T</em> is one of Regina's arbitrary precision integer types.  <a href="structregina_1_1IsReginaArbitraryPrecisionInteger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfSize.html">regina::IntOfSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>exactly</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1IntOfMinSize.html">regina::IntOfMinSize&lt; bytes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to native integer types that hold <em>at least</em> <em>k</em> bytes, where <em>k</em> may be any compile-time constant.  <a href="structregina_1_1IntOfMinSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1FaithfulAssignment.html">regina::FaithfulAssignment&lt; From, To &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an integer of type <em>From</em> can always be assigned to an integer of type <em>To</em> with no loss of information.  <a href="structregina_1_1FaithfulAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ListView.html">regina::ListView&lt; Container &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight object that can be used for iteration and random access to all elements of a given list.  <a href="classregina_1_1ListView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ListView_3_01Element_01_5_01_4.html">regina::ListView&lt; Element * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A specialisation of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a> for working with lists stored in a C-style array.  <a href="classregina_1_1ListView_3_01Element_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html">regina::MarkedElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for elements of <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="classregina_1_1MarkedElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedVector.html">regina::MarkedVector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of objects with fast, space-efficient reverse lookup of array indices.  <a href="classregina_1_1MarkedVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__istream.html">regina::mem_istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input stream that reads an array of characters in memory.  <a href="classregina_1_1mem__istream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1mem__streambuf.html">regina::mem_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stream buffer that provides the implementation details for <a class="el" href="classregina_1_1mem__istream.html" title="An input stream that reads an array of characters in memory.">mem_istream</a>.  <a href="classregina_1_1mem__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask1.html">regina::Qitmask1&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Qitmask2.html">regina::Qitmask2&lt; T, U &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small but extremely fast "base 4 bitmask" class that can store up to 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>) "qits", each equal to 0, 1, 2 or 3.  <a href="classregina_1_1Qitmask2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1RandomEngine.html">regina::RandomEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offers threadsafe access to Regina's global uniform random bit generator.  <a href="classregina_1_1RandomEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LightweightSequence.html">regina::LightweightSequence&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight class for storing a random-access sequence of objects.  <a href="classregina_1_1LightweightSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ShortArray.html">regina::ShortArray&lt; T, maxSize &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A short stack-based array of bounded size.  <a href="classregina_1_1ShortArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Base64SigEncoding.html">regina::Base64SigEncoding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General helper tools for signatures that use base64 encodings.  <a href="structregina_1_1Base64SigEncoding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotWriteError.html">regina::SnapshotWriteError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when someone tries to modify the read-only deep copy taken by a snapshot.  <a href="classregina_1_1SnapshotWriteError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshot.html">regina::Snapshot&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps a snapshot of an object of type <em>T</em> as it was at a particular moment in time.  <a href="classregina_1_1Snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Snapshottable.html">regina::Snapshottable&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for images of type <em>T</em> that can be snapshotted at a particular moment in time.  <a href="classregina_1_1Snapshottable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to an image of type <em>T</em> that has been snapshotted at a particular moment in time.  <a href="classregina_1_1SnapshotRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trie-like data structure for storing and retriving sets.  <a href="classregina_1_1TrieSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1EnableIf.html">regina::EnableIf&lt; condition, T, defaultValue &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that holds either a single value of type <em>T</em> or nothing at all, depending on whether the given compile-time condition holds.  <a href="structregina_1_1EnableIf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad9e0856df6a522ff8035873cb0571776"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad9e0856df6a522ff8035873cb0571776">ENABLE_MEMBER_FOR_REGINA_INTEGER</a>(T,  returnType)</td></tr>
<tr class="memdesc:gad9e0856df6a522ff8035873cb0571776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally enables a member function for a template class only when the type <em>T</em> is one of Regina's own integer classes.  <a href="group__utilities.html#gad9e0856df6a522ff8035873cb0571776">More...</a><br /></td></tr>
<tr class="separator:gad9e0856df6a522ff8035873cb0571776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga10ce619cba5ee33051626b477ec19a73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga10ce619cba5ee33051626b477ec19a73">regina::BitmaskLen8</a> = <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; uint8_t &gt;</td></tr>
<tr class="memdesc:ga10ce619cba5ee33051626b477ec19a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#ga10ce619cba5ee33051626b477ec19a73">More...</a><br /></td></tr>
<tr class="separator:ga10ce619cba5ee33051626b477ec19a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64e0b858babc0955c37c92983e78db2b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga64e0b858babc0955c37c92983e78db2b">regina::BitmaskLen16</a> = <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; uint16_t &gt;</td></tr>
<tr class="memdesc:ga64e0b858babc0955c37c92983e78db2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#ga64e0b858babc0955c37c92983e78db2b">More...</a><br /></td></tr>
<tr class="separator:ga64e0b858babc0955c37c92983e78db2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad59e621503ca6d62de2802e4450b20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaaad59e621503ca6d62de2802e4450b20">regina::BitmaskLen32</a> = <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; uint32_t &gt;</td></tr>
<tr class="memdesc:gaaad59e621503ca6d62de2802e4450b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#gaaad59e621503ca6d62de2802e4450b20">More...</a><br /></td></tr>
<tr class="separator:gaaad59e621503ca6d62de2802e4450b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98076bdce114778ff8656a7dd64f688e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga98076bdce114778ff8656a7dd64f688e">regina::BitmaskLen64</a> = <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; uint64_t &gt;</td></tr>
<tr class="memdesc:ga98076bdce114778ff8656a7dd64f688e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#ga98076bdce114778ff8656a7dd64f688e">More...</a><br /></td></tr>
<tr class="separator:ga98076bdce114778ff8656a7dd64f688e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75769a7c34c064f484125111a3a9d8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab75769a7c34c064f484125111a3a9d8a">regina::QitmaskLen8</a> = <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; uint8_t &gt;</td></tr>
<tr class="memdesc:gab75769a7c34c064f484125111a3a9d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits.  <a href="group__utilities.html#gab75769a7c34c064f484125111a3a9d8a">More...</a><br /></td></tr>
<tr class="separator:gab75769a7c34c064f484125111a3a9d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2221dbfd6810a81a26505d46e5f836a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga2221dbfd6810a81a26505d46e5f836a2">regina::QitmaskLen16</a> = <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; uint16_t &gt;</td></tr>
<tr class="memdesc:ga2221dbfd6810a81a26505d46e5f836a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits.  <a href="group__utilities.html#ga2221dbfd6810a81a26505d46e5f836a2">More...</a><br /></td></tr>
<tr class="separator:ga2221dbfd6810a81a26505d46e5f836a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd4d6a8e26c3a550ef9fc4d07fd1fa65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gadd4d6a8e26c3a550ef9fc4d07fd1fa65">regina::QitmaskLen32</a> = <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; uint32_t &gt;</td></tr>
<tr class="memdesc:gadd4d6a8e26c3a550ef9fc4d07fd1fa65"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits.  <a href="group__utilities.html#gadd4d6a8e26c3a550ef9fc4d07fd1fa65">More...</a><br /></td></tr>
<tr class="separator:gadd4d6a8e26c3a550ef9fc4d07fd1fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01655ebe66cc37683095dd86828e6f82"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga01655ebe66cc37683095dd86828e6f82">regina::QitmaskLen64</a> = <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; uint64_t &gt;</td></tr>
<tr class="memdesc:ga01655ebe66cc37683095dd86828e6f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits.  <a href="group__utilities.html#ga01655ebe66cc37683095dd86828e6f82">More...</a><br /></td></tr>
<tr class="separator:ga01655ebe66cc37683095dd86828e6f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">regina::base64Length</a> (size_t bytes)</td></tr>
<tr class="memdesc:gaa8d632b73943b5c52e395d56f8e03af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of base64 characters required to encode the given number of bytes.  <a href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2">More...</a><br /></td></tr>
<tr class="separator:gaa8d632b73943b5c52e395d56f8e03af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">regina::isBase64</a> (char ch)</td></tr>
<tr class="memdesc:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given character is a base64 printable character as used by the base64 routines in Regina.  <a href="group__utilities.html#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">More...</a><br /></td></tr>
<tr class="separator:ga231a1c1fdf6cc37e09fbc77ea2cf14ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081d322bec8070a889aba14d5988ae80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">regina::base64Encode</a> (const char *in, size_t inlen, char *out, size_t outlen)</td></tr>
<tr class="memdesc:ga081d322bec8070a889aba14d5988ae80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer.  <a href="group__utilities.html#ga081d322bec8070a889aba14d5988ae80">More...</a><br /></td></tr>
<tr class="separator:ga081d322bec8070a889aba14d5988ae80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga541f612d6bb0f94db16da14169813e29"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">regina::base64Encode</a> (const char *in, size_t inlen, char **out)</td></tr>
<tr class="memdesc:ga541f612d6bb0f94db16da14169813e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29">More...</a><br /></td></tr>
<tr class="separator:ga541f612d6bb0f94db16da14169813e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">regina::base64Decode</a> (const char *in, size_t inlen, char *out, size_t *outlen)</td></tr>
<tr class="memdesc:ga6811ec511cb61bfc071467ba5d0e8076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer.  <a href="group__utilities.html#ga6811ec511cb61bfc071467ba5d0e8076">More...</a><br /></td></tr>
<tr class="separator:ga6811ec511cb61bfc071467ba5d0e8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d6c710ee070d88c4b670b48bec3878"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">regina::base64Decode</a> (const char *in, size_t inlen, char **out, size_t *outlen)</td></tr>
<tr class="memdesc:ga47d6c710ee070d88c4b670b48bec3878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results.  <a href="group__utilities.html#ga47d6c710ee070d88c4b670b48bec3878">More...</a><br /></td></tr>
<tr class="separator:ga47d6c710ee070d88c4b670b48bec3878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga242c17df8901ed6224a6741ad945cf46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga242c17df8901ed6224a6741ad945cf46">regina::swap</a> (<a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;a, <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga242c17df8901ed6224a6741ad945cf46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given bitmasks.  <a href="group__utilities.html#ga242c17df8901ed6224a6741ad945cf46">More...</a><br /></td></tr>
<tr class="separator:ga242c17df8901ed6224a6741ad945cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687edae41955adbcf9e58c8cce90ea68"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;mask)</td></tr>
<tr class="memdesc:ga687edae41955adbcf9e58c8cce90ea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#ga687edae41955adbcf9e58c8cce90ea68">More...</a><br /></td></tr>
<tr class="separator:ga687edae41955adbcf9e58c8cce90ea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2309e18138c1e4d8166a47a4408bdc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae2309e18138c1e4d8166a47a4408bdc4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae2309e18138c1e4d8166a47a4408bdc4">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:gae2309e18138c1e4d8166a47a4408bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#gae2309e18138c1e4d8166a47a4408bdc4">More...</a><br /></td></tr>
<tr class="separator:gae2309e18138c1e4d8166a47a4408bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a859bcdb5958b927015eed8e033527"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab3a859bcdb5958b927015eed8e033527"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab3a859bcdb5958b927015eed8e033527">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:gab3a859bcdb5958b927015eed8e033527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="group__utilities.html#gab3a859bcdb5958b927015eed8e033527">More...</a><br /></td></tr>
<tr class="separator:gab3a859bcdb5958b927015eed8e033527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53b5c83676706821d636840cc976aecf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga53b5c83676706821d636840cc976aecf">regina::operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> set)</td></tr>
<tr class="memdesc:ga53b5c83676706821d636840cc976aecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given boolean set to the given output stream.  <a href="group__utilities.html#ga53b5c83676706821d636840cc976aecf">More...</a><br /></td></tr>
<tr class="separator:ga53b5c83676706821d636840cc976aecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3439925c61c42453159e0b50bdff960"><td class="memItemLeft" align="right" valign="top">std::string::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">regina::i18n::utf8ValidTo</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:gad3439925c61c42453159e0b50bdff960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#gad3439925c61c42453159e0b50bdff960">More...</a><br /></td></tr>
<tr class="separator:gad3439925c61c42453159e0b50bdff960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91eb70b23252b007d149e269b1afb973"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga91eb70b23252b007d149e269b1afb973">regina::i18n::utf8ValidTo</a> (const char *s)</td></tr>
<tr class="memdesc:ga91eb70b23252b007d149e269b1afb973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the longest prefix of the given string that is valid UTF-8.  <a href="group__utilities.html#ga91eb70b23252b007d149e269b1afb973">More...</a><br /></td></tr>
<tr class="separator:ga91eb70b23252b007d149e269b1afb973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">regina::bitsRequired</a> (IntType n)</td></tr>
<tr class="memdesc:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bits required to store integers in the range 0,...,<em>n</em>-1.  <a href="group__utilities.html#gaf3cfd88109df8473b8ae9647ff96d35a">More...</a><br /></td></tr>
<tr class="separator:gaf3cfd88109df8473b8ae9647ff96d35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">regina::nextPowerOfTwo</a> (IntType n)</td></tr>
<tr class="memdesc:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest integer power of two that is greater than or equal to the given argument <em>n</em>.  <a href="group__utilities.html#gaf8ad7790348b617ffd8fdf50736cd9cf">More...</a><br /></td></tr>
<tr class="separator:gaf8ad7790348b617ffd8fdf50736cd9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cb08c9668a04e355a26fd30afdeb52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga97cb08c9668a04e355a26fd30afdeb52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga97cb08c9668a04e355a26fd30afdeb52">regina::swap</a> (<a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga97cb08c9668a04e355a26fd30afdeb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given vectors.  <a href="group__utilities.html#ga97cb08c9668a04e355a26fd30afdeb52">More...</a><br /></td></tr>
<tr class="separator:ga97cb08c9668a04e355a26fd30afdeb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fcd763de878bdad5baf8c67406e0236"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; unsigned long, unsigned long, unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6fcd763de878bdad5baf8c67406e0236">regina::resUsage</a> ()</td></tr>
<tr class="memdesc:ga6fcd763de878bdad5baf8c67406e0236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns time and memory usage for the current process, for use on Linux systems.  <a href="group__utilities.html#ga6fcd763de878bdad5baf8c67406e0236">More...</a><br /></td></tr>
<tr class="separator:ga6fcd763de878bdad5baf8c67406e0236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b4d5d732453f12f636c552435e605d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga45b4d5d732453f12f636c552435e605d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga45b4d5d732453f12f636c552435e605d">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;mask)</td></tr>
<tr class="memdesc:ga45b4d5d732453f12f636c552435e605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#ga45b4d5d732453f12f636c552435e605d">More...</a><br /></td></tr>
<tr class="separator:ga45b4d5d732453f12f636c552435e605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae31ecb27359bcdae0607c56c834f5269"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae31ecb27359bcdae0607c56c834f5269"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae31ecb27359bcdae0607c56c834f5269">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;mask)</td></tr>
<tr class="memdesc:gae31ecb27359bcdae0607c56c834f5269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3).  <a href="group__utilities.html#gae31ecb27359bcdae0607c56c834f5269">More...</a><br /></td></tr>
<tr class="separator:gae31ecb27359bcdae0607c56c834f5269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:gaa0c5c9157147686a6bfc401312b8d90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given sequence to the given output stream.  <a href="group__utilities.html#gaa0c5c9157147686a6bfc401312b8d90c">More...</a><br /></td></tr>
<tr class="separator:gaa0c5c9157147686a6bfc401312b8d90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga7c2e72a3a85bfa1503a0e934497dca69">regina::swap</a> (<a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the given sequences.  <a href="group__utilities.html#ga7c2e72a3a85bfa1503a0e934497dca69">More...</a><br /></td></tr>
<tr class="separator:ga7c2e72a3a85bfa1503a0e934497dca69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga66f73edd06b7cc0e066e11c1d8ea35c8">regina::swap</a> (<a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;a, <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;b) noexcept</td></tr>
<tr class="memdesc:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the given references so that they refer to each others' snapshots.  <a href="group__utilities.html#ga66f73edd06b7cc0e066e11c1d8ea35c8">More...</a><br /></td></tr>
<tr class="separator:ga66f73edd06b7cc0e066e11c1d8ea35c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4056bad007750e92b40959aca2c4f987"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">regina::startsWith</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ga4056bad007750e92b40959aca2c4f987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given C++ string begins with the given prefix.  <a href="group__utilities.html#ga4056bad007750e92b40959aca2c4f987">More...</a><br /></td></tr>
<tr class="separator:ga4056bad007750e92b40959aca2c4f987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa678d35fabfebccce72406d01076829c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">regina::stripWhitespace</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa678d35fabfebccce72406d01076829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips all whitespace from the beginning and end of the given C++ string.  <a href="group__utilities.html#gaa678d35fabfebccce72406d01076829c">More...</a><br /></td></tr>
<tr class="separator:gaa678d35fabfebccce72406d01076829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c2e62bf0908919834ea10762def19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">regina::valueOf</a> (const std::string &amp;str, int8_t &amp;dest)</td></tr>
<tr class="memdesc:gae40c2e62bf0908919834ea10762def19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gae40c2e62bf0908919834ea10762def19">More...</a><br /></td></tr>
<tr class="separator:gae40c2e62bf0908919834ea10762def19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">regina::valueOf</a> (const std::string &amp;str, uint8_t &amp;dest)</td></tr>
<tr class="memdesc:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaf9eaa1f183454edc0db4f915d98c0a73">More...</a><br /></td></tr>
<tr class="separator:gaf9eaa1f183454edc0db4f915d98c0a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga384de19626353085bf20eedc89c3c30a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">regina::valueOf</a> (const std::string &amp;str, short &amp;dest)</td></tr>
<tr class="memdesc:ga384de19626353085bf20eedc89c3c30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga384de19626353085bf20eedc89c3c30a">More...</a><br /></td></tr>
<tr class="separator:ga384de19626353085bf20eedc89c3c30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183ba5dd849f33e9153c3363323abf5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">regina::valueOf</a> (const std::string &amp;str, unsigned short &amp;dest)</td></tr>
<tr class="memdesc:ga183ba5dd849f33e9153c3363323abf5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned short integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga183ba5dd849f33e9153c3363323abf5a">More...</a><br /></td></tr>
<tr class="separator:ga183ba5dd849f33e9153c3363323abf5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">regina::valueOf</a> (const std::string &amp;str, int &amp;dest)</td></tr>
<tr class="memdesc:ga896ae2c6783d6d6dc4081bddabb22518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga896ae2c6783d6d6dc4081bddabb22518">More...</a><br /></td></tr>
<tr class="separator:ga896ae2c6783d6d6dc4081bddabb22518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga974a77f98013a0274540b1d0b06519f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">regina::valueOf</a> (const std::string &amp;str, unsigned &amp;dest)</td></tr>
<tr class="memdesc:ga974a77f98013a0274540b1d0b06519f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga974a77f98013a0274540b1d0b06519f3">More...</a><br /></td></tr>
<tr class="separator:ga974a77f98013a0274540b1d0b06519f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">regina::valueOf</a> (const std::string &amp;str, long &amp;dest)</td></tr>
<tr class="memdesc:gaad0bb367f8c8f4172e6a979751907c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gaad0bb367f8c8f4172e6a979751907c6c">More...</a><br /></td></tr>
<tr class="separator:gaad0bb367f8c8f4172e6a979751907c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007abfa18426eedc6277f644ded3e068"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">regina::valueOf</a> (const std::string &amp;str, unsigned long &amp;dest)</td></tr>
<tr class="memdesc:ga007abfa18426eedc6277f644ded3e068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga007abfa18426eedc6277f644ded3e068">More...</a><br /></td></tr>
<tr class="separator:ga007abfa18426eedc6277f644ded3e068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd5eebbe6059d16231b0e41966e2056a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">regina::valueOf</a> (const std::string &amp;str, long long &amp;dest)</td></tr>
<tr class="memdesc:gacd5eebbe6059d16231b0e41966e2056a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gacd5eebbe6059d16231b0e41966e2056a">More...</a><br /></td></tr>
<tr class="separator:gacd5eebbe6059d16231b0e41966e2056a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0bc034686407302e3ad597e39933a99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">regina::valueOf</a> (const std::string &amp;str, unsigned long long &amp;dest)</td></tr>
<tr class="memdesc:gad0bc034686407302e3ad597e39933a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful.  <a href="group__utilities.html#gad0bc034686407302e3ad597e39933a99">More...</a><br /></td></tr>
<tr class="separator:gad0bc034686407302e3ad597e39933a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memTemplParams" colspan="2">template&lt;bool supportInfinity&gt; </td></tr>
<tr class="memitem:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4c91417b8ffbca35aa32c82532f5330f">regina::valueOf</a> (const std::string &amp;str, <a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; supportInfinity &gt; &amp;dest)</td></tr>
<tr class="memdesc:ga4c91417b8ffbca35aa32c82532f5330f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful.  <a href="group__utilities.html#ga4c91417b8ffbca35aa32c82532f5330f">More...</a><br /></td></tr>
<tr class="separator:ga4c91417b8ffbca35aa32c82532f5330f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">regina::valueOf</a> (const std::string &amp;str, double &amp;dest)</td></tr>
<tr class="memdesc:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a double precision real number and reports whether this conversion was successful.  <a href="group__utilities.html#ga6d3266c3fb5264747ed7af53464ac7a9">More...</a><br /></td></tr>
<tr class="separator:ga6d3266c3fb5264747ed7af53464ac7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e706f7f722922798776b74f9933bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">regina::valueOf</a> (const std::string &amp;str, bool &amp;dest)</td></tr>
<tr class="memdesc:ga17e706f7f722922798776b74f9933bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a boolean and reports whether this conversion was successful.  <a href="group__utilities.html#ga17e706f7f722922798776b74f9933bd0">More...</a><br /></td></tr>
<tr class="separator:ga17e706f7f722922798776b74f9933bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">regina::valueOf</a> (const std::string &amp;str, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;dest)</td></tr>
<tr class="memdesc:ga6083d66d2dcac7dce8637e6282c6c679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the entire given string to a set of booleans and reports whether this conversion was successful.  <a href="group__utilities.html#ga6083d66d2dcac7dce8637e6282c6c679">More...</a><br /></td></tr>
<tr class="separator:ga6083d66d2dcac7dce8637e6282c6c679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829779c4fa33b63924f584c933314229"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga829779c4fa33b63924f584c933314229">regina::basicTokenise</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga829779c4fa33b63924f584c933314229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decomposes the given string into tokens.  <a href="group__utilities.html#ga829779c4fa33b63924f584c933314229">More...</a><br /></td></tr>
<tr class="separator:ga829779c4fa33b63924f584c933314229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplParams" colspan="2">template&lt;class OutputIterator &gt; </td></tr>
<tr class="memitem:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga032b26a588e2bdbcc5a74e05f8c37fa9">regina::basicTokenise</a> (OutputIterator results, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine to decompose a string into tokens.  <a href="group__utilities.html#ga032b26a588e2bdbcc5a74e05f8c37fa9">More...</a><br /></td></tr>
<tr class="separator:ga032b26a588e2bdbcc5a74e05f8c37fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5114cac055c590a0239b7b34b94458d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae5114cac055c590a0239b7b34b94458d">regina::stringToToken</a> (std::string str)</td></tr>
<tr class="memdesc:gae5114cac055c590a0239b7b34b94458d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a token derived from the given string.  <a href="group__utilities.html#gae5114cac055c590a0239b7b34b94458d">More...</a><br /></td></tr>
<tr class="separator:gae5114cac055c590a0239b7b34b94458d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">regina::superscript</a> (T value)</td></tr>
<tr class="memdesc:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode superscript string.  <a href="group__utilities.html#ga92f5f4f8be21a36101e67ed4b461ba19">More...</a><br /></td></tr>
<tr class="separator:ga92f5f4f8be21a36101e67ed4b461ba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga61ea966075c340b411ef07cc5aee1213"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">regina::subscript</a> (T value)</td></tr>
<tr class="memdesc:ga61ea966075c340b411ef07cc5aee1213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given C++ integer into a unicode subscript string.  <a href="group__utilities.html#ga61ea966075c340b411ef07cc5aee1213">More...</a><br /></td></tr>
<tr class="separator:ga61ea966075c340b411ef07cc5aee1213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3071be3bed13d0057ebe344aab4ed4ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3071be3bed13d0057ebe344aab4ed4ef">regina::tightEncode</a> (std::ostream &amp;out, int value)</td></tr>
<tr class="memdesc:ga3071be3bed13d0057ebe344aab4ed4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given signed integer to the given output stream.  <a href="group__utilities.html#ga3071be3bed13d0057ebe344aab4ed4ef">More...</a><br /></td></tr>
<tr class="separator:ga3071be3bed13d0057ebe344aab4ed4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04ee6a550c68d8d29b2c1eb35d4bc82"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82">regina::tightEncoding</a> (int value)</td></tr>
<tr class="memdesc:gad04ee6a550c68d8d29b2c1eb35d4bc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given signed integer.  <a href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82">More...</a><br /></td></tr>
<tr class="separator:gad04ee6a550c68d8d29b2c1eb35d4bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc77642572c2f8eea1818db38b28de2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gafc77642572c2f8eea1818db38b28de2b">regina::tightEncode</a> (std::ostream &amp;out, long value)</td></tr>
<tr class="memdesc:gafc77642572c2f8eea1818db38b28de2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given signed long integer to the given output stream.  <a href="group__utilities.html#gafc77642572c2f8eea1818db38b28de2b">More...</a><br /></td></tr>
<tr class="separator:gafc77642572c2f8eea1818db38b28de2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d43fc580edb50fb9a0756a1ffedb58"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58">regina::tightEncoding</a> (long value)</td></tr>
<tr class="memdesc:gae5d43fc580edb50fb9a0756a1ffedb58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given signed long integer.  <a href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58">More...</a><br /></td></tr>
<tr class="separator:gae5d43fc580edb50fb9a0756a1ffedb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db618c87ebf51d61009cc98c3cef150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3db618c87ebf51d61009cc98c3cef150">regina::tightEncode</a> (std::ostream &amp;out, long long value)</td></tr>
<tr class="memdesc:ga3db618c87ebf51d61009cc98c3cef150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given signed long long integer to the given output stream.  <a href="group__utilities.html#ga3db618c87ebf51d61009cc98c3cef150">More...</a><br /></td></tr>
<tr class="separator:ga3db618c87ebf51d61009cc98c3cef150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac847807974dbe589cfc57056a236cd46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gac847807974dbe589cfc57056a236cd46">regina::tightEncoding</a> (long long value)</td></tr>
<tr class="memdesc:gac847807974dbe589cfc57056a236cd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given signed long long integer.  <a href="group__utilities.html#gac847807974dbe589cfc57056a236cd46">More...</a><br /></td></tr>
<tr class="separator:gac847807974dbe589cfc57056a236cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00bbae1e4f050d67575a68752b4018f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf00bbae1e4f050d67575a68752b4018f">regina::tightEncode</a> (std::ostream &amp;out, unsigned value)</td></tr>
<tr class="memdesc:gaf00bbae1e4f050d67575a68752b4018f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given unsigned integer to the given output stream.  <a href="group__utilities.html#gaf00bbae1e4f050d67575a68752b4018f">More...</a><br /></td></tr>
<tr class="separator:gaf00bbae1e4f050d67575a68752b4018f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd29cdddc4af9b3dbd98fd08badbc2a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5dd29cdddc4af9b3dbd98fd08badbc2a">regina::tightEncoding</a> (unsigned value)</td></tr>
<tr class="memdesc:ga5dd29cdddc4af9b3dbd98fd08badbc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given unsigned integer.  <a href="group__utilities.html#ga5dd29cdddc4af9b3dbd98fd08badbc2a">More...</a><br /></td></tr>
<tr class="separator:ga5dd29cdddc4af9b3dbd98fd08badbc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56176c1b2cedb9dcf027c7cf88907806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga56176c1b2cedb9dcf027c7cf88907806">regina::tightEncode</a> (std::ostream &amp;out, unsigned long value)</td></tr>
<tr class="memdesc:ga56176c1b2cedb9dcf027c7cf88907806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given unsigned long integer to the given output stream.  <a href="group__utilities.html#ga56176c1b2cedb9dcf027c7cf88907806">More...</a><br /></td></tr>
<tr class="separator:ga56176c1b2cedb9dcf027c7cf88907806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c703c35095c4407b987054ec056cc7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaf1c703c35095c4407b987054ec056cc7">regina::tightEncoding</a> (unsigned long value)</td></tr>
<tr class="memdesc:gaf1c703c35095c4407b987054ec056cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given unsigned long integer.  <a href="group__utilities.html#gaf1c703c35095c4407b987054ec056cc7">More...</a><br /></td></tr>
<tr class="separator:gaf1c703c35095c4407b987054ec056cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfd99d3c0d21833b55a4af77736092d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gaadfd99d3c0d21833b55a4af77736092d">regina::tightEncode</a> (std::ostream &amp;out, unsigned long long value)</td></tr>
<tr class="memdesc:gaadfd99d3c0d21833b55a4af77736092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of the given unsigned long long integer to the given output stream.  <a href="group__utilities.html#gaadfd99d3c0d21833b55a4af77736092d">More...</a><br /></td></tr>
<tr class="separator:gaadfd99d3c0d21833b55a4af77736092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ddfa37a33307ca03dcb087da759280"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#gab1ddfa37a33307ca03dcb087da759280">regina::tightEncoding</a> (unsigned long long value)</td></tr>
<tr class="memdesc:gab1ddfa37a33307ca03dcb087da759280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of the given unsigned long long integer.  <a href="group__utilities.html#gab1ddfa37a33307ca03dcb087da759280">More...</a><br /></td></tr>
<tr class="separator:gab1ddfa37a33307ca03dcb087da759280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12ac49ef48ad51831f09c40a326fcce9"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:ga12ac49ef48ad51831f09c40a326fcce9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga12ac49ef48ad51831f09c40a326fcce9">regina::detail::tightEncodeInteger</a> (std::ostream &amp;out, Int value)</td></tr>
<tr class="memdesc:ga12ac49ef48ad51831f09c40a326fcce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function that writes the tight encoding of the given integer to the given output stream.  <a href="group__utilities.html#ga12ac49ef48ad51831f09c40a326fcce9">More...</a><br /></td></tr>
<tr class="separator:ga12ac49ef48ad51831f09c40a326fcce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4edb9a7b2681015b7a294f9f323c30b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga4edb9a7b2681015b7a294f9f323c30b1">regina::swap</a> (<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;a, <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga4edb9a7b2681015b7a294f9f323c30b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of the two given collections.  <a href="group__utilities.html#ga4edb9a7b2681015b7a294f9f323c30b1">More...</a><br /></td></tr>
<tr class="separator:ga4edb9a7b2681015b7a294f9f323c30b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">regina::xml::xmlEncodeSpecialChars</a> (const std::string &amp;original)</td></tr>
<tr class="memdesc:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given string with special characters converted to XML entities.  <a href="group__utilities.html#ga3a9273b1e8e9c18b33d73012b77c1b3f">More...</a><br /></td></tr>
<tr class="separator:ga3a9273b1e8e9c18b33d73012b77c1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">regina::xml::xmlEncodeComment</a> (const std::string &amp;comment)</td></tr>
<tr class="memdesc:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given string encoded so it is suitable for use inside an XML comment.  <a href="group__utilities.html#ga6d9135c01a79c7fcfa32caafd8bb4652">More...</a><br /></td></tr>
<tr class="separator:ga6d9135c01a79c7fcfa32caafd8bb4652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">regina::xml::xmlValueTag</a> (const std::string &amp;tagName, const T &amp;value)</td></tr>
<tr class="memdesc:gacb9d9d42e182de0dc67e4176414cb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an XML tag with a single property containing the given value.  <a href="group__utilities.html#gacb9d9d42e182de0dc67e4176414cb07d">More...</a><br /></td></tr>
<tr class="separator:gacb9d9d42e182de0dc67e4176414cb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5616d8b8cc6091811f09782f0dad6449"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga5616d8b8cc6091811f09782f0dad6449">regina::base64Table</a> []</td></tr>
<tr class="memdesc:ga5616d8b8cc6091811f09782f0dad6449"><td class="mdescLeft">&#160;</td><td class="mdescRight">The table of all base64 printable characters, as used by the base64 routines in Regina.  <a href="group__utilities.html#ga5616d8b8cc6091811f09782f0dad6449">More...</a><br /></td></tr>
<tr class="separator:ga5616d8b8cc6091811f09782f0dad6449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3657172c4ecb2d7217bd5220b83cf41f"><td class="memItemLeft" align="right" valign="top">constexpr char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utilities.html#ga3657172c4ecb2d7217bd5220b83cf41f">regina::base64Spare</a> [] = &quot;_-.&quot;</td></tr>
<tr class="memdesc:ga3657172c4ecb2d7217bd5220b83cf41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table of printable characters that are <em>not</em> amongst the base64 printable characters used by Regina.  <a href="group__utilities.html#ga3657172c4ecb2d7217bd5220b83cf41f">More...</a><br /></td></tr>
<tr class="separator:ga3657172c4ecb2d7217bd5220b83cf41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Miscellaneous helper classes and functions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad9e0856df6a522ff8035873cb0571776" name="gad9e0856df6a522ff8035873cb0571776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e0856df6a522ff8035873cb0571776">&#9670;&nbsp;</a></span>ENABLE_MEMBER_FOR_REGINA_INTEGER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENABLE_MEMBER_FOR_REGINA_INTEGER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">returnType&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args, <span class="keyword">typename</span> Return = returnType&gt; \</div>
<div class="line">    std::enable_if_t&lt;IsReginaInteger&lt;T&gt;::value, Return&gt;</div>
</div><!-- fragment -->
<p>Conditionally enables a member function for a template class only when the type <em>T</em> is one of Regina's own integer classes. </p>
<p >This macro should be used as the return type for such a member function. If <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger or NativeInteger), then the actual return type for the member function will be the argument <em>returnType</em>. Otherwise the member function will be disabled, will not appear in the class at all, and will not generate compile errors if it uses operations that <em>T</em> does not support.</p>
<p >The implementation uses SFINAE to remove the member function without compile errors. A side-effect of this is that the member function will now be a <em>template</em> member function. The user should never specify their own template arguments, and indeed the template parameter pack <em>Args</em> in the implementation is there precisely to stop users from doing this.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The member function this macro is applied to is <em>not</em> a template member function (though, as noted above, this macro will silently make it one).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga64e0b858babc0955c37c92983e78db2b" name="ga64e0b858babc0955c37c92983e78db2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64e0b858babc0955c37c92983e78db2b">&#9670;&nbsp;</a></span>BitmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#ga64e0b858babc0955c37c92983e78db2b">regina::BitmaskLen16</a> = typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;uint16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 16 true-or-false bits. </p>
<p >This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000210">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use Bitmask1&lt;uint16_t&gt; instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised bitmask class via the name Bitmask16. </dd></dl>

</div>
</div>
<a id="gaaad59e621503ca6d62de2802e4450b20" name="gaaad59e621503ca6d62de2802e4450b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaad59e621503ca6d62de2802e4450b20">&#9670;&nbsp;</a></span>BitmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#gaaad59e621503ca6d62de2802e4450b20">regina::BitmaskLen32</a> = typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 32 true-or-false bits. </p>
<p >This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000211">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use Bitmask1&lt;uint32_t&gt; instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised bitmask class via the name Bitmask32. </dd></dl>

</div>
</div>
<a id="ga98076bdce114778ff8656a7dd64f688e" name="ga98076bdce114778ff8656a7dd64f688e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98076bdce114778ff8656a7dd64f688e">&#9670;&nbsp;</a></span>BitmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#ga98076bdce114778ff8656a7dd64f688e">regina::BitmaskLen64</a> = typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 64 true-or-false bits. </p>
<p >This bitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or the template class <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000212">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use Bitmask1&lt;uint64_t&gt; instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised bitmask class via the name Bitmask64. </dd></dl>

</div>
</div>
<a id="ga10ce619cba5ee33051626b477ec19a73" name="ga10ce619cba5ee33051626b477ec19a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ce619cba5ee33051626b477ec19a73">&#9670;&nbsp;</a></span>BitmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#ga10ce619cba5ee33051626b477ec19a73">regina::BitmaskLen8</a> = typedef <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt;uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast bitmask class capable of holding at least 8 true-or-false bits. </p>
<p >This bitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000209">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a>&lt;uint8_t instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised bitmask class via the name Bitmask8. </dd></dl>

</div>
</div>
<a id="ga2221dbfd6810a81a26505d46e5f836a2" name="ga2221dbfd6810a81a26505d46e5f836a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2221dbfd6810a81a26505d46e5f836a2">&#9670;&nbsp;</a></span>QitmaskLen16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#ga2221dbfd6810a81a26505d46e5f836a2">regina::QitmaskLen16</a> = typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;uint16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 16 true-or-false bits. </p>
<p >This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000218">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use Qitmask1&lt;uint16_t&gt; instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised qitmask class via the name Qitmask16. </dd></dl>

</div>
</div>
<a id="gadd4d6a8e26c3a550ef9fc4d07fd1fa65" name="gadd4d6a8e26c3a550ef9fc4d07fd1fa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd4d6a8e26c3a550ef9fc4d07fd1fa65">&#9670;&nbsp;</a></span>QitmaskLen32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#gadd4d6a8e26c3a550ef9fc4d07fd1fa65">regina::QitmaskLen32</a> = typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;uint32_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 32 true-or-false bits. </p>
<p >This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000219">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use Qitmask1&lt;uint32_t&gt; instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised qitmask class via the name Qitmask32. </dd></dl>

</div>
</div>
<a id="ga01655ebe66cc37683095dd86828e6f82" name="ga01655ebe66cc37683095dd86828e6f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01655ebe66cc37683095dd86828e6f82">&#9670;&nbsp;</a></span>QitmaskLen64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#ga01655ebe66cc37683095dd86828e6f82">regina::QitmaskLen64</a> = typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;uint64_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 64 true-or-false bits. </p>
<p >This qitmask class is guaranteed to be an instantiation of <em>either</em> the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a> or the template class <a class="el" href="classregina_1_1Qitmask2.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) + 8 * sizeof(U) ...">Qitmask2</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000220">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use Qitmask1&lt;uint64_t&gt; instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised qitmask class via the name Qitmask64. </dd></dl>

</div>
</div>
<a id="gab75769a7c34c064f484125111a3a9d8a" name="gab75769a7c34c064f484125111a3a9d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab75769a7c34c064f484125111a3a9d8a">&#9670;&nbsp;</a></span>QitmaskLen8</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__utilities.html#gab75769a7c34c064f484125111a3a9d8a">regina::QitmaskLen8</a> = typedef <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt;uint8_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A deprecated type alias that gives a small and extremely fast qitmask class capable of holding at least 8 true-or-false bits. </p>
<p >This qitmask class is guaranteed to be an instantiation of the template class <a class="el" href="classregina_1_1Qitmask1.html" title="A small but extremely fast &quot;base 4 bitmask&quot; class that can store up to 8 * sizeof(T) &quot;qits&quot;,...">Qitmask1</a>.</p>
<p >The particular instantiation is subject to change between different platforms, different compilers and/or different versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000217">Deprecated:</a></b></dt><dd>This type alias is deprecated; just use Qitmask1&lt;uint8_t&gt; instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but in Python you can access essentially the same optimised qitmask class via the name Qitmask8. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga47d6c710ee070d88c4b670b48bec3878" name="ga47d6c710ee070d88c4b670b48bec3878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d6c710ee070d88c4b670b48bec3878">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and passes back a newly allocated array containing the results. </p>
<p >The <em>out</em> pointer will be set to this new array, and <em>outlen</em> will be set to the number of raw bytes in this output array. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p >The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p >The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found or the output buffer is exhausted, this routine will return <code>false</code>, set <em>out</em> to <code>null</code>, and leave <em>outlen</em> undefined. Otherwise (on success) it will return <code>true</code> and set <em>outlen</em> to the total number of output bytes.</p>
<p >If the user is not interested in the length of the output array, a null pointer may be passed in the <em>outlen</em> argument. Note however that the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 decoding routines are made available to Python in the form <code>base64Decode(input_string)</code>. In Python 3, this routine takes a base64 string as input and returns a Python <code>bytes</code> object; in Python 2 it takes a base64 string as input and returns a string of bytes. You do not need to supply any input or output buffer lengths. If the decoding is unsuccessful, this routine will return <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of raw bytes (or which will be set to <code>null</code> on failure). </td></tr>
    <tr><td class="paramname">outlen</td><td>the address of an integer which will be set to the length of the output array (or which will be left undefined on failure). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if an unexpected input character was found or some other error occurred.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga6811ec511cb61bfc071467ba5d0e8076" name="ga6811ec511cb61bfc071467ba5d0e8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6811ec511cb61bfc071467ba5d0e8076">&#9670;&nbsp;</a></span>base64Decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::base64Decode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes the given sequence of base64 characters, and writes the resulting raw bytes into a preallocated output buffer. </p>
<p >The given base64 sequence should not contain any unexpected characters; even whitespace will cause the decoding procedure to abort.</p>
<p >The length of the output buffer is passed as the argument <em>outlen</em>. If an unexpected or invalid character is found, or the output buffer is exhausted, this routine will write as many output bytes as it can and then return <code>false</code>. Otherwise (on success) it will return <code>true</code>. Either way, it will reset <em>outlen</em> to the total number of bytes that were written.</p>
<p >The total number of output bytes is important to know, since the output array is not terminated in any special way.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 decoding routines are made available to Python in the form <code>base64Decode(input_string)</code>. In Python 3, this routine takes a base64 string as input and returns a Python <code>bytes</code> object; in Python 2 it takes a base64 string as input and returns a string of bytes. You do not need to supply any input or output buffer lengths. If the decoding is unsuccessful, this routine will return <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input sequence of base64 characters; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting raw bytes will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>must contain the length of the output buffer on entry, and on exit contains the number of output bytes that were successfully written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if decoding was successful, or <code>false</code> if the output buffer was exhausted or an unexpected input character was found.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga541f612d6bb0f94db16da14169813e29" name="ga541f612d6bb0f94db16da14169813e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga541f612d6bb0f94db16da14169813e29">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing the results. </p>
<p >The <em>out</em> pointer will be set to this new array, which will be null-terminated. This array will be allocated using <code>new</code>[], and the caller is responsible for destroying it using <code>delete</code>[].</p>
<p >If the output array is too large (in particular, the expected size will overflow a <code>size_t</code>), the <em>out</em> pointer will be set to <code>null</code>.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 encoding routines are made available to Python in the form <code>base64Encode(input_bytes)</code>. In Python 3, this routine takes a single Python <code>bytes</code> object as input and returns a string; in Python 2 it takes the input bytes as a byte string and returns a unicode string. You do not need to supply any input or output buffer lengths.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the address of a pointer which will be set to the output array of base64 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the output array, not counting the terminating null.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="ga081d322bec8070a889aba14d5988ae80" name="ga081d322bec8070a889aba14d5988ae80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081d322bec8070a889aba14d5988ae80">&#9670;&nbsp;</a></span>base64Encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::base64Encode </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the given sequence of raw bytes in base64, and writes the results into a preallocated output buffer. </p>
<p >The length of the output buffer is passed as the argument <em>outlen</em>. If the number of base64 characters required is less than <em>outlen</em>, a terminating <code>null</code> will be written to the end of the output sequence. If the number of base64 characters is <em>outlen</em> or greater, this routine will output as many base64 characters as possible, up to a maximum of <em>outlen</em>.</p>
<p >The routine <a class="el" href="group__utilities.html#gaa8d632b73943b5c52e395d56f8e03af2" title="Returns the number of base64 characters required to encode the given number of bytes.">base64Length()</a> can be used to precalculate precisely how many output characters will be required.</p>
<dl class="section user"><dt>Python</dt><dd>These base64 encoding routines are made available to Python in the form <code>base64Encode(input_bytes)</code>. In Python 3, this routine takes a single Python <code>bytes</code> object as input and returns a string; in Python 2 it takes the input bytes as a byte string and returns a unicode string. You do not need to supply any input or output buffer lengths.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the sequence of input bytes; this does not need to be terminated in any special way. </td></tr>
    <tr><td class="paramname">inlen</td><td>the length of the input sequence. </td></tr>
    <tr><td class="paramname">out</td><td>the output buffer into which the resulting base64 characters will be written. </td></tr>
    <tr><td class="paramname">outlen</td><td>the length of the output buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>This routine is based on the <em>Base64</em> project at base64.sourceforge.net. The original was written by Bob Trower, and is licensed under the MIT license. See the <a class="el" href="base64_8h.html" title="Routines for base64 encoding and decoding taken and modified from the Base64 project at base64....">base64.h</a> notes for details. </dd></dl>

</div>
</div>
<a id="gaa8d632b73943b5c52e395d56f8e03af2" name="gaa8d632b73943b5c52e395d56f8e03af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8d632b73943b5c52e395d56f8e03af2">&#9670;&nbsp;</a></span>base64Length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::base64Length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of base64 characters required to encode the given number of bytes. </p>
<p >This is the number of characters used (excluding the null terminator) by the routine <a class="el" href="group__utilities.html#ga541f612d6bb0f94db16da14169813e29" title="Encodes the given sequence of raw bytes in base64, and passes back a newly allocated array containing...">base64Encode(const char*, size_t, char**)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>the number of raw input bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding number of base64 printable output characters. </dd></dl>

</div>
</div>
<a id="ga829779c4fa33b63924f584c933314229" name="ga829779c4fa33b63924f584c933314229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829779c4fa33b63924f584c933314229">&#9670;&nbsp;</a></span>basicTokenise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; regina::basicTokenise </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decomposes the given string into tokens. </p>
<p >This is an extremely simple tokeniser; tokens are defined to be separated by arbitrary blocks of whitespace. Any leading or trailing whitespace will be ignored.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to decompose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting list of tokens. </dd></dl>

</div>
</div>
<a id="ga032b26a588e2bdbcc5a74e05f8c37fa9" name="ga032b26a588e2bdbcc5a74e05f8c37fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032b26a588e2bdbcc5a74e05f8c37fa9">&#9670;&nbsp;</a></span>basicTokenise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::basicTokenise </td>
          <td>(</td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine to decompose a string into tokens. </p>
<p >This is an extremely simple tokeniser; tokens are defined to be separated by arbitrary blocks of whitespace. Any leading or trailing whitespace will be ignored.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000222">Deprecated:</a></b></dt><dd>This routine has been rewritten to return the list of tokens as a std::vector. Use that variant of <a class="el" href="group__utilities.html#ga829779c4fa33b63924f584c933314229" title="Decomposes the given string into tokens.">basicTokenise()</a> instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present; instead use the one-argument variant of <a class="el" href="group__utilities.html#ga829779c4fa33b63924f584c933314229" title="Decomposes the given string into tokens.">basicTokenise()</a>, which returns the list of tokens.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">results</td><td>the output iterator to which the resulting tokens will be written; this must accept objects of type <code>const std::string&amp;</code>. </td></tr>
    <tr><td class="paramname">str</td><td>the string to decompose. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tokens found. </dd></dl>

</div>
</div>
<a id="gaf3cfd88109df8473b8ae9647ff96d35a" name="gaf3cfd88109df8473b8ae9647ff96d35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3cfd88109df8473b8ae9647ff96d35a">&#9670;&nbsp;</a></span>bitsRequired()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int regina::bitsRequired </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bits required to store integers in the range 0,...,<em>n</em>-1. </p>
<p >This is simply the number of bits in the binary expansion of <em>n</em>-1.</p>
<p >If <em>n</em> is non-positive then this function will return 0.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bits required to store 0,...,<em>n</em>-1.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga231a1c1fdf6cc37e09fbc77ea2cf14ce" name="ga231a1c1fdf6cc37e09fbc77ea2cf14ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga231a1c1fdf6cc37e09fbc77ea2cf14ce">&#9670;&nbsp;</a></span>isBase64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::isBase64 </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given character is a base64 printable character as used by the base64 routines in Regina. </p>
<p >The base64 printable characters are the letters (both upper-case and lower-case), digits, plus (+), and forward slash (/).</p>
<p >Note that the equals sign (=) is padding, and is not considered by this routine to be a base64 printable character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>any character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given character is one of the base64 printable characters used in Regina, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a id="gaf8ad7790348b617ffd8fdf50736cd9cf" name="gaf8ad7790348b617ffd8fdf50736cd9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8ad7790348b617ffd8fdf50736cd9cf">&#9670;&nbsp;</a></span>nextPowerOfTwo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr IntType regina::nextPowerOfTwo </td>
          <td>(</td>
          <td class="paramtype">IntType&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest integer power of two that is greater than or equal to the given argument <em>n</em>. </p>
<p >If <em>n</em> is non-positive then this function will return 1.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine fixes the integer type <em>IntType</em> to be <code>long</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Even though the return value is the same type as the argument <em>n</em>, this routine may still overflow. For example, if <em>IntType</em> is a signed char then nextPowerOfTwo(127) will return -128, and if <em>IntType</em> is an unsigned char then nextPowerOfTwo(255) will return 0. Be sure that <em>IntType</em> is large enough for your requirements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>any integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest integer power of two that is &ge; <em>n</em>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntType</td><td>any integer type, such as <code>int</code>, <code>long</code>, and so on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53b5c83676706821d636840cc976aecf" name="ga53b5c83676706821d636840cc976aecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b5c83676706821d636840cc976aecf">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given boolean set to the given output stream. </p>
<p >The set will be written in the form <code>{ true, false }</code>, <code>{ true }</code>, <code>{ false }</code> or <code>{ }</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">set</td><td>the boolean set to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga687edae41955adbcf9e58c8cce90ea68" name="ga687edae41955adbcf9e58c8cce90ea68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687edae41955adbcf9e58c8cce90ea68">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p >Since the length of the bitmask is not stored, the number of bits written might be greater than the length initially assigned to this bitmask (specifically, the length will be rounded up to the next "raw
unit of storage").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gae2309e18138c1e4d8166a47a4408bdc4" name="gae2309e18138c1e4d8166a47a4408bdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2309e18138c1e4d8166a47a4408bdc4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask1.html">Bitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p >Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gab3a859bcdb5958b927015eed8e033527" name="gab3a859bcdb5958b927015eed8e033527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a859bcdb5958b927015eed8e033527">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask2.html">Bitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p >Since the length of the bitmask is not stored, the number of bits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gaa0c5c9157147686a6bfc401312b8d90c" name="gaa0c5c9157147686a6bfc401312b8d90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c5c9157147686a6bfc401312b8d90c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given sequence to the given output stream. </p>
<p >No newline will be written.</p>
<p >The sequence will be written in the form <code>(a, b, c, ...)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>An object <em>x</em> of type <em>T</em> can be written to an output stream using the syntax <code>out &lt;&lt; x</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">s</td><td>the sequence to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga45b4d5d732453f12f636c552435e605d" name="ga45b4d5d732453f12f636c552435e605d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45b4d5d732453f12f636c552435e605d">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask1.html">Qitmask1</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p >Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gae31ecb27359bcdae0607c56c834f5269" name="gae31ecb27359bcdae0607c56c834f5269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae31ecb27359bcdae0607c56c834f5269">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Qitmask2.html">Qitmask2</a>&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given qitmask to the given output stream as a sequence of digits (0, 1, 2 and/or 3). </p>
<p >Since the length of the qitmask is not stored, the number of qits written will be 8 * sizeof(<em>T</em>) + 8 * sizeof(<em>U</em>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the qitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga6fcd763de878bdad5baf8c67406e0236" name="ga6fcd763de878bdad5baf8c67406e0236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fcd763de878bdad5baf8c67406e0236">&#9670;&nbsp;</a></span>resUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; unsigned long, unsigned long, unsigned long &gt; regina::resUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns time and memory usage for the current process, for use on Linux systems. </p>
<p >Information is gathered from the <code>/proc</code> filesystem; if this is run on a non-Linux system (or a Linux system where <code>/proc</code> is not mounted), then this routine will throw an exception.</p>
<p >More precisely, this routine reads information on the running process from <code>/proc/self/stat</code>, and returns a tuple (<em>utime</em>, <em>stime</em>, <em>vsize</em>). These three fields reperesent:</p>
<ul>
<li>the number jiffies that this process has been scheduled in user mode (the <em>utime</em> field);</li>
<li>the number jiffies that this process has been scheduled in kernel mode (the <em>stime</em> field);</li>
<li>the the virtual memory size in bytes (the <em>vsize</em> field).</li>
</ul>
<p >The description of these three fields is taken directly from the <code>proc(5)</code> manpage. Note that the length of a jiffy can differ from system to system; see the <code>time(7)</code> manpage for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FileError.html" title="An exception thrown when trying to access data from the filesystem.">FileError</a></td><td>Either <code>/proc/self/stat</code> cannot be read, or it contains unexpected information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Currently this routine allows at most 255 characters for the <em>comm</em> field in <code>/proc/self/stat</code> (which stores the executable filename along with surrounding parentheses). If the <em>comm</em> field is too long (i.e., the executable filename is too long), then this routine will not be able to parse <code>/proc/self/stat</code>, and will throw an exception. If you encounter this problem, you should be able to fix it by renaming your executable to something shorter. </dd></dl>

</div>
</div>
<a id="ga4056bad007750e92b40959aca2c4f987" name="ga4056bad007750e92b40959aca2c4f987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4056bad007750e92b40959aca2c4f987">&#9670;&nbsp;</a></span>startsWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::startsWith </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given C++ string begins with the given prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the full C++ string to examine. </td></tr>
    <tr><td class="paramname">prefix</td><td>the prefix whose presence we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>str</em> begins with <em>prefix</em>. </dd></dl>

</div>
</div>
<a id="gae5114cac055c590a0239b7b34b94458d" name="gae5114cac055c590a0239b7b34b94458d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5114cac055c590a0239b7b34b94458d">&#9670;&nbsp;</a></span>stringToToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stringToToken </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a token derived from the given string. </p>
<p >All whitespace characters in the given string will be replaced with an underscore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string on which to base the token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding token. </dd></dl>

</div>
</div>
<a id="gaa678d35fabfebccce72406d01076829c" name="gaa678d35fabfebccce72406d01076829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa678d35fabfebccce72406d01076829c">&#9670;&nbsp;</a></span>stripWhitespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::stripWhitespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strips all whitespace from the beginning and end of the given C++ string. </p>
<p >The new stripped string is returned; the original string is not altered.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine treats all strings as plain ASCII. In particular, characters are examined one at a time, and the C routine isspace() is used to identify whitespace. Use it on strings with international characters at your own peril.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to be stripped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting stripped string. </dd></dl>

</div>
</div>
<a id="ga61ea966075c340b411ef07cc5aee1213" name="ga61ea966075c340b411ef07cc5aee1213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ea966075c340b411ef07cc5aee1213">&#9670;&nbsp;</a></span>subscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::subscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode subscript string. </p>
<p >The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="ga92f5f4f8be21a36101e67ed4b461ba19" name="ga92f5f4f8be21a36101e67ed4b461ba19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92f5f4f8be21a36101e67ed4b461ba19">&#9670;&nbsp;</a></span>superscript()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::superscript </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given C++ integer into a unicode superscript string. </p>
<p >The resulting string will be encoded using UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>T</em> is either (i) a native C++ integer type, for which the standard C++11 library routine std::to_string(T) is defined; or (ii) a const reference to Integer or LargeInteger.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This template function is instantiated in Python for types <em>T</em> = <code>long</code>, as well as const references to Integer and LargeInteger. </dd></dl>

</div>
</div>
<a id="ga242c17df8901ed6224a6741ad945cf46" name="ga242c17df8901ed6224a6741ad945cf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga242c17df8901ed6224a6741ad945cf46">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given bitmasks. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1Bitmask.html#a3d96fef8bfbe92fc6574be2b741143fb" title="Swaps the contents of this and the given bitmask.">Bitmask::swap()</a>; it is provided so that <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a> meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first bitmask whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second bitmask whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c2e72a3a85bfa1503a0e934497dca69" name="ga7c2e72a3a85bfa1503a0e934497dca69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c2e72a3a85bfa1503a0e934497dca69">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1LightweightSequence.html">LightweightSequence</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given sequences. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1LightweightSequence.html#a4b58379dc15318fef2effed7ec54a256" title="Swaps the contents of this and the given sequence.">LightweightSequence&lt;T&gt;::swap()</a>; it is provided so that LightweightSequence&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first sequence whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second sequence whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97cb08c9668a04e355a26fd30afdeb52" name="ga97cb08c9668a04e355a26fd30afdeb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97cb08c9668a04e355a26fd30afdeb52">&#9670;&nbsp;</a></span>swap() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the given vectors. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1MarkedVector.html#a1dd05a3f81ded7aa92ee43d062f9dd03" title="Swaps the contents of this and the given vector.">MarkedVector&lt;T&gt;::swap()</a>; it is provided so that MarkedVector&lt;T&gt; meets the C++ Swappable requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first vector whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second vector whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66f73edd06b7cc0e066e11c1d8ea35c8" name="ga66f73edd06b7cc0e066e11c1d8ea35c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66f73edd06b7cc0e066e11c1d8ea35c8">&#9670;&nbsp;</a></span>swap() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the given references so that they refer to each others' snapshots. </p>
<p >This global routine simply calls <a class="el" href="classregina_1_1SnapshotRef.html#a6be79e7f767935ecbb71de226b63049a" title="Swaps this and the given reference so that they refer to each others&#39; snapshots.">SnapshotRef&lt;T&gt;::swap()</a>; it is provided so that SnapshotRef&lt;T&gt; meets the C++ Swappable requirements.</p>
<p >See the <a class="el" href="classregina_1_1Snapshot.html" title="Keeps a snapshot of an object of type T as it was at a particular moment in time.">Snapshot</a> documentation for a full explanation of how Regina's snapshotting machinery works.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first snapshot reference to swap. </td></tr>
    <tr><td class="paramname">b</td><td>the second snapshot reference to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4edb9a7b2681015b7a294f9f323c30b1" name="ga4edb9a7b2681015b7a294f9f323c30b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4edb9a7b2681015b7a294f9f323c30b1">&#9670;&nbsp;</a></span>swap() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of the two given collections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>the first collection of sets whose contents should be swapped. </td></tr>
    <tr><td class="paramname">b</td><td>the second collection of sets whose contents should be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3071be3bed13d0057ebe344aab4ed4ef" name="ga3071be3bed13d0057ebe344aab4ed4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3071be3bed13d0057ebe344aab4ed4ef">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given signed integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82" title="Returns the tight encoding of the given signed integer.">regina::tightEncoding(int)</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3db618c87ebf51d61009cc98c3cef150" name="ga3db618c87ebf51d61009cc98c3cef150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3db618c87ebf51d61009cc98c3cef150">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given signed long long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gac847807974dbe589cfc57056a236cd46" title="Returns the tight encoding of the given signed long long integer.">regina::tightEncoding(long long)</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafc77642572c2f8eea1818db38b28de2b" name="gafc77642572c2f8eea1818db38b28de2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc77642572c2f8eea1818db38b28de2b">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given signed long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58" title="Returns the tight encoding of the given signed long integer.">regina::tightEncoding(long)</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadfd99d3c0d21833b55a4af77736092d" name="gaadfd99d3c0d21833b55a4af77736092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadfd99d3c0d21833b55a4af77736092d">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given unsigned long long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gac847807974dbe589cfc57056a236cd46" title="Returns the tight encoding of the given signed long long integer.">regina::tightEncoding(long long)</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56176c1b2cedb9dcf027c7cf88907806" name="ga56176c1b2cedb9dcf027c7cf88907806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56176c1b2cedb9dcf027c7cf88907806">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given unsigned long integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gae5d43fc580edb50fb9a0756a1ffedb58" title="Returns the tight encoding of the given signed long integer.">regina::tightEncoding(long)</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf00bbae1e4f050d67575a68752b4018f" name="gaf00bbae1e4f050d67575a68752b4018f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf00bbae1e4f050d67575a68752b4018f">&#9670;&nbsp;</a></span>tightEncode() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of the given unsigned integer to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="group__utilities.html#gad04ee6a550c68d8d29b2c1eb35d4bc82" title="Returns the tight encoding of the given signed integer.">regina::tightEncoding(int)</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12ac49ef48ad51831f09c40a326fcce9" name="ga12ac49ef48ad51831f09c40a326fcce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12ac49ef48ad51831f09c40a326fcce9">&#9670;&nbsp;</a></span>tightEncodeInteger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::detail::tightEncodeInteger </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function that writes the tight encoding of the given integer to the given output stream. </p>
<p >This should not be called directly; its purpose is to provide a common implementation for <a class="el" href="group__maths.html#gae8cd5c004f47461d75f07d3696fa855a" title="Writes the tight encoding of the given arbitrary precision integer to the given output stream.">tightEncode()</a> and <a class="el" href="group__maths.html#gaed202995c74bfebb0d60b38044dfd2b5" title="Returns the tight encoding of the given arbitrary precision integer.">tightEncoding()</a> for all integer types.</p>
<p >This routine does support passing infinity as the given value (which is only relevant when the integer type <em>Int</em> is <a class="el" href="group__maths.html#ga952eff9b22eb6c0f2b1d8a5f6d2a3b76" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use regina::tightEncoding(...) instead.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Int</td><td>The type of integer to encode; this must be either (i) a native C++ integer type, or (ii) one of Regina's arbitrary precision integer types (i.e., <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a> or <a class="el" href="group__maths.html#ga952eff9b22eb6c0f2b1d8a5f6d2a3b76" title="LargeInteger is a type alias for IntegerBase&lt;true&gt;, which offers arbitrary precision integers with su...">regina::LargeInteger</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad04ee6a550c68d8d29b2c1eb35d4bc82" name="gad04ee6a550c68d8d29b2c1eb35d4bc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04ee6a550c68d8d29b2c1eb35d4bc82">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given signed integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gac847807974dbe589cfc57056a236cd46" name="gac847807974dbe589cfc57056a236cd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac847807974dbe589cfc57056a236cd46">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given signed long long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gae5d43fc580edb50fb9a0756a1ffedb58" name="gae5d43fc580edb50fb9a0756a1ffedb58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d43fc580edb50fb9a0756a1ffedb58">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given signed long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gab1ddfa37a33307ca03dcb087da759280" name="gab1ddfa37a33307ca03dcb087da759280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1ddfa37a33307ca03dcb087da759280">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given unsigned long long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="gaf1c703c35095c4407b987054ec056cc7" name="gaf1c703c35095c4407b987054ec056cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1c703c35095c4407b987054ec056cc7">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given unsigned long integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ga5dd29cdddc4af9b3dbd98fd08badbc2a" name="ga5dd29cdddc4af9b3dbd98fd08badbc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd29cdddc4af9b3dbd98fd08badbc2a">&#9670;&nbsp;</a></span>tightEncoding() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::tightEncoding </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of the given unsigned integer. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the integer to encode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ga91eb70b23252b007d149e269b1afb973" name="ga91eb70b23252b007d149e269b1afb973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91eb70b23252b007d149e269b1afb973">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p >The substring from <em>s</em> until just before the pointer that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return a pointer to the null terminator of <em>s</em>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="gad3439925c61c42453159e0b50bdff960" name="gad3439925c61c42453159e0b50bdff960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3439925c61c42453159e0b50bdff960">&#9670;&nbsp;</a></span>utf8ValidTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string::const_iterator regina::i18n::utf8ValidTo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the longest prefix of the given string that is valid UTF-8. </p>
<p >The substring from <code>s.begin()</code> to the iterator that is returned is guaranteed to be valid UTF-8. If the entire string is valid UTF-8, then this routine will return <code>s.end()</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns the <em>length</em> of the longest valid UTF-8 prefix. The length is measured in raw bytes (not unicode characters).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator marking the end of the longest valid UTF-8 prefix. </dd></dl>

</div>
</div>
<a id="ga17e706f7f722922798776b74f9933bd0" name="ga17e706f7f722922798776b74f9933bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17e706f7f722922798776b74f9933bd0">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a boolean and reports whether this conversion was successful. </p>
<p >If the given string begins with <code>T</code>, <code>t</code> or <code>1</code>, then the string will be successfully converted to <code>true</code>. If the given string begins with <code>F</code>, <code>f</code> or <code>0</code>, then the string will be successfully converted to <code>false</code>. Otherwise the conversion will be unsuccessful and argument <em>dest</em> will be set to <code>false</code>.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting boolean. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6083d66d2dcac7dce8637e6282c6c679" name="ga6083d66d2dcac7dce8637e6282c6c679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6083d66d2dcac7dce8637e6282c6c679">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a set of booleans and reports whether this conversion was successful. </p>
<p >A set of booleans is represented by one of the four string codes <code>&ndash;</code>, <code>T-</code>, <code>-F</code> or <code>TF</code>, as returned by <a class="el" href="classregina_1_1BoolSet.html#a9304c4a54cdd030b77eb8a8cd283fae3" title="Returns the string code representing this boolean set.">BoolSet::stringCode()</a>. If the conversion is unsuccessful, argument <em>dest</em> will be set to the empty set and <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, since none of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are available to Python. Instead you can use <a class="el" href="classregina_1_1BoolSet.html#a6081f30003ede42f4ce3d4e053f80e74" title="Sets this to be the boolean set represented by the given string code.">BoolSet::setStringCode()</a>, which performs the same task (with the minor difference that it does not change <em>dest</em> if the conversion is unsuccessful).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting set of booleans. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6d3266c3fb5264747ed7af53464ac7a9" name="ga6d3266c3fb5264747ed7af53464ac7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d3266c3fb5264747ed7af53464ac7a9">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a double precision real number and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the real number that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting real number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga896ae2c6783d6d6dc4081bddabb22518" name="ga896ae2c6783d6d6dc4081bddabb22518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896ae2c6783d6d6dc4081bddabb22518">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gae40c2e62bf0908919834ea10762def19" name="gae40c2e62bf0908919834ea10762def19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40c2e62bf0908919834ea10762def19">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an 8-bit integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4c91417b8ffbca35aa32c82532f5330f" name="ga4c91417b8ffbca35aa32c82532f5330f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c91417b8ffbca35aa32c82532f5330f">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool supportInfinity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1IntegerBase.html">IntegerBase</a>&lt; supportInfinity &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that converts the entire given string to an arbitrary precision integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000221">Deprecated:</a></b></dt><dd>Simply use the string constructor or string assignment operator for Integer / LargeInteger (but note that these throw exceptions on error).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present; instead use the Integer / LargeInteger string constructor as noted above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting arbitrary precision integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaad0bb367f8c8f4172e6a979751907c6c" name="gaad0bb367f8c8f4172e6a979751907c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad0bb367f8c8f4172e6a979751907c6c">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gacd5eebbe6059d16231b0e41966e2056a" name="gacd5eebbe6059d16231b0e41966e2056a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd5eebbe6059d16231b0e41966e2056a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a long long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga384de19626353085bf20eedc89c3c30a" name="ga384de19626353085bf20eedc89c3c30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga384de19626353085bf20eedc89c3c30a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to a short integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaf9eaa1f183454edc0db4f915d98c0a73" name="gaf9eaa1f183454edc0db4f915d98c0a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9eaa1f183454edc0db4f915d98c0a73">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned 8-bit integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned 8-bit integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga974a77f98013a0274540b1d0b06519f3" name="ga974a77f98013a0274540b1d0b06519f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974a77f98013a0274540b1d0b06519f3">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga007abfa18426eedc6277f644ded3e068" name="ga007abfa18426eedc6277f644ded3e068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga007abfa18426eedc6277f644ded3e068">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad0bc034686407302e3ad597e39933a99" name="gad0bc034686407302e3ad597e39933a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0bc034686407302e3ad597e39933a99">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned long long integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned long long integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga183ba5dd849f33e9153c3363323abf5a" name="ga183ba5dd849f33e9153c3363323abf5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga183ba5dd849f33e9153c3363323abf5a">&#9670;&nbsp;</a></span>valueOf() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::valueOf </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the entire given string to an unsigned short integer and reports whether this conversion was successful. </p>
<p >The given string should contain no whitespace or other characters that are not a part of the integer that the string represents. If any unexpected characters are encountered, the routine will convert the string as best it can but <code>false</code> will be returned.</p>
<dl class="section user"><dt>Python</dt><dd>None of Regina's <a class="el" href="group__utilities.html#gae40c2e62bf0908919834ea10762def19" title="Converts the entire given string to an 8-bit integer and reports whether this conversion was successf...">valueOf()</a> functions are wrapped in Python, since these tailored to the many different native C++ numeric types. Instead, use Python's own native string-to-number mechanisms.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to convert. </td></tr>
    <tr><td class="paramname">dest</td><td>the variable in which to store the resulting unsigned short integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the conversion was completely successful or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga6d9135c01a79c7fcfa32caafd8bb4652" name="ga6d9135c01a79c7fcfa32caafd8bb4652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9135c01a79c7fcfa32caafd8bb4652">&#9670;&nbsp;</a></span>xmlEncodeComment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeComment </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>comment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given string encoded so it is suitable for use inside an XML comment. </p>
<p >As well as converting special characters to XML entities, this routine will replace dashes with underscores to avoid double-hyphens (which are illegal in XML comments).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comment</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string converted to be usable inside an XML comment. </dd></dl>

</div>
</div>
<a id="ga3a9273b1e8e9c18b33d73012b77c1b3f" name="ga3a9273b1e8e9c18b33d73012b77c1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a9273b1e8e9c18b33d73012b77c1b3f">&#9670;&nbsp;</a></span>xmlEncodeSpecialChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlEncodeSpecialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the given string with special characters converted to XML entities. </p>
<p >For instance, the string <code>"a \&lt; b"</code> would be converted to <code>"a \&amp;lt; b"</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the string to convert; this string will not be changed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted string with special characters replaced by XML entities. </dd></dl>

</div>
</div>
<a id="gacb9d9d42e182de0dc67e4176414cb07d" name="gacb9d9d42e182de0dc67e4176414cb07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9d9d42e182de0dc67e4176414cb07d">&#9670;&nbsp;</a></span>xmlValueTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::xml::xmlValueTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an XML tag with a single property containing the given value. </p>
<p >The tag will be of the form <code>&lt;tagName value="..."/&gt;</code>.</p>
<p >The value itself will be written to the tag string using the standard output stream operator &lt;&lt;.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The property value when written to an output stream does not contain any special characters (such as <code>&lt;</code> or <code>&amp;</code>) that need to be encoded as XML entities.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the XML tag to create. </td></tr>
    <tr><td class="paramname">value</td><td>the value to assign to the <em>value</em> property of the tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding XML tag. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga3657172c4ecb2d7217bd5220b83cf41f" name="ga3657172c4ecb2d7217bd5220b83cf41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3657172c4ecb2d7217bd5220b83cf41f">&#9670;&nbsp;</a></span>base64Spare</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char regina::base64Spare[] = &quot;_-.&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table of printable characters that are <em>not</em> amongst the base64 printable characters used by Regina. </p>
<p >These characters could be used (for example) to mark the boundaries of base64 blocks.</p>
<p >These characters are presented as a string of length at least 3. Future versions of Regina may append new characters to the end of this string, but the existing characters base64Spare[0], base64Spare[1], etc. will not change. </p>

</div>
</div>
<a id="ga5616d8b8cc6091811f09782f0dad6449" name="ga5616d8b8cc6091811f09782f0dad6449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5616d8b8cc6091811f09782f0dad6449">&#9670;&nbsp;</a></span>base64Table</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr char regina::base64Table[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <span class="stringliteral">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></div>
</div><!-- fragment -->
<p>The table of all base64 printable characters, as used by the base64 routines in Regina. </p>
<p >This is the translation table as described in RFC1113. It is presented as a string of length 64. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
