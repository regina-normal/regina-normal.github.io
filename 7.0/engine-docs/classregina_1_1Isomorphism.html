<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: regina::Isomorphism&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1Isomorphism-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Isomorphism&lt; dim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__generic.html">Generic triangulations</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a combinatorial isomorphism from one <em>dim</em>-manifold triangulation into another.  
 <a href="classregina_1_1Isomorphism.html#details">More...</a></p>

<p><code>#include &lt;triangulation/generic.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Isomorphism&lt; dim &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Isomorphism.png" usemap="#regina::Isomorphism_3C_20dim_20_3E_map" alt=""/>
  <map id="regina::Isomorphism_3C_20dim_20_3E_map" name="regina::Isomorphism_3C_20dim_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Isomorphism&lt; dim &gt; &gt;" shape="rect" coords="0,0,352,24"/>
<area href="classregina_1_1alias_1_1IsomorphismImage.html" alt="regina::alias::IsomorphismImage&lt; Isomorphism&lt; dim &gt;, dim &gt;" shape="rect" coords="362,0,714,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ada62164849890b968650046b715e9f69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#ada62164849890b968650046b715e9f69">Isomorphism</a> (unsigned nSimplices)</td></tr>
<tr class="memdesc:ada62164849890b968650046b715e9f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new isomorphism with no initialisation.  <a href="classregina_1_1Isomorphism.html#ada62164849890b968650046b715e9f69">More...</a><br /></td></tr>
<tr class="separator:ada62164849890b968650046b715e9f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9f2112ee5058c263535563715c585e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a8f9f2112ee5058c263535563715c585e">Isomorphism</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;src)</td></tr>
<tr class="memdesc:a8f9f2112ee5058c263535563715c585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given isomorphism.  <a href="classregina_1_1Isomorphism.html#a8f9f2112ee5058c263535563715c585e">More...</a><br /></td></tr>
<tr class="separator:a8f9f2112ee5058c263535563715c585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a8b6612fe01e4ecc8bfad1423898c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#ad3a8b6612fe01e4ecc8bfad1423898c8">Isomorphism</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ad3a8b6612fe01e4ecc8bfad1423898c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given isomorphism into this new isomorphism.  <a href="classregina_1_1Isomorphism.html#ad3a8b6612fe01e4ecc8bfad1423898c8">More...</a><br /></td></tr>
<tr class="separator:ad3a8b6612fe01e4ecc8bfad1423898c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99cf1afeffd310db7d7ca89d19b2437"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#ac99cf1afeffd310db7d7ca89d19b2437">~Isomorphism</a> ()</td></tr>
<tr class="memdesc:ac99cf1afeffd310db7d7ca89d19b2437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this isomorphism.  <a href="classregina_1_1Isomorphism.html#ac99cf1afeffd310db7d7ca89d19b2437">More...</a><br /></td></tr>
<tr class="separator:ac99cf1afeffd310db7d7ca89d19b2437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdfca99e94446a343b101ec6331f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#aadbdfca99e94446a343b101ec6331f77">operator=</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;src)</td></tr>
<tr class="memdesc:aadbdfca99e94446a343b101ec6331f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given isomorphism into this isomorphism.  <a href="classregina_1_1Isomorphism.html#aadbdfca99e94446a343b101ec6331f77">More...</a><br /></td></tr>
<tr class="separator:aadbdfca99e94446a343b101ec6331f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4812ece221766e1dfd2cca99f007f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a0a4812ece221766e1dfd2cca99f007f5">operator=</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a0a4812ece221766e1dfd2cca99f007f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given isomorphism into this isomorphism.  <a href="classregina_1_1Isomorphism.html#a0a4812ece221766e1dfd2cca99f007f5">More...</a><br /></td></tr>
<tr class="separator:a0a4812ece221766e1dfd2cca99f007f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add60c472f78f9fbabaa4990bcea77d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#add60c472f78f9fbabaa4990bcea77d4b">swap</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:add60c472f78f9fbabaa4990bcea77d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given isomorphism.  <a href="classregina_1_1Isomorphism.html#add60c472f78f9fbabaa4990bcea77d4b">More...</a><br /></td></tr>
<tr class="separator:add60c472f78f9fbabaa4990bcea77d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99087d3e4963b6d8bace0dbb29dbcd85"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85">size</a> () const</td></tr>
<tr class="memdesc:a99087d3e4963b6d8bace0dbb29dbcd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simplices in the source triangulation associated with this isomorphism.  <a href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85">More...</a><br /></td></tr>
<tr class="separator:a99087d3e4963b6d8bace0dbb29dbcd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf291b695f240016a023cc055f248530"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#acf291b695f240016a023cc055f248530">simpImage</a> (unsigned sourceSimp)</td></tr>
<tr class="memdesc:acf291b695f240016a023cc055f248530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex under this isomorphism.  <a href="classregina_1_1Isomorphism.html#acf291b695f240016a023cc055f248530">More...</a><br /></td></tr>
<tr class="separator:acf291b695f240016a023cc055f248530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac9a103114e81dc510a034230b4bca6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a1ac9a103114e81dc510a034230b4bca6">simpImage</a> (unsigned sourceSimp) const</td></tr>
<tr class="memdesc:a1ac9a103114e81dc510a034230b4bca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex under this isomorphism.  <a href="classregina_1_1Isomorphism.html#a1ac9a103114e81dc510a034230b4bca6">More...</a><br /></td></tr>
<tr class="separator:a1ac9a103114e81dc510a034230b4bca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bebdc5fb3c1f7e9abe69da675119cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a77bebdc5fb3c1f7e9abe69da675119cb">facetPerm</a> (unsigned sourceSimp)</td></tr>
<tr class="memdesc:a77bebdc5fb3c1f7e9abe69da675119cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism.  <a href="classregina_1_1Isomorphism.html#a77bebdc5fb3c1f7e9abe69da675119cb">More...</a><br /></td></tr>
<tr class="separator:a77bebdc5fb3c1f7e9abe69da675119cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ca925b9f251eef0fe07287f9de736f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a44ca925b9f251eef0fe07287f9de736f">facetPerm</a> (unsigned sourceSimp) const</td></tr>
<tr class="memdesc:a44ca925b9f251eef0fe07287f9de736f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism.  <a href="classregina_1_1Isomorphism.html#a44ca925b9f251eef0fe07287f9de736f">More...</a><br /></td></tr>
<tr class="separator:a44ca925b9f251eef0fe07287f9de736f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b5f3b813d309d8e0b91e347635e163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#af6b5f3b813d309d8e0b91e347635e163">operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:af6b5f3b813d309d8e0b91e347635e163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex facet under this isomorphism.  <a href="classregina_1_1Isomorphism.html#af6b5f3b813d309d8e0b91e347635e163">More...</a><br /></td></tr>
<tr class="separator:af6b5f3b813d309d8e0b91e347635e163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880e50ac413fde3e237c905aa210afca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a880e50ac413fde3e237c905aa210afca">isIdentity</a> () const</td></tr>
<tr class="memdesc:a880e50ac413fde3e237c905aa210afca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this is an identity isomorphism.  <a href="classregina_1_1Isomorphism.html#a880e50ac413fde3e237c905aa210afca">More...</a><br /></td></tr>
<tr class="separator:a880e50ac413fde3e237c905aa210afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e2d651969d2a00a13acdec2137a3bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#ad5e2d651969d2a00a13acdec2137a3bb">apply</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;original) const</td></tr>
<tr class="memdesc:ad5e2d651969d2a00a13acdec2137a3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.  <a href="classregina_1_1Isomorphism.html#ad5e2d651969d2a00a13acdec2137a3bb">More...</a><br /></td></tr>
<tr class="separator:ad5e2d651969d2a00a13acdec2137a3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa78db49451ace59647d31fa33336739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#afa78db49451ace59647d31fa33336739">applyInPlace</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri) const</td></tr>
<tr class="memdesc:afa78db49451ace59647d31fa33336739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies this isomorphism to the given triangulation, modifying the given triangulation directly.  <a href="classregina_1_1Isomorphism.html#afa78db49451ace59647d31fa33336739">More...</a><br /></td></tr>
<tr class="separator:afa78db49451ace59647d31fa33336739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5651b16d2278cea837a1174241694d6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a5651b16d2278cea837a1174241694d6b">operator*</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a5651b16d2278cea837a1174241694d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the composition of this isomorphism with the given isomorphism.  <a href="classregina_1_1Isomorphism.html#a5651b16d2278cea837a1174241694d6b">More...</a><br /></td></tr>
<tr class="separator:a5651b16d2278cea837a1174241694d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b4a10117f941ed3f6d274582310f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#ae4b4a10117f941ed3f6d274582310f3e">operator*</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;&amp;rhs) const</td></tr>
<tr class="memdesc:ae4b4a10117f941ed3f6d274582310f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the composition of this isomorphism with the given isomorphism.  <a href="classregina_1_1Isomorphism.html#ae4b4a10117f941ed3f6d274582310f3e">More...</a><br /></td></tr>
<tr class="separator:ae4b4a10117f941ed3f6d274582310f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba485488b0b1a4c03d5b5b3611f382c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a2ba485488b0b1a4c03d5b5b3611f382c">inverse</a> () const</td></tr>
<tr class="memdesc:a2ba485488b0b1a4c03d5b5b3611f382c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of this isomorphism.  <a href="classregina_1_1Isomorphism.html#a2ba485488b0b1a4c03d5b5b3611f382c">More...</a><br /></td></tr>
<tr class="separator:a2ba485488b0b1a4c03d5b5b3611f382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1b944c2c93b301727c302ca5d7ae8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a3e1b944c2c93b301727c302ca5d7ae8c">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a3e1b944c2c93b301727c302ca5d7ae8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1Isomorphism.html#a3e1b944c2c93b301727c302ca5d7ae8c">More...</a><br /></td></tr>
<tr class="separator:a3e1b944c2c93b301727c302ca5d7ae8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce6b558d467de401dbdd5d1bc1e339a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#abce6b558d467de401dbdd5d1bc1e339a">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:abce6b558d467de401dbdd5d1bc1e339a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1Isomorphism.html#abce6b558d467de401dbdd5d1bc1e339a">More...</a><br /></td></tr>
<tr class="separator:abce6b558d467de401dbdd5d1bc1e339a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368f8ed113d2bc0f2d10b3697309c494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a368f8ed113d2bc0f2d10b3697309c494">operator==</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;other) const</td></tr>
<tr class="memdesc:a368f8ed113d2bc0f2d10b3697309c494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given isomorphism are identical.  <a href="classregina_1_1Isomorphism.html#a368f8ed113d2bc0f2d10b3697309c494">More...</a><br /></td></tr>
<tr class="separator:a368f8ed113d2bc0f2d10b3697309c494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210bdceddb2f2a0caad514a9a1b478c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a210bdceddb2f2a0caad514a9a1b478c8">operator!=</a> (const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> &amp;other) const</td></tr>
<tr class="memdesc:a210bdceddb2f2a0caad514a9a1b478c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given isomorphism are not identical.  <a href="classregina_1_1Isomorphism.html#a210bdceddb2f2a0caad514a9a1b478c8">More...</a><br /></td></tr>
<tr class="separator:a210bdceddb2f2a0caad514a9a1b478c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a42f4b01a471694268240b639eb72fbf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a42f4b01a471694268240b639eb72fbf9">identity</a> (unsigned nSimplices)</td></tr>
<tr class="memdesc:a42f4b01a471694268240b639eb72fbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity isomorphism for the given number of simplices.  <a href="classregina_1_1Isomorphism.html#a42f4b01a471694268240b639eb72fbf9">More...</a><br /></td></tr>
<tr class="separator:a42f4b01a471694268240b639eb72fbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac041d5673d8d914f5c286fce598b79f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#ac041d5673d8d914f5c286fce598b79f5">random</a> (unsigned nSimplices, bool even=false)</td></tr>
<tr class="memdesc:ac041d5673d8d914f5c286fce598b79f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random isomorphism for the given number of simplices.  <a href="classregina_1_1Isomorphism.html#ac041d5673d8d914f5c286fce598b79f5">More...</a><br /></td></tr>
<tr class="separator:ac041d5673d8d914f5c286fce598b79f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a19ef954bea6197c53a3e9f9a2f0256b3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#a19ef954bea6197c53a3e9f9a2f0256b3">nSimplices_</a></td></tr>
<tr class="memdesc:a19ef954bea6197c53a3e9f9a2f0256b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simplices in the source triangulation.  <a href="classregina_1_1Isomorphism.html#a19ef954bea6197c53a3e9f9a2f0256b3">More...</a><br /></td></tr>
<tr class="separator:a19ef954bea6197c53a3e9f9a2f0256b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc62997dc407ed8a90f5ebc4decfb312"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#afc62997dc407ed8a90f5ebc4decfb312">simpImage_</a></td></tr>
<tr class="memdesc:afc62997dc407ed8a90f5ebc4decfb312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the simplex of the destination triangulation that each simplex of the source triangulation maps to.  <a href="classregina_1_1Isomorphism.html#afc62997dc407ed8a90f5ebc4decfb312">More...</a><br /></td></tr>
<tr class="separator:afc62997dc407ed8a90f5ebc4decfb312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f8449939cf548ae66b62b0853d269c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Isomorphism.html#aa3f8449939cf548ae66b62b0853d269c">facetPerm_</a></td></tr>
<tr class="memdesc:aa3f8449939cf548ae66b62b0853d269c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The permutation applied to the facets of each source simplex.  <a href="classregina_1_1Isomorphism.html#aa3f8449939cf548ae66b62b0853d269c">More...</a><br /></td></tr>
<tr class="separator:aa3f8449939cf548ae66b62b0853d269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim&gt;<br />
class regina::Isomorphism&lt; dim &gt;</div><p >Represents a combinatorial isomorphism from one <em>dim</em>-manifold triangulation into another. </p>
<p >In essence, a combinatorial isomorphism from triangulation <em>T</em> to triangulation <em>U</em> is a one-to-one map from the simplices of <em>T</em> to the simplices of <em>U</em> that allows relabelling of both the simplices and their facets (or equivalently, their vertices), and that preserves gluings across adjacent simplices.</p>
<p >More precisely: An isomorphism consists of (i) a one-to-one map <em>f</em> from the simplices of <em>T</em> to the simplices of <em>U</em>, and (ii) for each simplex <em>S</em> of <em>T</em>, a permutation <em>f<sub>S</sub></em> of the facets (0,...,<em>dim</em>) of <em>S</em>, for which the following condition holds:</p>
<ul>
<li>If facet <em>k</em> of simplex <em>S</em> and facet <em>k'</em> of simplex <em>S'</em> are identified in <em>T</em>, then facet <em>f<sub>S</sub></em>(<em>k</em>) of <em>f(S)</em> and facet <em>f<sub>S'</sub></em>(<em>k'</em>) of <em>f</em>(S') are identified in <em>U</em>. Moreover, their gluing is consistent with the facet/vertex permutations; that is, there is a commutative square involving the gluing maps in <em>T</em> and <em>U</em> and the permutations <em>f<sub>S</sub></em> and <em>f<sub>S'</sub></em>.</li>
</ul>
<p >Isomorphisms can be <em>boundary complete</em> or <em>boundary incomplete</em>. A boundary complete isomorphism satisfies the additional condition:</p>
<ul>
<li>If facet <em>x</em> is a boundary facet of <em>T</em> then facet <em>f(x)</em> is a boundary facet of <em>U</em>.</li>
</ul>
<p >A boundary complete isomorphism thus indicates that a copy of triangulation <em>T</em> is present as an entire component (or components) of <em>U</em>, whereas a boundary incomplete isomorphism represents an embedding of a copy of triangulation <em>T</em> as a subcomplex of some possibly larger component (or components) of <em>U</em>.</p>
<p >Note that for all types of isomorphism, triangulation <em>U</em> is allowed to contain more simplices than triangulation <em>T</em>.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead this class can be used by appending the dimension as a suffix (e.g., Isomorphism2 and Isomorphism3 for dimensions 2 and 3).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the triangulations that this isomorphism class works with. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ada62164849890b968650046b715e9f69" name="ada62164849890b968650046b715e9f69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada62164849890b968650046b715e9f69">&#9670;&nbsp;</a></span>Isomorphism() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nSimplices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new isomorphism with no initialisation. </p>
<p >The images of the simplices and their vertices must be explicitly set using <a class="el" href="classregina_1_1Isomorphism.html#acf291b695f240016a023cc055f248530" title="Determines the image of the given source simplex under this isomorphism.">simpImage()</a> and <a class="el" href="classregina_1_1Isomorphism.html#a77bebdc5fb3c1f7e9abe69da675119cb" title="Returns a read-write reference to the permutation that is applied to the (dim + 1) facets of the give...">facetPerm()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>For Python users, the images of the simplices and their vertices must be set using setSimpImage() and setFacetPerm() instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices in the source triangulation associated with this isomorphism. This is allowed to be zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f9f2112ee5058c263535563715c585e" name="a8f9f2112ee5058c263535563715c585e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9f2112ee5058c263535563715c585e">&#9670;&nbsp;</a></span>Isomorphism() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given isomorphism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a8b6612fe01e4ecc8bfad1423898c8" name="ad3a8b6612fe01e4ecc8bfad1423898c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a8b6612fe01e4ecc8bfad1423898c8">&#9670;&nbsp;</a></span>Isomorphism() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given isomorphism into this new isomorphism. </p>
<p >This is a fast (constant time) operation.</p>
<p >The isomorphism that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99cf1afeffd310db7d7ca89d19b2437" name="ac99cf1afeffd310db7d7ca89d19b2437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99cf1afeffd310db7d7ca89d19b2437">&#9670;&nbsp;</a></span>~Isomorphism()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this isomorphism. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad5e2d651969d2a00a13acdec2137a3bb" name="ad5e2d651969d2a00a13acdec2137a3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e2d651969d2a00a13acdec2137a3bb">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies this isomorphism to the given triangulation, and returns the result as a new triangulation. </p>
<p >An isomorphism represents a combinatorial map from a triangulation <em>T</em> to a triangulation <em>U</em>. This routine treats the given triangulation as the domain <em>T</em>, and returns the corresponding range <em>U</em>. The given triangulation <em>T</em> is not modified in any way.</p>
<p >In more detail: A new triangulation <em>U</em> is returned, so that this isomorphism represents a one-to-one, onto and boundary complete isomorphism from <em>T</em> to <em>U</em>. That is, <em>T</em> and <em>U</em> will be combinatorially identical triangulations, and this isomorphism describes the mapping from the simplices of <em>T</em> and their facets to the simplices of <em>U</em> and their facets.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The simplex images are precisely 0,1,...,<a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000047">Todo:</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>the number of simplices in the given triangulation is not equal to <a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the triangulation to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new isomorphic triangulation. </dd></dl>

</div>
</div>
<a id="afa78db49451ace59647d31fa33336739" name="afa78db49451ace59647d31fa33336739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa78db49451ace59647d31fa33336739">&#9670;&nbsp;</a></span>applyInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::applyInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies this isomorphism to the given triangulation, modifying the given triangulation directly. </p>
<p >This is similar to <a class="el" href="classregina_1_1Isomorphism.html#ad5e2d651969d2a00a13acdec2137a3bb" title="Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.">apply()</a>, except that instead of creating a new triangulation, the simplices and vertices of the given triangulation are modified in-place.</p>
<p >See <a class="el" href="classregina_1_1Isomorphism.html#ad5e2d651969d2a00a13acdec2137a3bb" title="Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.">apply()</a> for further details on how this operation is performed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The simplex images are precisely 0,1,...,<a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>the number of simplices in the given triangulation is not equal to <a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a77bebdc5fb3c1f7e9abe69da675119cb" name="a77bebdc5fb3c1f7e9abe69da675119cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bebdc5fb3c1f7e9abe69da675119cb">&#9670;&nbsp;</a></span>facetPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::facetPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism. </p>
<p >Facet <em>i</em> of source simplex <em>sourceSimp</em> will be mapped to facet <code>facetPerm(sourceSimp)[i]</code> of simplex <code>simpImage(sourceSimp)</code>.</p>
<p >If the dimension <em>dim</em> is 2 or 3, then you can also access this permutation through the dimension-specific alias edgePerm() or facePerm() respectively.</p>
<dl class="section user"><dt>Python</dt><dd>Python users can only access the read-only version of this function that returns by value: you cannot use <a class="el" href="classregina_1_1Isomorphism.html#a77bebdc5fb3c1f7e9abe69da675119cb" title="Returns a read-write reference to the permutation that is applied to the (dim + 1) facets of the give...">facetPerm()</a> to edit the isomorphism. As an alternative however, Python users can call <code>setFacetPerm(sourceSimp, perm)</code> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex containing the original (<em>dim</em> + 1) facets; this must be between 0 and <code><a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a read-write reference to the permutation applied to the facets of the source simplex. </dd></dl>

</div>
</div>
<a id="a44ca925b9f251eef0fe07287f9de736f" name="a44ca925b9f251eef0fe07287f9de736f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ca925b9f251eef0fe07287f9de736f">&#9670;&nbsp;</a></span>facetPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::facetPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism. </p>
<p >Facet <em>i</em> of source simplex <em>sourceSimp</em> will be mapped to face <code>facetPerm(sourceSimp)[i]</code> of simplex <code>simpImage(sourceSimp)</code>.</p>
<p >If the dimension <em>dim</em> is 2 or 3, then you can also access this permutation through the dimension-specific alias edgePerm() or facePerm() respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex containing the original (<em>dim</em> + 1) facets; this must be between 0 and <code><a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation applied to the facets of the source simplex. </dd></dl>

</div>
</div>
<a id="a42f4b01a471694268240b639eb72fbf9" name="a42f4b01a471694268240b639eb72fbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42f4b01a471694268240b639eb72fbf9">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::identity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nSimplices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity isomorphism for the given number of simplices. </p>
<p >This isomorphism sends every simplex and every vertex to itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices that the new isomorphism should operate upon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identity isomorphism. </dd></dl>

</div>
</div>
<a id="a2ba485488b0b1a4c03d5b5b3611f382c" name="a2ba485488b0b1a4c03d5b5b3611f382c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba485488b0b1a4c03d5b5b3611f382c">&#9670;&nbsp;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::inverse</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inverse of this isomorphism. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The destination triangulation has precisely the same number of simplices as the source triangulation. In other words, there are no "gaps" in the simplex images: the values <code>simpImage(0)</code>, ..., <code>simpImage(<a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1)</code> must be a permutation of 0, ..., <code><a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse isomorphism. </dd></dl>

</div>
</div>
<a id="a880e50ac413fde3e237c905aa210afca" name="a880e50ac413fde3e237c905aa210afca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880e50ac413fde3e237c905aa210afca">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::isIdentity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not this is an identity isomorphism. </p>
<p >In an identity isomorphism, each simplex image is itself, and within each simplex the facet/vertex permutation is the identity permutation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an identity isomorphism, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a210bdceddb2f2a0caad514a9a1b478c8" name="a210bdceddb2f2a0caad514a9a1b478c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210bdceddb2f2a0caad514a9a1b478c8">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given isomorphism are not identical. </p>
<p >Two isomorphisms are considered <em>identical</em> if they act on the same number of top-dimensional simplices, and all destination simplex numbers and facet permutations are the same for both isomorphisms.</p>
<p >In particular it is only the simplex, facet and vertex <em>labels</em> that matter: an isomorphism does not refer to a specific triangulation, and there is no sense in which the two isomorphisms need to act on the same triangulations and/or point to the same destination Simplex objects.</p>
<p >It is safe to compare isomorphisms of different sizes (in which case this routine will return <code>true</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the isomorphism to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given isomorphism are not identical. </dd></dl>

</div>
</div>
<a id="a5651b16d2278cea837a1174241694d6b" name="a5651b16d2278cea837a1174241694d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5651b16d2278cea837a1174241694d6b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the composition of this isomorphism with the given isomorphism. </p>
<p >This follows the same order convention as Regina's permutation classes: the composition <code>a * b</code> first applies the right-hand isomorphism <em>b</em>, and then the left-hand isomorphism <em>a</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The source triangulation for this isomorphism (the left-hand side) is at least as large as the destination triangulation for <em>rhs</em> (the right-hand side). In other words, the maximum value of <code>rhs.simpImage(i)</code> over all <em>i</em> must be less than <code>this-&gt;<a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both isomorphisms. </dd></dl>

</div>
</div>
<a id="ae4b4a10117f941ed3f6d274582310f3e" name="ae4b4a10117f941ed3f6d274582310f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b4a10117f941ed3f6d274582310f3e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the composition of this isomorphism with the given isomorphism. </p>
<p >This follows the same order convention as Regina's permutation classes: the composition <code>a * b</code> first applies the right-hand isomorphism <em>b</em>, and then the left-hand isomorphism <em>a</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The source triangulation for this isomorphism (the left-hand side) is at least as large as the destination triangulation for <em>rhs</em> (the right-hand side). In other words, the maximum value of <code>rhs.simpImage(i)</code> over all <em>i</em> must be less than <code>this-&gt;<a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a></code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both isomorphisms. </dd></dl>

</div>
</div>
<a id="aadbdfca99e94446a343b101ec6331f77" name="aadbdfca99e94446a343b101ec6331f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbdfca99e94446a343b101ec6331f77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the given isomorphism into this isomorphism. </p>
<p >It does not matter if this and the given isomorphism use different numbers of simplices; if they do then this isomorphism will be resized as a result.</p>
<p >This operator induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this isomorphism. </dd></dl>

</div>
</div>
<a id="a0a4812ece221766e1dfd2cca99f007f5" name="a0a4812ece221766e1dfd2cca99f007f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4812ece221766e1dfd2cca99f007f5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given isomorphism into this isomorphism. </p>
<p >This is a fast (constant time) operation.</p>
<p >It does not matter if this and the given isomorphism use different numbers of simplices; if they do then this isomorphism will be resized as a result.</p>
<p >The isomorphism that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this isomorphism. </dd></dl>

</div>
</div>
<a id="a368f8ed113d2bc0f2d10b3697309c494" name="a368f8ed113d2bc0f2d10b3697309c494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368f8ed113d2bc0f2d10b3697309c494">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given isomorphism are identical. </p>
<p >Two isomorphisms are considered <em>identical</em> if they act on the same number of top-dimensional simplices, and all destination simplex numbers and facet permutations are the same for both isomorphisms.</p>
<p >In particular it is only the simplex, facet and vertex <em>labels</em> that matter: an isomorphism does not refer to a specific triangulation, and there is no sense in which the two isomorphisms need to act on the same triangulations and/or point to the same destination Simplex objects.</p>
<p >It is safe to compare isomorphisms of different sizes (in which case this routine will return <code>false</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the isomorphism to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given isomorphism are identical. </dd></dl>

</div>
</div>
<a id="af6b5f3b813d309d8e0b91e347635e163" name="af6b5f3b813d309d8e0b91e347635e163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b5f3b813d309d8e0b91e347635e163">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex facet under this isomorphism. </p>
<p >This operator returns by value: it cannot be used to alter the isomorphism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the given source simplex facet; this must be one of the (<em>dim</em> + 1) facets of one of the <a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> simplices in the source triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of the source simplex facet under this isomorphism. </dd></dl>

</div>
</div>
<a id="ac041d5673d8d914f5c286fce598b79f5" name="ac041d5673d8d914f5c286fce598b79f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac041d5673d8d914f5c286fce598b79f5">&#9670;&nbsp;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::random </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>even</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random isomorphism for the given number of simplices. </p>
<p >This isomorphism will reorder simplices 0 to <code>nSimplices-1</code> in a random fashion, and for each simplex a random permutation of its (<em>dim</em> + 1) vertices will be selected.</p>
<p >All possible isomorphisms for the given number of simplices are equally likely.</p>
<p >This routine is thread-safe, and uses <a class="el" href="classregina_1_1RandomEngine.html" title="Offers threadsafe access to Regina&#39;s global uniform random bit generator.">RandomEngine</a> for its random number generation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices that the new isomorphism should operate upon. </td></tr>
    <tr><td class="paramname">even</td><td>if <code>true</code>, then every simplex will have its vertices permuted with an even permutation. This means that, if the random isomorphism is applied to an oriented triangulation, it will preserve the orientation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new random isomorphism. </dd></dl>

</div>
</div>
<a id="acf291b695f240016a023cc055f248530" name="acf291b695f240016a023cc055f248530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf291b695f240016a023cc055f248530">&#9670;&nbsp;</a></span>simpImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::simpImage </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex under this isomorphism. </p>
<p >If the dimension <em>dim</em> is 2, 3 or 4, then you can also access this image through the dimension-specific alias triImage(), tetImage() or pentImage() respectively.</p>
<dl class="section user"><dt>Python</dt><dd>Python users can only access the read-only version of this function that returns by value: you cannot use <a class="el" href="classregina_1_1Isomorphism.html#acf291b695f240016a023cc055f248530" title="Determines the image of the given source simplex under this isomorphism.">simpImage()</a> to edit the isomorphism. As an alternative however, Python users can call <code>setSimpImage(sourceSimp, image)</code> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex; this must be between 0 and <code><a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the index of the destination simplex that the source simplex maps to. </dd></dl>

</div>
</div>
<a id="a1ac9a103114e81dc510a034230b4bca6" name="a1ac9a103114e81dc510a034230b4bca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac9a103114e81dc510a034230b4bca6">&#9670;&nbsp;</a></span>simpImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::simpImage </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex under this isomorphism. </p>
<p >If the dimension <em>dim</em> is 2, 3 or 4, then you can also access this image through the dimension-specific alias triImage(), tetImage() or pentImage() respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex; this must be between 0 and <code><a class="el" href="classregina_1_1Isomorphism.html#a99087d3e4963b6d8bace0dbb29dbcd85" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the destination simplex that the source simplex maps to. </dd></dl>

</div>
</div>
<a id="a99087d3e4963b6d8bace0dbb29dbcd85" name="a99087d3e4963b6d8bace0dbb29dbcd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99087d3e4963b6d8bace0dbb29dbcd85">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of simplices in the source triangulation associated with this isomorphism. </p>
<p >Note that this is always less than or equal to the number of simplices in the destination triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices in the source triangulation. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="add60c472f78f9fbabaa4990bcea77d4b" name="add60c472f78f9fbabaa4990bcea77d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add60c472f78f9fbabaa4990bcea77d4b">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given isomorphism. </p>
<p >It does not matter if this and the given isomorphism use different numbers of simplices; if so then they will be adjusted accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the isomorphism whose contents are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="abce6b558d467de401dbdd5d1bc1e339a" name="abce6b558d467de401dbdd5d1bc1e339a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce6b558d467de401dbdd5d1bc1e339a">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e1b944c2c93b301727c302ca5d7ae8c" name="a3e1b944c2c93b301727c302ca5d7ae8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1b944c2c93b301727c302ca5d7ae8c">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa3f8449939cf548ae66b62b0853d269c" name="aa3f8449939cf548ae66b62b0853d269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f8449939cf548ae66b62b0853d269c">&#9670;&nbsp;</a></span>facetPerm_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt;* <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::facetPerm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The permutation applied to the facets of each source simplex. </p>
<p >This array has size nSimplices_. </p>

</div>
</div>
<a id="a19ef954bea6197c53a3e9f9a2f0256b3" name="a19ef954bea6197c53a3e9f9a2f0256b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ef954bea6197c53a3e9f9a2f0256b3">&#9670;&nbsp;</a></span>nSimplices_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::nSimplices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of simplices in the source triangulation. </p>

</div>
</div>
<a id="afc62997dc407ed8a90f5ebc4decfb312" name="afc62997dc407ed8a90f5ebc4decfb312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc62997dc407ed8a90f5ebc4decfb312">&#9670;&nbsp;</a></span>simpImage_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1Isomorphism.html">regina::Isomorphism</a>&lt; dim &gt;::simpImage_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the simplex of the destination triangulation that each simplex of the source triangulation maps to. </p>
<p >This array has size nSimplices_. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>triangulation/<a class="el" href="forward_8h.html">forward.h</a></li>
<li>triangulation/generic/<a class="el" href="generic_2isomorphism_8h.html">isomorphism.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
