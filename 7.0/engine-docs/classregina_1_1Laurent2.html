<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: regina::Laurent2&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Laurent2-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Laurent2&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>x</em>, <em>y</em> with coefficients of type <em>T</em>.  
 <a href="classregina_1_1Laurent2.html#details">More...</a></p>

<p><code>#include &lt;maths/laurent2.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Laurent2&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Laurent2.png" usemap="#regina::Laurent2_3C_20T_20_3E_map" alt=""/>
  <map id="regina::Laurent2_3C_20T_20_3E_map" name="regina::Laurent2_3C_20T_20_3E_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; Laurent2&lt; T &gt;, true &gt;" shape="rect" coords="0,56,275,80"/>
<area href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output." alt="regina::Output&lt; T, supportsUtf8 &gt;" shape="rect" coords="0,0,275,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab6f6ee7dcc072a40c5efd0047534ed8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#ab6f6ee7dcc072a40c5efd0047534ed8a">Coefficient</a> = T</td></tr>
<tr class="memdesc:ab6f6ee7dcc072a40c5efd0047534ed8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of each coefficient of the polynomial.  <a href="classregina_1_1Laurent2.html#ab6f6ee7dcc072a40c5efd0047534ed8a">More...</a><br /></td></tr>
<tr class="separator:ab6f6ee7dcc072a40c5efd0047534ed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9616417b71fba47f8169ef0ed71f0f95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a9616417b71fba47f8169ef0ed71f0f95">Laurent2</a> ()=default</td></tr>
<tr class="memdesc:a9616417b71fba47f8169ef0ed71f0f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the zero polynomial.  <a href="classregina_1_1Laurent2.html#a9616417b71fba47f8169ef0ed71f0f95">More...</a><br /></td></tr>
<tr class="separator:a9616417b71fba47f8169ef0ed71f0f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bc2af7274f123e473f108bc1259d5c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a66bc2af7274f123e473f108bc1259d5c">Laurent2</a> (long xExp, long yExp)</td></tr>
<tr class="memdesc:a66bc2af7274f123e473f108bc1259d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>.  <a href="classregina_1_1Laurent2.html#a66bc2af7274f123e473f108bc1259d5c">More...</a><br /></td></tr>
<tr class="separator:a66bc2af7274f123e473f108bc1259d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae807c716cf55df302a2ce75d0eb596aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#ae807c716cf55df302a2ce75d0eb596aa">Laurent2</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:ae807c716cf55df302a2ce75d0eb596aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given polynomial.  <a href="classregina_1_1Laurent2.html#ae807c716cf55df302a2ce75d0eb596aa">More...</a><br /></td></tr>
<tr class="separator:ae807c716cf55df302a2ce75d0eb596aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa340676c9f944ce88693e69bbea56023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#aa340676c9f944ce88693e69bbea56023">Laurent2</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;value) noexcept=default</td></tr>
<tr class="memdesc:aa340676c9f944ce88693e69bbea56023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given polynomial to this new polynomial.  <a href="classregina_1_1Laurent2.html#aa340676c9f944ce88693e69bbea56023">More...</a><br /></td></tr>
<tr class="separator:aa340676c9f944ce88693e69bbea56023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1c31a611b8708d14bdf6e809d016f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a25c1c31a611b8708d14bdf6e809d016f">Laurent2</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;toShift, long xShift, long yShift)</td></tr>
<tr class="memdesc:a25c1c31a611b8708d14bdf6e809d016f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given polynomial with all terms multiplied by <code>x^d y^e</code> for some integers <em>d</em> and <em>e</em>.  <a href="classregina_1_1Laurent2.html#a25c1c31a611b8708d14bdf6e809d016f">More...</a><br /></td></tr>
<tr class="separator:a25c1c31a611b8708d14bdf6e809d016f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd07a8882921df669daf862ebd624a73"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acd07a8882921df669daf862ebd624a73"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#acd07a8882921df669daf862ebd624a73">Laurent2</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;value)</td></tr>
<tr class="memdesc:acd07a8882921df669daf862ebd624a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given polynomial.  <a href="classregina_1_1Laurent2.html#acd07a8882921df669daf862ebd624a73">More...</a><br /></td></tr>
<tr class="separator:acd07a8882921df669daf862ebd624a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97f3c265d8997bdfa3b8b494673d25e"><td class="memTemplParams" colspan="2">template&lt;typename iterator , typename deref  = decltype(*iterator())&gt; </td></tr>
<tr class="memitem:ab97f3c265d8997bdfa3b8b494673d25e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#ab97f3c265d8997bdfa3b8b494673d25e">Laurent2</a> (iterator begin, iterator end)</td></tr>
<tr class="memdesc:ab97f3c265d8997bdfa3b8b494673d25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new polynomial from the given collection of coefficients.  <a href="classregina_1_1Laurent2.html#ab97f3c265d8997bdfa3b8b494673d25e">More...</a><br /></td></tr>
<tr class="separator:ab97f3c265d8997bdfa3b8b494673d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c3979b7f375496277c6d81a0fc7e87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#aa6c3979b7f375496277c6d81a0fc7e87">Laurent2</a> (std::initializer_list&lt; std::tuple&lt; long, long, T &gt; &gt; coefficients)</td></tr>
<tr class="memdesc:aa6c3979b7f375496277c6d81a0fc7e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new polynomial from a hard-coded collection of non-zero coefficients.  <a href="classregina_1_1Laurent2.html#aa6c3979b7f375496277c6d81a0fc7e87">More...</a><br /></td></tr>
<tr class="separator:aa6c3979b7f375496277c6d81a0fc7e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9ab37ac09da1d2c1af9597f6e333dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a3b9ab37ac09da1d2c1af9597f6e333dd">init</a> ()</td></tr>
<tr class="memdesc:a3b9ab37ac09da1d2c1af9597f6e333dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to become the zero polynomial.  <a href="classregina_1_1Laurent2.html#a3b9ab37ac09da1d2c1af9597f6e333dd">More...</a><br /></td></tr>
<tr class="separator:a3b9ab37ac09da1d2c1af9597f6e333dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151f203694f59cfa524785828edf9e81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a151f203694f59cfa524785828edf9e81">init</a> (long xExp, long yExp)</td></tr>
<tr class="memdesc:a151f203694f59cfa524785828edf9e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to become the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>.  <a href="classregina_1_1Laurent2.html#a151f203694f59cfa524785828edf9e81">More...</a><br /></td></tr>
<tr class="separator:a151f203694f59cfa524785828edf9e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2127cd484f250361b34862f116a597"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a0f2127cd484f250361b34862f116a597">isZero</a> () const</td></tr>
<tr class="memdesc:a0f2127cd484f250361b34862f116a597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this is the zero polynomial.  <a href="classregina_1_1Laurent2.html#a0f2127cd484f250361b34862f116a597">More...</a><br /></td></tr>
<tr class="separator:a0f2127cd484f250361b34862f116a597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9123daa1ba8056b3afde06f9a3087d77"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a9123daa1ba8056b3afde06f9a3087d77">operator()</a> (long xExp, long yExp) const</td></tr>
<tr class="memdesc:a9123daa1ba8056b3afde06f9a3087d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given coefficient of this polynomial.  <a href="classregina_1_1Laurent2.html#a9123daa1ba8056b3afde06f9a3087d77">More...</a><br /></td></tr>
<tr class="separator:a9123daa1ba8056b3afde06f9a3087d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e21fd6436363e5555380f69aef2b5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a6e21fd6436363e5555380f69aef2b5ba">set</a> (long xExp, long yExp, const T &amp;value)</td></tr>
<tr class="memdesc:a6e21fd6436363e5555380f69aef2b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the given coefficient of this polynomial.  <a href="classregina_1_1Laurent2.html#a6e21fd6436363e5555380f69aef2b5ba">More...</a><br /></td></tr>
<tr class="separator:a6e21fd6436363e5555380f69aef2b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0">operator==</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given polynomial are equal.  <a href="classregina_1_1Laurent2.html#a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0">More...</a><br /></td></tr>
<tr class="separator:a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c5b2e6e8649e8e31009121e1aca4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#ada7c5b2e6e8649e8e31009121e1aca4d">operator!=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ada7c5b2e6e8649e8e31009121e1aca4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given polynomial are not equal.  <a href="classregina_1_1Laurent2.html#ada7c5b2e6e8649e8e31009121e1aca4d">More...</a><br /></td></tr>
<tr class="separator:ada7c5b2e6e8649e8e31009121e1aca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49925bfdf4d0d6d602425705699211e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#ac49925bfdf4d0d6d602425705699211e">operator&lt;</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:ac49925bfdf4d0d6d602425705699211e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent2.html#ac49925bfdf4d0d6d602425705699211e">More...</a><br /></td></tr>
<tr class="separator:ac49925bfdf4d0d6d602425705699211e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698cac8d261c4ed6bd00bd90fbbeb6a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a698cac8d261c4ed6bd00bd90fbbeb6a2">operator&gt;</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a698cac8d261c4ed6bd00bd90fbbeb6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent2.html#a698cac8d261c4ed6bd00bd90fbbeb6a2">More...</a><br /></td></tr>
<tr class="separator:a698cac8d261c4ed6bd00bd90fbbeb6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e626d56686a59faa24a5e0e0eaae871"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a5e626d56686a59faa24a5e0e0eaae871">operator&lt;=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a5e626d56686a59faa24a5e0e0eaae871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent2.html#a5e626d56686a59faa24a5e0e0eaae871">More...</a><br /></td></tr>
<tr class="separator:a5e626d56686a59faa24a5e0e0eaae871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2f7e865921b55ff7ae750614121c15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a3e2f7e865921b55ff7ae750614121c15">operator&gt;=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a3e2f7e865921b55ff7ae750614121c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials.  <a href="classregina_1_1Laurent2.html#a3e2f7e865921b55ff7ae750614121c15">More...</a><br /></td></tr>
<tr class="separator:a3e2f7e865921b55ff7ae750614121c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c335642e5da5084f38d5b3c166e36b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a48c335642e5da5084f38d5b3c166e36b">operator=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a48c335642e5da5084f38d5b3c166e36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given polynomial.  <a href="classregina_1_1Laurent2.html#a48c335642e5da5084f38d5b3c166e36b">More...</a><br /></td></tr>
<tr class="separator:a48c335642e5da5084f38d5b3c166e36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538528845f776b8908e3a08f24af37b1"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a538528845f776b8908e3a08f24af37b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a538528845f776b8908e3a08f24af37b1">operator=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;value)</td></tr>
<tr class="memdesc:a538528845f776b8908e3a08f24af37b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given polynomial.  <a href="classregina_1_1Laurent2.html#a538528845f776b8908e3a08f24af37b1">More...</a><br /></td></tr>
<tr class="separator:a538528845f776b8908e3a08f24af37b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032ed022582395968183345ee988f77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a032ed022582395968183345ee988f77b">operator=</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;value) noexcept=default</td></tr>
<tr class="memdesc:a032ed022582395968183345ee988f77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given polynomial to this polynomial.  <a href="classregina_1_1Laurent2.html#a032ed022582395968183345ee988f77b">More...</a><br /></td></tr>
<tr class="separator:a032ed022582395968183345ee988f77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5382c0231814155a040fd05d908d1f73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a5382c0231814155a040fd05d908d1f73">swap</a> (<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a5382c0231814155a040fd05d908d1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given polynomial.  <a href="classregina_1_1Laurent2.html#a5382c0231814155a040fd05d908d1f73">More...</a><br /></td></tr>
<tr class="separator:a5382c0231814155a040fd05d908d1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fed3d5d702211cfd7b90cad87f43205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a8fed3d5d702211cfd7b90cad87f43205">negate</a> ()</td></tr>
<tr class="memdesc:a8fed3d5d702211cfd7b90cad87f43205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates this polynomial.  <a href="classregina_1_1Laurent2.html#a8fed3d5d702211cfd7b90cad87f43205">More...</a><br /></td></tr>
<tr class="separator:a8fed3d5d702211cfd7b90cad87f43205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928f26c1e006e72e788e2c997ba414d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a928f26c1e006e72e788e2c997ba414d5">invertX</a> ()</td></tr>
<tr class="memdesc:a928f26c1e006e72e788e2c997ba414d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>x</code> with <code>x^-1</code> in this polynomial.  <a href="classregina_1_1Laurent2.html#a928f26c1e006e72e788e2c997ba414d5">More...</a><br /></td></tr>
<tr class="separator:a928f26c1e006e72e788e2c997ba414d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edd6a788a049890345d6e73942259f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a6edd6a788a049890345d6e73942259f2">invertY</a> ()</td></tr>
<tr class="memdesc:a6edd6a788a049890345d6e73942259f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces <code>y</code> with <code>y^-1</code> in this polynomial.  <a href="classregina_1_1Laurent2.html#a6edd6a788a049890345d6e73942259f2">More...</a><br /></td></tr>
<tr class="separator:a6edd6a788a049890345d6e73942259f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b4233936c5293e81447dc71daaf157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a62b4233936c5293e81447dc71daaf157">operator*=</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:a62b4233936c5293e81447dc71daaf157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this polynomial by the given constant.  <a href="classregina_1_1Laurent2.html#a62b4233936c5293e81447dc71daaf157">More...</a><br /></td></tr>
<tr class="separator:a62b4233936c5293e81447dc71daaf157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a5d7d2ee2b527e1bf6f24564f6175a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#ad2a5d7d2ee2b527e1bf6f24564f6175a">operator/=</a> (const T &amp;scalar)</td></tr>
<tr class="memdesc:ad2a5d7d2ee2b527e1bf6f24564f6175a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this polynomial by the given constant.  <a href="classregina_1_1Laurent2.html#ad2a5d7d2ee2b527e1bf6f24564f6175a">More...</a><br /></td></tr>
<tr class="separator:ad2a5d7d2ee2b527e1bf6f24564f6175a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f7e7ab24cc91845a017b34b887cb3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a88f7e7ab24cc91845a017b34b887cb3c">operator+=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a88f7e7ab24cc91845a017b34b887cb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given polynomial to this.  <a href="classregina_1_1Laurent2.html#a88f7e7ab24cc91845a017b34b887cb3c">More...</a><br /></td></tr>
<tr class="separator:a88f7e7ab24cc91845a017b34b887cb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4cdcdcf36e3c2323d6add8eb5f802f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a5c4cdcdcf36e3c2323d6add8eb5f802f">operator-=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a5c4cdcdcf36e3c2323d6add8eb5f802f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given polynomial from this.  <a href="classregina_1_1Laurent2.html#a5c4cdcdcf36e3c2323d6add8eb5f802f">More...</a><br /></td></tr>
<tr class="separator:a5c4cdcdcf36e3c2323d6add8eb5f802f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91abd504dba2918cfc8e1589eac7c147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a91abd504dba2918cfc8e1589eac7c147">operator*=</a> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a91abd504dba2918cfc8e1589eac7c147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by the given polynomial.  <a href="classregina_1_1Laurent2.html#a91abd504dba2918cfc8e1589eac7c147">More...</a><br /></td></tr>
<tr class="separator:a91abd504dba2918cfc8e1589eac7c147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be6449b77d1e89b70195d5467bddff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a92be6449b77d1e89b70195d5467bddff">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="classregina_1_1Laurent2.html#ade0a2543536786e006e31898f01140bb">utf8</a>=false, const char *varX=nullptr, const char *varY=nullptr) const</td></tr>
<tr class="memdesc:a92be6449b77d1e89b70195d5467bddff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this polynomial to the given output stream, using the given variable names instead of <code>x</code> and <code>y</code>.  <a href="classregina_1_1Laurent2.html#a92be6449b77d1e89b70195d5467bddff">More...</a><br /></td></tr>
<tr class="separator:a92be6449b77d1e89b70195d5467bddff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760f12b76398e549fa66a3a0e7ef3b79"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a760f12b76398e549fa66a3a0e7ef3b79">str</a> (const char *varX, const char *varY=nullptr) const</td></tr>
<tr class="memdesc:a760f12b76398e549fa66a3a0e7ef3b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this polynomial as a human-readable string, using the given variable names instead of <code>x</code> and <code>y</code>.  <a href="classregina_1_1Laurent2.html#a760f12b76398e549fa66a3a0e7ef3b79">More...</a><br /></td></tr>
<tr class="separator:a760f12b76398e549fa66a3a0e7ef3b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0a2543536786e006e31898f01140bb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#ade0a2543536786e006e31898f01140bb">utf8</a> (const char *varX, const char *varY=nullptr) const</td></tr>
<tr class="memdesc:ade0a2543536786e006e31898f01140bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this polynomial as a human-readable string using unicode characters, using the given variable names instead of <code>x</code> and <code>y</code>.  <a href="classregina_1_1Laurent2.html#ade0a2543536786e006e31898f01140bb">More...</a><br /></td></tr>
<tr class="separator:ade0a2543536786e006e31898f01140bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73caa4080f9139ff3c5fe4b3954af005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#a73caa4080f9139ff3c5fe4b3954af005">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a73caa4080f9139ff3c5fe4b3954af005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this polynomial to the given output stream.  <a href="classregina_1_1Laurent2.html#a73caa4080f9139ff3c5fe4b3954af005">More...</a><br /></td></tr>
<tr class="separator:a73caa4080f9139ff3c5fe4b3954af005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef276574a8952c46612ac02b4851b5c9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Laurent2.html#aef276574a8952c46612ac02b4851b5c9">tightEncoding</a> () const</td></tr>
<tr class="memdesc:aef276574a8952c46612ac02b4851b5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this polynomial.  <a href="classregina_1_1Laurent2.html#aef276574a8952c46612ac02b4851b5c9">More...</a><br /></td></tr>
<tr class="separator:aef276574a8952c46612ac02b4851b5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e97b509d29d458859958ab84d0874d0"><td class="memTemplParams" colspan="2"><a id="a7e97b509d29d458859958ab84d0874d0" name="a7e97b509d29d458859958ab84d0874d0"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a7e97b509d29d458859958ab84d0874d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;other)</td></tr>
<tr class="separator:a7e97b509d29d458859958ab84d0874d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memItemLeft" align="right" valign="top"><a id="a1e9ca4d39ca75620494c1f03ae5b00e8" name="a1e9ca4d39ca75620494c1f03ae5b00e8"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Link</b></td></tr>
<tr class="separator:a1e9ca4d39ca75620494c1f03ae5b00e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6e7f5f2f40f9bc758612463732f203"><td class="memTemplParams" colspan="2"><a id="a2e6e7f5f2f40f9bc758612463732f203" name="a2e6e7f5f2f40f9bc758612463732f203"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2e6e7f5f2f40f9bc758612463732f203"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;, const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;)</td></tr>
<tr class="separator:a2e6e7f5f2f40f9bc758612463732f203"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class regina::Laurent2&lt; T &gt;</div><p >Represents a <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial in the two variables <em>x</em>, <em>y</em> with coefficients of type <em>T</em>. </p>
<p >A <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomial differs from an ordinary polynomial in that it allows negative exponents (so, for example, you can represent a polynomial such as <code>2 + 3x^2 + y/x - 1/y^3</code>).</p>
<p >The type <em>T</em> must represent a ring with no zero divisors. In particular, it must:</p>
<ul>
<li>support basic arithmetic operations;</li>
<li>support assignments of the form <code>x = int</code> and tests of the form <code>x == int</code> and <code>x &lt; int</code>;</li>
<li>have a default constructor that assigns an explicit value of zero.</li>
</ul>
<p >This means that Regina's numerical types such as Integer and <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a> are supported, but native data types such as int and long are not (since they have no zero-initialising default constructor).</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<p >The underlying storage method for this class is sparse: only the non-zero coefficients are stored.</p>
<p >See also the class <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a>, which describes <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials in just one variable.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, the class <a class="el" href="classregina_1_1Laurent2.html" title="Represents a Laurent polynomial in the two variables x, y with coefficients of type T.">Laurent2</a> refers to the specific template class Laurent2&lt;Integer&gt;. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab6f6ee7dcc072a40c5efd0047534ed8a" name="ab6f6ee7dcc072a40c5efd0047534ed8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f6ee7dcc072a40c5efd0047534ed8a">&#9670;&nbsp;</a></span>Coefficient</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html#ab6f6ee7dcc072a40c5efd0047534ed8a">Coefficient</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of each coefficient of the polynomial. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9616417b71fba47f8169ef0ed71f0f95" name="a9616417b71fba47f8169ef0ed71f0f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9616417b71fba47f8169ef0ed71f0f95">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the zero polynomial. </p>

</div>
</div>
<a id="a66bc2af7274f123e473f108bc1259d5c" name="a66bc2af7274f123e473f108bc1259d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66bc2af7274f123e473f108bc1259d5c">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>yExp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the exponent <em>d</em>, which is attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the exponent <em>e</em>, which is attached to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae807c716cf55df302a2ce75d0eb596aa" name="ae807c716cf55df302a2ce75d0eb596aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae807c716cf55df302a2ce75d0eb596aa">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given polynomial. </p>
<p >This constructor induces a deep copy of <em>value</em>.</p>
<p >A note for developers: even though this routine is identical to the templated copy constructor, it must be declared and implemented separately. Otherwise the compiler might create its own (incorrect) copy constructor automatically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa340676c9f944ce88693e69bbea56023" name="aa340676c9f944ce88693e69bbea56023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa340676c9f944ce88693e69bbea56023">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given polynomial to this new polynomial. </p>
<p >This is a fast (constant time) operation.</p>
<p >The polynomial that was passed (<em>value</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25c1c31a611b8708d14bdf6e809d016f" name="a25c1c31a611b8708d14bdf6e809d016f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c1c31a611b8708d14bdf6e809d016f">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>toShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>yShift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of the given polynomial with all terms multiplied by <code>x^d y^e</code> for some integers <em>d</em> and <em>e</em>. </p>
<p >This constructor induces a deep (and modified) copy of <em>value</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toShift</td><td>the polynomial to clone and shift. </td></tr>
    <tr><td class="paramname">xShift</td><td>the integer <em>d</em>, which will be added to all exponents for <em>x</em>. </td></tr>
    <tr><td class="paramname">yShift</td><td>the integer <em>e</em>, which will be added to all exponents for <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd07a8882921df669daf862ebd624a73" name="acd07a8882921df669daf862ebd624a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd07a8882921df669daf862ebd624a73">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given polynomial. </p>
<p >This constructor induces a deep copy of <em>value</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Objects of type <em>T</em> can be assigned values of type <em>U</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab97f3c265d8997bdfa3b8b494673d25e" name="ab97f3c265d8997bdfa3b8b494673d25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97f3c265d8997bdfa3b8b494673d25e">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename iterator , typename deref &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new polynomial from the given collection of coefficients. </p>
<p >The coefficients should be presented as a collection of tuples of the form (<em>d</em>, <em>e</em>, <em>v</em>), each representing a term of the form <code>v x^d y^e</code>.</p>
<p >The tuples may be given in any order. An empty sequence will be treated as the zero polynomial.</p>
<p >Unlike the std::initializer_list constructor, zero coefficients are allowed (these will be silently ignored), and multiple coefficients with the same exponents are also allowed (these will be aggregated using the += operator).</p>
<dl class="section user"><dt>Python</dt><dd>Instead of the iterators <em>begin</em> and <em>end</em>, this routine takes a python list of tuples.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">iterator</td><td>an iterator type which, when dereferenced, gives a std::tuple of the form (<em>d</em>, <em>e</em>, <em>v</em>), where <em>d</em> and <em>e</em> can be assigned to long integers, and where <em>v</em> can be assigned to type <em>T</em>.</td></tr>
    <tr><td class="paramname">deref</td><td>a dummy argument that should be ignored. This is present to ensure that <em>iterator</em> can be dereferenced, so that a call such as Laurent2(int, int) falls through to the (long, long) constructor, and not this iterator-based constructor instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>the beginning of the set of coefficients, as outlined above. </td></tr>
    <tr><td class="paramname">end</td><td>a past-the-end iterator indicating the end of the set of coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6c3979b7f375496277c6d81a0fc7e87" name="aa6c3979b7f375496277c6d81a0fc7e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c3979b7f375496277c6d81a0fc7e87">&#9670;&nbsp;</a></span>Laurent2() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::<a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::tuple&lt; long, long, T &gt; &gt;&#160;</td>
          <td class="paramname"><em>coefficients</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new polynomial from a hard-coded collection of non-zero coefficients. </p>
<p >The coefficients should be presented as a collection of tuples of the form (<em>d</em>, <em>e</em>, <em>v</em>) each representing a term of the form <code>v x^d y^e</code>.</p>
<p >The tuples may be given in any order. An empty sequence will be treated as the zero polynomial.</p>
<p >In practice, this means you can create a hard-coded polynomial using syntax such as:</p>
<div class="fragment"><div class="line">Laurent2&lt;Integer&gt; p = { { 0, 0, 3 }, { 1, -1, 2 } };</div>
</div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>Each tuple has a non-zero value <em>v</em>, and no two tuples share the same pair of exponents (<em>d</em>, <em>e</em>).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not available, but there is a Python constructor that takes a list of coefficients (which need not be constant).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coefficients</td><td>the set of all non-zero coefficients, as outlined above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a3b9ab37ac09da1d2c1af9597f6e333dd" name="a3b9ab37ac09da1d2c1af9597f6e333dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9ab37ac09da1d2c1af9597f6e333dd">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::init</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to become the zero polynomial. </p>

</div>
</div>
<a id="a151f203694f59cfa524785828edf9e81" name="a151f203694f59cfa524785828edf9e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151f203694f59cfa524785828edf9e81">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::init </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>yExp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to become the polynomial <code>x^d y^e</code> for the given exponents <em>d</em> and <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the new exponent <em>d</em>, which is attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the new exponent <em>e</em>, which is attached to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a928f26c1e006e72e788e2c997ba414d5" name="a928f26c1e006e72e788e2c997ba414d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928f26c1e006e72e788e2c997ba414d5">&#9670;&nbsp;</a></span>invertX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::invertX</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces <code>x</code> with <code>x^-1</code> in this polynomial. </p>
<p >This polynomial is changed directly. </p>

</div>
</div>
<a id="a6edd6a788a049890345d6e73942259f2" name="a6edd6a788a049890345d6e73942259f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edd6a788a049890345d6e73942259f2">&#9670;&nbsp;</a></span>invertY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::invertY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces <code>y</code> with <code>y^-1</code> in this polynomial. </p>
<p >This polynomial is changed directly. </p>

</div>
</div>
<a id="a0f2127cd484f250361b34862f116a597" name="a0f2127cd484f250361b34862f116a597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2127cd484f250361b34862f116a597">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::isZero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this is the zero polynomial. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the zero polynomial. </dd></dl>

</div>
</div>
<a id="a8fed3d5d702211cfd7b90cad87f43205" name="a8fed3d5d702211cfd7b90cad87f43205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fed3d5d702211cfd7b90cad87f43205">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::negate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates this polynomial. </p>
<p >This polynomial is changed directly. </p>

</div>
</div>
<a id="ada7c5b2e6e8649e8e31009121e1aca4d" name="ada7c5b2e6e8649e8e31009121e1aca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7c5b2e6e8649e8e31009121e1aca4d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given polynomial are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given polynomial are not equal. </dd></dl>

</div>
</div>
<a id="a9123daa1ba8056b3afde06f9a3087d77" name="a9123daa1ba8056b3afde06f9a3087d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9123daa1ba8056b3afde06f9a3087d77">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>yExp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given coefficient of this polynomial. </p>
<p >There are no restrictions on the exponents <em>xExp</em> and <em>yExp</em>.</p>
<dl class="section user"><dt>Python</dt><dd>In Python, this is the square bracket operator, not the round bracket operator; that is, Python users can access coefficients through the syntax <code>poly[xExp, yExp]</code>. Moreover, this operator can also <em>set</em> cofficients; that is, you can write <code>poly[xExp, yExp] = value</code>. However, when <em>getting</em> a coefficient this operator will return by value (to enforce constness), which means for example you cannot write something like <code>poly[xExp, yExp].<a class="el" href="classregina_1_1Laurent2.html#a8fed3d5d702211cfd7b90cad87f43205" title="Negates this polynomial.">negate()</a></code>.</dd></dl>
<dl class="section user"><dt>C++</dt><dd>C++ users must always set coefficients using the separate routine <a class="el" href="classregina_1_1Laurent2.html#a6e21fd6436363e5555380f69aef2b5ba" title="Changes the given coefficient of this polynomial.">set()</a>, since this bracket operator is const.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the exponent attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the exponent attached to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coefficient of the term with the given exponents. </dd></dl>

</div>
</div>
<a id="a91abd504dba2918cfc8e1589eac7c147" name="a91abd504dba2918cfc8e1589eac7c147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91abd504dba2918cfc8e1589eac7c147">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this by the given polynomial. </p>
<p >This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to multiply this by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a62b4233936c5293e81447dc71daaf157" name="a62b4233936c5293e81447dc71daaf157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b4233936c5293e81447dc71daaf157">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this polynomial by the given constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar factor to multiply by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a88f7e7ab24cc91845a017b34b887cb3c" name="a88f7e7ab24cc91845a017b34b887cb3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f7e7ab24cc91845a017b34b887cb3c">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given polynomial to this. </p>
<p >This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to add to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a5c4cdcdcf36e3c2323d6add8eb5f802f" name="a5c4cdcdcf36e3c2323d6add8eb5f802f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c4cdcdcf36e3c2323d6add8eb5f802f">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts the given polynomial from this. </p>
<p >This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial to subtract from this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="ad2a5d7d2ee2b527e1bf6f24564f6175a" name="ad2a5d7d2ee2b527e1bf6f24564f6175a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a5d7d2ee2b527e1bf6f24564f6175a">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this polynomial by the given constant. </p>
<p >This uses the division operator /= for the coefficient type <em>T</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>scalar</em> is non-zero.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>the scalar factor to divide by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="ac49925bfdf4d0d6d602425705699211e" name="ac49925bfdf4d0d6d602425705699211e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49925bfdf4d0d6d602425705699211e">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="a5e626d56686a59faa24a5e0e0eaae871" name="a5e626d56686a59faa24a5e0e0eaae871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e626d56686a59faa24a5e0e0eaae871">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is less than or equal to the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="a48c335642e5da5084f38d5b3c166e36b" name="a48c335642e5da5084f38d5b3c166e36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c335642e5da5084f38d5b3c166e36b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given polynomial. </p>
<p >This and the given polynomial need not have the same range of non-zero coefficients.</p>
<p >This operator induces a deep copy of <em>value</em>.</p>
<p >A note to developers: although this is identical to the templated assignment operator, it must be declared and implemented separately. See the copy constructor for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a538528845f776b8908e3a08f24af37b1" name="a538528845f776b8908e3a08f24af37b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538528845f776b8908e3a08f24af37b1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given polynomial. </p>
<p >This and the given polynomial need not have the same range of non-zero coefficients.</p>
<p >This operator induces a deep copy of <em>value</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a032ed022582395968183345ee988f77b" name="a032ed022582395968183345ee988f77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032ed022582395968183345ee988f77b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a> &amp; <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given polynomial to this polynomial. </p>
<p >This is a fast (constant time) operation.</p>
<p >This and the given polynomial need not have the same range of non-zero coefficients.</p>
<p >The polynomial that was passed (<em>value</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the polynomial to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this polynomial. </dd></dl>

</div>
</div>
<a id="a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0" name="a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbcaa4dc7a2ef20bd8e32c3a4ca8ee0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given polynomial are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given polynomial are equal. </dd></dl>

</div>
</div>
<a id="a698cac8d261c4ed6bd00bd90fbbeb6a2" name="a698cac8d261c4ed6bd00bd90fbbeb6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698cac8d261c4ed6bd00bd90fbbeb6a2">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is greater than the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="a3e2f7e865921b55ff7ae750614121c15" name="a3e2f7e865921b55ff7ae750614121c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2f7e865921b55ff7ae750614121c15">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this against the given polynomial under a total ordering of all two-variable <a class="el" href="classregina_1_1Laurent.html" title="Represents a single-variable Laurent polynomial with coefficients of type T.">Laurent</a> polynomials. </p>
<p >The particular total order that Regina uses is not important, and may change between Regina releases (though such changes should be very infrequent). The main purpose of this routine is to support algorithms that require a "canonical" choice of polynomial from amongst many alternatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the polynomial to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is greater than or equal to the given polynomial under the total order that Regina uses. </dd></dl>

</div>
</div>
<a id="a6e21fd6436363e5555380f69aef2b5ba" name="a6e21fd6436363e5555380f69aef2b5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e21fd6436363e5555380f69aef2b5ba">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>xExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>yExp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the given coefficient of this polynomial. </p>
<p >There are no restrictions on the exponents <em>xExp</em> and <em>yExp</em>, and the new coefficient <em>value</em> may be zero.</p>
<p >Moreover, the underlying data structures ensure that this operation is cheap regardless of the exponents involved.</p>
<dl class="section user"><dt>Python</dt><dd>This <a class="el" href="classregina_1_1Laurent2.html#a6e21fd6436363e5555380f69aef2b5ba" title="Changes the given coefficient of this polynomial.">set()</a> routine is available, but you can also set coefficients directly using syntax of the form <code>p[xExp, yExp] = value</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xExp</td><td>the exponent attached to <em>x</em>. </td></tr>
    <tr><td class="paramname">yExp</td><td>the exponent attached to <em>y</em>. </td></tr>
    <tr><td class="paramname">value</td><td>the new value of the corresponding coefficient. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a760f12b76398e549fa66a3a0e7ef3b79" name="a760f12b76398e549fa66a3a0e7ef3b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760f12b76398e549fa66a3a0e7ef3b79">&#9670;&nbsp;</a></span>str() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::str </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varY</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this polynomial as a human-readable string, using the given variable names instead of <code>x</code> and <code>y</code>. </p>
<dl class="section note"><dt>Note</dt><dd>There is also the usual variant of <a class="el" href="classregina_1_1Laurent2.html#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a> which takes no arguments; that variant is inherited from the <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varX</td><td>the symbol to use for the variable <em>x</em>. This may be <code>null</code>, in which case the default symbol <code>'x'</code> will be used. </td></tr>
    <tr><td class="paramname">varY</td><td>the symbol to use for the variable <em>y</em>. This may be <code>null</code>, in which case the default symbol <code>'y'</code> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this polynomial as a human-readable string. </dd></dl>

</div>
</div>
<a id="a5382c0231814155a040fd05d908d1f73" name="a5382c0231814155a040fd05d908d1f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5382c0231814155a040fd05d908d1f73">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given polynomial. </p>
<p >This is a fast (constant time) operation.</p>
<p >This and the given polynomial need not have the same range of non-zero coefficients.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the polynomial whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73caa4080f9139ff3c5fe4b3954af005" name="a73caa4080f9139ff3c5fe4b3954af005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73caa4080f9139ff3c5fe4b3954af005">&#9670;&nbsp;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this polynomial to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coefficient type <em>T</em> must have a corresponding global <a class="el" href="group__maths.html#gae8cd5c004f47461d75f07d3696fa855a" title="Writes the tight encoding of the given arbitrary precision integer to the given output stream.">regina::tightEncode()</a> function. This is true for native C++ integer types, as well as Regina's arbitrary precision integer types (Integer and LargeInteger).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="classregina_1_1Laurent2.html#aef276574a8952c46612ac02b4851b5c9" title="Returns the tight encoding of this polynomial.">tightEncoding()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef276574a8952c46612ac02b4851b5c9" name="aef276574a8952c46612ac02b4851b5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef276574a8952c46612ac02b4851b5c9">&#9670;&nbsp;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::tightEncoding</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this polynomial. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The coefficient type <em>T</em> must have a corresponding global <a class="el" href="group__maths.html#gae8cd5c004f47461d75f07d3696fa855a" title="Writes the tight encoding of the given arbitrary precision integer to the given output stream.">regina::tightEncode()</a> function. This is true for native C++ integer types, as well as Regina's arbitrary precision integer types (Integer and LargeInteger).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="classregina_1_1Laurent2.html#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="classregina_1_1Laurent2.html#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ade0a2543536786e006e31898f01140bb" name="ade0a2543536786e006e31898f01140bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0a2543536786e006e31898f01140bb">&#9670;&nbsp;</a></span>utf8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::utf8 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varY</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this polynomial as a human-readable string using unicode characters, using the given variable names instead of <code>x</code> and <code>y</code>. </p>
<p >This is similar to the output from <a class="el" href="classregina_1_1Laurent2.html#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a>, except that it uses unicode characters to make the output more pleasant to read. In particular, it makes use of superscript digits for exponents and a wider minus sign.</p>
<p >The string is encoded in UTF-8.</p>
<dl class="section note"><dt>Note</dt><dd>There is also the usual variant of <a class="el" href="classregina_1_1Laurent2.html#ade0a2543536786e006e31898f01140bb" title="Returns this polynomial as a human-readable string using unicode characters, using the given variable...">utf8()</a> which takes no arguments; that variant is inherited from the <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> class.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varX</td><td>the symbol to use for the variable <em>x</em>. This may be <code>null</code>, in which case the default symbol <code>'x'</code> will be used. </td></tr>
    <tr><td class="paramname">varY</td><td>the symbol to use for the variable <em>y</em>. This may be <code>null</code>, in which case the default symbol <code>'y'</code> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this polynomial as a unicode-enabled human-readable string. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1Laurent2.html">Laurent2</a>&lt; T &gt; , supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92be6449b77d1e89b70195d5467bddff" name="a92be6449b77d1e89b70195d5467bddff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92be6449b77d1e89b70195d5467bddff">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Laurent2.html">regina::Laurent2</a>&lt; T &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varX</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varY</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this polynomial to the given output stream, using the given variable names instead of <code>x</code> and <code>y</code>. </p>
<p >If <em>utf8</em> is passed as <code>true</code> then unicode superscript characters will be used for exponents and the minus sign; these will be encoded using UTF-8. This will make the output nicer, but will require more complex fonts to be available on the user's machine.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="classregina_1_1Laurent2.html#a760f12b76398e549fa66a3a0e7ef3b79" title="Returns this polynomial as a human-readable string, using the given variable names instead of x and y...">str()</a> or <a class="el" href="classregina_1_1Laurent2.html#ade0a2543536786e006e31898f01140bb" title="Returns this polynomial as a human-readable string using unicode characters, using the given variable...">utf8()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td><code>true</code> if unicode characters may be used. </td></tr>
    <tr><td class="paramname">varX</td><td>the symbol to use for the variable <em>x</em>. This may be <code>null</code>, in which case the default symbol <code>'x'</code> will be used. </td></tr>
    <tr><td class="paramname">varY</td><td>the symbol to use for the variable <em>y</em>. This may be <code>null</code>, in which case the default symbol <code>'y'</code> will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>link/<a class="el" href="link_8h.html">link.h</a></li>
<li>maths/<a class="el" href="laurent2_8h.html">laurent2.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
