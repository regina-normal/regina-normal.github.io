<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: regina::LayeredSolidTorus Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1LayeredSolidTorus-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::LayeredSolidTorus Class Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a layered solid torus in a triangulation.  
 <a href="classregina_1_1LayeredSolidTorus.html#details">More...</a></p>

<p><code>#include &lt;subcomplex/layeredsolidtorus.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::LayeredSolidTorus:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1LayeredSolidTorus.png" usemap="#regina::LayeredSolidTorus_map" alt=""/>
  <map id="regina::LayeredSolidTorus_map" name="regina::LayeredSolidTorus_map">
<area href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood." alt="regina::StandardTriangulation" shape="rect" coords="0,56,239,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; StandardTriangulation &gt;" shape="rect" coords="0,0,239,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a09d276e0e2111ba4eb8c870e01ace888"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a09d276e0e2111ba4eb8c870e01ace888">LayeredSolidTorus</a> (const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;)=default</td></tr>
<tr class="memdesc:a09d276e0e2111ba4eb8c870e01ace888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of this structure.  <a href="classregina_1_1LayeredSolidTorus.html#a09d276e0e2111ba4eb8c870e01ace888">More...</a><br /></td></tr>
<tr class="separator:a09d276e0e2111ba4eb8c870e01ace888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2607485ab41eadd080a86deca986b09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#ad2607485ab41eadd080a86deca986b09">operator=</a> (const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;)=default</td></tr>
<tr class="memdesc:ad2607485ab41eadd080a86deca986b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given structure.  <a href="classregina_1_1LayeredSolidTorus.html#ad2607485ab41eadd080a86deca986b09">More...</a><br /></td></tr>
<tr class="separator:ad2607485ab41eadd080a86deca986b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf91448a3ac701e3c8d92f55bcd6e923"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#acf91448a3ac701e3c8d92f55bcd6e923">clone</a> () const</td></tr>
<tr class="memdesc:acf91448a3ac701e3c8d92f55bcd6e923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns a new copy of this structure.  <a href="classregina_1_1LayeredSolidTorus.html#acf91448a3ac701e3c8d92f55bcd6e923">More...</a><br /></td></tr>
<tr class="separator:acf91448a3ac701e3c8d92f55bcd6e923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0125a1fced945a89c931728f2517805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#aa0125a1fced945a89c931728f2517805">swap</a> (<a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aa0125a1fced945a89c931728f2517805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given structure.  <a href="classregina_1_1LayeredSolidTorus.html#aa0125a1fced945a89c931728f2517805">More...</a><br /></td></tr>
<tr class="separator:aa0125a1fced945a89c931728f2517805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bebe108f5548a9a54906ff125eea76"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a19bebe108f5548a9a54906ff125eea76">size</a> () const</td></tr>
<tr class="memdesc:a19bebe108f5548a9a54906ff125eea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of tetrahedra in this layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a19bebe108f5548a9a54906ff125eea76">More...</a><br /></td></tr>
<tr class="separator:a19bebe108f5548a9a54906ff125eea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c4ba0b396da11144f1731eb57afa6d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a65c4ba0b396da11144f1731eb57afa6d">base</a> () const</td></tr>
<tr class="memdesc:a65c4ba0b396da11144f1731eb57afa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tetrahedron that is glued to itself at the base of this layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a65c4ba0b396da11144f1731eb57afa6d">More...</a><br /></td></tr>
<tr class="separator:a65c4ba0b396da11144f1731eb57afa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe4f467fdcdf10f93cfa51add967408"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a1fe4f467fdcdf10f93cfa51add967408">baseEdge</a> (int group, int index) const</td></tr>
<tr class="memdesc:a1fe4f467fdcdf10f93cfa51add967408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested edge of the base tetrahedron belonging to the given group.  <a href="classregina_1_1LayeredSolidTorus.html#a1fe4f467fdcdf10f93cfa51add967408">More...</a><br /></td></tr>
<tr class="separator:a1fe4f467fdcdf10f93cfa51add967408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bef8d63cbb68b084b6f83eee9e4b46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#ae4bef8d63cbb68b084b6f83eee9e4b46">baseEdgeGroup</a> (int edge) const</td></tr>
<tr class="memdesc:ae4bef8d63cbb68b084b6f83eee9e4b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group that the given edge of the base tetrahedron belongs to.  <a href="classregina_1_1LayeredSolidTorus.html#ae4bef8d63cbb68b084b6f83eee9e4b46">More...</a><br /></td></tr>
<tr class="separator:ae4bef8d63cbb68b084b6f83eee9e4b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbc6675863e3d5b646ee2da41dd0c1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a2cbc6675863e3d5b646ee2da41dd0c1c">baseFace</a> (int index) const</td></tr>
<tr class="memdesc:a2cbc6675863e3d5b646ee2da41dd0c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the two faces of the base tetrahedron that are glued to each other.  <a href="classregina_1_1LayeredSolidTorus.html#a2cbc6675863e3d5b646ee2da41dd0c1c">More...</a><br /></td></tr>
<tr class="separator:a2cbc6675863e3d5b646ee2da41dd0c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ab7e811f03de50313c9e294803047a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#ae2ab7e811f03de50313c9e294803047a">topLevel</a> () const</td></tr>
<tr class="memdesc:ae2ab7e811f03de50313c9e294803047a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top level tetrahedron in this layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#ae2ab7e811f03de50313c9e294803047a">More...</a><br /></td></tr>
<tr class="separator:ae2ab7e811f03de50313c9e294803047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3b241365315391145ebe5fb7f7ad3c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a1e3b241365315391145ebe5fb7f7ad3c">meridinalCuts</a> (int group) const</td></tr>
<tr class="memdesc:a1e3b241365315391145ebe5fb7f7ad3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of times the meridinal disc of the torus cuts the top level tetrahedron edges in the given group.  <a href="classregina_1_1LayeredSolidTorus.html#a1e3b241365315391145ebe5fb7f7ad3c">More...</a><br /></td></tr>
<tr class="separator:a1e3b241365315391145ebe5fb7f7ad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8910645cf2e930df846536098d9a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a0b8910645cf2e930df846536098d9a34">topEdge</a> (int group, int index) const</td></tr>
<tr class="memdesc:a0b8910645cf2e930df846536098d9a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested edge of the top level tetrahedron belonging to the given group.  <a href="classregina_1_1LayeredSolidTorus.html#a0b8910645cf2e930df846536098d9a34">More...</a><br /></td></tr>
<tr class="separator:a0b8910645cf2e930df846536098d9a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ba8a45362bc1ef93195913c4cc6b9e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a52ba8a45362bc1ef93195913c4cc6b9e">topEdgeGroup</a> (int edge) const</td></tr>
<tr class="memdesc:a52ba8a45362bc1ef93195913c4cc6b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group that the given edge of the top level tetrahedron belongs to.  <a href="classregina_1_1LayeredSolidTorus.html#a52ba8a45362bc1ef93195913c4cc6b9e">More...</a><br /></td></tr>
<tr class="separator:a52ba8a45362bc1ef93195913c4cc6b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba992cb747e96fe1da6ec884daffa4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#afba992cb747e96fe1da6ec884daffa4d">topFace</a> (int index) const</td></tr>
<tr class="memdesc:afba992cb747e96fe1da6ec884daffa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the two faces of the top level tetrahedron that form the boundary of this layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#afba992cb747e96fe1da6ec884daffa4d">More...</a><br /></td></tr>
<tr class="separator:afba992cb747e96fe1da6ec884daffa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6f4afd229cf86144dc0f7f2ec030fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a4a6f4afd229cf86144dc0f7f2ec030fc">operator==</a> (const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;other) const</td></tr>
<tr class="memdesc:a4a6f4afd229cf86144dc0f7f2ec030fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object represent the same type of layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a4a6f4afd229cf86144dc0f7f2ec030fc">More...</a><br /></td></tr>
<tr class="separator:a4a6f4afd229cf86144dc0f7f2ec030fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e403663e0e312f71f5f4fd56aed875d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a1e403663e0e312f71f5f4fd56aed875d">operator!=</a> (const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;other) const</td></tr>
<tr class="memdesc:a1e403663e0e312f71f5f4fd56aed875d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object do not represent the same type of layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a1e403663e0e312f71f5f4fd56aed875d">More...</a><br /></td></tr>
<tr class="separator:a1e403663e0e312f71f5f4fd56aed875d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4589e8128b4bc63cf6b5fba94480efde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a4589e8128b4bc63cf6b5fba94480efde">flatten</a> (int mobiusBandBdry) const</td></tr>
<tr class="memdesc:a4589e8128b4bc63cf6b5fba94480efde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens this layered solid torus to a Mobius band.  <a href="classregina_1_1LayeredSolidTorus.html#a4589e8128b4bc63cf6b5fba94480efde">More...</a><br /></td></tr>
<tr class="separator:a4589e8128b4bc63cf6b5fba94480efde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da374f35eee604d0dabb55128036d45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a5da374f35eee604d0dabb55128036d45">transform</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;originalTri, const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;iso, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;newTri)</td></tr>
<tr class="memdesc:a5da374f35eee604d0dabb55128036d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the details of this layered solid torus according to the given isomorphism between triangulations.  <a href="classregina_1_1LayeredSolidTorus.html#a5da374f35eee604d0dabb55128036d45">More...</a><br /></td></tr>
<tr class="separator:a5da374f35eee604d0dabb55128036d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a86c6e0b838794cd5043b79d7e7f2e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a82a86c6e0b838794cd5043b79d7e7f2e">manifold</a> () const override</td></tr>
<tr class="memdesc:a82a86c6e0b838794cd5043b79d7e7f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 3-manifold represented by this triangulation, if such a recognition routine has been implemented.  <a href="classregina_1_1LayeredSolidTorus.html#a82a86c6e0b838794cd5043b79d7e7f2e">More...</a><br /></td></tr>
<tr class="separator:a82a86c6e0b838794cd5043b79d7e7f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4d064266fd8acfac4a738527ac9d82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a7b4d064266fd8acfac4a738527ac9d82">homology</a> () const override</td></tr>
<tr class="memdesc:a7b4d064266fd8acfac4a738527ac9d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the expected first homology group of this triangulation, if such a routine has been implemented.  <a href="classregina_1_1LayeredSolidTorus.html#a7b4d064266fd8acfac4a738527ac9d82">More...</a><br /></td></tr>
<tr class="separator:a7b4d064266fd8acfac4a738527ac9d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d03cc2acaae8ef46a0c64d311b0e04"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a77d03cc2acaae8ef46a0c64d311b0e04">writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a77d03cc2acaae8ef46a0c64d311b0e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation as a human-readable string to the given output stream.  <a href="classregina_1_1LayeredSolidTorus.html#a77d03cc2acaae8ef46a0c64d311b0e04">More...</a><br /></td></tr>
<tr class="separator:a77d03cc2acaae8ef46a0c64d311b0e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b26b8de06723564d00d023362df52a0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a7b26b8de06723564d00d023362df52a0">writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a7b26b8de06723564d00d023362df52a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the name of this triangulation in TeX format to the given output stream.  <a href="classregina_1_1LayeredSolidTorus.html#a7b26b8de06723564d00d023362df52a0">More...</a><br /></td></tr>
<tr class="separator:a7b26b8de06723564d00d023362df52a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a090404befec76de5deefbb74bc4063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a3a090404befec76de5deefbb74bc4063">writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a3a090404befec76de5deefbb74bc4063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1LayeredSolidTorus.html#a3a090404befec76de5deefbb74bc4063">More...</a><br /></td></tr>
<tr class="separator:a3a090404befec76de5deefbb74bc4063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f318c415f2ec73916cc6c3aa669d8a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a62f318c415f2ec73916cc6c3aa669d8a">name</a> () const</td></tr>
<tr class="memdesc:a62f318c415f2ec73916cc6c3aa669d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this specific triangulation as a human-readable string.  <a href="classregina_1_1StandardTriangulation.html#a62f318c415f2ec73916cc6c3aa669d8a">More...</a><br /></td></tr>
<tr class="separator:a62f318c415f2ec73916cc6c3aa669d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b043a590a3fe156a6d7174cfc2b67"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a2d4b043a590a3fe156a6d7174cfc2b67">texName</a> () const</td></tr>
<tr class="memdesc:a2d4b043a590a3fe156a6d7174cfc2b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of this specific triangulation in TeX format.  <a href="classregina_1_1StandardTriangulation.html#a2d4b043a590a3fe156a6d7174cfc2b67">More...</a><br /></td></tr>
<tr class="separator:a2d4b043a590a3fe156a6d7174cfc2b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad060bab2f08b1e5881d25b2291d8e09c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#ad060bab2f08b1e5881d25b2291d8e09c">TeXName</a> () const</td></tr>
<tr class="memdesc:ad060bab2f08b1e5881d25b2291d8e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the name of this specific triangulation in TeX format.  <a href="classregina_1_1StandardTriangulation.html#ad060bab2f08b1e5881d25b2291d8e09c">More...</a><br /></td></tr>
<tr class="separator:ad060bab2f08b1e5881d25b2291d8e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034d94b674ab9665cf89343e4e6bf4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a034d94b674ab9665cf89343e4e6bf4a1">homologyH1</a> () const</td></tr>
<tr class="memdesc:a034d94b674ab9665cf89343e4e6bf4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for <a class="el" href="classregina_1_1StandardTriangulation.html#a16113b9e3a77b2a6c7660b52963c6669" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homology()</a>.  <a href="classregina_1_1StandardTriangulation.html#a034d94b674ab9665cf89343e4e6bf4a1">More...</a><br /></td></tr>
<tr class="separator:a034d94b674ab9665cf89343e4e6bf4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a933ec0aad81b4560f574f4f2e15813"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a1a933ec0aad81b4560f574f4f2e15813">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a1a933ec0aad81b4560f574f4f2e15813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1StandardTriangulation.html#a1a933ec0aad81b4560f574f4f2e15813">More...</a><br /></td></tr>
<tr class="separator:a1a933ec0aad81b4560f574f4f2e15813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8c9f85d8ef89414b2ed84a5d31f57532"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a8c9f85d8ef89414b2ed84a5d31f57532">recogniseFromBase</a> (const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet)</td></tr>
<tr class="memdesc:a8c9f85d8ef89414b2ed84a5d31f57532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms the base of a layered solid torus within a triangulation.  <a href="classregina_1_1LayeredSolidTorus.html#a8c9f85d8ef89414b2ed84a5d31f57532">More...</a><br /></td></tr>
<tr class="separator:a8c9f85d8ef89414b2ed84a5d31f57532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382a51d61b9b7799a880efcace1a8f01"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a382a51d61b9b7799a880efcace1a8f01">formsLayeredSolidTorusBase</a> (const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet)</td></tr>
<tr class="memdesc:a382a51d61b9b7799a880efcace1a8f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias to recognise if a tetrahedron forms the base of a layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a382a51d61b9b7799a880efcace1a8f01">More...</a><br /></td></tr>
<tr class="separator:a382a51d61b9b7799a880efcace1a8f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312bd1f98781f43f8a05113454499741"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a312bd1f98781f43f8a05113454499741">recogniseFromTop</a> (const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet, unsigned topFace1, unsigned topFace2)</td></tr>
<tr class="memdesc:a312bd1f98781f43f8a05113454499741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given tetrahedron forms the top level tetrahedron of a layered solid torus, with the two given faces of this tetrahedron representing the boundary of the layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a312bd1f98781f43f8a05113454499741">More...</a><br /></td></tr>
<tr class="separator:a312bd1f98781f43f8a05113454499741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb94ea57665d7746a8160c71ec3e955"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a0cb94ea57665d7746a8160c71ec3e955">formsLayeredSolidTorusTop</a> (const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *tet, unsigned topFace1, unsigned topFace2)</td></tr>
<tr class="memdesc:a0cb94ea57665d7746a8160c71ec3e955"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias to recognise if a tetrahedron forms the top level of a layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a0cb94ea57665d7746a8160c71ec3e955">More...</a><br /></td></tr>
<tr class="separator:a0cb94ea57665d7746a8160c71ec3e955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d323dfe63fba359d466dd2d568b7f7d"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d">recognise</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:a4d323dfe63fba359d466dd2d568b7f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given triangulation component forms a layered solid torus in its entirity.  <a href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d">More...</a><br /></td></tr>
<tr class="separator:a4d323dfe63fba359d466dd2d568b7f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b910323fb2f584e69dffced34cceba4"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LayeredSolidTorus.html#a4b910323fb2f584e69dffced34cceba4">isLayeredSolidTorus</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *comp)</td></tr>
<tr class="memdesc:a4b910323fb2f584e69dffced34cceba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias to recognise if a component forms a layered solid torus.  <a href="classregina_1_1LayeredSolidTorus.html#a4b910323fb2f584e69dffced34cceba4">More...</a><br /></td></tr>
<tr class="separator:a4b910323fb2f584e69dffced34cceba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea8690c85576087eded614370f3864e"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#aaea8690c85576087eded614370f3864e">recognise</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="memdesc:aaea8690c85576087eded614370f3864e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given triangulation represents one of the standard triangulations understood by Regina.  <a href="classregina_1_1StandardTriangulation.html#aaea8690c85576087eded614370f3864e">More...</a><br /></td></tr>
<tr class="separator:aaea8690c85576087eded614370f3864e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b21ea5a5f5c8a47336905bf8bb2caf"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#a54b21ea5a5f5c8a47336905bf8bb2caf">isStandardTriangulation</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *component)</td></tr>
<tr class="memdesc:a54b21ea5a5f5c8a47336905bf8bb2caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias to determine whether a component represents one of the standard triangulations understood by Regina.  <a href="classregina_1_1StandardTriangulation.html#a54b21ea5a5f5c8a47336905bf8bb2caf">More...</a><br /></td></tr>
<tr class="separator:a54b21ea5a5f5c8a47336905bf8bb2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6df8bce837b8adc7d3897f9d3e49fbb"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1StandardTriangulation.html#af6df8bce837b8adc7d3897f9d3e49fbb">isStandardTriangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="memdesc:af6df8bce837b8adc7d3897f9d3e49fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias to determine whether a triangulation represents one of the standard triangulations understood by Regina.  <a href="classregina_1_1StandardTriangulation.html#af6df8bce837b8adc7d3897f9d3e49fbb">More...</a><br /></td></tr>
<tr class="separator:af6df8bce837b8adc7d3897f9d3e49fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a layered solid torus in a triangulation. </p>
<p >A layered solid torus must contain at least one tetrahedron.</p>
<p >Note that this class <b>only</b> represents layered solid tori with a (3,2,1) at their base. Thus triangulations that begin with a degenerate (2,1,1) mobius strip and layer over the mobius strip boundary (including the minimal (1,1,0) triangulation) are not described by this class.</p>
<p >All optional <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> routines are implemented for this class.</p>
<p >This class supports copying but does not implement separate move operations, since its internal data is so small that copying is just as efficient. It implements the C++ Swappable requirement via its own member and global <a class="el" href="classregina_1_1LayeredSolidTorus.html#aa0125a1fced945a89c931728f2517805" title="Swaps the contents of this and the given structure.">swap()</a> functions, for consistency with the other <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> subclasses. Note that the only way to create these objects (aside from copying or moving) is via the static member function <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a09d276e0e2111ba4eb8c870e01ace888" name="a09d276e0e2111ba4eb8c870e01ace888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d276e0e2111ba4eb8c870e01ace888">&#9670;&nbsp;</a></span>LayeredSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::LayeredSolidTorus::LayeredSolidTorus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of this structure. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65c4ba0b396da11144f1731eb57afa6d" name="a65c4ba0b396da11144f1731eb57afa6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c4ba0b396da11144f1731eb57afa6d">&#9670;&nbsp;</a></span>base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::LayeredSolidTorus::base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tetrahedron that is glued to itself at the base of this layered solid torus. </p>
<dl class="section return"><dt>Returns</dt><dd>the base tetrahedron. </dd></dl>

</div>
</div>
<a id="a1fe4f467fdcdf10f93cfa51add967408" name="a1fe4f467fdcdf10f93cfa51add967408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe4f467fdcdf10f93cfa51add967408">&#9670;&nbsp;</a></span>baseEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::baseEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested edge of the base tetrahedron belonging to the given group. </p>
<p >The layering identifies the six edges of the base tetrahedron into a group of three, a group of two and a single unidentified edge; these are referred to as groups 3, 2 and 1 respectively.</p>
<p >Note that <code>baseEdgeGroup(baseEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code>.</p>
<p >Edges <code>baseEdge(2,0)</code> and <code>baseEdge(3,0)</code> will both belong to face <code>baseFace(0)</code>. Edges <code>baseEdge(2,1)</code> and <code>baseEdge(3,2)</code> will both belong to face <code>baseFace(1)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group that the requested edge should belong to; this must be 1, 2 or 3. </td></tr>
    <tr><td class="paramname">index</td><td>the index within the given group of the requested edge; this must be between 0 and <em>group</em>-1 inclusive. Note that in group 3 the edge at index 1 is adjacent to both the edges at indexes 0 and 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge number in the base tetrahedron of the requested edge; this will be between 0 and 5 inclusive. </dd></dl>

</div>
</div>
<a id="ae4bef8d63cbb68b084b6f83eee9e4b46" name="ae4bef8d63cbb68b084b6f83eee9e4b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4bef8d63cbb68b084b6f83eee9e4b46">&#9670;&nbsp;</a></span>baseEdgeGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::baseEdgeGroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the group that the given edge of the base tetrahedron belongs to. </p>
<p >See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a1fe4f467fdcdf10f93cfa51add967408" title="Returns the requested edge of the base tetrahedron belonging to the given group.">baseEdge()</a> for further details about groups.</p>
<p >Note that <code>baseEdgeGroup(baseEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>the edge number in the base tetrahedron of the given edge; this must be between 0 and 5 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the group to which the given edge belongs; this will be 1, 2 or 3. </dd></dl>

</div>
</div>
<a id="a2cbc6675863e3d5b646ee2da41dd0c1c" name="a2cbc6675863e3d5b646ee2da41dd0c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbc6675863e3d5b646ee2da41dd0c1c">&#9670;&nbsp;</a></span>baseFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::baseFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns one of the two faces of the base tetrahedron that are glued to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two faces to return; this must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face number in the base tetrahedron; this will be between 0 and 3 inclusive. </dd></dl>

</div>
</div>
<a id="acf91448a3ac701e3c8d92f55bcd6e923" name="acf91448a3ac701e3c8d92f55bcd6e923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf91448a3ac701e3c8d92f55bcd6e923">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> * regina::LayeredSolidTorus::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns a new copy of this structure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000140">Deprecated:</a></b></dt><dd>Just use the copy constructor instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created clone. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a4589e8128b4bc63cf6b5fba94480efde" name="a4589e8128b4bc63cf6b5fba94480efde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4589e8128b4bc63cf6b5fba94480efde">&#9670;&nbsp;</a></span>flatten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::LayeredSolidTorus::flatten </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mobiusBandBdry</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens this layered solid torus to a Mobius band. </p>
<p >A new modified triangulation is returned; the original triangulation that contains this layered solid torus will be left unchanged.</p>
<p >Note that there are three different ways in which this layered solid torus can be flattened, corresponding to the three different edges of the boundary torus that could become the boundary edge of the new Mobius band.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mobiusBandBdry</td><td>the edge group on the boundary of this layered solid torus that will become the boundary of the new Mobius band (the remaining edge groups will become internal edges of the new Mobius band). This must be 0, 1 or 2. See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">topEdge()</a> for further details about edge groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new triangulation in which this layered solid torus has been flattened to a Mobius band. </dd></dl>

</div>
</div>
<a id="a382a51d61b9b7799a880efcace1a8f01" name="a382a51d61b9b7799a880efcace1a8f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382a51d61b9b7799a880efcace1a8f01">&#9670;&nbsp;</a></span>formsLayeredSolidTorusBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt; regina::LayeredSolidTorus::formsLayeredSolidTorusBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias to recognise if a tetrahedron forms the base of a layered solid torus. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000141">Deprecated:</a></b></dt><dd>This function has been renamed to <a class="el" href="classregina_1_1LayeredSolidTorus.html#a8c9f85d8ef89414b2ed84a5d31f57532" title="Determines if the given tetrahedron forms the base of a layered solid torus within a triangulation.">recogniseFromBase()</a>. See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a> for details on the parameters and return value. </dd></dl>

</div>
</div>
<a id="a0cb94ea57665d7746a8160c71ec3e955" name="a0cb94ea57665d7746a8160c71ec3e955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb94ea57665d7746a8160c71ec3e955">&#9670;&nbsp;</a></span>formsLayeredSolidTorusTop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt; regina::LayeredSolidTorus::formsLayeredSolidTorusTop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>topFace1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>topFace2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias to recognise if a tetrahedron forms the top level of a layered solid torus. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000142">Deprecated:</a></b></dt><dd>This function has been renamed to <a class="el" href="classregina_1_1LayeredSolidTorus.html#a312bd1f98781f43f8a05113454499741" title="Determines if the given tetrahedron forms the top level tetrahedron of a layered solid torus,...">recogniseFromTop()</a>. See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a> for details on the parameters and return value. </dd></dl>

</div>
</div>
<a id="a7b4d064266fd8acfac4a738527ac9d82" name="a7b4d064266fd8acfac4a738527ac9d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4d064266fd8acfac4a738527ac9d82">&#9670;&nbsp;</a></span>homology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> regina::LayeredSolidTorus::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the expected first homology group of this triangulation, if such a routine has been implemented. </p>
<p >This routine does not work by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">Triangulation&lt;3&gt;::homology()</a> on the associated real triangulation. Instead the homology is calculated directly from the known properties of this standard triangulation.</p>
<p >This means that <a class="el" href="classregina_1_1LayeredSolidTorus.html#a7b4d064266fd8acfac4a738527ac9d82" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homology()</a> needs to be implemented separately for each class of standard triangulation. See the class notes for each subclass of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> for details on whether homology has been implemented for that particular subclass. The default implementation of this routine just throws a <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> exception.</p>
<p >Most users will not need this routine, since presumably you already have an explicit <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> available and so you can just call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">Triangulation&lt;3&gt;::homology()</a> instead (which, unlike this routine, <em>is</em> always implemented). This <a class="el" href="classregina_1_1StandardTriangulation.html#a16113b9e3a77b2a6c7660b52963c6669" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">StandardTriangulation::homology()</a> routine should be seen as more of a verification/validation tool for the Regina developers.</p>
<p >If this <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> describes an entire <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> (and not just a part thereof) then the results of this routine should be identical to the homology group obtained by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34a72bfac6207c6ac044d98cd6ec2081" title="Returns the kth homology group of this triangulation, treating any ideal vertices as though they had ...">Triangulation&lt;3&gt;::homology()</a> upon the associated real triangulation.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>homology calculation has not yet been implemented for this particular type of standard triangulation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FileError.html" title="An exception thrown when trying to access data from the filesystem.">FileError</a></td><td>the homology needs to be read from file (as opposed to computed), but the file is inaccessible or its contents cannot be read and parsed correctly. Currently this can only happen for the subclass <a class="el" href="classregina_1_1SnapPeaCensusTri.html" title="Represents a 3-manifold triangulation from the SnapPea cusped census.">SnapPeaCensusTri</a>, which reads its results from the SnapPea census databases that are installed with Regina.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, if this functionality has been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1StandardTriangulation.html#a16113b9e3a77b2a6c7660b52963c6669">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="a034d94b674ab9665cf89343e4e6bf4a1" name="a034d94b674ab9665cf89343e4e6bf4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034d94b674ab9665cf89343e4e6bf4a1">&#9670;&nbsp;</a></span>homologyH1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> regina::StandardTriangulation::homologyH1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for <a class="el" href="classregina_1_1LayeredSolidTorus.html#a7b4d064266fd8acfac4a738527ac9d82" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homology()</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000163">Deprecated:</a></b></dt><dd>This routine can be accessed by the simpler name <a class="el" href="classregina_1_1LayeredSolidTorus.html#a7b4d064266fd8acfac4a738527ac9d82" title="Returns the expected first homology group of this triangulation, if such a routine has been implement...">homology()</a>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>homology calculation has not yet been implemented for this particular type of standard triangulation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this triangulation, if this functionality has been implemented. </dd></dl>

</div>
</div>
<a id="a4b910323fb2f584e69dffced34cceba4" name="a4b910323fb2f584e69dffced34cceba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b910323fb2f584e69dffced34cceba4">&#9670;&nbsp;</a></span>isLayeredSolidTorus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt; regina::LayeredSolidTorus::isLayeredSolidTorus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias to recognise if a component forms a layered solid torus. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000143">Deprecated:</a></b></dt><dd>This function has been renamed to <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a>. See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a> for details on the parameters and return value. </dd></dl>

</div>
</div>
<a id="a54b21ea5a5f5c8a47336905bf8bb2caf" name="a54b21ea5a5f5c8a47336905bf8bb2caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b21ea5a5f5c8a47336905bf8bb2caf">&#9670;&nbsp;</a></span>isStandardTriangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &gt; regina::StandardTriangulation::isStandardTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias to determine whether a component represents one of the standard triangulations understood by Regina. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000164">Deprecated:</a></b></dt><dd>This function has been renamed to <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a>. See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a> for details on the parameters and return value. </dd></dl>

</div>
</div>
<a id="af6df8bce837b8adc7d3897f9d3e49fbb" name="af6df8bce837b8adc7d3897f9d3e49fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6df8bce837b8adc7d3897f9d3e49fbb">&#9670;&nbsp;</a></span>isStandardTriangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &gt; regina::StandardTriangulation::isStandardTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias to determine whether a triangulation represents one of the standard triangulations understood by Regina. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000165">Deprecated:</a></b></dt><dd>This function has been renamed to <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a>. See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise()</a> for details on the parameters and return value. </dd></dl>

</div>
</div>
<a id="a82a86c6e0b838794cd5043b79d7e7f2e" name="a82a86c6e0b838794cd5043b79d7e7f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a86c6e0b838794cd5043b79d7e7f2e">&#9670;&nbsp;</a></span>manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &gt; regina::LayeredSolidTorus::manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 3-manifold represented by this triangulation, if such a recognition routine has been implemented. </p>
<p >If the 3-manifold cannot be recognised then this routine will return <code>null</code>.</p>
<p >The details of which standard triangulations have 3-manifold recognition routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a>. The default implementation of this routine returns <code>null</code>.</p>
<p >It is expected that the number of triangulations whose underlying 3-manifolds can be recognised will grow between releases.</p>
<dl class="section return"><dt>Returns</dt><dd>the underlying 3-manifold. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1StandardTriangulation.html#af7586803cc7091bbafd8f5311f7fc963">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="a1e3b241365315391145ebe5fb7f7ad3c" name="a1e3b241365315391145ebe5fb7f7ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3b241365315391145ebe5fb7f7ad3c">&#9670;&nbsp;</a></span>meridinalCuts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::LayeredSolidTorus::meridinalCuts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of times the meridinal disc of the torus cuts the top level tetrahedron edges in the given group. </p>
<p >See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">topEdge()</a> for further details about groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the given edge group; this must be 0, 1 or 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times the meridinal disc cuts the edges in the given group. </dd></dl>

</div>
</div>
<a id="a62f318c415f2ec73916cc6c3aa669d8a" name="a62f318c415f2ec73916cc6c3aa669d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f318c415f2ec73916cc6c3aa669d8a">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::StandardTriangulation::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this specific triangulation as a human-readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation. </dd></dl>

</div>
</div>
<a id="a1e403663e0e312f71f5f4fd56aed875d" name="a1e403663e0e312f71f5f4fd56aed875d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e403663e0e312f71f5f4fd56aed875d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredSolidTorus::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object do not represent the same type of layered solid torus. </p>
<p >Specifically, two layered solid tori will compare as equal if and only if each has the same ordered triple of integer parameters (describing how many times the three top-level edge groups cut the meridinal disc).</p>
<p >Note that it is possible for two non-isomorphic layered solid tori to compare as equal, since these integer parameters do not detect the presence of redundant layerings (i.e., consecutive layerings that topologically cancel each other out).</p>
<p >This test follows the general rule for most subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> (excluding fixed structures such as <a class="el" href="classregina_1_1SnappedBall.html" title="Represents a snapped 3-ball in a triangulation.">SnappedBall</a> and <a class="el" href="classregina_1_1TriSolidTorus.html" title="Represents a three-tetrahedron triangular solid torus in a triangulation.">TriSolidTorus</a>): two objects compare as equal if and only if they have the same combinatorial parameters (which for this subclass, as noted above, is weaker than combinatorial isomorphism).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the layered solid torus to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object do not represent the same type of layered solid torus. </dd></dl>

</div>
</div>
<a id="ad2607485ab41eadd080a86deca986b09" name="ad2607485ab41eadd080a86deca986b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2607485ab41eadd080a86deca986b09">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp; regina::LayeredSolidTorus::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given structure. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this structure. </dd></dl>

</div>
</div>
<a id="a4a6f4afd229cf86144dc0f7f2ec030fc" name="a4a6f4afd229cf86144dc0f7f2ec030fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6f4afd229cf86144dc0f7f2ec030fc">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::LayeredSolidTorus::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object represent the same type of layered solid torus. </p>
<p >Specifically, two layered solid tori will compare as equal if and only if each has the same ordered triple of integer parameters (describing how many times the three top-level edge groups cut the meridinal disc).</p>
<p >Note that it is possible for two non-isomorphic layered solid tori to compare as equal, since these integer parameters do not detect the presence of redundant layerings (i.e., consecutive layerings that topologically cancel each other out).</p>
<p >This test follows the general rule for most subclasses of <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> (excluding fixed structures such as <a class="el" href="classregina_1_1SnappedBall.html" title="Represents a snapped 3-ball in a triangulation.">SnappedBall</a> and <a class="el" href="classregina_1_1TriSolidTorus.html" title="Represents a three-tetrahedron triangular solid torus in a triangulation.">TriSolidTorus</a>): two objects compare as equal if and only if they have the same combinatorial parameters (which for this subclass, as noted above, is weaker than combinatorial isomorphism).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the layered solid torus to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object represent the same type of layered solid torus. </dd></dl>

</div>
</div>
<a id="a4d323dfe63fba359d466dd2d568b7f7d" name="a4d323dfe63fba359d466dd2d568b7f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d323dfe63fba359d466dd2d568b7f7d">&#9670;&nbsp;</a></span>recognise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt; regina::LayeredSolidTorus::recognise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given triangulation component forms a layered solid torus in its entirity. </p>
<p >Note that, unlike <a class="el" href="classregina_1_1LayeredSolidTorus.html#a382a51d61b9b7799a880efcace1a8f01" title="A deprecated alias to recognise if a tetrahedron forms the base of a layered solid torus.">formsLayeredSolidTorusBase()</a>, this routine tests for a component that is a layered solid torus with no additional tetrahedra or gluings. That is, the two boundary triangles of the layered solid torus must in fact be boundary triangles of the component.</p>
<p >This function returns by (smart) pointer for consistency with <a class="el" href="classregina_1_1StandardTriangulation.html#aa58caa75373914748a713c2d60c8af9a" title="Determines whether the given component represents one of the standard triangulations understood by Re...">StandardTriangulation::recognise()</a>, which makes use of the polymorphic nature of the <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the triangulation component to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure containing details of the layered solid torus, or <code>null</code> if the given component is not a layered solid torus. </dd></dl>

</div>
</div>
<a id="aaea8690c85576087eded614370f3864e" name="aaea8690c85576087eded614370f3864e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaea8690c85576087eded614370f3864e">&#9670;&nbsp;</a></span>recognise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> &gt; regina::StandardTriangulation::recognise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given triangulation represents one of the standard triangulations understood by Regina. </p>
<p >The list of recognised triangulations is expected to grow between releases.</p>
<p >If the standard triangulation returned has boundary triangles then the given triangulation must have the same corresponding boundary triangles, i.e., the triangulation cannot have any further identifications of these boundary triangles with each other.</p>
<p >This routine may recognise more triangulations than the component-based <a class="el" href="classregina_1_1LayeredSolidTorus.html#a4d323dfe63fba359d466dd2d568b7f7d" title="Determines if the given triangulation component forms a layered solid torus in its entirity.">recognise(Component&lt;3&gt;*)</a>, since passing an entire triangulation allows access to more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation under examination. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the details of the standard triangualation if the given triangulation is recognised, or <code>null</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8c9f85d8ef89414b2ed84a5d31f57532" name="a8c9f85d8ef89414b2ed84a5d31f57532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9f85d8ef89414b2ed84a5d31f57532">&#9670;&nbsp;</a></span>recogniseFromBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt; regina::LayeredSolidTorus::recogniseFromBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms the base of a layered solid torus within a triangulation. </p>
<p >The torus need not be the entire triangulation; the top level tetrahedron of the torus may be glued to something else (or to itself).</p>
<p >Note that the base tetrahedron of a layered solid torus is the tetrahedron furthest from the boundary of the torus, i.e. the tetrahedron glued to itself with a twist.</p>
<p >This function returns by (smart) pointer for consistency with <a class="el" href="classregina_1_1StandardTriangulation.html#aa58caa75373914748a713c2d60c8af9a" title="Determines whether the given component represents one of the standard triangulations understood by Re...">StandardTriangulation::recognise()</a>, which makes use of the polymorphic nature of the <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine as a potential base. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure containing details of the layered solid torus, or <code>null</code> if the given tetrahedron is not the base of a layered solid torus. </dd></dl>

</div>
</div>
<a id="a312bd1f98781f43f8a05113454499741" name="a312bd1f98781f43f8a05113454499741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a312bd1f98781f43f8a05113454499741">&#9670;&nbsp;</a></span>recogniseFromTop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt; <a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &gt; regina::LayeredSolidTorus::recogniseFromTop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>topFace1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>topFace2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given tetrahedron forms the top level tetrahedron of a layered solid torus, with the two given faces of this tetrahedron representing the boundary of the layered solid torus. </p>
<p >Note that the two given faces need not be boundary triangles in the overall triangulation. That is, the layered solid torus may be a subcomplex of some larger triangulation. For example, the two given faces may be joined to some other tetrahedra outside the layered solid torus or they may be joined to each other. In fact, they may even extend this smaller layered solid torus to a larger layered solid torus.</p>
<p >This function returns by (smart) pointer for consistency with <a class="el" href="classregina_1_1StandardTriangulation.html#aa58caa75373914748a713c2d60c8af9a" title="Determines whether the given component represents one of the standard triangulations understood by Re...">StandardTriangulation::recognise()</a>, which makes use of the polymorphic nature of the <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tet</td><td>the tetrahedron to examine as a potential top level of a layered solid torus. </td></tr>
    <tr><td class="paramname">topFace1</td><td>the face number of the given tetrahedron that should represent the first boundary triangle of the layered solid torus. This should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">topFace2</td><td>the face number of the given tetrahedron that should represent the second boundary triangle of the layered solid torus. This should be between 0 and 3 inclusive, and should not be equal to <em>topFace1</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a structure containing details of the layered solid torus, or <code>null</code> if the given tetrahedron with its two faces do not form the top level of a layered solid torus. </dd></dl>

</div>
</div>
<a id="a19bebe108f5548a9a54906ff125eea76" name="a19bebe108f5548a9a54906ff125eea76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bebe108f5548a9a54906ff125eea76">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::LayeredSolidTorus::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of tetrahedra in this layered solid torus. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa0125a1fced945a89c931728f2517805" name="aa0125a1fced945a89c931728f2517805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0125a1fced945a89c931728f2517805">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredSolidTorus::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LayeredSolidTorus.html">LayeredSolidTorus</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the structure whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d4b043a590a3fe156a6d7174cfc2b67" name="a2d4b043a590a3fe156a6d7174cfc2b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4b043a590a3fe156a6d7174cfc2b67">&#9670;&nbsp;</a></span>texName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::StandardTriangulation::texName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of this specific triangulation in TeX format. </p>
<p >No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation in TeX format. </dd></dl>

</div>
</div>
<a id="ad060bab2f08b1e5881d25b2291d8e09c" name="ad060bab2f08b1e5881d25b2291d8e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad060bab2f08b1e5881d25b2291d8e09c">&#9670;&nbsp;</a></span>TeXName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::StandardTriangulation::TeXName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the name of this specific triangulation in TeX format. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000162">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1StandardTriangulation.html#a2d4b043a590a3fe156a6d7174cfc2b67" title="Returns the name of this specific triangulation in TeX format.">texName()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the name of this triangulation in TeX format. </dd></dl>

</div>
</div>
<a id="a0b8910645cf2e930df846536098d9a34" name="a0b8910645cf2e930df846536098d9a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8910645cf2e930df846536098d9a34">&#9670;&nbsp;</a></span>topEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::topEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested edge of the top level tetrahedron belonging to the given group. </p>
<p >The layering reduces five of the top level tetrahedron edges to three boundary edges of the solid torus; this divides the five initial edges into groups of size two, two and one.</p>
<p >Group 0 represents the boundary edge that the meridinal disc cuts fewest times. Group 2 represents the boundary edge that the meridinal disc cuts most times. Group 1 is in the middle.</p>
<p >Note that <code>topEdgeGroup(topEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code> that actually correspond to an edge.</p>
<p >Edges <code>topEdge(group, 0)</code> will all belong to face <code>topFace(0)</code>. Edges <code>topEdge(group, 1)</code> (if they exist) will all belong to face <code>topFace(1)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group that the requested edge should belong to; this must be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">index</td><td>the index within the given group of the requested edge; this must be 0 or 1. Note that one of the groups only contains one tetrahedron edge, in which case this edge will be stored at index 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge number in the top level tetrahedron of the requested edge (between 0 and 5 inclusive), or -1 if there is no such edge (only possible if the given group was the group of size one and the given index was 1). </dd></dl>

</div>
</div>
<a id="a52ba8a45362bc1ef93195913c4cc6b9e" name="a52ba8a45362bc1ef93195913c4cc6b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ba8a45362bc1ef93195913c4cc6b9e">&#9670;&nbsp;</a></span>topEdgeGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::topEdgeGroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the group that the given edge of the top level tetrahedron belongs to. </p>
<p >See <a class="el" href="classregina_1_1LayeredSolidTorus.html#a0b8910645cf2e930df846536098d9a34" title="Returns the requested edge of the top level tetrahedron belonging to the given group.">topEdge()</a> for further details about groups.</p>
<p >Note that <code>topEdgeGroup(topEdge(group, index)) == group</code> for all values of <code>group</code> and <code>index</code> that actually correspond to an edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>the edge number in the top level tetrahedron of the given edge; this must be between 0 and 5 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the group to which the given edge belongs (0, 1 or 2), or -1 if this edge does not belong to any group (only possible if this is the unique edge in the top tetrahedron not on the torus boundary). </dd></dl>

</div>
</div>
<a id="afba992cb747e96fe1da6ec884daffa4d" name="afba992cb747e96fe1da6ec884daffa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba992cb747e96fe1da6ec884daffa4d">&#9670;&nbsp;</a></span>topFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::LayeredSolidTorus::topFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns one of the two faces of the top level tetrahedron that form the boundary of this layered solid torus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which of the two faces to return; this must be 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face number in the top level tetrahedron; this will be between 0 and 3 inclusive. </dd></dl>

</div>
</div>
<a id="ae2ab7e811f03de50313c9e294803047a" name="ae2ab7e811f03de50313c9e294803047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ab7e811f03de50313c9e294803047a">&#9670;&nbsp;</a></span>topLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::LayeredSolidTorus::topLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top level tetrahedron in this layered solid torus. </p>
<p >This is the tetrahedron that would be on the boundary of the torus if the torus were the entire manifold.</p>
<dl class="section return"><dt>Returns</dt><dd>the top level tetrahedron. </dd></dl>

</div>
</div>
<a id="a5da374f35eee604d0dabb55128036d45" name="a5da374f35eee604d0dabb55128036d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da374f35eee604d0dabb55128036d45">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredSolidTorus::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts the details of this layered solid torus according to the given isomorphism between triangulations. </p>
<p >The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this layered solid torus must currently refer to tetrahedra in <em>originalTri</em>. After this routine is called this structure will instead refer to the corresponding tetrahedra in <em>newTri</em> (with changes in vertex/face numbering also accounted for).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This layered solid torus currently refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently referenced by this layered solid torus. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be referenced by the updated layered solid torus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1StandardTriangulation.html">StandardTriangulation</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a77d03cc2acaae8ef46a0c64d311b0e04" name="a77d03cc2acaae8ef46a0c64d311b0e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d03cc2acaae8ef46a0c64d311b0e04">&#9670;&nbsp;</a></span>writeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredSolidTorus::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead use the variant <a class="el" href="classregina_1_1StandardTriangulation.html#a62f318c415f2ec73916cc6c3aa669d8a" title="Returns the name of this specific triangulation as a human-readable string.">name()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1StandardTriangulation.html#a49cb50d02c8cc0d61c214adba6beb7fa">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="a7b26b8de06723564d00d023362df52a0" name="a7b26b8de06723564d00d023362df52a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b26b8de06723564d00d023362df52a0">&#9670;&nbsp;</a></span>writeTeXName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::LayeredSolidTorus::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the name of this triangulation in TeX format to the given output stream. </p>
<p >No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present; instead use the variant <a class="el" href="classregina_1_1StandardTriangulation.html#a2d4b043a590a3fe156a6d7174cfc2b67" title="Returns the name of this specific triangulation in TeX format.">texName()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1StandardTriangulation.html#a51b828528a7da6c21a23f2fcb2055d3d">regina::StandardTriangulation</a>.</p>

</div>
</div>
<a id="a1a933ec0aad81b4560f574f4f2e15813" name="a1a933ec0aad81b4560f574f4f2e15813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a933ec0aad81b4560f574f4f2e15813">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::StandardTriangulation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p >This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="classregina_1_1LayeredSolidTorus.html#a3a090404befec76de5deefbb74bc4063" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1AugTriSolidTorus.html#a62bf0dddd611fb1ac1b0d05f79f50f51">regina::AugTriSolidTorus</a>, <a class="el" href="classregina_1_1BlockedSFS.html#aaf88cb11f0dc3fa4717cfe0970b0671b">regina::BlockedSFS</a>, <a class="el" href="classregina_1_1BlockedSFSLoop.html#a2ed6371374a10a805c612b5f82eef296">regina::BlockedSFSLoop</a>, <a class="el" href="classregina_1_1BlockedSFSPair.html#af44d8e2931379c7b16b1df400205363e">regina::BlockedSFSPair</a>, <a class="el" href="classregina_1_1BlockedSFSTriple.html#a1204d734453ff396ed67e8d4932638c7">regina::BlockedSFSTriple</a>, <a class="el" href="classregina_1_1LayeredChainPair.html#acd44940e8690d4efa5fead8c5b8de349">regina::LayeredChainPair</a>, <a class="el" href="classregina_1_1LayeredLensSpace.html#adc54288677ea5caef65896ad25f4e95b">regina::LayeredLensSpace</a>, <a class="el" href="classregina_1_1LayeredLoop.html#a566d5c530d931e15893ca17018b2f216">regina::LayeredLoop</a>, <a class="el" href="classregina_1_1LayeredTorusBundle.html#a08de39903d5532b0957df84fbcae493e">regina::LayeredTorusBundle</a>, <a class="el" href="classregina_1_1PluggedTorusBundle.html#a4278557170643a37470486a03599153d">regina::PluggedTorusBundle</a>, <a class="el" href="classregina_1_1PlugTriSolidTorus.html#a62026c61dc76949cc5ce03dea53f70b0">regina::PlugTriSolidTorus</a>, and <a class="el" href="classregina_1_1TrivialTri.html#a78fec3514968e13c7ff4b8f900be4c0b">regina::TrivialTri</a>.</p>

</div>
</div>
<a id="a3a090404befec76de5deefbb74bc4063" name="a3a090404befec76de5deefbb74bc4063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a090404befec76de5deefbb74bc4063">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::LayeredSolidTorus::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p >This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1StandardTriangulation.html" title="Describes a triangulation or subcomplex of a triangulation whose structure is well-understood.">StandardTriangulation</a> class offers a reasonable default implementation based on <a class="el" href="classregina_1_1LayeredSolidTorus.html#a77d03cc2acaae8ef46a0c64d311b0e04" title="Writes the name of this triangulation as a human-readable string to the given output stream.">writeName()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1StandardTriangulation.html#a11da317c33469df8b5518cecb60b2109">regina::StandardTriangulation</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="layeredsolidtorus_8h.html">layeredsolidtorus.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
