<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: regina::AbelianGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1AbelianGroup-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::AbelianGroup Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a finitely generated abelian group.  
 <a href="classregina_1_1AbelianGroup.html#details">More...</a></p>

<p><code>#include &lt;algebra/abeliangroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::AbelianGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1AbelianGroup.png" usemap="#regina::AbelianGroup_map" alt=""/>
  <map id="regina::AbelianGroup_map" name="regina::AbelianGroup_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; AbelianGroup, true &gt;" shape="rect" coords="0,56,272,80"/>
<area href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output." alt="regina::Output&lt; T, supportsUtf8 &gt;" shape="rect" coords="0,0,272,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ad5bf25488fbf05a2f0ad0d7c3b63be59">AbelianGroup</a> ()</td></tr>
<tr class="memdesc:ad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial group.  <a href="classregina_1_1AbelianGroup.html#ad5bf25488fbf05a2f0ad0d7c3b63be59">More...</a><br /></td></tr>
<tr class="separator:ad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe48cc46e37632284163c6cd005dfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ac6fe48cc46e37632284163c6cd005dfb">AbelianGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:ac6fe48cc46e37632284163c6cd005dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group.  <a href="classregina_1_1AbelianGroup.html#ac6fe48cc46e37632284163c6cd005dfb">More...</a><br /></td></tr>
<tr class="separator:ac6fe48cc46e37632284163c6cd005dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5e70bd7e57f8ab65cd40107ee822dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a0c5e70bd7e57f8ab65cd40107ee822dd">AbelianGroup</a> (<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:a0c5e70bd7e57f8ab65cd40107ee822dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group to this new group.  <a href="classregina_1_1AbelianGroup.html#a0c5e70bd7e57f8ab65cd40107ee822dd">More...</a><br /></td></tr>
<tr class="separator:a0c5e70bd7e57f8ab65cd40107ee822dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f43fdbc3e86a05938be1ee8aee2fd67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a3f43fdbc3e86a05938be1ee8aee2fd67">AbelianGroup</a> (unsigned <a class="el" href="classregina_1_1AbelianGroup.html#ada506c15842e993b6fdc651b0122d3af">rank</a>)</td></tr>
<tr class="memdesc:a3f43fdbc3e86a05938be1ee8aee2fd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a free abelian group of the given rank.  <a href="classregina_1_1AbelianGroup.html#a3f43fdbc3e86a05938be1ee8aee2fd67">More...</a><br /></td></tr>
<tr class="separator:a3f43fdbc3e86a05938be1ee8aee2fd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817aa8e0c414ab2e5f43368033cae53f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a817aa8e0c414ab2e5f43368033cae53f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a817aa8e0c414ab2e5f43368033cae53f">AbelianGroup</a> (unsigned <a class="el" href="classregina_1_1AbelianGroup.html#ada506c15842e993b6fdc651b0122d3af">rank</a>, std::initializer_list&lt; T &gt; invFac)</td></tr>
<tr class="memdesc:a817aa8e0c414ab2e5f43368033cae53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new group with the given rank and invariant factors.  <a href="classregina_1_1AbelianGroup.html#a817aa8e0c414ab2e5f43368033cae53f">More...</a><br /></td></tr>
<tr class="separator:a817aa8e0c414ab2e5f43368033cae53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab846ee644b4edd4d2d287c6ef0ae9533"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classregina_1_1Container.html">Container</a> &gt; </td></tr>
<tr class="memitem:ab846ee644b4edd4d2d287c6ef0ae9533"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ab846ee644b4edd4d2d287c6ef0ae9533">AbelianGroup</a> (unsigned <a class="el" href="classregina_1_1AbelianGroup.html#ada506c15842e993b6fdc651b0122d3af">rank</a>, const <a class="el" href="classregina_1_1Container.html">Container</a> &amp;invFac)</td></tr>
<tr class="memdesc:ab846ee644b4edd4d2d287c6ef0ae9533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new group with the given rank and invariant factors.  <a href="classregina_1_1AbelianGroup.html#ab846ee644b4edd4d2d287c6ef0ae9533">More...</a><br /></td></tr>
<tr class="separator:ab846ee644b4edd4d2d287c6ef0ae9533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791e00f5098bf6beb7bb48b6dce20050"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a791e00f5098bf6beb7bb48b6dce20050">AbelianGroup</a> (<a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> presentation)</td></tr>
<tr class="memdesc:a791e00f5098bf6beb7bb48b6dce20050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the abelian group defined by the given presentation matrix.  <a href="classregina_1_1AbelianGroup.html#a791e00f5098bf6beb7bb48b6dce20050">More...</a><br /></td></tr>
<tr class="separator:a791e00f5098bf6beb7bb48b6dce20050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1782f02c61cfc17f669ab34f873ab3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aa1782f02c61cfc17f669ab34f873ab3c">AbelianGroup</a> (<a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> M, <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> N)</td></tr>
<tr class="memdesc:aa1782f02c61cfc17f669ab34f873ab3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex.  <a href="classregina_1_1AbelianGroup.html#aa1782f02c61cfc17f669ab34f873ab3c">More...</a><br /></td></tr>
<tr class="separator:aa1782f02c61cfc17f669ab34f873ab3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7020239c7bcbcdfbbb1da98d5195edb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ab7020239c7bcbcdfbbb1da98d5195edb">AbelianGroup</a> (<a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> M, <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> N, const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;p)</td></tr>
<tr class="memdesc:ab7020239c7bcbcdfbbb1da98d5195edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients.  <a href="classregina_1_1AbelianGroup.html#ab7020239c7bcbcdfbbb1da98d5195edb">More...</a><br /></td></tr>
<tr class="separator:ab7020239c7bcbcdfbbb1da98d5195edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffd523df4ffbe34d6d38adacd4b6e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aaffd523df4ffbe34d6d38adacd4b6e7d">addRank</a> (int extraRank=1)</td></tr>
<tr class="memdesc:aaffd523df4ffbe34d6d38adacd4b6e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the rank of the group by the given integer.  <a href="classregina_1_1AbelianGroup.html#aaffd523df4ffbe34d6d38adacd4b6e7d">More...</a><br /></td></tr>
<tr class="separator:aaffd523df4ffbe34d6d38adacd4b6e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d0639c896d068034c99eb53f487b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93">addTorsion</a> (<a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> degree)</td></tr>
<tr class="memdesc:a70d0639c896d068034c99eb53f487b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given torsion element to the group.  <a href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93">More...</a><br /></td></tr>
<tr class="separator:a70d0639c896d068034c99eb53f487b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9de8c90029f068306126465da9f7296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aa9de8c90029f068306126465da9f7296">addTorsionElement</a> (const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;degree, unsigned mult=1)</td></tr>
<tr class="memdesc:aa9de8c90029f068306126465da9f7296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that adds the given torsion element to the group.  <a href="classregina_1_1AbelianGroup.html#aa9de8c90029f068306126465da9f7296">More...</a><br /></td></tr>
<tr class="separator:aa9de8c90029f068306126465da9f7296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae926d3d6b0dce31e40c27eb475057077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ae926d3d6b0dce31e40c27eb475057077">addTorsionElement</a> (unsigned long degree, unsigned mult=1)</td></tr>
<tr class="memdesc:ae926d3d6b0dce31e40c27eb475057077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that adds the given torsion element to the group.  <a href="classregina_1_1AbelianGroup.html#ae926d3d6b0dce31e40c27eb475057077">More...</a><br /></td></tr>
<tr class="separator:ae926d3d6b0dce31e40c27eb475057077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9f394fc848b2483e5ac93ad6e7cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a70f9f394fc848b2483e5ac93ad6e7cef">addTorsionElements</a> (const std::multiset&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;torsion)</td></tr>
<tr class="memdesc:a70f9f394fc848b2483e5ac93ad6e7cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that adds the given set of torsion elements to this group.  <a href="classregina_1_1AbelianGroup.html#a70f9f394fc848b2483e5ac93ad6e7cef">More...</a><br /></td></tr>
<tr class="separator:a70f9f394fc848b2483e5ac93ad6e7cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8c9b3e44af87012db52b9492e0b59b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aba8c9b3e44af87012db52b9492e0b59b">addGroup</a> (<a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> presentation)</td></tr>
<tr class="memdesc:aba8c9b3e44af87012db52b9492e0b59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the abelian group defined by the given presentation to this group.  <a href="classregina_1_1AbelianGroup.html#aba8c9b3e44af87012db52b9492e0b59b">More...</a><br /></td></tr>
<tr class="separator:aba8c9b3e44af87012db52b9492e0b59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f258af0b04c62e2de0f61df3d710509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a3f258af0b04c62e2de0f61df3d710509">addGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;group)</td></tr>
<tr class="memdesc:a3f258af0b04c62e2de0f61df3d710509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given abelian group to this group.  <a href="classregina_1_1AbelianGroup.html#a3f258af0b04c62e2de0f61df3d710509">More...</a><br /></td></tr>
<tr class="separator:a3f258af0b04c62e2de0f61df3d710509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada506c15842e993b6fdc651b0122d3af"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ada506c15842e993b6fdc651b0122d3af">rank</a> () const</td></tr>
<tr class="memdesc:ada506c15842e993b6fdc651b0122d3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the group.  <a href="classregina_1_1AbelianGroup.html#ada506c15842e993b6fdc651b0122d3af">More...</a><br /></td></tr>
<tr class="separator:ada506c15842e993b6fdc651b0122d3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b15418d1e879e91983cbbd13dcbb1e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a72b15418d1e879e91983cbbd13dcbb1e">torsionRank</a> (const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;degree) const</td></tr>
<tr class="memdesc:a72b15418d1e879e91983cbbd13dcbb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank in the group of the torsion term of given degree.  <a href="classregina_1_1AbelianGroup.html#a72b15418d1e879e91983cbbd13dcbb1e">More...</a><br /></td></tr>
<tr class="separator:a72b15418d1e879e91983cbbd13dcbb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3777b5ec94d450465db9327c7ea774e7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a3777b5ec94d450465db9327c7ea774e7">torsionRank</a> (unsigned long degree) const</td></tr>
<tr class="memdesc:a3777b5ec94d450465db9327c7ea774e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank in the group of the torsion term of given degree.  <a href="classregina_1_1AbelianGroup.html#a3777b5ec94d450465db9327c7ea774e7">More...</a><br /></td></tr>
<tr class="separator:a3777b5ec94d450465db9327c7ea774e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7bc0b871554e7302ba01b17470fe0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a3eb7bc0b871554e7302ba01b17470fe0">countInvariantFactors</a> () const</td></tr>
<tr class="memdesc:a3eb7bc0b871554e7302ba01b17470fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of invariant factors that describe the torsion elements of this group.  <a href="classregina_1_1AbelianGroup.html#a3eb7bc0b871554e7302ba01b17470fe0">More...</a><br /></td></tr>
<tr class="separator:a3eb7bc0b871554e7302ba01b17470fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67d3b2e704ec84b1e20555e32f4c3ed"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ab67d3b2e704ec84b1e20555e32f4c3ed">invariantFactor</a> (size_t index) const</td></tr>
<tr class="memdesc:ab67d3b2e704ec84b1e20555e32f4c3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the given invariant factor describing the torsion elements of this group.  <a href="classregina_1_1AbelianGroup.html#ab67d3b2e704ec84b1e20555e32f4c3ed">More...</a><br /></td></tr>
<tr class="separator:ab67d3b2e704ec84b1e20555e32f4c3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65860d714f70889df0fec507a7658f8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a65860d714f70889df0fec507a7658f8f">isTrivial</a> () const</td></tr>
<tr class="memdesc:a65860d714f70889df0fec507a7658f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the trivial (zero) group.  <a href="classregina_1_1AbelianGroup.html#a65860d714f70889df0fec507a7658f8f">More...</a><br /></td></tr>
<tr class="separator:a65860d714f70889df0fec507a7658f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919a9f896922a25d7c9b6e32a877471f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a919a9f896922a25d7c9b6e32a877471f">isZ</a> () const</td></tr>
<tr class="memdesc:a919a9f896922a25d7c9b6e32a877471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the infinite cyclic group (Z).  <a href="classregina_1_1AbelianGroup.html#a919a9f896922a25d7c9b6e32a877471f">More...</a><br /></td></tr>
<tr class="separator:a919a9f896922a25d7c9b6e32a877471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd8d4c1dd13f30df21855b26e4d1198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a1dd8d4c1dd13f30df21855b26e4d1198">isFree</a> (unsigned r) const</td></tr>
<tr class="memdesc:a1dd8d4c1dd13f30df21855b26e4d1198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the free abelian group of the given rank.  <a href="classregina_1_1AbelianGroup.html#a1dd8d4c1dd13f30df21855b26e4d1198">More...</a><br /></td></tr>
<tr class="separator:a1dd8d4c1dd13f30df21855b26e4d1198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75846527dae06863f9b924622ccfe8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ae75846527dae06863f9b924622ccfe8b">isZn</a> (unsigned long n) const</td></tr>
<tr class="memdesc:ae75846527dae06863f9b924622ccfe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the non-trivial cyclic group on the given number of elements.  <a href="classregina_1_1AbelianGroup.html#ae75846527dae06863f9b924622ccfe8b">More...</a><br /></td></tr>
<tr class="separator:ae75846527dae06863f9b924622ccfe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ed4b87463c30c91f16059b8587522b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a87ed4b87463c30c91f16059b8587522b">operator==</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:a87ed4b87463c30c91f16059b8587522b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group have identical presentations (which means they are isomorphic).  <a href="classregina_1_1AbelianGroup.html#a87ed4b87463c30c91f16059b8587522b">More...</a><br /></td></tr>
<tr class="separator:a87ed4b87463c30c91f16059b8587522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654c5cee9a97206990fcc36ff62906b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a654c5cee9a97206990fcc36ff62906b1">operator!=</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:a654c5cee9a97206990fcc36ff62906b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group have different presentations (which means they are non-isomorphic).  <a href="classregina_1_1AbelianGroup.html#a654c5cee9a97206990fcc36ff62906b1">More...</a><br /></td></tr>
<tr class="separator:a654c5cee9a97206990fcc36ff62906b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbdfc133bb2e81f4ec95e74049817d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a2cbdfc133bb2e81f4ec95e74049817d4">operator=</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:a2cbdfc133bb2e81f4ec95e74049817d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given group.  <a href="classregina_1_1AbelianGroup.html#a2cbdfc133bb2e81f4ec95e74049817d4">More...</a><br /></td></tr>
<tr class="separator:a2cbdfc133bb2e81f4ec95e74049817d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f96717878ee0e56cd24f20b797019a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#af4f96717878ee0e56cd24f20b797019a">operator=</a> (<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:af4f96717878ee0e56cd24f20b797019a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given group to this group.  <a href="classregina_1_1AbelianGroup.html#af4f96717878ee0e56cd24f20b797019a">More...</a><br /></td></tr>
<tr class="separator:af4f96717878ee0e56cd24f20b797019a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc7c540ed48c527365fa852a5746dc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aafc7c540ed48c527365fa852a5746dc5">swap</a> (<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aafc7c540ed48c527365fa852a5746dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given abelian group.  <a href="classregina_1_1AbelianGroup.html#aafc7c540ed48c527365fa852a5746dc5">More...</a><br /></td></tr>
<tr class="separator:aafc7c540ed48c527365fa852a5746dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa94585fdce3980370bb8a0a10f33ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a0fa94585fdce3980370bb8a0a10f33ce">tightEncode</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a0fa94585fdce3980370bb8a0a10f33ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tight encoding of this abelian group to the given output stream.  <a href="classregina_1_1AbelianGroup.html#a0fa94585fdce3980370bb8a0a10f33ce">More...</a><br /></td></tr>
<tr class="separator:a0fa94585fdce3980370bb8a0a10f33ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033d4a5f7cc477f608274f327bc902e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a033d4a5f7cc477f608274f327bc902e5">tightEncoding</a> () const</td></tr>
<tr class="memdesc:a033d4a5f7cc477f608274f327bc902e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tight encoding of this abelian group.  <a href="classregina_1_1AbelianGroup.html#a033d4a5f7cc477f608274f327bc902e5">More...</a><br /></td></tr>
<tr class="separator:a033d4a5f7cc477f608274f327bc902e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd184409a580597ac709e7875355be74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#afd184409a580597ac709e7875355be74">writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afd184409a580597ac709e7875355be74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this abelian group.  <a href="classregina_1_1AbelianGroup.html#afd184409a580597ac709e7875355be74">More...</a><br /></td></tr>
<tr class="separator:afd184409a580597ac709e7875355be74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655d3a9de8d18a136f5ca578b6cfa7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a655d3a9de8d18a136f5ca578b6cfa7b9">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a>=false) const</td></tr>
<tr class="memdesc:a655d3a9de8d18a136f5ca578b6cfa7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1AbelianGroup.html#a655d3a9de8d18a136f5ca578b6cfa7b9">More...</a><br /></td></tr>
<tr class="separator:a655d3a9de8d18a136f5ca578b6cfa7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9bb4166ec40c17c6a042f6d0609ed4db"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a9bb4166ec40c17c6a042f6d0609ed4db">rank_</a> { 0 }</td></tr>
<tr class="memdesc:a9bb4166ec40c17c6a042f6d0609ed4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of the group (the number of Z components).  <a href="classregina_1_1AbelianGroup.html#a9bb4166ec40c17c6a042f6d0609ed4db">More...</a><br /></td></tr>
<tr class="separator:a9bb4166ec40c17c6a042f6d0609ed4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad69a3e9caa2736e6126399e890a836d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ad69a3e9caa2736e6126399e890a836d6">revInvFactors_</a></td></tr>
<tr class="memdesc:ad69a3e9caa2736e6126399e890a836d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.  <a href="classregina_1_1AbelianGroup.html#ad69a3e9caa2736e6126399e890a836d6">More...</a><br /></td></tr>
<tr class="separator:ad69a3e9caa2736e6126399e890a836d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a finitely generated abelian group. </p>
<p >The torsion elements of the group are stored in terms of their invariant factors. For instance, Z_2+Z_3 will appear as Z_6, and Z_2+Z_2+Z_3 will appear as Z_2+Z_6.</p>
<p >In general the factors will appear as Z_<em>d0</em>+...+Z_<em>dn</em>, where the invariant factors <em>di</em> are all greater than 1 and satisfy <em>d0</em>|<em>d1</em>|...|<em>dn</em>. Note that this representation is unique.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like.</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad5bf25488fbf05a2f0ad0d7c3b63be59" name="ad5bf25488fbf05a2f0ad0d7c3b63be59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bf25488fbf05a2f0ad0d7c3b63be59">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new trivial group. </p>

</div>
</div>
<a id="ac6fe48cc46e37632284163c6cd005dfb" name="ac6fe48cc46e37632284163c6cd005dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fe48cc46e37632284163c6cd005dfb">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group. </p>

</div>
</div>
<a id="a0c5e70bd7e57f8ab65cd40107ee822dd" name="a0c5e70bd7e57f8ab65cd40107ee822dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5e70bd7e57f8ab65cd40107ee822dd">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group to this new group. </p>
<p >This is a fast (constant time) operation.</p>
<p >The group that was passed will no longer be usable. </p>

</div>
</div>
<a id="a3f43fdbc3e86a05938be1ee8aee2fd67" name="a3f43fdbc3e86a05938be1ee8aee2fd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f43fdbc3e86a05938be1ee8aee2fd67">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a free abelian group of the given rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the rank of the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a817aa8e0c414ab2e5f43368033cae53f" name="a817aa8e0c414ab2e5f43368033cae53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817aa8e0c414ab2e5f43368033cae53f">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>invFac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new group with the given rank and invariant factors. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">The</td><td>invariant factors were not all greater than 1, and/or they did not satisfy the divisibily requirement (where each invariant factor must divide the one after it).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not available, but there is a constructor that takes the invariant factors as a Python list.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>an integer type, which may be a native C++ integer type or one of Regina's own integer types.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the rank of the new group (i.e., the number of copies of <em>Z</em>). </td></tr>
    <tr><td class="paramname">invFac</td><td>the list of invariant factors <em>d0</em>, <em>d1</em>, ..., as described in the class notes, where each invariant factor is greater than 1 and divides the invariant factor after it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab846ee644b4edd4d2d287c6ef0ae9533" name="ab846ee644b4edd4d2d287c6ef0ae9533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab846ee644b4edd4d2d287c6ef0ae9533">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classregina_1_1Container.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Container.html">Container</a> &amp;&#160;</td>
          <td class="paramname"><em>invFac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new group with the given rank and invariant factors. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">The</td><td>invariant factors were not all greater than 1, and/or they did not satisfy the divisibily requirement (where each invariant factor must divide the one after it).</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classregina_1_1Container.html" title="A packet that simply contains other packets.">Container</a></td><td>a container or view that supports reverse iteration via rbegin(), rend(), that has an empty() function, and whose elements may be of a native C++ integer type or one of Regina's own integer types. A suitable example might be std::vector&lt;int&gt;.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>the rank of the new group (i.e., the number of copies of <em>Z</em>). </td></tr>
    <tr><td class="paramname">invFac</td><td>the list of invariant factors <em>d0</em>, <em>d1</em>, ..., as described in the class notes, where each invariant factor is greater than 1 and divides the invariant factor after it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a791e00f5098bf6beb7bb48b6dce20050" name="a791e00f5098bf6beb7bb48b6dce20050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791e00f5098bf6beb7bb48b6dce20050">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>presentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the abelian group defined by the given presentation matrix. </p>
<p >Each column of the matrix represents a generator, and each row of the matrix represents a relation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">presentation</td><td>a presentation matrix for the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1782f02c61cfc17f669ab34f873ab3c" name="aa1782f02c61cfc17f669ab34f873ab3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1782f02c61cfc17f669ab34f873ab3c">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex. </p>
<p >The abelian group is the kernel of <em>M</em> modulo the image of <em>N</em>.</p>
<p >The matrices should be thought of as acting on column vectors: this means that the product <code>B*A</code> applies the linear transformation <em>A</em>, then the linear transformation <em>B</em>. This is consistent (for example) with the convention that Regina uses for for multiplying permutations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). This condition will be tested, and an exception will be thrown if it does not hold.</dd>
<dd>
The product M*N = 0. This condition will <em>not</em> be tested (for efficiency reasons); this is left to the user/programmer to ensure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of columns in <em>M</em> does not match the number of rows in <em>N</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7020239c7bcbcdfbbb1da98d5195edb" name="ab7020239c7bcbcdfbbb1da98d5195edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7020239c7bcbcdfbbb1da98d5195edb">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients. </p>
<p >The abelian group is the kernel of <em>M</em> modulo the image of <em>N</em>.</p>
<p >The matrices should be thought of as acting on column vectors: this means that the product <code>B*A</code> applies the linear transformation <em>A</em>, then the linear transformation <em>B</em>. This is consistent (for example) with the convention that Regina uses for for multiplying permutations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). This condition will be tested, and an exception will be thrown if it does not hold.</dd>
<dd>
The product M*N = 0. This condition will <em>not</em> be tested (for efficiency reasons); this is left to the user/programmer to ensure.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The number of columns in <em>M</em> does not match the number of rows in <em>N</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
    <tr><td class="paramname">p</td><td>the modulus, which may be any Integer. Zero is interpreted as a request for integer coefficents, which will give the same result as the <a class="el" href="classregina_1_1AbelianGroup.html#aa1782f02c61cfc17f669ab34f873ab3c" title="Creates an abelian group as the homology of a chain complex.">AbelianGroup(MatrixInt, MatrixInt)</a> constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3f258af0b04c62e2de0f61df3d710509" name="a3f258af0b04c62e2de0f61df3d710509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f258af0b04c62e2de0f61df3d710509">&#9670;&nbsp;</a></span>addGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given abelian group to this group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to add to this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba8c9b3e44af87012db52b9492e0b59b" name="aba8c9b3e44af87012db52b9492e0b59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8c9b3e44af87012db52b9492e0b59b">&#9670;&nbsp;</a></span>addGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>presentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the abelian group defined by the given presentation to this group. </p>
<p >Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">presentation</td><td>a presentation matrix for the group to be added to this group, where each column represents a generator and each row a relation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaffd523df4ffbe34d6d38adacd4b6e7d" name="aaffd523df4ffbe34d6d38adacd4b6e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffd523df4ffbe34d6d38adacd4b6e7d">&#9670;&nbsp;</a></span>addRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addRank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extraRank</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the rank of the group by the given integer. </p>
<p >This integer may be positive, negative or zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The current rank plus the given integer is non-negative. In other words, if we are subtracting rank then we are not trying to subtract more rank than the group actually has.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraRank</td><td>the extra rank to add; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70d0639c896d068034c99eb53f487b93" name="a70d0639c896d068034c99eb53f487b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70d0639c896d068034c99eb53f487b93">&#9670;&nbsp;</a></span>addTorsion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given torsion element to the group. </p>
<p >As of Regina 7.0, this routine is much faster than it used to be. In particular, if you have many torsion elements to add, it is now efficient just to call <a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> for each new torsion element, one at a time.</p>
<p >In this routine we add a single copy of Z_<em>d</em>, where <em>d</em> is the given degree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the new torsion element; this must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9de8c90029f068306126465da9f7296" name="aa9de8c90029f068306126465da9f7296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9de8c90029f068306126465da9f7296">&#9670;&nbsp;</a></span>addTorsionElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mult</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that adds the given torsion element to the group. </p>
<p >As of Regina 7.0, this routine is much faster than it used to be. In particular, if you have many torsion elements to add, it is now efficient just to call <a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> for each new torsion element, one at a time.</p>
<p >In this routine we add a specified number of copies of Z_<em>d</em>, where <em>d</em> is some given degree.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use <a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> instead, multiple times if necessary (which is exactly how this routine is implemented).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is strictly positive, and the given multiplicity is at least 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td><em>d</em>, where we are adding copies of <em>Z_d</em> to the torsion. </td></tr>
    <tr><td class="paramname">mult</td><td>the multiplicity <em>m</em>, where we are adding precisely <em>m</em> copies of <em>Z_d</em>; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae926d3d6b0dce31e40c27eb475057077" name="ae926d3d6b0dce31e40c27eb475057077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae926d3d6b0dce31e40c27eb475057077">&#9670;&nbsp;</a></span>addTorsionElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElement </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mult</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that adds the given torsion element to the group. </p>
<p >As of Regina 7.0, this routine is much faster than it used to be. In particular, if you have many torsion elements to add, it is now efficient just to call <a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> for each new torsion element, one at a time.</p>
<p >In this routine we add a specified number of copies of Z_<em>d</em>, where <em>d</em> is some given degree.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> instead, multiple times if necessary (which is exactly how this routine is implemented).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is strictly positive, and the given multiplicity is at least 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td><em>d</em>, where we are adding copies of <em>Z_d</em> to the torsion. </td></tr>
    <tr><td class="paramname">mult</td><td>the multiplicity <em>m</em>, where we are adding precisely <em>m</em> copies of <em>Z_d</em>; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70f9f394fc848b2483e5ac93ad6e7cef" name="a70f9f394fc848b2483e5ac93ad6e7cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f9f394fc848b2483e5ac93ad6e7cef">&#9670;&nbsp;</a></span>addTorsionElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElements </td>
          <td>(</td>
          <td class="paramtype">const std::multiset&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>torsion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that adds the given set of torsion elements to this group. </p>
<p >The torsion elements to add are described by a list of integers <em>k1</em>,...,<em>km</em>, where we are adding Z_<em>k1</em>,...,Z_<em>km</em>. Unlike invariant factors, the <em>ki</em> are not required to divide each other.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>This routine uses an old implementation, and it is now much faster just to add each torsion element one at a time using <a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Each integer in the given list is strictly greater than 1.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine takes a python list as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">torsion</td><td>a list containing the torsion elements to add, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eb7bc0b871554e7302ba01b17470fe0" name="a3eb7bc0b871554e7302ba01b17470fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb7bc0b871554e7302ba01b17470fe0">&#9670;&nbsp;</a></span>countInvariantFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::countInvariantFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of invariant factors that describe the torsion elements of this group. </p>
<p >See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of invariant factors. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ab67d3b2e704ec84b1e20555e32f4c3ed" name="ab67d3b2e704ec84b1e20555e32f4c3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67d3b2e704ec84b1e20555e32f4c3ed">&#9670;&nbsp;</a></span>invariantFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp; regina::AbelianGroup::invariantFactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the given invariant factor describing the torsion elements of this group. </p>
<p >See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<p >If the invariant factors are <em>d0</em>|<em>d1</em>|...|<em>dn</em>, this routine will return <em>di</em> where <em>i</em> is the value of parameter <em>index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the invariant factor to return; this must be between 0 and <a class="el" href="classregina_1_1AbelianGroup.html#a3eb7bc0b871554e7302ba01b17470fe0" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested invariant factor. </dd></dl>

</div>
</div>
<a id="a1dd8d4c1dd13f30df21855b26e4d1198" name="a1dd8d4c1dd13f30df21855b26e4d1198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd8d4c1dd13f30df21855b26e4d1198">&#9670;&nbsp;</a></span>isFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isFree </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the free abelian group of the given rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the rank of the free abelian group that we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the free abelian group of rank <em>r</em>. </dd></dl>

</div>
</div>
<a id="a65860d714f70889df0fec507a7658f8f" name="a65860d714f70889df0fec507a7658f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65860d714f70889df0fec507a7658f8f">&#9670;&nbsp;</a></span>isTrivial()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the trivial (zero) group. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial group. </dd></dl>

</div>
</div>
<a id="a919a9f896922a25d7c9b6e32a877471f" name="a919a9f896922a25d7c9b6e32a877471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919a9f896922a25d7c9b6e32a877471f">&#9670;&nbsp;</a></span>isZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the infinite cyclic group (Z). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the infinite cyclic group. </dd></dl>

</div>
</div>
<a id="ae75846527dae06863f9b924622ccfe8b" name="ae75846527dae06863f9b924622ccfe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75846527dae06863f9b924622ccfe8b">&#9670;&nbsp;</a></span>isZn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZn </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the non-trivial cyclic group on the given number of elements. </p>
<p >As a special case, if <em>n</em> = 0 then this routine will test for the infinite cyclic group (i.e., it will behave the same as <a class="el" href="classregina_1_1AbelianGroup.html#a919a9f896922a25d7c9b6e32a877471f" title="Determines whether this is the infinite cyclic group (Z).">isZ()</a>). If <em>n</em> = 1, then this routine will test for the trivial group (i.e., it will behave the same as <a class="el" href="classregina_1_1AbelianGroup.html#a65860d714f70889df0fec507a7658f8f" title="Determines whether this is the trivial (zero) group.">isTrivial()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of elements of the cyclic group in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the cyclic group Z_n. </dd></dl>

</div>
</div>
<a id="a654c5cee9a97206990fcc36ff62906b1" name="a654c5cee9a97206990fcc36ff62906b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654c5cee9a97206990fcc36ff62906b1">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group have different presentations (which means they are non-isomorphic). </p>
<p >Since the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class stores <em>only</em> the invariants required to identify the isomorphism type, two groups will compare as equal if and only if they are isomorphic. This is in contrast to the comparisons for <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> (which tests for identical generators and relations), or for <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> (which tests for identical chain complex presentations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups have different presentations (i.e., they are non-isomorphic). </dd></dl>

</div>
</div>
<a id="af4f96717878ee0e56cd24f20b797019a" name="af4f96717878ee0e56cd24f20b797019a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f96717878ee0e56cd24f20b797019a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::AbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given group to this group. </p>
<p >This is a fast (constant time) operation.</p>
<p >The group that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group. </dd></dl>

</div>
</div>
<a id="a2cbdfc133bb2e81f4ec95e74049817d4" name="a2cbdfc133bb2e81f4ec95e74049817d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbdfc133bb2e81f4ec95e74049817d4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::AbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given group. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group. </dd></dl>

</div>
</div>
<a id="a87ed4b87463c30c91f16059b8587522b" name="a87ed4b87463c30c91f16059b8587522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ed4b87463c30c91f16059b8587522b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group have identical presentations (which means they are isomorphic). </p>
<p >Since the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class stores <em>only</em> the invariants required to identify the isomorphism type, two groups will compare as equal if and only if they are isomorphic. This is in contrast to the comparisons for <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> (which tests for identical generators and relations), or for <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> (which tests for identical chain complex presentations).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups have identical presentations (i.e., they are isomorphic). </dd></dl>

</div>
</div>
<a id="ada506c15842e993b6fdc651b0122d3af" name="ada506c15842e993b6fdc651b0122d3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada506c15842e993b6fdc651b0122d3af">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the group. </p>
<p >This is the number of included copies of <em>Z</em>.</p>
<p >Equivalently, the rank is the maximum number of linearly independent elements, and it indicates the size of the largest free abelian subgroup. The rank effectively ignores all torsion elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>SnapPy users should be aware that SnapPy defines rank differently. Specifically, SnapPy's <a class="el" href="classregina_1_1AbelianGroup.html#ada506c15842e993b6fdc651b0122d3af" title="Returns the rank of the group.">AbelianGroup.rank()</a> computation includes torsion factors also.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of included copies of <em>Z</em>. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aafc7c540ed48c527365fa852a5746dc5" name="aafc7c540ed48c527365fa852a5746dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc7c540ed48c527365fa852a5746dc5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given abelian group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fa94585fdce3980370bb8a0a10f33ce" name="a0fa94585fdce3980370bb8a0a10f33ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa94585fdce3980370bb8a0a10f33ce">&#9670;&nbsp;</a></span>tightEncode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::tightEncode </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the tight encoding of this abelian group to the given output stream. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="classregina_1_1AbelianGroup.html#a033d4a5f7cc477f608274f327bc902e5" title="Returns the tight encoding of this abelian group.">tightEncoding()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the encoded string will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a033d4a5f7cc477f608274f327bc902e5" name="a033d4a5f7cc477f608274f327bc902e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033d4a5f7cc477f608274f327bc902e5">&#9670;&nbsp;</a></span>tightEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::AbelianGroup::tightEncoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tight encoding of this abelian group. </p>
<p >See the page on <a class="el" href="tight.html">tight encodings</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>the resulting encoded string. </dd></dl>

</div>
</div>
<a id="a72b15418d1e879e91983cbbd13dcbb1e" name="a72b15418d1e879e91983cbbd13dcbb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b15418d1e879e91983cbbd13dcbb1e">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rank in the group of the torsion term of given degree. </p>
<p >If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p >For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="a3777b5ec94d450465db9327c7ea774e7" name="a3777b5ec94d450465db9327c7ea774e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3777b5ec94d450465db9327c7ea774e7">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank in the group of the torsion term of given degree. </p>
<p >If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p >For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool supportsUtf8 = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; T, supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> , supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a655d3a9de8d18a136f5ca578b6cfa7b9" name="a655d3a9de8d18a136f5ca578b6cfa7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655d3a9de8d18a136f5ca578b6cfa7b9">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p >The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>. The torsion elements will be written in terms of the invariant factors of the group, as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> or <a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2" title="Returns a short text representation of this object using unicode characters.">utf8()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td>if <code>true</code>, then richer unicode characters will be used to make the output more pleasant to read. In particular, the output will use subscript digits and the blackboard bold Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd184409a580597ac709e7875355be74" name="afd184409a580597ac709e7875355be74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd184409a580597ac709e7875355be74">&#9670;&nbsp;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this abelian group. </p>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> should be an open Python file object.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9bb4166ec40c17c6a042f6d0609ed4db" name="a9bb4166ec40c17c6a042f6d0609ed4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb4166ec40c17c6a042f6d0609ed4db">&#9670;&nbsp;</a></span>rank_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::rank_ { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rank of the group (the number of Z components). </p>

</div>
</div>
<a id="ad69a3e9caa2736e6126399e890a836d6" name="ad69a3e9caa2736e6126399e890a836d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69a3e9caa2736e6126399e890a836d6">&#9670;&nbsp;</a></span>revInvFactors_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a>&gt; regina::AbelianGroup::revInvFactors_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes. </p>
<p >These are stored in reverse order, since <a class="el" href="classregina_1_1AbelianGroup.html#a70d0639c896d068034c99eb53f487b93" title="Adds the given torsion element to the group.">addTorsion()</a> always extends the vector on the <em>d0</em> end. Note that we cannot use std::deque (which does support pushing to the front), since older gcc versions do not have a noexcept std::deque move constructor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="abeliangroup_8h.html">abeliangroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
