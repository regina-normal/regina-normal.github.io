<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.0 Calculation Engine: regina::LPMatrix&lt; IntType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina 7.0 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1LPMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::LPMatrix&lt; IntType &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A matrix class for use with linear programming.  
 <a href="classregina_1_1LPMatrix.html#details">More...</a></p>

<p><code>#include &lt;enumerate/treelp.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::LPMatrix&lt; IntType &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1LPMatrix.png" usemap="#regina::LPMatrix_3C_20IntType_20_3E_map" alt=""/>
  <map id="regina::LPMatrix_3C_20IntType_20_3E_map" name="regina::LPMatrix_3C_20IntType_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; LPMatrix&lt; IntType &gt; &gt;" shape="rect" coords="0,0,230,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc147112c87842fa3f81f983b1a74fae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#abc147112c87842fa3f81f983b1a74fae">LPMatrix</a> ()</td></tr>
<tr class="memdesc:abc147112c87842fa3f81f983b1a74fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised matrix with no memory storage.  <a href="classregina_1_1LPMatrix.html#abc147112c87842fa3f81f983b1a74fae">More...</a><br /></td></tr>
<tr class="separator:abc147112c87842fa3f81f983b1a74fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd286b6b0f9ea3176934d00b8c1cc0c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#acd286b6b0f9ea3176934d00b8c1cc0c8">LPMatrix</a> (unsigned <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a">rows</a>, unsigned cols)</td></tr>
<tr class="memdesc:acd286b6b0f9ea3176934d00b8c1cc0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a fully initialised <em>rows</em> by <em>cols</em> matrix with all elements set to zero.  <a href="classregina_1_1LPMatrix.html#acd286b6b0f9ea3176934d00b8c1cc0c8">More...</a><br /></td></tr>
<tr class="separator:acd286b6b0f9ea3176934d00b8c1cc0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c45064e7da7df3b5eff61b6c2d9a5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#ad7c45064e7da7df3b5eff61b6c2d9a5a">LPMatrix</a> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ad7c45064e7da7df3b5eff61b6c2d9a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given matrix into this new matrix.  <a href="classregina_1_1LPMatrix.html#ad7c45064e7da7df3b5eff61b6c2d9a5a">More...</a><br /></td></tr>
<tr class="separator:ad7c45064e7da7df3b5eff61b6c2d9a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac4b64820129111953fb8fd76ccbed2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a7ac4b64820129111953fb8fd76ccbed2">~LPMatrix</a> ()</td></tr>
<tr class="memdesc:a7ac4b64820129111953fb8fd76ccbed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix and all of the data it contains.  <a href="classregina_1_1LPMatrix.html#a7ac4b64820129111953fb8fd76ccbed2">More...</a><br /></td></tr>
<tr class="separator:a7ac4b64820129111953fb8fd76ccbed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03360971a5eb8c8b3deaf63d1c2400fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a03360971a5eb8c8b3deaf63d1c2400fa">operator=</a> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a03360971a5eb8c8b3deaf63d1c2400fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given matrix into this matrix.  <a href="classregina_1_1LPMatrix.html#a03360971a5eb8c8b3deaf63d1c2400fa">More...</a><br /></td></tr>
<tr class="separator:a03360971a5eb8c8b3deaf63d1c2400fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c658781ce8ea1daa51222d9e63c9d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a38c658781ce8ea1daa51222d9e63c9d9">swap</a> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a38c658781ce8ea1daa51222d9e63c9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given matrix.  <a href="classregina_1_1LPMatrix.html#a38c658781ce8ea1daa51222d9e63c9d9">More...</a><br /></td></tr>
<tr class="separator:a38c658781ce8ea1daa51222d9e63c9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e8f80901ea9c05b3fc97db4a365c94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94">reserve</a> (unsigned maxRows, unsigned maxCols)</td></tr>
<tr class="memdesc:a87e8f80901ea9c05b3fc97db4a365c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves enough space to store the elements of a <em>maxRows</em> by <em>maxCols</em> matrix.  <a href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94">More...</a><br /></td></tr>
<tr class="separator:a87e8f80901ea9c05b3fc97db4a365c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6806f38ae07678edd93b44219943a70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#ad6806f38ae07678edd93b44219943a70">initClone</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;clone)</td></tr>
<tr class="memdesc:ad6806f38ae07678edd93b44219943a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this matrix to a copy of the given matrix.  <a href="classregina_1_1LPMatrix.html#ad6806f38ae07678edd93b44219943a70">More...</a><br /></td></tr>
<tr class="separator:ad6806f38ae07678edd93b44219943a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756eaa237b40e6b640655622d4fc57a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a756eaa237b40e6b640655622d4fc57a6">initIdentity</a> (unsigned size)</td></tr>
<tr class="memdesc:a756eaa237b40e6b640655622d4fc57a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this matrix to the identity matrix of the given size.  <a href="classregina_1_1LPMatrix.html#a756eaa237b40e6b640655622d4fc57a6">More...</a><br /></td></tr>
<tr class="separator:a756eaa237b40e6b640655622d4fc57a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e1ff5aebfd645cf4c9cac1b5a149d6"><td class="memItemLeft" align="right" valign="top">IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a66e1ff5aebfd645cf4c9cac1b5a149d6">entry</a> (unsigned row, unsigned col)</td></tr>
<tr class="memdesc:a66e1ff5aebfd645cf4c9cac1b5a149d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-write reference to the given element of this matrix.  <a href="classregina_1_1LPMatrix.html#a66e1ff5aebfd645cf4c9cac1b5a149d6">More...</a><br /></td></tr>
<tr class="separator:a66e1ff5aebfd645cf4c9cac1b5a149d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e0af3ad3d609a2c27b8c65a8423aa5"><td class="memItemLeft" align="right" valign="top">const IntType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#ad8e0af3ad3d609a2c27b8c65a8423aa5">entry</a> (unsigned row, unsigned col) const</td></tr>
<tr class="memdesc:ad8e0af3ad3d609a2c27b8c65a8423aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a read-only reference to the given element of this matrix.  <a href="classregina_1_1LPMatrix.html#ad8e0af3ad3d609a2c27b8c65a8423aa5">More...</a><br /></td></tr>
<tr class="separator:ad8e0af3ad3d609a2c27b8c65a8423aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7dcd27036a3970aa80a523b2c86f43a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a">rows</a> () const</td></tr>
<tr class="memdesc:af7dcd27036a3970aa80a523b2c86f43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in this matrix.  <a href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a">More...</a><br /></td></tr>
<tr class="separator:af7dcd27036a3970aa80a523b2c86f43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442958409fd076f06fa54e6e24d37405"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a442958409fd076f06fa54e6e24d37405">columns</a> () const</td></tr>
<tr class="memdesc:a442958409fd076f06fa54e6e24d37405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in this matrix.  <a href="classregina_1_1LPMatrix.html#a442958409fd076f06fa54e6e24d37405">More...</a><br /></td></tr>
<tr class="separator:a442958409fd076f06fa54e6e24d37405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fcc5cb2578243e7f774a0bdcb3a650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#ad6fcc5cb2578243e7f774a0bdcb3a650">operator==</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:ad6fcc5cb2578243e7f774a0bdcb3a650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given matrix are equal.  <a href="classregina_1_1LPMatrix.html#ad6fcc5cb2578243e7f774a0bdcb3a650">More...</a><br /></td></tr>
<tr class="separator:ad6fcc5cb2578243e7f774a0bdcb3a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb6c33fc93023e20713526945f4e779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#aebb6c33fc93023e20713526945f4e779">operator!=</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;other) const</td></tr>
<tr class="memdesc:aebb6c33fc93023e20713526945f4e779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given matrix are not equal.  <a href="classregina_1_1LPMatrix.html#aebb6c33fc93023e20713526945f4e779">More...</a><br /></td></tr>
<tr class="separator:aebb6c33fc93023e20713526945f4e779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee81a1df448f26c82f389cdbafcb52c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a0ee81a1df448f26c82f389cdbafcb52c">swapRows</a> (unsigned r1, unsigned r2)</td></tr>
<tr class="memdesc:a0ee81a1df448f26c82f389cdbafcb52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the two given rows of this matrix.  <a href="classregina_1_1LPMatrix.html#a0ee81a1df448f26c82f389cdbafcb52c">More...</a><br /></td></tr>
<tr class="separator:a0ee81a1df448f26c82f389cdbafcb52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad77b3d164a3c52cb5908069c99c37da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#aad77b3d164a3c52cb5908069c99c37da">combRow</a> (const IntType &amp;destCoeff, unsigned dest, const IntType &amp;srcCoeff, unsigned src, const IntType &amp;div)</td></tr>
<tr class="memdesc:aad77b3d164a3c52cb5908069c99c37da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a particular row operation to this matrix.  <a href="classregina_1_1LPMatrix.html#aad77b3d164a3c52cb5908069c99c37da">More...</a><br /></td></tr>
<tr class="separator:aad77b3d164a3c52cb5908069c99c37da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dcf7e72e994c8b0c1ec953db3ad18e"><td class="memItemLeft" align="right" valign="top">IntType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#af0dcf7e72e994c8b0c1ec953db3ad18e">combRowAndNorm</a> (const IntType &amp;destCoeff, unsigned dest, const IntType &amp;srcCoeff, unsigned src)</td></tr>
<tr class="memdesc:af0dcf7e72e994c8b0c1ec953db3ad18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a particular row operation to this matrix, and then normalises.  <a href="classregina_1_1LPMatrix.html#af0dcf7e72e994c8b0c1ec953db3ad18e">More...</a><br /></td></tr>
<tr class="separator:af0dcf7e72e994c8b0c1ec953db3ad18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948a2c32521ba570aa0693cfce49953c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a948a2c32521ba570aa0693cfce49953c">negateRow</a> (unsigned row)</td></tr>
<tr class="memdesc:a948a2c32521ba570aa0693cfce49953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates all elements in the given row of this matrix.  <a href="classregina_1_1LPMatrix.html#a948a2c32521ba570aa0693cfce49953c">More...</a><br /></td></tr>
<tr class="separator:a948a2c32521ba570aa0693cfce49953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46722ff71404c0849f5aaf8b0ac3aa64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a46722ff71404c0849f5aaf8b0ac3aa64">dump</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a46722ff71404c0849f5aaf8b0ac3aa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that writes this matrix to the given output stream.  <a href="classregina_1_1LPMatrix.html#a46722ff71404c0849f5aaf8b0ac3aa64">More...</a><br /></td></tr>
<tr class="separator:a46722ff71404c0849f5aaf8b0ac3aa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c25ff753b95ce359dd702c757e5276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a88c25ff753b95ce359dd702c757e5276">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a88c25ff753b95ce359dd702c757e5276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1LPMatrix.html#a88c25ff753b95ce359dd702c757e5276">More...</a><br /></td></tr>
<tr class="separator:a88c25ff753b95ce359dd702c757e5276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d731b06bc784eb992c8b78f8a8b3a1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPMatrix.html#a0d731b06bc784eb992c8b78f8a8b3a1e">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a0d731b06bc784eb992c8b78f8a8b3a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1LPMatrix.html#a0d731b06bc784eb992c8b78f8a8b3a1e">More...</a><br /></td></tr>
<tr class="separator:a0d731b06bc784eb992c8b78f8a8b3a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d3a7177a1a3aca1460b0192361db6e"><td class="memItemLeft" align="right" valign="top"><a id="a98d3a7177a1a3aca1460b0192361db6e" name="a98d3a7177a1a3aca1460b0192361db6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LPMatrix</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:a98d3a7177a1a3aca1460b0192361db6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1239a5da6b4cd59eb6c16604222c7e86"><td class="memItemLeft" align="right" valign="top"><a id="a1239a5da6b4cd59eb6c16604222c7e86" name="a1239a5da6b4cd59eb6c16604222c7e86"></a>
<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:a1239a5da6b4cd59eb6c16604222c7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename IntType&gt;<br />
class regina::LPMatrix&lt; IntType &gt;</div><p >A matrix class for use with linear programming. </p>
<p >This class is used in the tree traversal algorithms for enumerating and locating vertex normal surfaces, as described in "A tree traversal
algorithm for decision problems in knot theory and 3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801, and "A fast branching algorithm for unknot recognition with
experimental polynomial-time behaviour", Burton and Ozlen, arXiv:1211.1079. It is also used for locating a single strict angle structure, and for enumerating all taut angle structures.</p>
<p >The operations on this matrix class are tailored and optimised specifically for use with the dual simplex method in the context of a repetitive backtracking search. As a result, the API is cumbersome and highly specialised, which makes this matrix class inappropriate for general use. If you just want a general-use integer matrix class, use MatrixInt instead.</p>
<p >It is <em>critical</em> that, before using an <a class="el" href="classregina_1_1LPMatrix.html" title="A matrix class for use with linear programming.">LPMatrix</a>, you reserve space for its elements, and then fix a specific size. A matrix for which both tasks have been done will be called <em>initialised</em>. You can initialise a matrix in one of two ways:</p>
<ul>
<li>by using the (<em>rows</em>, <em>columns</em>) constructor, which does everything for you;</li>
<li>by using the default (no-arguments) constructor, then calling <a class="el" href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a>, and then calling one of the initialisation routines <a class="el" href="classregina_1_1LPMatrix.html#ad6806f38ae07678edd93b44219943a70" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="classregina_1_1LPMatrix.html#a756eaa237b40e6b640655622d4fc57a6" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a>.</li>
</ul>
<p >You may call the initialisation <a class="el" href="classregina_1_1LPMatrix.html#ad6806f38ae07678edd93b44219943a70" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> and <a class="el" href="classregina_1_1LPMatrix.html#a756eaa237b40e6b640655622d4fc57a6" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a> routines more than once (e.g., during a backtracking search), and you may use different matrix sizes each time. However, you may never use more elements than you originally reserved space for.</p>
<p >This matrix is stored in dense form. All elements are of the integer class <em>IntType</em>, which is supplied as a template argument.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. However, due to the unusual create-reserve-initialise procedure, it does not support copying (either by copy construction or copy assignment). Because of the move semantics, this class avoids deep copies, even when passing or returning objects by value.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The default constructor for the template class IntType must intialise each new integer to zero. The classes Integer and <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>, for instance, have this property.</dd></dl>
<dl class="section user"><dt>Headers</dt><dd>Parts of this template class are implemented in a separate header (treelp-impl.h), which is not included automatically by this file. Most end users should not need this extra header, since Regina's calculation engine already includes explicit instantiations for common combinations of template arguments.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The template argument <em>IntType</em> is taken to be <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6" title="Integer is a type alias for IntegerBase&lt;false&gt;, which offers arbitrary precision integers without sup...">regina::Integer</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abc147112c87842fa3f81f983b1a74fae" name="abc147112c87842fa3f81f983b1a74fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc147112c87842fa3f81f983b1a74fae">&#9670;&nbsp;</a></span>LPMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an uninitialised matrix with no memory storage. </p>
<p >You <em>must</em> call <a class="el" href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> and then either <a class="el" href="classregina_1_1LPMatrix.html#ad6806f38ae07678edd93b44219943a70" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="classregina_1_1LPMatrix.html#a756eaa237b40e6b640655622d4fc57a6" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a> before this matrix will become initialised. </p>

</div>
</div>
<a id="acd286b6b0f9ea3176934d00b8c1cc0c8" name="acd286b6b0f9ea3176934d00b8c1cc0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd286b6b0f9ea3176934d00b8c1cc0c8">&#9670;&nbsp;</a></span>LPMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a fully initialised <em>rows</em> by <em>cols</em> matrix with all elements set to zero. </p>
<p >This routine reserves space for precisely <em>rows</em> * <em>cols</em> elements. In other words, you may later re-initialise the matrix to become smaller if you like, but you cannot re-initialise the matrix to become larger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the number of rows in the new matrix. This must be strictly positive. </td></tr>
    <tr><td class="paramname">cols</td><td>the number of columns in the new matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7c45064e7da7df3b5eff61b6c2d9a5a" name="ad7c45064e7da7df3b5eff61b6c2d9a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c45064e7da7df3b5eff61b6c2d9a5a">&#9670;&nbsp;</a></span>LPMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given matrix into this new matrix. </p>
<p >This is a fast (constant time) operation.</p>
<p >If the given matrix is uninitialised, then this new matrix will be uninitialised also.</p>
<p >The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ac4b64820129111953fb8fd76ccbed2" name="a7ac4b64820129111953fb8fd76ccbed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac4b64820129111953fb8fd76ccbed2">&#9670;&nbsp;</a></span>~LPMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::~<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix and all of the data it contains. </p>
<p >You can safely destroy a matrix that is uninitialised or only partially initialised (i.e., space has been reserved but the matrix size is not set). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a442958409fd076f06fa54e6e24d37405" name="a442958409fd076f06fa54e6e24d37405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442958409fd076f06fa54e6e24d37405">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of columns in this matrix. </p>
<p >This relates to the currently assigned matrix size, not the total amount of memory that was originally reserved.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="aad77b3d164a3c52cb5908069c99c37da" name="aad77b3d164a3c52cb5908069c99c37da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad77b3d164a3c52cb5908069c99c37da">&#9670;&nbsp;</a></span>combRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::combRow </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>destCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>srcCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a particular row operation to this matrix. </p>
<p >Specifically, row <em>dest</em> will be replaced with the linear combination: (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>) / <em>div</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> and <em>src</em> are not equal. </dd>
<dd>
It is known in advance that every integer in (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>) will be divisible by <em>div</em>. In other words, it is known in advance that we can use exact integer division without remainders.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destCoeff</td><td>the coefficient applied to row <em>dest</em> in the linear combination. </td></tr>
    <tr><td class="paramname">dest</td><td>the index of the row to replace. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">srcCoeff</td><td>the coefficient applied to row <em>src</em> in the linear combination. </td></tr>
    <tr><td class="paramname">src</td><td>the index of the other row used in this linear combination. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">div</td><td>the integer to divide the final row by. This must be non-zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0dcf7e72e994c8b0c1ec953db3ad18e" name="af0dcf7e72e994c8b0c1ec953db3ad18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dcf7e72e994c8b0c1ec953db3ad18e">&#9670;&nbsp;</a></span>combRowAndNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::combRowAndNorm </td>
          <td>(</td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>destCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntType &amp;&#160;</td>
          <td class="paramname"><em>srcCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a particular row operation to this matrix, and then normalises. </p>
<p >Specifically, row <em>dest</em> will be replaced with the linear combination: (<em>destCoeff</em> * row <em>dest</em> - <em>srcCoeff</em> * row <em>src</em>); then, if row <em>dest</em> is non-zero, it will be normalised by dividing through by the gcd of its elements. Note that this gcd is always taken to be positive (i.e., the final normalisation will never change the signs of the elements in the row).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> and <em>src</em> are not equal.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destCoeff</td><td>the coefficient applied to row <em>dest</em> in the linear combination. </td></tr>
    <tr><td class="paramname">dest</td><td>the index of the row to replace. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">srcCoeff</td><td>the coefficient applied to row <em>src</em> in the linear combination. </td></tr>
    <tr><td class="paramname">src</td><td>the index of the other row used in this linear combination. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the positive gcd that row <em>dest</em> was scaled down by, or 0 if row <em>dest</em> is entirely zero. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a46722ff71404c0849f5aaf8b0ac3aa64" name="a46722ff71404c0849f5aaf8b0ac3aa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46722ff71404c0849f5aaf8b0ac3aa64">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that writes this matrix to the given output stream. </p>
<p >The output is "rough" and wasteful, and is intended for debugging purposes only. The precise output format is subject to change in future versions of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000035">Deprecated:</a></b></dt><dd>This has been replaced by <a class="el" href="classregina_1_1LPMatrix.html#a0d731b06bc784eb992c8b78f8a8b3a1e" title="Writes a detailed text representation of this object to the given output stream.">writeTextLong()</a> (which uses a slightly tighter output format), for compatibility with Regina's usual text output facilities.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, but you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66e1ff5aebfd645cf4c9cac1b5a149d6" name="a66e1ff5aebfd645cf4c9cac1b5a149d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e1ff5aebfd645cf4c9cac1b5a149d6">&#9670;&nbsp;</a></span>entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType &amp; <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-write reference to the given element of this matrix. </p>
<dl class="section user"><dt>Python</dt><dd>The <a class="el" href="classregina_1_1LPMatrix.html#a66e1ff5aebfd645cf4c9cac1b5a149d6" title="Returns a read-write reference to the given element of this matrix.">entry()</a> routine gives direct read-write access to matrix elements, but does not allow them to be set using the assignment operator. In other words, code such as <code>matrix.entry(r, c).negate()</code> will work, but <code>matrix.entry(r, c) = value</code> will not. To assign values to matrix elements, you should instead use the syntax <code>matrix.set(row, column, value)</code>. This set() routine returns nothing, and is provided for python only (i.e., it is not part of the C++ calculation engine).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">col</td><td>the column of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#a442958409fd076f06fa54e6e24d37405" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8e0af3ad3d609a2c27b8c65a8423aa5" name="ad8e0af3ad3d609a2c27b8c65a8423aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e0af3ad3d609a2c27b8c65a8423aa5">&#9670;&nbsp;</a></span>entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const IntType &amp; <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a read-only reference to the given element of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">col</td><td>the column of the requested element. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#a442958409fd076f06fa54e6e24d37405" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6806f38ae07678edd93b44219943a70" name="ad6806f38ae07678edd93b44219943a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6806f38ae07678edd93b44219943a70">&#9670;&nbsp;</a></span>initClone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::initClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>clone</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this matrix to a copy of the given matrix. </p>
<p >This matrix does not yet need to be initialised, but it does need to have enough space reserved.</p>
<p >You may call this routine on an already-initialised matrix, and you may use this routine to assign it a different size (as long as enough space was originally reserved).</p>
<dl class="section pre"><dt>Precondition</dt><dd>If this matrix has not been initialised before, then <a class="el" href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> must have already been called.</dd>
<dd>
This matrix has enough space reserved for at least clone.rows() * clone.columns() elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clone</td><td>the matrix to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a756eaa237b40e6b640655622d4fc57a6" name="a756eaa237b40e6b640655622d4fc57a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756eaa237b40e6b640655622d4fc57a6">&#9670;&nbsp;</a></span>initIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::initIdentity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this matrix to the identity matrix of the given size. </p>
<p >This matrix does not yet need to be initialised, but it does need to have enough space reserved.</p>
<p >You may call this routine on an already-initialised matrix, and you may use this routine to assign it a different size (as long as enough space was originally reserved).</p>
<dl class="section pre"><dt>Precondition</dt><dd>If this matrix has not been initialised before, then <a class="el" href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> must have already been called.</dd>
<dd>
This matrix has enough space reserved for at least <em>size</em> * <em>size</em> elements.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of rows, and also the number of columns, that will be assigned to this matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a948a2c32521ba570aa0693cfce49953c" name="a948a2c32521ba570aa0693cfce49953c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948a2c32521ba570aa0693cfce49953c">&#9670;&nbsp;</a></span>negateRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::negateRow </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates all elements in the given row of this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row whose elements should be negated. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebb6c33fc93023e20713526945f4e779" name="aebb6c33fc93023e20713526945f4e779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb6c33fc93023e20713526945f4e779">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given matrix are not equal. </p>
<p >Two matrices are equal if and only if their dimensions are the same, and the corresponding elements of each matrix are equal.</p>
<p >It is safe to compare matrices of different dimensions, and it is safe to compare matrices that might not yet be initialised. Two uninitialised matrices will compare as equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two matrices are not equal. </dd></dl>

</div>
</div>
<a id="a03360971a5eb8c8b3deaf63d1c2400fa" name="a03360971a5eb8c8b3deaf63d1c2400fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03360971a5eb8c8b3deaf63d1c2400fa">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp; <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given matrix into this matrix. </p>
<p >This is a fast (constant time) operation.</p>
<p >If the given matrix is uninitialised, then this matrix will become uninitialised also.</p>
<p >The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this matrix. </dd></dl>

</div>
</div>
<a id="ad6fcc5cb2578243e7f774a0bdcb3a650" name="ad6fcc5cb2578243e7f774a0bdcb3a650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fcc5cb2578243e7f774a0bdcb3a650">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given matrix are equal. </p>
<p >Two matrices are equal if and only if their dimensions are the same, and the corresponding elements of each matrix are equal.</p>
<p >It is safe to compare matrices of different dimensions, and it is safe to compare matrices that might not yet be initialised. Two uninitialised matrices will compare as equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two matrices are equal. </dd></dl>

</div>
</div>
<a id="a87e8f80901ea9c05b3fc97db4a365c94" name="a87e8f80901ea9c05b3fc97db4a365c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e8f80901ea9c05b3fc97db4a365c94">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserves enough space to store the elements of a <em>maxRows</em> by <em>maxCols</em> matrix. </p>
<p >This is just an upper bound: your matrix may end up using fewer elements than this, but it cannot use more.</p>
<p >This matrix will still not be initialised until you call either <a class="el" href="classregina_1_1LPMatrix.html#ad6806f38ae07678edd93b44219943a70" title="Initialises this matrix to a copy of the given matrix.">initClone()</a> or <a class="el" href="classregina_1_1LPMatrix.html#a756eaa237b40e6b640655622d4fc57a6" title="Initialises this matrix to the identity matrix of the given size.">initIdentity()</a>. See the class notes for details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This matrix was created using the default (no-argument) constructor, and you have not called any other routines on this matrix since.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>To elaborate on the precondition above: you can only call <a class="el" href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> once, and if you did not use the default <a class="el" href="classregina_1_1LPMatrix.html" title="A matrix class for use with linear programming.">LPMatrix</a> constructor then you cannot call it at all. Any additional calls to <a class="el" href="classregina_1_1LPMatrix.html#a87e8f80901ea9c05b3fc97db4a365c94" title="Reserves enough space to store the elements of a maxRows by maxCols matrix.">reserve()</a> will result in a memory leak.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRows</td><td>an upper bound on the number of rows that you will need for this matrix. This must be strictly positive. </td></tr>
    <tr><td class="paramname">maxCols</td><td>an upper bound on the number of columns that you will need for this matrix. This must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7dcd27036a3970aa80a523b2c86f43a" name="af7dcd27036a3970aa80a523b2c86f43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7dcd27036a3970aa80a523b2c86f43a">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of rows in this matrix. </p>
<p >This relates to the currently assigned matrix size, not the total amount of memory that was originally reserved.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of rows. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code><b>str</b>()</code> and <code><b>repr</b>()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code><b>str</b>()</code> will use precisely this function, and for most classes the Python <code><b>repr</b>()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a38c658781ce8ea1daa51222d9e63c9d9" name="a38c658781ce8ea1daa51222d9e63c9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c658781ce8ea1daa51222d9e63c9d9">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given matrix. </p>
<p >It does not matter if the two matrices have different sizes, or if one or both is unintialised; if so then these properties will be swapped also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ee81a1df448f26c82f389cdbafcb52c" name="a0ee81a1df448f26c82f389cdbafcb52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee81a1df448f26c82f389cdbafcb52c">&#9670;&nbsp;</a></span>swapRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::swapRows </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the two given rows of this matrix. </p>
<p >The two arguments <em>r1</em> and <em>r2</em> may be equal (in which case the matrix will be left unchanged).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r1</td><td>the index of the first row to swap. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">r2</td><td>the index of the second row to swap. This must be between 0 and <a class="el" href="classregina_1_1LPMatrix.html#af7dcd27036a3970aa80a523b2c86f43a" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a0d731b06bc784eb992c8b78f8a8b3a1e" name="a0d731b06bc784eb992c8b78f8a8b3a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d731b06bc784eb992c8b78f8a8b3a1e">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88c25ff753b95ce359dd702c757e5276" name="a88c25ff753b95ce359dd702c757e5276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c25ff753b95ce359dd702c757e5276">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPMatrix.html">regina::LPMatrix</a>&lt; IntType &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>enumerate/<a class="el" href="treeconstraint_8h.html">treeconstraint.h</a></li>
<li>enumerate/<a class="el" href="treelp_8h.html">treelp.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
