<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::SnapshotRef&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1SnapshotRef-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SnapshotRef&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__utilities.html">Miscellaneous Utilities</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A reference to an image of type <em>T</em> that has been snapshotted at a particular moment in time.  
 <a href="classregina_1_1SnapshotRef.html#details">More...</a></p>

<p><code>#include &lt;utilities/snapshot.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea9b87cdcdc798900577d3e4f0f15645"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#aea9b87cdcdc798900577d3e4f0f15645">SnapshotRef</a> (const T &amp;src)</td></tr>
<tr class="memdesc:aea9b87cdcdc798900577d3e4f0f15645"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; The snapshot that we are referencing.  <a href="classregina_1_1SnapshotRef.html#aea9b87cdcdc798900577d3e4f0f15645">More...</a><br /></td></tr>
<tr class="separator:aea9b87cdcdc798900577d3e4f0f15645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486a9029606afc09a9aa72b9c388d271"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a486a9029606afc09a9aa72b9c388d271">SnapshotRef</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;src)</td></tr>
<tr class="memdesc:a486a9029606afc09a9aa72b9c388d271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given snapshot reference.  <a href="classregina_1_1SnapshotRef.html#a486a9029606afc09a9aa72b9c388d271">More...</a><br /></td></tr>
<tr class="separator:a486a9029606afc09a9aa72b9c388d271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b47c75559045a6bcd627f05bff4d3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a32b47c75559045a6bcd627f05bff4d3f">SnapshotRef</a> (<a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a32b47c75559045a6bcd627f05bff4d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given snapshot reference into this new reference.  <a href="classregina_1_1SnapshotRef.html#a32b47c75559045a6bcd627f05bff4d3f">More...</a><br /></td></tr>
<tr class="separator:a32b47c75559045a6bcd627f05bff4d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b5a3329e5124f08f9c97052ce938f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a015b5a3329e5124f08f9c97052ce938f">~SnapshotRef</a> ()</td></tr>
<tr class="memdesc:a015b5a3329e5124f08f9c97052ce938f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this snapshot reference.  <a href="classregina_1_1SnapshotRef.html#a015b5a3329e5124f08f9c97052ce938f">More...</a><br /></td></tr>
<tr class="separator:a015b5a3329e5124f08f9c97052ce938f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a50eade9bc3923b638c316555301dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#aa2a50eade9bc3923b638c316555301dc">operator=</a> (const T &amp;src)</td></tr>
<tr class="memdesc:aa2a50eade9bc3923b638c316555301dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a snapshot of the given object in its current state.  <a href="classregina_1_1SnapshotRef.html#aa2a50eade9bc3923b638c316555301dc">More...</a><br /></td></tr>
<tr class="separator:aa2a50eade9bc3923b638c316555301dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5364e7eab2bf6507be865e8f3b50432d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a5364e7eab2bf6507be865e8f3b50432d">operator=</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;src)</td></tr>
<tr class="memdesc:a5364e7eab2bf6507be865e8f3b50432d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given snapshot reference.  <a href="classregina_1_1SnapshotRef.html#a5364e7eab2bf6507be865e8f3b50432d">More...</a><br /></td></tr>
<tr class="separator:a5364e7eab2bf6507be865e8f3b50432d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29792b6c8cb11e133c6c7dbf104cb340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a29792b6c8cb11e133c6c7dbf104cb340">operator=</a> (<a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a29792b6c8cb11e133c6c7dbf104cb340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given snapshot reference into this new reference.  <a href="classregina_1_1SnapshotRef.html#a29792b6c8cb11e133c6c7dbf104cb340">More...</a><br /></td></tr>
<tr class="separator:a29792b6c8cb11e133c6c7dbf104cb340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be79e7f767935ecbb71de226b63049a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a6be79e7f767935ecbb71de226b63049a">swap</a> (<a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a6be79e7f767935ecbb71de226b63049a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this and the given reference so that they refer to each others' snapshots.  <a href="classregina_1_1SnapshotRef.html#a6be79e7f767935ecbb71de226b63049a">More...</a><br /></td></tr>
<tr class="separator:a6be79e7f767935ecbb71de226b63049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd9e40d193586020c438262ac5f43d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#aabd9e40d193586020c438262ac5f43d0">operator==</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aabd9e40d193586020c438262ac5f43d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given snapshot reference refer to the same snapshot of the same type <em>T</em> object.  <a href="classregina_1_1SnapshotRef.html#aabd9e40d193586020c438262ac5f43d0">More...</a><br /></td></tr>
<tr class="separator:aabd9e40d193586020c438262ac5f43d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b6ff58475380e648b42cab8af6b766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a78b6ff58475380e648b42cab8af6b766">operator!=</a> (const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a78b6ff58475380e648b42cab8af6b766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given snapshot reference do not refer to the same snapshot of the same type <em>T</em> object.  <a href="classregina_1_1SnapshotRef.html#a78b6ff58475380e648b42cab8af6b766">More...</a><br /></td></tr>
<tr class="separator:a78b6ff58475380e648b42cab8af6b766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31af85a84d09ccda2444b9261d87e491"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#a31af85a84d09ccda2444b9261d87e491">operator*</a> () const</td></tr>
<tr class="memdesc:a31af85a84d09ccda2444b9261d87e491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the image that was snapshotted.  <a href="classregina_1_1SnapshotRef.html#a31af85a84d09ccda2444b9261d87e491">More...</a><br /></td></tr>
<tr class="separator:a31af85a84d09ccda2444b9261d87e491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ad3403c9880036a673474613a3ae38"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SnapshotRef.html#af1ad3403c9880036a673474613a3ae38">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:af1ad3403c9880036a673474613a3ae38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the image that was snapshotted.  <a href="classregina_1_1SnapshotRef.html#af1ad3403c9880036a673474613a3ae38">More...</a><br /></td></tr>
<tr class="separator:af1ad3403c9880036a673474613a3ae38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class regina::SnapshotRef&lt; T &gt;</div><p >A reference to an image of type <em>T</em> that has been snapshotted at a particular moment in time. </p>
<p >See the <a class="el" href="classregina_1_1Snapshot.html" title="Keeps a snapshot of an object of type T as it was at a particular moment in time.">Snapshot</a> documentation for a full explanation of how Regina's snapshotting machinery works.</p>
<p >As a quick recap:</p>
<ul>
<li>There can be many <a class="el" href="classregina_1_1SnapshotRef.html" title="A reference to an image of type T that has been snapshotted at a particular moment in time.">SnapshotRef</a> references all pointing to the same image. The underlying snapshot is guaranteed to exist and maintain the same value for as long as there is some <a class="el" href="classregina_1_1SnapshotRef.html" title="A reference to an image of type T that has been snapshotted at a particular moment in time.">SnapshotRef</a> that refers to it, even if the original type <em>T</em> object has since been modified or destroyed.</li>
<li>The user of a <a class="el" href="classregina_1_1SnapshotRef.html" title="A reference to an image of type T that has been snapshotted at a particular moment in time.">SnapshotRef</a> <em>R</em> must only access the snapshotted image through the dereference operators <code>*R</code> and <code>R-&gt;</code>. This access must remain read-only, and any attempt to circumvent it could lead to a <a class="el" href="classregina_1_1SnapshotWriteError.html" title="An exception thrown when someone tries to modify the read-only deep copy taken by a snapshot.">regina::SnapshotWriteError</a> exception being thrown.</li>
<li>The user of a <a class="el" href="classregina_1_1SnapshotRef.html" title="A reference to an image of type T that has been snapshotted at a particular moment in time.">SnapshotRef</a> should not keep a pointer or reference to the underlying type <em>T</em> object, since the snapshot may switch to a different internal type <em>T</em> object if the original is ever modified or destroyed.</li>
</ul>
<p >These references are lightweight objects that can be freely copied by value. They do also offer move and swap operations that in some cases are more efficient (though all copy, move and swap operations are fast).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea9b87cdcdc798900577d3e4f0f15645" name="aea9b87cdcdc798900577d3e4f0f15645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9b87cdcdc798900577d3e4f0f15645">&#9670;&nbsp;</a></span>SnapshotRef() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::SnapshotRef </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>&lt; The snapshot that we are referencing. </p>
<p >This is held by pointer to support assignment; it must not be <code>null</code>. Creates a new snapshot reference to the given object in its current state.</p>
<p >If you already have a snapshot reference <em>R</em> to the same object in the same state, it is (slightly) cheaper to copy <em>R</em> instead of going through the source object <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the underlying type <em>T</em> object whose current snapshot we wish to maintain a reference to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486a9029606afc09a9aa72b9c388d271" name="a486a9029606afc09a9aa72b9c388d271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486a9029606afc09a9aa72b9c388d271">&#9670;&nbsp;</a></span>SnapshotRef() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::SnapshotRef </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given snapshot reference. </p>
<p >The new reference will refer to the same object as <em>src</em>, as it appeared at the same point in time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the snapshot reference to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b47c75559045a6bcd627f05bff4d3f" name="a32b47c75559045a6bcd627f05bff4d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b47c75559045a6bcd627f05bff4d3f">&#9670;&nbsp;</a></span>SnapshotRef() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::SnapshotRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given snapshot reference into this new reference. </p>
<p >The new reference will refer to the same object as <em>src</em>, as it appeared at the same point in time.</p>
<p >This move constructor is identical to the copy constructor, and there is no particular reason to call it. It is included here for consistency because the move <em>assignment</em> operator is different from (and more efficient) than copy assignment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the snapshot reference to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a015b5a3329e5124f08f9c97052ce938f" name="a015b5a3329e5124f08f9c97052ce938f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015b5a3329e5124f08f9c97052ce938f">&#9670;&nbsp;</a></span>~SnapshotRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::~<a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this snapshot reference. </p>
<p >If this is the last surviving reference to the underlying snapshot, then the snapshot itself (along with its internal deep copy of the original object, if it made one) will be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a78b6ff58475380e648b42cab8af6b766" name="a78b6ff58475380e648b42cab8af6b766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b6ff58475380e648b42cab8af6b766">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given snapshot reference do not refer to the same snapshot of the same type <em>T</em> object. </p>
<p >This will be true if either the two references were obtained from different type <em>T</em> objects (possibly via copies/moves/swaps from other references), or if they were obtained from the same type <em>T</em> object but at times that were separated by a modification of this type <em>T</em> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the snapshot reference to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and <em>rhs</em> do not refer to the same snapshot of the same underlying type <em>T</em> object. </dd></dl>

</div>
</div>
<a id="a31af85a84d09ccda2444b9261d87e491" name="a31af85a84d09ccda2444b9261d87e491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31af85a84d09ccda2444b9261d87e491">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the image that was snapshotted. </p>
<p >Note that this dereference operator may refer to different objects in memory at different times (according to how the snapshots are being managed and copied behind the scenes). Therefore you should always access the snapshot through these dereference operators, and never take your own reference or pointer to the underlying type <em>T</em> object.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the snapshot of the type <em>T</em> object. </dd></dl>

</div>
</div>
<a id="af1ad3403c9880036a673474613a3ae38" name="af1ad3403c9880036a673474613a3ae38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ad3403c9880036a673474613a3ae38">&#9670;&nbsp;</a></span>operator-&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the image that was snapshotted. </p>
<p >Note that this dereference operator may refer to different objects in memory at different times (according to how the snapshots are being managed and copied behind the scenes). Therefore you should always access the snapshot through these dereference operators, and never take your own reference or pointer to the underlying type <em>T</em> object.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the snapshot of the type <em>T</em> object. </dd></dl>

</div>
</div>
<a id="a5364e7eab2bf6507be865e8f3b50432d" name="a5364e7eab2bf6507be865e8f3b50432d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5364e7eab2bf6507be865e8f3b50432d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp; <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given snapshot reference. </p>
<p >This reference will be made to refer to the same object as <em>src</em>, as it appeared at the same point in time.</p>
<p >If the old value of this reference was the last surviving reference to its underlying snapshot, then the old snapshot itself (along with its internal deep copy of the original object, if it made one) will be destroyed.</p>
<p >Self-assignment (<code>r = r</code>) is harmless, and will never cause the underlying snapshot to be destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the snapshot reference to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="aa2a50eade9bc3923b638c316555301dc" name="aa2a50eade9bc3923b638c316555301dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a50eade9bc3923b638c316555301dc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp; <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a snapshot of the given object in its current state. </p>
<p >If you already have a snapshot reference <em>R</em> to the same object in the same state, it is (slightly) cheaper to assign from <em>R</em> instead of assigning from the source object <em>src</em>.</p>
<p >If the old value of this reference was the last surviving reference to its underlying snapshot, then the old snapshot itself (along with its internal deep copy of the original object, if it made one) will be destroyed.</p>
<p >Self-assignment (<code>r = *r</code>) is harmless, and will never cause the underlying snapshot to be destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the underlying type <em>T</em> object whose current snapshot we wish to make this a reference to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="a29792b6c8cb11e133c6c7dbf104cb340" name="a29792b6c8cb11e133c6c7dbf104cb340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29792b6c8cb11e133c6c7dbf104cb340">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a> &amp; <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given snapshot reference into this new reference. </p>
<p >The new reference will refer to the same object as <em>src</em>, as it appeared at the same point in time.</p>
<p >This is more efficient than copy assignment, since it avoids atomic changes to reference counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the snapshot reference to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this object. </dd></dl>

</div>
</div>
<a id="aabd9e40d193586020c438262ac5f43d0" name="aabd9e40d193586020c438262ac5f43d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd9e40d193586020c438262ac5f43d0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given snapshot reference refer to the same snapshot of the same type <em>T</em> object. </p>
<p >This will be true if and only if both references were obtained from the same type <em>T</em> object (possibly via copies/moves/swaps from other references), during the same time period in which the underlying type <em>T</em> object was not modified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the snapshot reference to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and <em>rhs</em> refer to the same snapshot of the same underlying type <em>T</em> object. </dd></dl>

</div>
</div>
<a id="a6be79e7f767935ecbb71de226b63049a" name="a6be79e7f767935ecbb71de226b63049a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be79e7f767935ecbb71de226b63049a">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1SnapshotRef.html">regina::SnapshotRef</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this and the given reference so that they refer to each others' snapshots. </p>
<p >Self-swapping (<code>r.swap(r)</code>) is harmless, and will never cause the underlying snapshot to be destroyed.</p>
<p >This is more efficient than a sequence of copies, since it avoids atomic changes to reference counts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the reference to swap with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>utilities/<a class="el" href="snapshot_8h.html">snapshot.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
