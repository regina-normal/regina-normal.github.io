<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::HomGroupPresentation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1HomGroupPresentation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::HomGroupPresentation Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a homomorphism between groups which are described via finite presentations.  
 <a href="classregina_1_1HomGroupPresentation.html#details">More...</a></p>

<p><code>#include &lt;algebra/homgrouppresentation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::HomGroupPresentation:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1HomGroupPresentation.png" usemap="#regina::HomGroupPresentation_map" alt=""/>
  <map id="regina::HomGroupPresentation_map" name="regina::HomGroupPresentation_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; HomGroupPresentation &gt;" shape="rect" coords="0,0,245,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15a6ea4be281b21a93a7a5435517a759"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a15a6ea4be281b21a93a7a5435517a759">HomGroupPresentation</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> <a class="el" href="classregina_1_1HomGroupPresentation.html#a7f7f2527f5247f549e2f96bae2f2682b">domain</a>, <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> <a class="el" href="classregina_1_1HomGroupPresentation.html#a55f0aadb546a83e748ad24954c51f5ea">codomain</a>, std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; map)</td></tr>
<tr class="memdesc:a15a6ea4be281b21a93a7a5435517a759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new homomorphism from the given data.  <a href="classregina_1_1HomGroupPresentation.html#a15a6ea4be281b21a93a7a5435517a759">More...</a><br /></td></tr>
<tr class="separator:a15a6ea4be281b21a93a7a5435517a759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97738be48708a356a7305b02fb605555"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a97738be48708a356a7305b02fb605555">HomGroupPresentation</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> <a class="el" href="classregina_1_1HomGroupPresentation.html#a7f7f2527f5247f549e2f96bae2f2682b">domain</a>, <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> <a class="el" href="classregina_1_1HomGroupPresentation.html#a55f0aadb546a83e748ad24954c51f5ea">codomain</a>, std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; map, std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; inv)</td></tr>
<tr class="memdesc:a97738be48708a356a7305b02fb605555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a declared isomorphism from the given data.  <a href="classregina_1_1HomGroupPresentation.html#a97738be48708a356a7305b02fb605555">More...</a><br /></td></tr>
<tr class="separator:a97738be48708a356a7305b02fb605555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3799566faa70c9e628dc75953553b8a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a3799566faa70c9e628dc75953553b8a2">HomGroupPresentation</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;groupForIdentity)</td></tr>
<tr class="memdesc:a3799566faa70c9e628dc75953553b8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new identity homomorphism for the given group.  <a href="classregina_1_1HomGroupPresentation.html#a3799566faa70c9e628dc75953553b8a2">More...</a><br /></td></tr>
<tr class="separator:a3799566faa70c9e628dc75953553b8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89f0a9e5f2a672e1958deaf012e8646"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#ad89f0a9e5f2a672e1958deaf012e8646">HomGroupPresentation</a> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;src)=default</td></tr>
<tr class="memdesc:ad89f0a9e5f2a672e1958deaf012e8646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#ad89f0a9e5f2a672e1958deaf012e8646">More...</a><br /></td></tr>
<tr class="separator:ad89f0a9e5f2a672e1958deaf012e8646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a255ed9ece3200453263aa97ae4cab133"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a255ed9ece3200453263aa97ae4cab133">HomGroupPresentation</a> (<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:a255ed9ece3200453263aa97ae4cab133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given homomorphism into this new homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#a255ed9ece3200453263aa97ae4cab133">More...</a><br /></td></tr>
<tr class="separator:a255ed9ece3200453263aa97ae4cab133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2ddc834aa292144ef80a1ef709bfc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a8d2ddc834aa292144ef80a1ef709bfc9">operator=</a> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;)=default</td></tr>
<tr class="memdesc:a8d2ddc834aa292144ef80a1ef709bfc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#a8d2ddc834aa292144ef80a1ef709bfc9">More...</a><br /></td></tr>
<tr class="separator:a8d2ddc834aa292144ef80a1ef709bfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb53e1c4c10d3c8e9d912f21eb6306b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#abb53e1c4c10d3c8e9d912f21eb6306b9">operator=</a> (<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:abb53e1c4c10d3c8e9d912f21eb6306b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given homomorphism to this homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#abb53e1c4c10d3c8e9d912f21eb6306b9">More...</a><br /></td></tr>
<tr class="separator:abb53e1c4c10d3c8e9d912f21eb6306b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274042726ce3fb00075ba19e5f42e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a4274042726ce3fb00075ba19e5f42e3e">swap</a> (<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a4274042726ce3fb00075ba19e5f42e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#a4274042726ce3fb00075ba19e5f42e3e">More...</a><br /></td></tr>
<tr class="separator:a4274042726ce3fb00075ba19e5f42e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b8aa6178f2ab80d9edd527cfa13833"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a85b8aa6178f2ab80d9edd527cfa13833">operator==</a> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;other) const</td></tr>
<tr class="memdesc:a85b8aa6178f2ab80d9edd527cfa13833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given homomorphism have identical presentations.  <a href="classregina_1_1HomGroupPresentation.html#a85b8aa6178f2ab80d9edd527cfa13833">More...</a><br /></td></tr>
<tr class="separator:a85b8aa6178f2ab80d9edd527cfa13833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66649e219844a078c431c1950ffbd5e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a66649e219844a078c431c1950ffbd5e4">operator!=</a> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;other) const</td></tr>
<tr class="memdesc:a66649e219844a078c431c1950ffbd5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given homomorphism do not have identical presentations.  <a href="classregina_1_1HomGroupPresentation.html#a66649e219844a078c431c1950ffbd5e4">More...</a><br /></td></tr>
<tr class="separator:a66649e219844a078c431c1950ffbd5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7f2527f5247f549e2f96bae2f2682b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a7f7f2527f5247f549e2f96bae2f2682b">domain</a> () const</td></tr>
<tr class="memdesc:a7f7f2527f5247f549e2f96bae2f2682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The domain of the map.  <a href="classregina_1_1HomGroupPresentation.html#a7f7f2527f5247f549e2f96bae2f2682b">More...</a><br /></td></tr>
<tr class="separator:a7f7f2527f5247f549e2f96bae2f2682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f0aadb546a83e748ad24954c51f5ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a55f0aadb546a83e748ad24954c51f5ea">codomain</a> () const</td></tr>
<tr class="memdesc:a55f0aadb546a83e748ad24954c51f5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The codomain of the map.  <a href="classregina_1_1HomGroupPresentation.html#a55f0aadb546a83e748ad24954c51f5ea">More...</a><br /></td></tr>
<tr class="separator:a55f0aadb546a83e748ad24954c51f5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af222ad0e798429548eb15ed5ceccd909"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#af222ad0e798429548eb15ed5ceccd909">knowsInverse</a> () const</td></tr>
<tr class="memdesc:af222ad0e798429548eb15ed5ceccd909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this is a declared isomorphism.  <a href="classregina_1_1HomGroupPresentation.html#af222ad0e798429548eb15ed5ceccd909">More...</a><br /></td></tr>
<tr class="separator:af222ad0e798429548eb15ed5ceccd909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa021da72c35116f790cb8529941bec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#aaaa021da72c35116f790cb8529941bec">evaluate</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> arg) const</td></tr>
<tr class="memdesc:aaaa021da72c35116f790cb8529941bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the homomorphism at an element of the domain.  <a href="classregina_1_1HomGroupPresentation.html#aaaa021da72c35116f790cb8529941bec">More...</a><br /></td></tr>
<tr class="separator:aaaa021da72c35116f790cb8529941bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6512988efb34a5c0d4785d5ae24bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#aea6512988efb34a5c0d4785d5ae24bd6">evaluate</a> (unsigned long i) const</td></tr>
<tr class="memdesc:aea6512988efb34a5c0d4785d5ae24bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the homomorphism at a generator of the domain.  <a href="classregina_1_1HomGroupPresentation.html#aea6512988efb34a5c0d4785d5ae24bd6">More...</a><br /></td></tr>
<tr class="separator:aea6512988efb34a5c0d4785d5ae24bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab541893a02328a01569404440fdc385d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#ab541893a02328a01569404440fdc385d">invEvaluate</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> arg) const</td></tr>
<tr class="memdesc:ab541893a02328a01569404440fdc385d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the isomorphisms's inverse at an element of the codomain.  <a href="classregina_1_1HomGroupPresentation.html#ab541893a02328a01569404440fdc385d">More...</a><br /></td></tr>
<tr class="separator:ab541893a02328a01569404440fdc385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37003838777aedbe54e9cf372aa2fbd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a37003838777aedbe54e9cf372aa2fbd9">invEvaluate</a> (unsigned long i) const</td></tr>
<tr class="memdesc:a37003838777aedbe54e9cf372aa2fbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the isomorphism at a generator of the codomain.  <a href="classregina_1_1HomGroupPresentation.html#a37003838777aedbe54e9cf372aa2fbd9">More...</a><br /></td></tr>
<tr class="separator:a37003838777aedbe54e9cf372aa2fbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51beafb7f570b78db3a9328313a81af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#ac51beafb7f570b78db3a9328313a81af">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:ac51beafb7f570b78db3a9328313a81af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simultaneously simplifies:  <a href="classregina_1_1HomGroupPresentation.html#ac51beafb7f570b78db3a9328313a81af">More...</a><br /></td></tr>
<tr class="separator:ac51beafb7f570b78db3a9328313a81af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb66be2c97c5c03a5ce61ea37f447dc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#adb66be2c97c5c03a5ce61ea37f447dc0">intelligentNielsen</a> ()</td></tr>
<tr class="memdesc:adb66be2c97c5c03a5ce61ea37f447dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the domain and codomain using only Nielsen moves, keeping track of the resulting map in the progress.  <a href="classregina_1_1HomGroupPresentation.html#adb66be2c97c5c03a5ce61ea37f447dc0">More...</a><br /></td></tr>
<tr class="separator:adb66be2c97c5c03a5ce61ea37f447dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a2112399e2d6b1b7a49368730920b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a29a2112399e2d6b1b7a49368730920b0">smallCancellation</a> ()</td></tr>
<tr class="memdesc:a29a2112399e2d6b1b7a49368730920b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the domain and codomain using only small cancellation theory.  <a href="classregina_1_1HomGroupPresentation.html#a29a2112399e2d6b1b7a49368730920b0">More...</a><br /></td></tr>
<tr class="separator:a29a2112399e2d6b1b7a49368730920b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc77e7d49af0da7c44a21b01e67031d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#afc77e7d49af0da7c44a21b01e67031d2">operator*</a> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;rhs) const</td></tr>
<tr class="memdesc:afc77e7d49af0da7c44a21b01e67031d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes this homomorphism with the given homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#afc77e7d49af0da7c44a21b01e67031d2">More...</a><br /></td></tr>
<tr class="separator:afc77e7d49af0da7c44a21b01e67031d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde7d057cecce3bc94d97c821c67739a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#afde7d057cecce3bc94d97c821c67739a">operator*</a> (<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&amp;rhs) const</td></tr>
<tr class="memdesc:afde7d057cecce3bc94d97c821c67739a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes this homomorphism with the given homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#afde7d057cecce3bc94d97c821c67739a">More...</a><br /></td></tr>
<tr class="separator:afde7d057cecce3bc94d97c821c67739a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746c24ac004ad8a426c072f0b7c17891"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a746c24ac004ad8a426c072f0b7c17891">invert</a> ()</td></tr>
<tr class="memdesc:a746c24ac004ad8a426c072f0b7c17891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#a746c24ac004ad8a426c072f0b7c17891">More...</a><br /></td></tr>
<tr class="separator:a746c24ac004ad8a426c072f0b7c17891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542d03cd5ebf7bd5d589fe5ef5ae2e48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a542d03cd5ebf7bd5d589fe5ef5ae2e48">verify</a> () const</td></tr>
<tr class="memdesc:a542d03cd5ebf7bd5d589fe5ef5ae2e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies the map is a valid homomorphism.  <a href="classregina_1_1HomGroupPresentation.html#a542d03cd5ebf7bd5d589fe5ef5ae2e48">More...</a><br /></td></tr>
<tr class="separator:a542d03cd5ebf7bd5d589fe5ef5ae2e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c8442bd57b8974495b657d3e675683"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a21c8442bd57b8974495b657d3e675683">verifyIsomorphism</a> () const</td></tr>
<tr class="memdesc:a21c8442bd57b8974495b657d3e675683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to verify that a declared isomorphism is, indeed, an isomorphism.  <a href="classregina_1_1HomGroupPresentation.html#a21c8442bd57b8974495b657d3e675683">More...</a><br /></td></tr>
<tr class="separator:a21c8442bd57b8974495b657d3e675683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296b782e27a59e65e68482c2d838c335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a296b782e27a59e65e68482c2d838c335">markedAbelianisation</a> () const</td></tr>
<tr class="memdesc:a296b782e27a59e65e68482c2d838c335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the induced map on the abelianizations of the domain and codomain.  <a href="classregina_1_1HomGroupPresentation.html#a296b782e27a59e65e68482c2d838c335">More...</a><br /></td></tr>
<tr class="separator:a296b782e27a59e65e68482c2d838c335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507262602c062ad0190e0c22af7390f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a507262602c062ad0190e0c22af7390f7">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a507262602c062ad0190e0c22af7390f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1HomGroupPresentation.html#a507262602c062ad0190e0c22af7390f7">More...</a><br /></td></tr>
<tr class="separator:a507262602c062ad0190e0c22af7390f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1eda088e5ec8331c924d284cfcc359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html#a2b1eda088e5ec8331c924d284cfcc359">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2b1eda088e5ec8331c924d284cfcc359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1HomGroupPresentation.html#a2b1eda088e5ec8331c924d284cfcc359">More...</a><br /></td></tr>
<tr class="separator:a2b1eda088e5ec8331c924d284cfcc359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a homomorphism between groups which are described via finite presentations. </p>
<p >Some homomorphisms may be <em>declared isomorphisms</em>. This means that the user (or some other function in Regina) has proven that this is an isomorphism and has explicitly provided the inverse map. To provide the inverse map, you should call the four-argument constructor HomGroupPresentation(const GroupPresentation&amp;, const GroupPresentation&amp;,
const std::vector&lt;GroupExpression&gt;&amp;, const std::vector&lt;GroupExpression&gt;&amp;).</p>
<p >You can test for a declared isomorphism by calling <a class="el" href="classregina_1_1HomGroupPresentation.html#af222ad0e798429548eb15ed5ceccd909" title="Returns whether or not this is a declared isomorphism.">knowsInverse()</a>. Even if a homomorphism is not a declared isomorphism, it might still be an isomorphism; this just means that no inverse map was explicitly provided.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Add a routine to attempt to verify validity of homomorphism.</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a15a6ea4be281b21a93a7a5435517a759" name="a15a6ea4be281b21a93a7a5435517a759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a6ea4be281b21a93a7a5435517a759">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td>
          <td class="paramname"><em>codomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new homomorphism from the given data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>the domain of the homomorphism. </td></tr>
    <tr><td class="paramname">codomain</td><td>the codomain of the homomorphism. </td></tr>
    <tr><td class="paramname">map</td><td>a vector of length <em>g</em>, where <em>g</em> is the number of generators of the domain, and where this homomorphism sends the <em>i</em>th generator of the domain to the element <code>map[i]</code> of the codomain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97738be48708a356a7305b02fb605555" name="a97738be48708a356a7305b02fb605555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97738be48708a356a7305b02fb605555">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td>
          <td class="paramname"><em>codomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt;&#160;</td>
          <td class="paramname"><em>inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a declared isomorphism from the given data. </p>
<p >Here you must provide both a map from the domain to codomain, and the inverse map from the codomain to domain.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>inv</em> is indeed the inverse of <em>map</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>the domain of the homomorphism. </td></tr>
    <tr><td class="paramname">codomain</td><td>the codomain of the homomorphism. </td></tr>
    <tr><td class="paramname">map</td><td>a vector of length <em>g</em>, where <em>g</em> is the number of generators of the domain, and where this homomorphism sends the <em>i</em>th generator of the domain to the element <code>map[i]</code> of the codomain. </td></tr>
    <tr><td class="paramname">inv</td><td>a vector of length <em>k</em> where <em>k</em> is the number of generators of the codomain, and where the inverse homomorphism sends the <em>i</em>th generator of the codomain to the element <code>inv[i]</code> of the domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3799566faa70c9e628dc75953553b8a2" name="a3799566faa70c9e628dc75953553b8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3799566faa70c9e628dc75953553b8a2">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>groupForIdentity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new identity homomorphism for the given group. </p>
<p >This will be a declared isomorphism (see the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupForIdentity</td><td>both the domain and codomain of the new identity homomorphism. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad89f0a9e5f2a672e1958deaf012e8646" name="ad89f0a9e5f2a672e1958deaf012e8646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89f0a9e5f2a672e1958deaf012e8646">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given homomorphism. </p>

</div>
</div>
<a id="a255ed9ece3200453263aa97ae4cab133" name="a255ed9ece3200453263aa97ae4cab133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a255ed9ece3200453263aa97ae4cab133">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given homomorphism into this new homomorphism. </p>
<p >This is a fast (constant time) operation.</p>
<p >The homomorphism that was passed will no longer be usable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a55f0aadb546a83e748ad24954c51f5ea" name="a55f0aadb546a83e748ad24954c51f5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f0aadb546a83e748ad24954c51f5ea">&#9670;&nbsp;</a></span>codomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; regina::HomGroupPresentation::codomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The codomain of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the codomain. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a7f7f2527f5247f549e2f96bae2f2682b" name="a7f7f2527f5247f549e2f96bae2f2682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7f2527f5247f549e2f96bae2f2682b">&#9670;&nbsp;</a></span>domain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; regina::HomGroupPresentation::domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The domain of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the domain. </dd></dl>

</div>
</div>
<a id="aaaa021da72c35116f790cb8529941bec" name="aaaa021da72c35116f790cb8529941bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa021da72c35116f790cb8529941bec">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::evaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the homomorphism at an element of the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>an element of the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this element in the codomain. </dd></dl>

</div>
</div>
<a id="aea6512988efb34a5c0d4785d5ae24bd6" name="aea6512988efb34a5c0d4785d5ae24bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6512988efb34a5c0d4785d5ae24bd6">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::evaluate </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the homomorphism at a generator of the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of a generator in the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of the <em>i</em>th generator in the codomain. </dd></dl>

</div>
</div>
<a id="adb66be2c97c5c03a5ce61ea37f447dc0" name="adb66be2c97c5c03a5ce61ea37f447dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb66be2c97c5c03a5ce61ea37f447dc0">&#9670;&nbsp;</a></span>intelligentNielsen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::intelligentNielsen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the domain and codomain using only Nielsen moves, keeping track of the resulting map in the progress. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if either presentation and/or the map was changed. </dd></dl>

</div>
</div>
<a id="ac51beafb7f570b78db3a9328313a81af" name="ac51beafb7f570b78db3a9328313a81af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51beafb7f570b78db3a9328313a81af">&#9670;&nbsp;</a></span>intelligentSimplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simultaneously simplifies: </p>
<ul>
<li>the presentation of the domain;</li>
<li>the presentation of the codomain;</li>
<li>the description of the map.</li>
</ul>
<p >Uses the underlying <a class="el" href="classregina_1_1GroupPresentation.html#aa7811777ca9d3e19fe5a3fddeca753ad" title="Attempts to simplify the group presentation as intelligently as possible without further input.">GroupPresentation::intelligentSimplify()</a>. See that routine for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if either presentation and/or the map was changed. </dd></dl>

</div>
</div>
<a id="a746c24ac004ad8a426c072f0b7c17891" name="a746c24ac004ad8a426c072f0b7c17891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a746c24ac004ad8a426c072f0b7c17891">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts the homomorphism. </p>
<p >This is only possible if the homomorphism is in fact a declared isomorphism (which means that the inverse map is already stored internally). See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for further details on declared isomorphisms.</p>
<p >If this is not a declared isomorphism then this routine will do nothing and simply return <code>false</code>.</p>
<p >This operation is (very) fast constant time.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the inversion operation was successful (i.e., if this is a declared isomorphism). </dd></dl>

</div>
</div>
<a id="ab541893a02328a01569404440fdc385d" name="ab541893a02328a01569404440fdc385d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab541893a02328a01569404440fdc385d">&#9670;&nbsp;</a></span>invEvaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::invEvaluate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the isomorphisms's inverse at an element of the codomain. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This homomorphism is in fact a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>an element of the codomain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this element in the domain. </dd></dl>

</div>
</div>
<a id="a37003838777aedbe54e9cf372aa2fbd9" name="a37003838777aedbe54e9cf372aa2fbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37003838777aedbe54e9cf372aa2fbd9">&#9670;&nbsp;</a></span>invEvaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::invEvaluate </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the isomorphism at a generator of the codomain. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This homomorphism is in fact a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of a generator in the codomain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this generator in the domain. </dd></dl>

</div>
</div>
<a id="af222ad0e798429548eb15ed5ceccd909" name="af222ad0e798429548eb15ed5ceccd909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af222ad0e798429548eb15ed5ceccd909">&#9670;&nbsp;</a></span>knowsInverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::knowsInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this is a declared isomorphism. </p>
<p >A <em>declared isomorphism</em> is a isomorphism for which the user has explicitly provided the inverse map. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a declared isomorphism, i.e, the inverse map was explicitly provided. </dd></dl>

</div>
</div>
<a id="a296b782e27a59e65e68482c2d838c335" name="a296b782e27a59e65e68482c2d838c335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296b782e27a59e65e68482c2d838c335">&#9670;&nbsp;</a></span>markedAbelianisation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> regina::HomGroupPresentation::markedAbelianisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the induced map on the abelianizations of the domain and codomain. </p>
<dl class="section return"><dt>Returns</dt><dd>the induced map on the abelianizations. </dd></dl>

</div>
</div>
<a id="a66649e219844a078c431c1950ffbd5e4" name="a66649e219844a078c431c1950ffbd5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66649e219844a078c431c1950ffbd5e4">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given homomorphism do not have identical presentations. </p>
<p >This routine does <em>not</em> test whether the two homomorphisms are equal in the sense that each element of the domain maps to the same group element of the codomain - in general this is an undecidable problem.</p>
<p >Instead, this routine tests whether the two homomorphisms map the <em>i</em>th generator of the domain to precisely the same <em>word</em> in the codomain, for each <em>i</em>.</p>
<p >This routine will not test whether the domains and codomains have identical presentations, or whether either homomorphism is declared to be an isomorphism. However, if the two domains have different numbers of generators then the two homomorphisms will compare as not equal (since it will be impossible to compare the words that the corresponding generators map to).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the homomorphism to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given homomorphisms do not have identical presentations. </dd></dl>

</div>
</div>
<a id="afc77e7d49af0da7c44a21b01e67031d2" name="afc77e7d49af0da7c44a21b01e67031d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc77e7d49af0da7c44a21b01e67031d2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> regina::HomGroupPresentation::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes this homomorphism with the given homomorphism. </p>
<p >Evaluating the composition on some group element <em>x</em> is the same as evaluating <code>this(rhs(x))</code>. In other words, in this composition, <em>rhs</em> is evaluated first and then the output of that is evaluated by this homomorphism.</p>
<p >If both of the given homomorphisms are declared isomorphisms, then the return value will be a declared isomoprhism also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the codomain of <em>rhs</em> must be the same as the domain of this homomorphism.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the homomorphism to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both homomorphisms. </dd></dl>

</div>
</div>
<a id="afde7d057cecce3bc94d97c821c67739a" name="afde7d057cecce3bc94d97c821c67739a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde7d057cecce3bc94d97c821c67739a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> regina::HomGroupPresentation::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes this homomorphism with the given homomorphism. </p>
<p >Evaluating the composition on some group element <em>x</em> is the same as evaluating <code>this(rhs(x))</code>. In other words, in this composition, <em>rhs</em> is evaluated first and then the output of that is evaluated by this homomorphism.</p>
<p >If both of the given homomorphisms are declared isomorphisms, then the return value will be a declared isomoprhism also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the codomain of <em>rhs</em> must be the same as the domain of this homomorphism.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the homomorphism to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both homomorphisms. </dd></dl>

</div>
</div>
<a id="a8d2ddc834aa292144ef80a1ef709bfc9" name="a8d2ddc834aa292144ef80a1ef709bfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d2ddc834aa292144ef80a1ef709bfc9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp; regina::HomGroupPresentation::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this homomorphism. </dd></dl>

</div>
</div>
<a id="abb53e1c4c10d3c8e9d912f21eb6306b9" name="abb53e1c4c10d3c8e9d912f21eb6306b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb53e1c4c10d3c8e9d912f21eb6306b9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp; regina::HomGroupPresentation::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given homomorphism to this homomorphism. </p>
<p >This is a fast (constant time) operation.</p>
<p >The homomorphism that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this homomorphism. </dd></dl>

</div>
</div>
<a id="a85b8aa6178f2ab80d9edd527cfa13833" name="a85b8aa6178f2ab80d9edd527cfa13833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b8aa6178f2ab80d9edd527cfa13833">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given homomorphism have identical presentations. </p>
<p >This routine does <em>not</em> test whether the two homomorphisms are equal in the sense that each element of the domain maps to the same group element of the codomain - in general this is an undecidable problem.</p>
<p >Instead, this routine tests whether the two homomorphisms map the <em>i</em>th generator of the domain to precisely the same <em>word</em> in the codomain, for each <em>i</em>.</p>
<p >This routine will not test whether the domains and codomains have identical presentations, or whether either homomorphism is declared to be an isomorphism. However, if the two domains have different numbers of generators then the two homomorphisms will compare as not equal (since it will be impossible to compare the words that the corresponding generators map to).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the homomorphism to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given homomorphisms have identical presentations. </dd></dl>

</div>
</div>
<a id="a29a2112399e2d6b1b7a49368730920b0" name="a29a2112399e2d6b1b7a49368730920b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a2112399e2d6b1b7a49368730920b0">&#9670;&nbsp;</a></span>smallCancellation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::smallCancellation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the domain and codomain using only small cancellation theory. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if either presentation and/or the map was changed. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a4274042726ce3fb00075ba19e5f42e3e" name="a4274042726ce3fb00075ba19e5f42e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4274042726ce3fb00075ba19e5f42e3e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomGroupPresentation::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given homomorphism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the homomorphism whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a542d03cd5ebf7bd5d589fe5ef5ae2e48" name="a542d03cd5ebf7bd5d589fe5ef5ae2e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542d03cd5ebf7bd5d589fe5ef5ae2e48">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies the map is a valid homomorphism. </p>
<p >Specifically, this routine runs through all the relators in the domain, evaluates the homomorphism on the relators and checks that they simplify to 1 in the codomain.</p>
<p >This routine does not guarantee a conclusive result (since the word problem is, in general, undecidable). If this routine returns <code>true</code> then this proves that the homomorphism is indeed valid. If this routine returns <code>false</code>, then the result is inconclusive (i.e., it might still be valid but Regina was not able to prove this).</p>
<p >This routine is intended for sanity checking only: any homomorphism that you construct in Regina should always be valid in this sense.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if Regina is able to verify that this is a homomorphism, or <code>false</code> if the result is inconclusive. </dd></dl>

</div>
</div>
<a id="a21c8442bd57b8974495b657d3e675683" name="a21c8442bd57b8974495b657d3e675683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c8442bd57b8974495b657d3e675683">&#9670;&nbsp;</a></span>verifyIsomorphism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::verifyIsomorphism </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to verify that a declared isomorphism is, indeed, an isomorphism. </p>
<p >This routine works by attempting to verify that <code>f^-1(f(x))x^-1</code> simplifes to 1 for all generators <em>x</em> in the domain, and likewise for the codomain.</p>
<p >This routine does not guarantee a conclusive result. If this routine returns <code>true</code> then this proves that this is indeed an isomorphism. If this routine returns <code>false</code> then the result is inconclusive (i.e., it might still be an isomorphism but Regina was not able to prove this).</p>
<p >You probably only want to run this on good presentations for small cancellation theory - an automorphism of a poorly-presented group likely will not be noticed.</p>
<p >This routine is intended for sanity checking only: any homomorphism that you construct as a declared isomorphism should always be an isomorphism.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This homomorphism is in fact a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it is verified that this is an isomorphism, or <code>false</code> if the result is inconclusive. </dd></dl>

</div>
</div>
<a id="a2b1eda088e5ec8331c924d284cfcc359" name="a2b1eda088e5ec8331c924d284cfcc359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1eda088e5ec8331c924d284cfcc359">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomGroupPresentation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a507262602c062ad0190e0c22af7390f7" name="a507262602c062ad0190e0c22af7390f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507262602c062ad0190e0c22af7390f7">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomGroupPresentation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="homgrouppresentation_8h.html">homgrouppresentation.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
