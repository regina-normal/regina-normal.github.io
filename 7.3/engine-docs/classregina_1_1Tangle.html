<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::Tangle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Tangle.html">Tangle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1Tangle-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Tangle Class Reference<div class="ingroups"><a class="el" href="group__link.html">Knots and Links</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a 2-tangle in the 3-ball.  
 <a href="classregina_1_1Tangle.html#details">More...</a></p>

<p><code>#include &lt;link/tangle.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Tangle:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Tangle.png" usemap="#regina::Tangle_map" alt=""/>
  <map id="regina::Tangle_map" name="regina::Tangle_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Tangle &gt;" shape="rect" coords="0,0,153,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a683a15a679a274e4cd2c905ef381d287"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a683a15a679a274e4cd2c905ef381d287">Tangle</a> ()</td></tr>
<tr class="memdesc:a683a15a679a274e4cd2c905ef381d287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the zero tangle.  <a href="classregina_1_1Tangle.html#a683a15a679a274e4cd2c905ef381d287">More...</a><br /></td></tr>
<tr class="separator:a683a15a679a274e4cd2c905ef381d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23fbb1a389e483e32f99c9eb1e3a3e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#ae23fbb1a389e483e32f99c9eb1e3a3e9">Tangle</a> (int twists)</td></tr>
<tr class="memdesc:ae23fbb1a389e483e32f99c9eb1e3a3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a tangle from the given number of twists.  <a href="classregina_1_1Tangle.html#ae23fbb1a389e483e32f99c9eb1e3a3e9">More...</a><br /></td></tr>
<tr class="separator:ae23fbb1a389e483e32f99c9eb1e3a3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a5f998255d48ee62fdd3c53b04c162"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a08a5f998255d48ee62fdd3c53b04c162">Tangle</a> (int num, int den)</td></tr>
<tr class="memdesc:a08a5f998255d48ee62fdd3c53b04c162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a rational tangle with the given parameters.  <a href="classregina_1_1Tangle.html#a08a5f998255d48ee62fdd3c53b04c162">More...</a><br /></td></tr>
<tr class="separator:a08a5f998255d48ee62fdd3c53b04c162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe69c31e2d787bf47ccd21513d9f302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#adbe69c31e2d787bf47ccd21513d9f302">Tangle</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;knot)</td></tr>
<tr class="memdesc:adbe69c31e2d787bf47ccd21513d9f302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tangle from two parallel copies of the given knot.  <a href="classregina_1_1Tangle.html#adbe69c31e2d787bf47ccd21513d9f302">More...</a><br /></td></tr>
<tr class="separator:adbe69c31e2d787bf47ccd21513d9f302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d96f9728fe44d1b8d0802d789e538c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a9d96f9728fe44d1b8d0802d789e538c9">Tangle</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;copy)</td></tr>
<tr class="memdesc:a9d96f9728fe44d1b8d0802d789e538c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given tangle.  <a href="classregina_1_1Tangle.html#a9d96f9728fe44d1b8d0802d789e538c9">More...</a><br /></td></tr>
<tr class="separator:a9d96f9728fe44d1b8d0802d789e538c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c4fbd2039992eed58ba74be5b4aef8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a60c4fbd2039992eed58ba74be5b4aef8">Tangle</a> (<a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a60c4fbd2039992eed58ba74be5b4aef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given tangle into this new tangle.  <a href="classregina_1_1Tangle.html#a60c4fbd2039992eed58ba74be5b4aef8">More...</a><br /></td></tr>
<tr class="separator:a60c4fbd2039992eed58ba74be5b4aef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda30f07f41d668822fb525b8253b8d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#abda30f07f41d668822fb525b8253b8d0">~Tangle</a> ()</td></tr>
<tr class="memdesc:abda30f07f41d668822fb525b8253b8d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this tangle.  <a href="classregina_1_1Tangle.html#abda30f07f41d668822fb525b8253b8d0">More...</a><br /></td></tr>
<tr class="separator:abda30f07f41d668822fb525b8253b8d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Crossings and Strings</div></td></tr>
<tr class="memitem:ab88015bcdf131873362ba1da8e26507c"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#ab88015bcdf131873362ba1da8e26507c">type</a> () const</td></tr>
<tr class="memdesc:ab88015bcdf131873362ba1da8e26507c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of this tangle.  <a href="classregina_1_1Tangle.html#ab88015bcdf131873362ba1da8e26507c">More...</a><br /></td></tr>
<tr class="separator:ab88015bcdf131873362ba1da8e26507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e255ebc40070d5c43f14fb3848f2827"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a3e255ebc40070d5c43f14fb3848f2827">size</a> () const</td></tr>
<tr class="memdesc:a3e255ebc40070d5c43f14fb3848f2827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of crossings in this tangle.  <a href="classregina_1_1Tangle.html#a3e255ebc40070d5c43f14fb3848f2827">More...</a><br /></td></tr>
<tr class="separator:a3e255ebc40070d5c43f14fb3848f2827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c92cf6b883589c87ef9ce24d36e318"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#af1c92cf6b883589c87ef9ce24d36e318">crossing</a> (size_t index) const</td></tr>
<tr class="memdesc:af1c92cf6b883589c87ef9ce24d36e318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the crossing at the given index within this tangle.  <a href="classregina_1_1Tangle.html#af1c92cf6b883589c87ef9ce24d36e318">More...</a><br /></td></tr>
<tr class="separator:af1c92cf6b883589c87ef9ce24d36e318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d198583c5f812a6106955f8bfb3b6c7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a2d198583c5f812a6106955f8bfb3b6c7">crossings</a> () const</td></tr>
<tr class="memdesc:a2d198583c5f812a6106955f8bfb3b6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all crossings within this tangle.  <a href="classregina_1_1Tangle.html#a2d198583c5f812a6106955f8bfb3b6c7">More...</a><br /></td></tr>
<tr class="separator:a2d198583c5f812a6106955f8bfb3b6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b27ae3e97e8ffb165914d67e235296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#ac0b27ae3e97e8ffb165914d67e235296">begin</a> (int string) const</td></tr>
<tr class="memdesc:ac0b27ae3e97e8ffb165914d67e235296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the crossing closest to the beginning of the given string.  <a href="classregina_1_1Tangle.html#ac0b27ae3e97e8ffb165914d67e235296">More...</a><br /></td></tr>
<tr class="separator:ac0b27ae3e97e8ffb165914d67e235296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85986cfd37035eaaa0f49a1bd4abb459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a85986cfd37035eaaa0f49a1bd4abb459">end</a> (int string) const</td></tr>
<tr class="memdesc:a85986cfd37035eaaa0f49a1bd4abb459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the crossing closest to the end of the given string.  <a href="classregina_1_1Tangle.html#a85986cfd37035eaaa0f49a1bd4abb459">More...</a><br /></td></tr>
<tr class="separator:a85986cfd37035eaaa0f49a1bd4abb459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b5027743f9f21e8ca84e165f75609f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a76b5027743f9f21e8ca84e165f75609f">operator==</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;other) const</td></tr>
<tr class="memdesc:a76b5027743f9f21e8ca84e165f75609f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this tangle is combinatorially identical to the given tangle.  <a href="classregina_1_1Tangle.html#a76b5027743f9f21e8ca84e165f75609f">More...</a><br /></td></tr>
<tr class="separator:a76b5027743f9f21e8ca84e165f75609f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab6939724cbe76d9c08c2cc0b69e8cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a2ab6939724cbe76d9c08c2cc0b69e8cf">operator!=</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;other) const</td></tr>
<tr class="memdesc:a2ab6939724cbe76d9c08c2cc0b69e8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this tangle is not combinatorially identical to the given tangle.  <a href="classregina_1_1Tangle.html#a2ab6939724cbe76d9c08c2cc0b69e8cf">More...</a><br /></td></tr>
<tr class="separator:a2ab6939724cbe76d9c08c2cc0b69e8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013419d2ffd00eb93d85b4aaae713209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a013419d2ffd00eb93d85b4aaae713209">translate</a> (const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;other) const</td></tr>
<tr class="memdesc:a013419d2ffd00eb93d85b4aaae713209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a strand reference from some other tangle into the corresponding strand reference from this tangle.  <a href="classregina_1_1Tangle.html#a013419d2ffd00eb93d85b4aaae713209">More...</a><br /></td></tr>
<tr class="separator:a013419d2ffd00eb93d85b4aaae713209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Editing</div></td></tr>
<tr class="memitem:adac3c2ba2a0f117182fdb7f33208eb34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#adac3c2ba2a0f117182fdb7f33208eb34">operator=</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;src)</td></tr>
<tr class="memdesc:adac3c2ba2a0f117182fdb7f33208eb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given tangle.  <a href="classregina_1_1Tangle.html#adac3c2ba2a0f117182fdb7f33208eb34">More...</a><br /></td></tr>
<tr class="separator:adac3c2ba2a0f117182fdb7f33208eb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f4df563cc7c93559abae2b50e81d3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#aa2f4df563cc7c93559abae2b50e81d3d">operator=</a> (<a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aa2f4df563cc7c93559abae2b50e81d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given tangle into this tangle.  <a href="classregina_1_1Tangle.html#aa2f4df563cc7c93559abae2b50e81d3d">More...</a><br /></td></tr>
<tr class="separator:aa2f4df563cc7c93559abae2b50e81d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c6083e947dadaf9ef981cd203bb44e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a24c6083e947dadaf9ef981cd203bb44e">swap</a> (<a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a24c6083e947dadaf9ef981cd203bb44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given tangle.  <a href="classregina_1_1Tangle.html#a24c6083e947dadaf9ef981cd203bb44e">More...</a><br /></td></tr>
<tr class="separator:a24c6083e947dadaf9ef981cd203bb44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf4a4fa65f6b91f929833f55fb2c06f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a1bf4a4fa65f6b91f929833f55fb2c06f">twist</a> (int sign=1)</td></tr>
<tr class="memdesc:a1bf4a4fa65f6b91f929833f55fb2c06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a twist to the right-hand end of this tangle.  <a href="classregina_1_1Tangle.html#a1bf4a4fa65f6b91f929833f55fb2c06f">More...</a><br /></td></tr>
<tr class="separator:a1bf4a4fa65f6b91f929833f55fb2c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe8878a670f2cea6734f336cb9d563f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#abfe8878a670f2cea6734f336cb9d563f">turn</a> (int direction=1)</td></tr>
<tr class="memdesc:abfe8878a670f2cea6734f336cb9d563f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates this tangle by 90 degrees.  <a href="classregina_1_1Tangle.html#abfe8878a670f2cea6734f336cb9d563f">More...</a><br /></td></tr>
<tr class="separator:abfe8878a670f2cea6734f336cb9d563f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efe758c243da18417406ed5bff41ee8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a0efe758c243da18417406ed5bff41ee8">changeAll</a> ()</td></tr>
<tr class="memdesc:a0efe758c243da18417406ed5bff41ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the upper and lower strands of every crossing in the tangle.  <a href="classregina_1_1Tangle.html#a0efe758c243da18417406ed5bff41ee8">More...</a><br /></td></tr>
<tr class="separator:a0efe758c243da18417406ed5bff41ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75456efb18f88399f5e800fb52c3d70d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a75456efb18f88399f5e800fb52c3d70d">r1</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Tangle.html#af1c92cf6b883589c87ef9ce24d36e318">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a75456efb18f88399f5e800fb52c3d70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type I Reidemeister move to remove a crossing.  <a href="classregina_1_1Tangle.html#a75456efb18f88399f5e800fb52c3d70d">More...</a><br /></td></tr>
<tr class="separator:a75456efb18f88399f5e800fb52c3d70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80f087595912ee502a37bf2c7980c33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#af80f087595912ee502a37bf2c7980c33">r2</a> (<a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> arc, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:af80f087595912ee502a37bf2c7980c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="classregina_1_1Tangle.html#af80f087595912ee502a37bf2c7980c33">More...</a><br /></td></tr>
<tr class="separator:af80f087595912ee502a37bf2c7980c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa71c2b2601ab277179d44e8f62176d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#aaa71c2b2601ab277179d44e8f62176d8">r2</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *<a class="el" href="classregina_1_1Tangle.html#af1c92cf6b883589c87ef9ce24d36e318">crossing</a>, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:aaa71c2b2601ab277179d44e8f62176d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for and/or performs a type II Reidemeister move to remove two crossings.  <a href="classregina_1_1Tangle.html#aaa71c2b2601ab277179d44e8f62176d8">More...</a><br /></td></tr>
<tr class="separator:aaa71c2b2601ab277179d44e8f62176d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82854b84b334083c2dd8ccd5e23ee41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#aa82854b84b334083c2dd8ccd5e23ee41">simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:aa82854b84b334083c2dd8ccd5e23ee41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses type I and II Reidemeister moves to reduce the tangle monotonically to some local minimum number of crossings.  <a href="classregina_1_1Tangle.html#aa82854b84b334083c2dd8ccd5e23ee41">More...</a><br /></td></tr>
<tr class="separator:aa82854b84b334083c2dd8ccd5e23ee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebra on Tangles</div></td></tr>
<tr class="memitem:a13c803002ef7a372a10340c644bc3f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a13c803002ef7a372a10340c644bc3f96">add</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;other)</td></tr>
<tr class="memdesc:a13c803002ef7a372a10340c644bc3f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given tangle to the right-hand side of this tangle.  <a href="classregina_1_1Tangle.html#a13c803002ef7a372a10340c644bc3f96">More...</a><br /></td></tr>
<tr class="separator:a13c803002ef7a372a10340c644bc3f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d50a1e2852266c95d1e87618af48b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#af8d50a1e2852266c95d1e87618af48b5">negate</a> ()</td></tr>
<tr class="memdesc:af8d50a1e2852266c95d1e87618af48b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reflects this tangle through the diagonal axis running from the top-left to bottom-right corners of the diagram.  <a href="classregina_1_1Tangle.html#af8d50a1e2852266c95d1e87618af48b5">More...</a><br /></td></tr>
<tr class="separator:af8d50a1e2852266c95d1e87618af48b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f70fc6613c99a6647d1a229ec36804"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a64f70fc6613c99a6647d1a229ec36804">box</a> (const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;topLeft, const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;topRight, const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;bottomLeft, const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;bottomRight)</td></tr>
<tr class="memdesc:a64f70fc6613c99a6647d1a229ec36804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encloses this tangle with the four given tangles in a box configuration.  <a href="classregina_1_1Tangle.html#a64f70fc6613c99a6647d1a229ec36804">More...</a><br /></td></tr>
<tr class="separator:a64f70fc6613c99a6647d1a229ec36804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f13efa433d0576171ebf403ebdb1ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a5f13efa433d0576171ebf403ebdb1ac1">numClosure</a> () const</td></tr>
<tr class="memdesc:a5f13efa433d0576171ebf403ebdb1ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the numerator closure of this tangle.  <a href="classregina_1_1Tangle.html#a5f13efa433d0576171ebf403ebdb1ac1">More...</a><br /></td></tr>
<tr class="separator:a5f13efa433d0576171ebf403ebdb1ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad493a656c6f0b9a6a2ae2f06e151f10e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Link.html">Link</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#ad493a656c6f0b9a6a2ae2f06e151f10e">denClosure</a> () const</td></tr>
<tr class="memdesc:ad493a656c6f0b9a6a2ae2f06e151f10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forms the denominator closure of this tangle.  <a href="classregina_1_1Tangle.html#ad493a656c6f0b9a6a2ae2f06e151f10e">More...</a><br /></td></tr>
<tr class="separator:ad493a656c6f0b9a6a2ae2f06e151f10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output</div></td></tr>
<tr class="memitem:afc9da0489723b099bd15bf729a401933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#afc9da0489723b099bd15bf729a401933">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afc9da0489723b099bd15bf729a401933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this tangle to the given output stream.  <a href="classregina_1_1Tangle.html#afc9da0489723b099bd15bf729a401933">More...</a><br /></td></tr>
<tr class="separator:afc9da0489723b099bd15bf729a401933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafb3ede468c74cd0a7280f8a5d0fcc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#afafb3ede468c74cd0a7280f8a5d0fcc2">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afafb3ede468c74cd0a7280f8a5d0fcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this tangle to the given output stream.  <a href="classregina_1_1Tangle.html#afafb3ede468c74cd0a7280f8a5d0fcc2">More...</a><br /></td></tr>
<tr class="separator:afafb3ede468c74cd0a7280f8a5d0fcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Tangles</div></td></tr>
<tr class="memitem:a5321327eaf8ad782b6b3e5b1d94442e8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a5321327eaf8ad782b6b3e5b1d94442e8">brief</a> () const</td></tr>
<tr class="memdesc:a5321327eaf8ad782b6b3e5b1d94442e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this tangle in Regina's own brief write-only format.  <a href="classregina_1_1Tangle.html#a5321327eaf8ad782b6b3e5b1d94442e8">More...</a><br /></td></tr>
<tr class="separator:a5321327eaf8ad782b6b3e5b1d94442e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f7db6307c6b975a3cd43362385617f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a74f7db6307c6b975a3cd43362385617f">brief</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a74f7db6307c6b975a3cd43362385617f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this tangle in Regina's own brief format to the given output stream.  <a href="classregina_1_1Tangle.html#a74f7db6307c6b975a3cd43362385617f">More...</a><br /></td></tr>
<tr class="separator:a74f7db6307c6b975a3cd43362385617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4901f74db4ad01ee8987de6b2e87191e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a4901f74db4ad01ee8987de6b2e87191e">orientedGauss</a> () const</td></tr>
<tr class="memdesc:a4901f74db4ad01ee8987de6b2e87191e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs an oriented Gauss code for this tangle.  <a href="classregina_1_1Tangle.html#a4901f74db4ad01ee8987de6b2e87191e">More...</a><br /></td></tr>
<tr class="separator:a4901f74db4ad01ee8987de6b2e87191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ad9e44a76bac84d1e314a2f60a6fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a57ad9e44a76bac84d1e314a2f60a6fe8">orientedGauss</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a57ad9e44a76bac84d1e314a2f60a6fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an oriented Gauss code for this tangle to the given output stream.  <a href="classregina_1_1Tangle.html#a57ad9e44a76bac84d1e314a2f60a6fe8">More...</a><br /></td></tr>
<tr class="separator:a57ad9e44a76bac84d1e314a2f60a6fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Tangles</h2></td></tr>
<tr class="memitem:a6d3287e0f6dc6017d9474c0089a4f27d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a6d3287e0f6dc6017d9474c0089a4f27d">fromOrientedGauss</a> (const std::string &amp;<a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:a6d3287e0f6dc6017d9474c0089a4f27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tangle from an oriented Gauss code.  <a href="classregina_1_1Tangle.html#a6d3287e0f6dc6017d9474c0089a4f27d">More...</a><br /></td></tr>
<tr class="separator:a6d3287e0f6dc6017d9474c0089a4f27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363f89f8246a5dc2c13c9e91e68da0c4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a363f89f8246a5dc2c13c9e91e68da0c4"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Tangle.html#a363f89f8246a5dc2c13c9e91e68da0c4">fromOrientedGauss</a> (Iterator <a class="el" href="classregina_1_1Tangle.html#ac0b27ae3e97e8ffb165914d67e235296">begin</a>, Iterator <a class="el" href="classregina_1_1Tangle.html#a85986cfd37035eaaa0f49a1bd4abb459">end</a>)</td></tr>
<tr class="memdesc:a363f89f8246a5dc2c13c9e91e68da0c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new tangle from an oriented Gauss code.  <a href="classregina_1_1Tangle.html#a363f89f8246a5dc2c13c9e91e68da0c4">More...</a><br /></td></tr>
<tr class="separator:a363f89f8246a5dc2c13c9e91e68da0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a 2-tangle in the 3-ball. </p>
<p >Regina does not allow closed components in a tangle; in other words, a tangle in Regina is a proper embedding of exactly two arcs in the 3-ball with the corresponding four endpoints attached to four marked points on the 3-ball boundary.</p>
<p >Regina stores tangles as projections, with the four endpoints fixed at the top-left, top-right, bottom-left and bottom-right corners of the diagram.</p>
<p >Each tangles has a <em>type</em>, indicating how the four endpoints are connected. The three possible types are:</p>
<ul>
<li><em>horizontal</em>, indicating that the two top endpoints are connected, and the two bottom endpoints are connected;</li>
<li><em>vertical</em>, indicating that the two left endpoints are connected, and the two right endpoints are connected;</li>
<li><em>diagonal</em>, indicating that the top-left and bottom-right endpoints are connected, and the bottom-left and top-right endpoints are connected.</li>
</ul>
<p >Internally, Regina numbers the two strings 0 and 1: string 0 will always be the one attached to the top-left endpoint. Regina also assigns each string an orientation: for a horizontal or diagonal tangle this will always be from left to right, and for a vertical tangle this will always be from top to bottom.</p>
<p >When traversing a tangle, if you reach one of the endpoints of a string then the corresponding return value of <a class="el" href="classregina_1_1Crossing.html#af17087fab18a03a777c04d2d6eba29b8" title="Returns the crossing reference that immediately follows this when walking forward in the direction of...">Crossing::next()</a> or <a class="el" href="classregina_1_1Crossing.html#ab9f537596ed523115aad084089553836" title="Returns the crossing reference that immediately precedes this when walking backward against the direc...">Crossing::prev()</a> (whichever is relevant) will be a null strand reference.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a683a15a679a274e4cd2c905ef381d287" name="a683a15a679a274e4cd2c905ef381d287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683a15a679a274e4cd2c905ef381d287">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the zero tangle. </p>
<p >This is the horizontal tangle with no crossings. </p>

</div>
</div>
<a id="ae23fbb1a389e483e32f99c9eb1e3a3e9" name="ae23fbb1a389e483e32f99c9eb1e3a3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23fbb1a389e483e32f99c9eb1e3a3e9">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>twists</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a tangle from the given number of twists. </p>
<p >If <em>twists</em> is positive, then the new tangle will consist of <em>twists</em> positive twists, stacked from left to right. If <em>twists</em> is negative, then the new tangle will consist of -(<em>twists</em>) negative twists, likewise stacked from left to right. If <em>twists</em> is zero, then the new tangle will be a horizontal tangle with no crossings at all.</p>
<p >In all cases, this is equivalent to calling the rational tangle constructor <a class="el" href="classregina_1_1Tangle.html" title="Represents a 2-tangle in the 3-ball.">Tangle</a>(<em>twists</em>, 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twists</td><td>the number of twists to perform; this may be positive, negative or zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08a5f998255d48ee62fdd3c53b04c162" name="a08a5f998255d48ee62fdd3c53b04c162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a5f998255d48ee62fdd3c53b04c162">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a rational tangle with the given parameters. </p>
<p >Here we use the following convention (following the description that Adams gives in <em>The Knot Book</em>):</p>
<ul>
<li>the zero tangle is horizontal with no crossings;</li>
<li>the infinity tangle is vertical with no crossings;</li>
<li>the +1 tangle is diagonal with one crossing, where the upper string runs from bottom-left to top-right.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given arguments are coprime.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>the numerator of the rational number that describes this tangle. </td></tr>
    <tr><td class="paramname">den</td><td>the denominator of the rational number that describes this tangle; this may be 0 (representing the infinity tangle). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe69c31e2d787bf47ccd21513d9f302" name="adbe69c31e2d787bf47ccd21513d9f302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe69c31e2d787bf47ccd21513d9f302">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>knot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a tangle from two parallel copies of the given knot. </p>
<p >Specifically, the tangle will consist of two parallel copies of the given knot diagram, which will be broken just before the starting strand as returned by <code>knot.component(0)</code>.</p>
<p >The two resulting endpoints that appear just before the starting strand will form the top-left and bottom-left endpoints of this tangle, and the endpoints on the other side of the break (which will be just after the parallel copies of the final strand <code>knot.component(0).prev()</code>) will form the top-right and bottom-right endpoints of this tangle.</p>
<p >The tangle will contain <code>4 * knot.size()</code> crossings in total.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument contains exactly one component (i.e., it is actually a knot, and not empty or a multiple-component link).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knot</td><td>the knot to break and duplicate to form this tangle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d96f9728fe44d1b8d0802d789e538c9" name="a9d96f9728fe44d1b8d0802d789e538c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d96f9728fe44d1b8d0802d789e538c9">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given tangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the tangle to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60c4fbd2039992eed58ba74be5b4aef8" name="a60c4fbd2039992eed58ba74be5b4aef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c4fbd2039992eed58ba74be5b4aef8">&#9670;&nbsp;</a></span>Tangle() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::Tangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given tangle into this new tangle. </p>
<p >This is a fast (constant time) operation.</p>
<p >All crossings that belong to <em>src</em> will be moved into this tangle, and so any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> object will remain valid. Likewise, all cached properties will be moved into this tangle.</p>
<p >The tangle that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tangle to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abda30f07f41d668822fb525b8253b8d0" name="abda30f07f41d668822fb525b8253b8d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda30f07f41d668822fb525b8253b8d0">&#9670;&nbsp;</a></span>~Tangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Tangle::~Tangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this tangle. </p>
<p >The <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> objects contained in this tangle will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a13c803002ef7a372a10340c644bc3f96" name="a13c803002ef7a372a10340c644bc3f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c803002ef7a372a10340c644bc3f96">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given tangle to the right-hand side of this tangle. </p>
<p >In Conway's notation, if this tangle is <em>t</em>, then this routine converts this into (<em>t</em> + <em>other</em>).</p>
<p >Specifically: this routine will attach the two right-hand endpoints of this tangle to the two left-hand endpoints of a copy of <em>other</em>.</p>
<p >This tangle will be changed directly. The tangle <em>other</em> (passed as the argumet) will be left unchanged.</p>
<p >It is allowed to pass this tangle as <em>other</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>It is not the case that both this and <em>other</em> are vertical tangles (which would cause the addition to create a closed link component).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tangle to add to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b27ae3e97e8ffb165914d67e235296" name="ac0b27ae3e97e8ffb165914d67e235296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b27ae3e97e8ffb165914d67e235296">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Tangle::begin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the crossing closest to the beginning of the given string. </p>
<p >Recall from the class notes that string 0 is always attached to the top-left endpoint. Recall also that strings are oriented from left-to-right for a horizontal or diagonal tangle, and from top-to-bottom for a vertical tangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>indicates which of the two strings in this tangle to query; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing closest to the beginning of the given string, or a null reference if the given string contains no crossings. </dd></dl>

</div>
</div>
<a id="a64f70fc6613c99a6647d1a229ec36804" name="a64f70fc6613c99a6647d1a229ec36804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f70fc6613c99a6647d1a229ec36804">&#9670;&nbsp;</a></span>box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::box </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>topLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>topRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>bottomLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>bottomRight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encloses this tangle with the four given tangles in a box configuration. </p>
<p >The five tangles will be connected as shown, with this tangle in the centre: </p><pre class="fragment"> \     /
  O---O
 / \ / \
 |  O  |
 \ / \ /
  O---O
 /     \
</pre><p >The top-left corner of the argument <em>topLeft</em> will become the top-left corner of the resulting tangle, and so on for the other three corners.</p>
<p >This tangle will be changed directly. The other four other tangles (passed as arguments) will be left unchanged.</p>
<p >You may use the same tangle for multiple arguments, and you may even use this tangle for one or more arguments.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Every string in all five tangles (the four arguments and this) has at least one crossing. </dd>
<dd>
None of the five tangles (the four arguments and this) have types that would result in a closed link component after this operation is performed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topLeft</td><td>the tangle to connect to the top-left corner of this. </td></tr>
    <tr><td class="paramname">topRight</td><td>the tangle to connect to the top-right corner of this. </td></tr>
    <tr><td class="paramname">bottomLeft</td><td>the tangle to connect to the bottom-left corner of this. </td></tr>
    <tr><td class="paramname">bottomRight</td><td>the tangle to connect to the bottom-right corner of this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5321327eaf8ad782b6b3e5b1d94442e8" name="a5321327eaf8ad782b6b3e5b1d94442e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5321327eaf8ad782b6b3e5b1d94442e8">&#9670;&nbsp;</a></span>brief() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Tangle::brief </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this tangle in Regina's own brief write-only format. </p>
<p >This format is concise, but contains enough information to manually reconstruct the complete tangle.</p>
<p >This format cannot (yet) be used to read tangles back into Regina, and so it is not good for external storage, or for passing tangles between different programs (or even different instances of Regina). It was originally designed for use with the test suite, where it was used to ensure that tangles with being created and/or manipulated correctly.</p>
<p >The output will contain the following elements, separated by single spaces:</p>
<ul>
<li>one of the symbols <code>-</code>, <code>|</code> or <code>x</code>, indicating that the tangle is of horizontal, vertical or diagonal type respectively (as described in the class notes);</li>
<li>a sequence of signs (<code>+</code> or <code>-</code>), concatenated together, giving the signs of the crossings in order from crossing 0 to crossing <a class="el" href="classregina_1_1Tangle.html#a3e255ebc40070d5c43f14fb3848f2827" title="Returns the number of crossings in this tangle.">size()</a>-1;</li>
<li>a description of string 0 and then string 1. Each string will be written in the form <code>( a b c ... )</code>, indicating the crossings that are encountered as we follow the string in the forward direction from its starting endpoint. Each element <em>a</em>, <em>b</em>, <em>c</em> and so on will be written in the format used by the <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> class: either <code>^n</code> when passing over crossing <em>n</em>, or <code>_n</code> when passing under crossing <em>n</em>.</li>
</ul>
<p >For example, the rational tangle 3/2 as returned by Tangle(3,2) will give the following brief output:</p>
<pre class="fragment">| --+ ( _0 ^1 ) ( ^2 _1 ^0 _2 )
</pre><p >As a special case, if the tangle contains no crossings then the output will contain just one space, not two consecutive spaces, between the type symbol and the string descriptions (since the sequence of crossing signs that would normally sit between them will be empty).</p>
<p >The string will not end in a newline.</p>
<p >There is also a variant of <a class="el" href="classregina_1_1Tangle.html#a5321327eaf8ad782b6b3e5b1d94442e8" title="Outputs this tangle in Regina&#39;s own brief write-only format.">brief()</a> that writes directly to an output stream.</p>
<dl class="section return"><dt>Returns</dt><dd>a description of this tangle in Regina's brief format. </dd></dl>

</div>
</div>
<a id="a74f7db6307c6b975a3cd43362385617f" name="a74f7db6307c6b975a3cd43362385617f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f7db6307c6b975a3cd43362385617f">&#9670;&nbsp;</a></span>brief() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::brief </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this tangle in Regina's own brief format to the given output stream. </p>
<p >See <a class="el" href="classregina_1_1Tangle.html#a5321327eaf8ad782b6b3e5b1d94442e8" title="Outputs this tangle in Regina&#39;s own brief write-only format.">brief()</a> for a full description of Regina's brief format, as well as its limitations.</p>
<p >The output from this routine is precisely the string that would be returned by <a class="el" href="classregina_1_1Tangle.html#a5321327eaf8ad782b6b3e5b1d94442e8" title="Outputs this tangle in Regina&#39;s own brief write-only format.">brief()</a>. In particular, the output does not contain any newlines.</p>
<p >See also <a class="el" href="classregina_1_1Tangle.html#a5321327eaf8ad782b6b3e5b1d94442e8" title="Outputs this tangle in Regina&#39;s own brief write-only format.">brief()</a>, which returns the brief format as a string.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Tangle.html#a5321327eaf8ad782b6b3e5b1d94442e8" title="Outputs this tangle in Regina&#39;s own brief write-only format.">brief()</a>, which takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0efe758c243da18417406ed5bff41ee8" name="a0efe758c243da18417406ed5bff41ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efe758c243da18417406ed5bff41ee8">&#9670;&nbsp;</a></span>changeAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::changeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the upper and lower strands of every crossing in the tangle. </p>
<p >This operation corresponds to reflecting the tangle through the plane on which the diagram is drawn. </p>

</div>
</div>
<a id="af1c92cf6b883589c87ef9ce24d36e318" name="af1c92cf6b883589c87ef9ce24d36e318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c92cf6b883589c87ef9ce24d36e318">&#9670;&nbsp;</a></span>crossing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::Tangle::crossing </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the crossing at the given index within this tangle. </p>
<p >For a tangle with <em>n</em> crossings, the crossings are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some crossings are added or removed then the indices of other crossings might change. If you wish to track a particular crossing through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested crossing. This must be between 0 and <a class="el" href="classregina_1_1Tangle.html#a3e255ebc40070d5c43f14fb3848f2827" title="Returns the number of crossings in this tangle.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing at the given index. </dd></dl>

</div>
</div>
<a id="a2d198583c5f812a6106955f8bfb3b6c7" name="a2d198583c5f812a6106955f8bfb3b6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d198583c5f812a6106955f8bfb3b6c7">&#9670;&nbsp;</a></span>crossings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::Tangle::crossings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all crossings within this tangle. </p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (Crossing* c : tangle.crossings()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the tangle exists: even as crossings are added and/or removed, it will always reflect the crossings that are currently in the tangle. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="classregina_1_1Tangle.html#a2d198583c5f812a6106955f8bfb3b6c7" title="Returns an object that allows iteration through and random access to all crossings within this tangle...">crossings()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all crossings. </dd></dl>

</div>
</div>
<a id="ad493a656c6f0b9a6a2ae2f06e151f10e" name="ad493a656c6f0b9a6a2ae2f06e151f10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad493a656c6f0b9a6a2ae2f06e151f10e">&#9670;&nbsp;</a></span>denClosure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Tangle::denClosure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the denominator closure of this tangle. </p>
<p >This is the link created by joining the two left endpoints of this tangle, and also joining the two right endpoints.</p>
<dl class="section return"><dt>Returns</dt><dd>the denominator closure of this tangle. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Tangle.html">Tangle</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a85986cfd37035eaaa0f49a1bd4abb459" name="a85986cfd37035eaaa0f49a1bd4abb459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85986cfd37035eaaa0f49a1bd4abb459">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Tangle::end </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the crossing closest to the end of the given string. </p>
<p >Recall from the class notes that string 0 is always attached to the top-left endpoint. Recall also that strings are oriented from left-to-right for a horizontal or diagonal tangle, and from top-to-bottom for a vertical tangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>indicates which of the two strings in this tangle to query; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the crossing closest to the end of the given string, or a null reference if the given string contains no crossings. </dd></dl>

</div>
</div>
<a id="a6d3287e0f6dc6017d9474c0089a4f27d" name="a6d3287e0f6dc6017d9474c0089a4f27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3287e0f6dc6017d9474c0089a4f27d">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a> regina::Tangle::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new tangle from an oriented Gauss code. </p>
<p >Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p >The format works as follows:</p>
<ul>
<li>Label the crossings arbitrarily as 1, 2, ..., <em>n</em>.</li>
<li>Write one of the tokens <code>-</code>, <code>|</code> or <code>x</code> to represent a horizontal, vertical or diagonal tangle respectively.</li>
<li>Start at the top-left endpoint and follow this string to its other endpoint. At every crossing that you pass, write a token of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code>, where:<ul>
<li>the symbol <code>+</code> indicates that you are passing over the crossing labelled <em>k</em>, and the symbol <code>-</code> indicates that you are passing under the crossing labelled <em>k</em>;</li>
<li>the symbol <code>&lt;</code> indicates that the other strand of the crossing passes from right to left, and <code>&gt;</code> indicates that the other strand passes from left to right;</li>
<li><em>k</em> is replaced with the integer crossing label.</li>
</ul>
</li>
<li>Write the token <code>_</code> to indicate that the first string has finished.</li>
<li>Start at the beginning of the other string (for horizontal or diagonal tangles, this is the bottom-left endpoint, and for vertical tangles this is the top-right endpoint). As before, follow this string to its other endpoint, writing a token of the form <code>+&lt;k</code>, <code>-&lt;k</code>, <code>+&gt;k</code> or <code>-&gt;k</code> at every crossing that you pass.</li>
</ul>
<p >Be aware that, once the tangle has been constructed, the crossings 1, ..., <em>n</em> will have been reindexed as 0, ..., <em>n</em>-1 (since every <a class="el" href="classregina_1_1Tangle.html" title="Represents a 2-tangle in the 3-ball.">Tangle</a> object numbers its crossings starting from 0).</p>
<p >As an example, you can construct the rational tangle -3/4 using the following code:</p>
<pre class="fragment">| -&lt;1 +&gt;2 -&lt;3 +&gt;4 _ -&lt;5 -&lt;4 +&gt;3 -&lt;2 +&gt;1 +&gt;5
</pre><p >There are two variants of this routine. This variant takes a single string, where the tokens have been combined together and separated by whitespace. The other variant takes a sequence of tokens, defined by a pair of iterators.</p>
<p >In this variant (the string variant), the given string may contain additional leading or trailing whitespace.</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for the viability of the diagram (i.e., whether the given crossings with the given signs actually produce a tangle of the given type with the correct endpoints). Of course non-viable inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The input was not a valid oriented Gauss code. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>an oriented Gauss code for a tangle, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting tangle. </dd></dl>

</div>
</div>
<a id="a363f89f8246a5dc2c13c9e91e68da0c4" name="a363f89f8246a5dc2c13c9e91e68da0c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363f89f8246a5dc2c13c9e91e68da0c4">&#9670;&nbsp;</a></span>fromOrientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Tangle.html">Tangle</a> regina::Tangle::fromOrientedGauss </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new tangle from an oriented Gauss code. </p>
<p >Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p >See <a class="el" href="classregina_1_1Tangle.html#a6d3287e0f6dc6017d9474c0089a4f27d" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a> for a detailed description of this format as it is used in Regina.</p>
<p >There are two variants of this routine. The other variant (<a class="el" href="classregina_1_1Tangle.html#a6d3287e0f6dc6017d9474c0089a4f27d" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which offers more detailed documentation) takes a single string, where the tokens have been combined together and separated by whitespace. This variant takes a sequence of tokens, defined by a pair of iterators.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>Iterator</em> is a random access iterator type.</dd>
<dd>
Dereferencing such an iterator produces either a C-style string (which can be cast to <code>const char*</code>) or a C++-style string (which can be cast to <code>const std::string&amp;</code>).</dd>
<dd>
The tokens in the input sequence do not contain any whitespace.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for the viability of the diagram (i.e., whether the given crossings with the given signs actually produce a tangle of the given type with the correct endpoints). Of course non-viable inputs are not allowed, and it is currently up to the user to enforce this.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The input did not describe a valid oriented Gauss code. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Instead of a pair of begin and past-the-end iterators, this routine takes a Python list of strings.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>an iterator that points to the beginning of the sequence of tokens for an oriented Gauss code. </td></tr>
    <tr><td class="paramname">end</td><td>an iterator that points past the end of the sequence of tokens for an oriented Gauss code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting tangle. </dd></dl>

</div>
</div>
<a id="af8d50a1e2852266c95d1e87618af48b5" name="af8d50a1e2852266c95d1e87618af48b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d50a1e2852266c95d1e87618af48b5">&#9670;&nbsp;</a></span>negate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reflects this tangle through the diagonal axis running from the top-left to bottom-right corners of the diagram. </p>
<p >In Conway's notation, this negates the tangle. </p>

</div>
</div>
<a id="a5f13efa433d0576171ebf403ebdb1ac1" name="a5f13efa433d0576171ebf403ebdb1ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f13efa433d0576171ebf403ebdb1ac1">&#9670;&nbsp;</a></span>numClosure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Link.html">Link</a> regina::Tangle::numClosure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forms the numerator closure of this tangle. </p>
<p >This is the link created by joining the two top endpoints of this tangle, and also joining the two bottom endpoints.</p>
<dl class="section return"><dt>Returns</dt><dd>the numerator closure of this tangle. </dd></dl>

</div>
</div>
<a id="a2ab6939724cbe76d9c08c2cc0b69e8cf" name="a2ab6939724cbe76d9c08c2cc0b69e8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab6939724cbe76d9c08c2cc0b69e8cf">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this tangle is not combinatorially identical to the given tangle. </p>
<p >Here "identical" means that:</p>
<ul>
<li>the tangles are of the same type and have the same number of crossings;</li>
<li>the same numbered crossings are positive and negative in both tangles;</li>
<li>the corresponding strings in each tangle pass through the same under/over-strands of the same numbered crossings in the same order.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tangle to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two tangles are not combinatorially identical. </dd></dl>

</div>
</div>
<a id="adac3c2ba2a0f117182fdb7f33208eb34" name="adac3c2ba2a0f117182fdb7f33208eb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac3c2ba2a0f117182fdb7f33208eb34">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp; regina::Tangle::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given tangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tangle to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tangle. </dd></dl>

</div>
</div>
<a id="aa2f4df563cc7c93559abae2b50e81d3d" name="aa2f4df563cc7c93559abae2b50e81d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f4df563cc7c93559abae2b50e81d3d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp; regina::Tangle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given tangle into this tangle. </p>
<p >This is a fast (constant time) operation.</p>
<p >All crossings that belong to <em>src</em> will be moved into this tangle, and so any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> object will remain valid. Likewise, all cached properties will be moved into this tangle.</p>
<p >The tangle that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the tangle to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this tangle. </dd></dl>

</div>
</div>
<a id="a76b5027743f9f21e8ca84e165f75609f" name="a76b5027743f9f21e8ca84e165f75609f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b5027743f9f21e8ca84e165f75609f">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this tangle is combinatorially identical to the given tangle. </p>
<p >Here "identical" means that:</p>
<ul>
<li>the tangles are of the same type and have the same number of crossings;</li>
<li>the same numbered crossings are positive and negative in both tangles;</li>
<li>the corresponding strings in each tangle pass through the same under/over-strands of the same numbered crossings in the same order.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tangle to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two tangles are combinatorially identical. </dd></dl>

</div>
</div>
<a id="a4901f74db4ad01ee8987de6b2e87191e" name="a4901f74db4ad01ee8987de6b2e87191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4901f74db4ad01ee8987de6b2e87191e">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Tangle::orientedGauss </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs an oriented Gauss code for this tangle. </p>
<p >Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p >For a full explanation of how oriented Gauss codes work for tangles, see the documentation for <a class="el" href="classregina_1_1Tangle.html#a6d3287e0f6dc6017d9474c0089a4f27d" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports tangles in this format.</p>
<p >The string that is returned will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of returning a string, writes directly to an output stream.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an oriented Gauss code for this tangle. </dd></dl>

</div>
</div>
<a id="a57ad9e44a76bac84d1e314a2f60a6fe8" name="a57ad9e44a76bac84d1e314a2f60a6fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ad9e44a76bac84d1e314a2f60a6fe8">&#9670;&nbsp;</a></span>orientedGauss() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::orientedGauss </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an oriented Gauss code for this tangle to the given output stream. </p>
<p >Oriented Gauss codes for tangles are an extension of oriented Gauss codes for knots. Whilst oriented Gauss codes for knots are used elsewhere (they are based on a format used by Andreeva et al.), these codes for tangles are specific to Regina (so you should not expect other software to understand them).</p>
<p >For a full explanation of how oriented Gauss codes work for tangles, see the documentation for <a class="el" href="classregina_1_1Tangle.html#a6d3287e0f6dc6017d9474c0089a4f27d" title="Creates a new tangle from an oriented Gauss code.">fromOrientedGauss(const std::string&amp;)</a>, which imports tangles in this format.</p>
<p >The output will not contain any newlines.</p>
<dl class="section note"><dt>Note</dt><dd>There is another variant of this routine that, instead of using an output stream, simply returns a string.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Tangle.html#a4901f74db4ad01ee8987de6b2e87191e" title="Outputs an oriented Gauss code for this tangle.">orientedGauss()</a>, which takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75456efb18f88399f5e800fb52c3d70d" name="a75456efb18f88399f5e800fb52c3d70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75456efb18f88399f5e800fb52c3d70d">&#9670;&nbsp;</a></span>r1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::r1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type I Reidemeister move to remove a crossing. </p>
<p >Unlike links, which implement the full suite of Reidemeister moves, tangles (at present) only offer the simplifying versions of Reidemeister moves I and II.</p>
<p >The behaviour of this routine is identical to the <a class="el" href="classregina_1_1Tangle.html#a75456efb18f88399f5e800fb52c3d70d" title="Tests for and/or performs a type I Reidemeister move to remove a crossing.">r1()</a> routine in the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> class; see <a class="el" href="classregina_1_1Link.html#a23a70af4f63bbd4f7dea13a04a3b984a" title="Tests for and/or performs a type I Reidemeister move to remove a crossing.">Link::r1()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this tangle.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing to be removed. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move can be performed at the given location. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the move can be performed. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="aaa71c2b2601ab277179d44e8f62176d8" name="aaa71c2b2601ab277179d44e8f62176d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa71c2b2601ab277179d44e8f62176d8">&#9670;&nbsp;</a></span>r2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p >Unlike links, which implement the full suite of Reidemeister moves, tangles (at present) only offer the simplifying versions of Reidemeister moves I and II.</p>
<p >The behaviour of this routine is identical to the <a class="el" href="classregina_1_1Tangle.html#af80f087595912ee502a37bf2c7980c33" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">r2()</a> routine in the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> class; see <a class="el" href="classregina_1_1Link.html#afaf3e0d6eaa504eba071e3950a939028" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">Link::r2()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given crossing is either a null pointer, or else some crossing in this tangle.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>identifies the crossing at the beginning of the "upper" arc that features in this move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="af80f087595912ee502a37bf2c7980c33" name="af80f087595912ee502a37bf2c7980c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80f087595912ee502a37bf2c7980c33">&#9670;&nbsp;</a></span>r2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::r2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a>&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests for and/or performs a type II Reidemeister move to remove two crossings. </p>
<p >Unlike links, which implement the full suite of Reidemeister moves, tangles (at present) only offer the simplifying versions of Reidemeister moves I and II.</p>
<p >The behaviour of this routine is identical to the <a class="el" href="classregina_1_1Tangle.html#af80f087595912ee502a37bf2c7980c33" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">r2()</a> routine in the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> class; see <a class="el" href="classregina_1_1Link.html#afaf3e0d6eaa504eba071e3950a939028" title="Tests for and/or performs a type II Reidemeister move to remove two crossings.">Link::r2()</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>perform</em> is <code>true</code> but <em>check</em> is <code>false</code>, then it must be known in advance that this move can be performed at the given location. </dd>
<dd>
The given strand reference is either a null reference, or else refers to some strand of some crossing in this tangle.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arc</td><td>identifies one of the arcs of the bigon about which the move will be performed. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is legal. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we should actually perform the move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move is legal. If <em>check</em> is <code>false</code>, this function always returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="aa82854b84b334083c2dd8ccd5e23ee41" name="aa82854b84b334083c2dd8ccd5e23ee41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82854b84b334083c2dd8ccd5e23ee41">&#9670;&nbsp;</a></span>simplifyToLocalMinimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Tangle::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses type I and II Reidemeister moves to reduce the tangle monotonically to some local minimum number of crossings. </p>
<p >Type III Reidemeister moves (which do not reduce the number of crossings) are not used in this routine.</p>
<p >Unlike links, tangle do not (at present) offer stronger simplification routines (such as the much better <a class="el" href="classregina_1_1Link.html#a5fc961ba707da75f2b71d3585c994cc9" title="Attempts to simplify the link diagram using fast and greedy heuristics.">Link::intelligentSimplify()</a> and <a class="el" href="classregina_1_1Link.html#a60fe044c436e5e1a8861de2ccb106e1c" title="Attempts to simplify this knot diagram using a slow but exhaustive search through the Reidemeister gr...">Link::simplifyExhaustive()</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this routine (and therefore its results) may change between different releases of Regina.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the link was changed to reduce the number of crossings; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a id="a3e255ebc40070d5c43f14fb3848f2827" name="a3e255ebc40070d5c43f14fb3848f2827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e255ebc40070d5c43f14fb3848f2827">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Tangle::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of crossings in this tangle. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of crossings. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Tangle.html">Tangle</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a24c6083e947dadaf9ef981cd203bb44e" name="a24c6083e947dadaf9ef981cd203bb44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c6083e947dadaf9ef981cd203bb44e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Tangle.html">Tangle</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given tangle. </p>
<p >All crossings that belong to this tangle will be moved to <em>other</em>, and all crossings that belong to <em>other</em> will be moved to this tangle. Likewise, all cached properties will be swapped.</p>
<p >In particular, any <a class="el" href="classregina_1_1Crossing.html" title="Represents a single crossing in a link diagram.">Crossing</a> pointers or references and any <a class="el" href="classregina_1_1StrandRef.html" title="A reference to one of the two strands of a link that pass each other at a crossing.">StrandRef</a> objects will remain valid.</p>
<p >This routine will behave correctly if <em>other</em> is in fact this tangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the tangle whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a013419d2ffd00eb93d85b4aaae713209" name="a013419d2ffd00eb93d85b4aaae713209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013419d2ffd00eb93d85b4aaae713209">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> regina::Tangle::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1StrandRef.html">StrandRef</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a strand reference from some other tangle into the corresponding strand reference from this tangle. </p>
<p >Typically this routine would be used when the given strand comes from a tangle that is combinatorially identical to this, and you wish to obtain the corresponding strand in this tangle.</p>
<p >Specifically: if <em>other</em> refers to some strand (upper or lower) of crossing number <em>k</em> of some other tangle, then the return value will refer to the same strand (upper or lower) of crossing number <em>k</em> of this tangle.</p>
<p >This routine behaves correctly even if <em>other</em> is a null reference.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This tangle contains at least as many crossings as the tangle containing <em>other</em> (though, as noted above, in typical scenarios both tangles would actually be combinatorially identical).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the strand reference to translate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding strand reference for this tangle. </dd></dl>

</div>
</div>
<a id="abfe8878a670f2cea6734f336cb9d563f" name="abfe8878a670f2cea6734f336cb9d563f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe8878a670f2cea6734f336cb9d563f">&#9670;&nbsp;</a></span>turn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::turn </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates this tangle by 90 degrees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>either 1 if the tangle should be rotated clockwise, or -1 if the tangle should be rotated anticlockwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bf4a4fa65f6b91f929833f55fb2c06f" name="a1bf4a4fa65f6b91f929833f55fb2c06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf4a4fa65f6b91f929833f55fb2c06f">&#9670;&nbsp;</a></span>twist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::twist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a twist to the right-hand end of this tangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sign</td><td>either 1 if we should perform a positive twist (dragging the bottom-right endpoint up over the top-right endpoint), or -1 if we should perform a negative twist (dragging the bottom-right endpoint up beneath the top-right endpoint). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab88015bcdf131873362ba1da8e26507c" name="ab88015bcdf131873362ba1da8e26507c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88015bcdf131873362ba1da8e26507c">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::Tangle::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of this tangle. </p>
<p >This will be one of the characters <code>-</code>, <code>|</code> or <code>x</code>, indicating a horizontal, vertical or diagonal type as described in the class notes.</p>
<dl class="section return"><dt>Returns</dt><dd>the type of this crossing. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Tangle.html">Tangle</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="afafb3ede468c74cd0a7280f8a5d0fcc2" name="afafb3ede468c74cd0a7280f8a5d0fcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafb3ede468c74cd0a7280f8a5d0fcc2">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this tangle to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc9da0489723b099bd15bf729a401933" name="afc9da0489723b099bd15bf729a401933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9da0489723b099bd15bf729a401933">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Tangle::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this tangle to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="tangle_8h.html">tangle.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
