<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::Layering Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Layering.html">Layering</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1Layering-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::Layering Class Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a layering of zero or more tetrahedra upon a torus boundary.  
 <a href="classregina_1_1Layering.html#details">More...</a></p>

<p><code>#include &lt;subcomplex/layering.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Layering:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Layering.png" usemap="#regina::Layering_map" alt=""/>
  <map id="regina::Layering_map" name="regina::Layering_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; Layering &gt;" shape="rect" coords="0,56,201,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Layering, false &gt;" shape="rect" coords="0,0,201,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a198e9d31e654da2d3718543436b095ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a198e9d31e654da2d3718543436b095ef">Layering</a> (const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *bdry0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; roles0, const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *bdry1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; roles1)</td></tr>
<tr class="memdesc:a198e9d31e654da2d3718543436b095ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial (zero-tetrahedron) layering upon the given boundary.  <a href="classregina_1_1Layering.html#a198e9d31e654da2d3718543436b095ef">More...</a><br /></td></tr>
<tr class="separator:a198e9d31e654da2d3718543436b095ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c518ac0e5617f623eb95fd3adcbbd36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a2c518ac0e5617f623eb95fd3adcbbd36">operator==</a> (const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;other) const</td></tr>
<tr class="memdesc:a2c518ac0e5617f623eb95fd3adcbbd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object represent the same layering.  <a href="classregina_1_1Layering.html#a2c518ac0e5617f623eb95fd3adcbbd36">More...</a><br /></td></tr>
<tr class="separator:a2c518ac0e5617f623eb95fd3adcbbd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ba939259738ad8b2e723e31081aaff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#aa0ba939259738ad8b2e723e31081aaff">operator!=</a> (const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;other) const</td></tr>
<tr class="memdesc:aa0ba939259738ad8b2e723e31081aaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object represent different layerings.  <a href="classregina_1_1Layering.html#aa0ba939259738ad8b2e723e31081aaff">More...</a><br /></td></tr>
<tr class="separator:aa0ba939259738ad8b2e723e31081aaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89050071e8e127a2158839ebc92e26bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a89050071e8e127a2158839ebc92e26bc">Layering</a> (const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;)=default</td></tr>
<tr class="memdesc:a89050071e8e127a2158839ebc92e26bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given layering structure.  <a href="classregina_1_1Layering.html#a89050071e8e127a2158839ebc92e26bc">More...</a><br /></td></tr>
<tr class="separator:a89050071e8e127a2158839ebc92e26bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141e5f9230b3c8f56ba055f2ba3591a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a141e5f9230b3c8f56ba055f2ba3591a2">operator=</a> (const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;)=default</td></tr>
<tr class="memdesc:a141e5f9230b3c8f56ba055f2ba3591a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given layering structure.  <a href="classregina_1_1Layering.html#a141e5f9230b3c8f56ba055f2ba3591a2">More...</a><br /></td></tr>
<tr class="separator:a141e5f9230b3c8f56ba055f2ba3591a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4217f6e46d0713d1af3b26ba6970c14"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#ac4217f6e46d0713d1af3b26ba6970c14">size</a> () const</td></tr>
<tr class="memdesc:ac4217f6e46d0713d1af3b26ba6970c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of individual tetrahedra that have been layered onto the original boundary, according to the data stored in this structure.  <a href="classregina_1_1Layering.html#ac4217f6e46d0713d1af3b26ba6970c14">More...</a><br /></td></tr>
<tr class="separator:ac4217f6e46d0713d1af3b26ba6970c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773898d6782958c71208a0f5d992c4d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a773898d6782958c71208a0f5d992c4d8">oldBoundaryTet</a> (unsigned which) const</td></tr>
<tr class="memdesc:a773898d6782958c71208a0f5d992c4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tetrahedra that provide the old boundary triangles.  <a href="classregina_1_1Layering.html#a773898d6782958c71208a0f5d992c4d8">More...</a><br /></td></tr>
<tr class="separator:a773898d6782958c71208a0f5d992c4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df4641fc7b186beed57c6d94a31675a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a5df4641fc7b186beed57c6d94a31675a">oldBoundaryRoles</a> (unsigned which) const</td></tr>
<tr class="memdesc:a5df4641fc7b186beed57c6d94a31675a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permutations that describe the old boundary triangles.  <a href="classregina_1_1Layering.html#a5df4641fc7b186beed57c6d94a31675a">More...</a><br /></td></tr>
<tr class="separator:a5df4641fc7b186beed57c6d94a31675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d80436014cded4542f591cf3f6cd6d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a4d80436014cded4542f591cf3f6cd6d7">newBoundaryTet</a> (unsigned which) const</td></tr>
<tr class="memdesc:a4d80436014cded4542f591cf3f6cd6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tetrahedra that provide the new boundary triangles.  <a href="classregina_1_1Layering.html#a4d80436014cded4542f591cf3f6cd6d7">More...</a><br /></td></tr>
<tr class="separator:a4d80436014cded4542f591cf3f6cd6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d707028b14c22101af674b7c599dd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#ac4d707028b14c22101af674b7c599dd9">newBoundaryRoles</a> (unsigned which) const</td></tr>
<tr class="memdesc:ac4d707028b14c22101af674b7c599dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the permutations that describe the new boundary triangles.  <a href="classregina_1_1Layering.html#ac4d707028b14c22101af674b7c599dd9">More...</a><br /></td></tr>
<tr class="separator:ac4d707028b14c22101af674b7c599dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf0c3a388a6b8ed9320553a4660c151"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#aedf0c3a388a6b8ed9320553a4660c151">boundaryReln</a> () const</td></tr>
<tr class="memdesc:aedf0c3a388a6b8ed9320553a4660c151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 2-by-2 matrix describing the relationship between curves on the old and new boundary tori.  <a href="classregina_1_1Layering.html#aedf0c3a388a6b8ed9320553a4660c151">More...</a><br /></td></tr>
<tr class="separator:aedf0c3a388a6b8ed9320553a4660c151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a97df250ac597168260389eb2c6edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a45a97df250ac597168260389eb2c6edc">extendOne</a> ()</td></tr>
<tr class="memdesc:a45a97df250ac597168260389eb2c6edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines whether a single additional tetrahedron has been layered upon the current new boundary.  <a href="classregina_1_1Layering.html#a45a97df250ac597168260389eb2c6edc">More...</a><br /></td></tr>
<tr class="separator:a45a97df250ac597168260389eb2c6edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48e1aabed68a1a39cd69a5c016533d9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#aa48e1aabed68a1a39cd69a5c016533d9">extend</a> ()</td></tr>
<tr class="memdesc:aa48e1aabed68a1a39cd69a5c016533d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines whether one or more additional tetrahedra have been layered upon the current new boundary.  <a href="classregina_1_1Layering.html#aa48e1aabed68a1a39cd69a5c016533d9">More...</a><br /></td></tr>
<tr class="separator:aa48e1aabed68a1a39cd69a5c016533d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7328b75a836997e86684848530ac5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#a1d7328b75a836997e86684848530ac5a">matchesTop</a> (const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *upperBdry0, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; upperRoles0, const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *upperBdry1, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; upperRoles1, <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;upperReln) const</td></tr>
<tr class="memdesc:a1d7328b75a836997e86684848530ac5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the new torus boundary of this structure is identified with the given torus boundary.  <a href="classregina_1_1Layering.html#a1d7328b75a836997e86684848530ac5a">More...</a><br /></td></tr>
<tr class="separator:a1d7328b75a836997e86684848530ac5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f87b670c82774f044bbca20ee2bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Layering.html#ae66f87b670c82774f044bbca20ee2bf4">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ae66f87b670c82774f044bbca20ee2bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1Layering.html#ae66f87b670c82774f044bbca20ee2bf4">More...</a><br /></td></tr>
<tr class="separator:ae66f87b670c82774f044bbca20ee2bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a layering of zero or more tetrahedra upon a torus boundary. </p>
<p >A <em>layering</em> involves laying a new tetrahedron flat upon two adjacent boundary triangles in order to change the boundary curves. Many tetrahedra may be layered upon a boundary in succession in order to change the boundary curves more dramatically.</p>
<p >A torus boundary is specified by two tetrahedra (which may be the same) and two permutations. Each permutation maps (0,1,2) in the diagram below to the corresponding vertex numbers in each tetrahedron (and therefore maps 3 to the corresponding face number).</p>
<pre>
    *---&gt;&gt;--*
    |0  2 / |
    |    / 1|
    v   /   v
    |1 /    |
    | / 2  0|
    *---&gt;&gt;--*
</pre><p >In particular, if the two tetrahedra are <em>t0</em> and <em>t1</em> and the two corresponding permutations are <em>p0</em> and <em>p1</em>, then:</p><ul>
<li>the torus boundary is formed from faces <em>p0</em>[3] and <em>p1</em>[3] of tetrahedra <em>t0</em> and <em>t1</em> respectively;</li>
<li>edges <em>p0</em>[0]-<em>p0</em>[1] and <em>p1</em>[1]-<em>p1</em>[0] of tetrahedra <em>t0</em> and <em>t1</em> respectively are identified;</li>
<li>edges <em>p0</em>[1]-<em>p0</em>[2] and <em>p1</em>[2]-<em>p1</em>[1] of tetrahedra <em>t0</em> and <em>t1</em> respectively are identified;</li>
<li>edges <em>p0</em>[2]-<em>p0</em>[0] and <em>p1</em>[0]-<em>p1</em>[2] of tetrahedra <em>t0</em> and <em>t1</em> respectively are identified.</li>
</ul>
<p >Note that we do not actually require these triangular faces to form a torus, and this is never verifed by any of the routines in this class. What these routines do is use the diagram above to define the rules of what forms a valid layering (and in fact the layering itself will often be the cause of these edge identifications). This allows the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class a little more versatility in degenerate and boundary cases.</p>
<p >This class keeps track of an <em>old</em> boundary, which is the original pair of triangles upon which the first tetrahedron is layered, and a <em>new</em> boundary, which is formed by the last layered tetrahedron and contains the modified boundary curves. If no tetrahedra are layered at all then the old and new boundaries will be identical.</p>
<p >This class is used to search for layerings as follows. The constructor is called with a particular pair of triangles that will form the old boundary (note that these are generally <em>not</em> boundary triangles in the triangulation, since we are searching for layerings that have been placed upon them). This forms a trivial (zero-tetrahedron) layering. The routines <a class="el" href="classregina_1_1Layering.html#aa48e1aabed68a1a39cd69a5c016533d9" title="Examines whether one or more additional tetrahedra have been layered upon the current new boundary.">extend()</a> or <a class="el" href="classregina_1_1Layering.html#a45a97df250ac597168260389eb2c6edc" title="Examines whether a single additional tetrahedron has been layered upon the current new boundary.">extendOne()</a> are then called to see how many additional tetrahedra have been layered upon this pair of triangles according to the rules above.</p>
<p >These objects are small enough to pass by value and swap with <a class="el" href="group__algebra.html#ga3d2f68e8a75ce7b663269c104346f937" title="Swaps the contents of the two given abelian groups.">std::swap()</a>, with no need for any specialised move operations or swap functions. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a198e9d31e654da2d3718543436b095ef" name="a198e9d31e654da2d3718543436b095ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a198e9d31e654da2d3718543436b095ef">&#9670;&nbsp;</a></span>Layering() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Layering::Layering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>bdry0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>roles0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>bdry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>roles1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new trivial (zero-tetrahedron) layering upon the given boundary. </p>
<p >The boundary is described by two tetrahedra and two permutations as explained in the class notes. Note that the given tetrahedra need not be boundary triangles in the triangulation (and if search routines such as <a class="el" href="classregina_1_1Layering.html#aa48e1aabed68a1a39cd69a5c016533d9" title="Examines whether one or more additional tetrahedra have been layered upon the current new boundary.">extend()</a> are called then they almost certainly should not be).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bdry0</td><td>the tetrahedron providing the first triangle of the boundary. </td></tr>
    <tr><td class="paramname">roles0</td><td>the permutation describing how this first triangle is formed from three vertices of tetrahedron <em>bdry0</em>, as described in the class notes. </td></tr>
    <tr><td class="paramname">bdry1</td><td>the tetrahedron providing the second triangle of the boundary. </td></tr>
    <tr><td class="paramname">roles1</td><td>the permutation describing how this second triangle is formed from three vertices of tetrahedron <em>bdry1</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89050071e8e127a2158839ebc92e26bc" name="a89050071e8e127a2158839ebc92e26bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89050071e8e127a2158839ebc92e26bc">&#9670;&nbsp;</a></span>Layering() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Layering::Layering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given layering structure. </p>
<p >The new structure will describe the same layering within the same underlying triangulation. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aedf0c3a388a6b8ed9320553a4660c151" name="aedf0c3a388a6b8ed9320553a4660c151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf0c3a388a6b8ed9320553a4660c151">&#9670;&nbsp;</a></span>boundaryReln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::Layering::boundaryReln </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a 2-by-2 matrix describing the relationship between curves on the old and new boundary tori. </p>
<p >Note that this relationship will often be non-trivial, since one of the key reasons for layering is to modify boundary curves.</p>
<p >Let <em>t</em> and <em>p</em> be the first tetrahedron and permutation of the old boundary (as returned by oldBoundaryTet(0) and oldBoundaryRoles(0)), and let <em>old_x</em> and <em>old_y</em> be the directed edges <em>p</em>[0]-<em>p</em>[1] and <em>p</em>[0]-<em>p</em>[2] respectively of tetrahedron <em>t</em> (these are the leftmost and uppermost edges of the diagram below). Likewise, let <em>s</em> and <em>q</em> be the first tetrahedron and permutation of the new boundary (as returned by newBoundaryTet(0) and newBoundaryRoles(0)), and let <em>new_x</em> and <em>new_y</em> be the directed edges <em>q</em>[0]-<em>q</em>[1] and <em>q</em>[0]-<em>q</em>[2] respectively of tetrahedron <em>s</em>.</p>
<pre>
    *---&gt;&gt;--*
    |0  2 / |
    |    / 1|
    v   /   v
    |1 /    |
    | / 2  0|
    *---&gt;&gt;--*
</pre><p >Assuming both boundaries are tori, edges <em>old_x</em> and <em>old_y</em> are generators of the old boundary torus and edges <em>new_x</em> and <em>new_y</em> are generators of the new boundary torus. Suppose that this routine returns the matrix <em>M</em>. This signifies that, using additive notation:</p>
<pre>
    [new_x]         [old_x]
    [     ]  =  M * [     ] .
    [new_y]         [old_y]
</pre><p >In other words, the matrix that is returned expresses the generator curves of the new boundary in terms of the generator curves of the old boundary.</p>
<p >Note that the determinant of this matrix will always be 1.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix relating the old and new boundary curves. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Layering.html">Layering</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="aa48e1aabed68a1a39cd69a5c016533d9" name="aa48e1aabed68a1a39cd69a5c016533d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48e1aabed68a1a39cd69a5c016533d9">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::Layering::extend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines whether one or more additional tetrahedra have been layered upon the current new boundary. </p>
<p >Specifically, this routine calls <a class="el" href="classregina_1_1Layering.html#a45a97df250ac597168260389eb2c6edc" title="Examines whether a single additional tetrahedron has been layered upon the current new boundary.">extendOne()</a> as many times as possible. If <em>k</em> additional layerings are discovered as a result, the size of this structure will have grown by <em>k</em> and the new boundary will be changed to describe the remaining two faces of the <em>kth</em> layered tetrahedron.</p>
<p >It is guaranteed that, once this routine is finished, the new boundary will not have any additional tetrahedron layered upon it. That is, if <a class="el" href="classregina_1_1Layering.html#a45a97df250ac597168260389eb2c6edc" title="Examines whether a single additional tetrahedron has been layered upon the current new boundary.">extendOne()</a> were called again then it would return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of additional layered tetrahedra that were discovered. </dd></dl>

</div>
</div>
<a id="a45a97df250ac597168260389eb2c6edc" name="a45a97df250ac597168260389eb2c6edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a97df250ac597168260389eb2c6edc">&#9670;&nbsp;</a></span>extendOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Layering::extendOne </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines whether a single additional tetrahedron has been layered upon the current new boundary. </p>
<p >The new boundary triangles are assumed to form a torus as described in the class notes (this is not verified, and there are degenerate cases where this will likely be false). This defines three possible ways in which an additional tetrahedron may be layered (over the three boundary edges respectively).</p>
<p >If it is found that an additional tetrahedron does exist and has been joined to the new boundary in one of these three possible ways, this structure is extended to incorporate the additional tetrahedron. The size will grow by one, and the new boundary will become the remaining two faces of this additional tetrahedron.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a tetrahedron was found as described above and this structure was extended accordingly, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1d7328b75a836997e86684848530ac5a" name="a1d7328b75a836997e86684848530ac5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7328b75a836997e86684848530ac5a">&#9670;&nbsp;</a></span>matchesTop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Layering::matchesTop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>upperBdry0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>upperRoles0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>upperBdry1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>upperRoles1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td>
          <td class="paramname"><em>upperReln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the new torus boundary of this structure is identified with the given torus boundary. </p>
<p >In other words, this routine determines whether the new torus boundary of this structure and the given torus boundary represent opposite sides of the same two triangles.</p>
<p >The two boundaries must be identified according to some homeomorphism of the torus. Note that there are 12 different ways in which this can be done (two choices for which tetrahedron face joins with which, and then six possible rotations and reflections).</p>
<p >As with the other routines in this class, this routine does not verify that either boundary in fact forms a torus. Instead, it uses this assumption to define the rules of what identifications are allowable.</p>
<p >If there is a match, the given matrix <em>upperReln</em> will be modified to describe how the edges of the given boundary relate to the edges of the old boundary torus. Note that this relationship depends on how the intermediate tetrahedra are layered (and in fact the purpose of a layering is often to produce such a non-trivial relationship).</p>
<p >Specifically, let <em>t0</em> and <em>p0</em> be the first tetrahedron and permutation of the old boundary (as returned by oldBoundaryTet(0) and oldBoundaryRoles(0)), and let <em>x</em> and <em>y</em> be the directed edges <em>p0</em>[0]-<em>p0</em>[1] and <em>p0</em>[0]-<em>p0</em>[2] of tetrahedron <em>t0</em> respectively (these are the leftmost and uppermost edges of the diagram below). Likewise, let <em>u</em> and <em>q</em> be the first tetrahedron and permutation of the given boundary (as passed by parameters <em>upperBdry0</em> and <em>upperRoles0</em>), and let <em>a</em> and <em>b</em> be the directed edges <em>q</em>[0]-<em>q</em>[1] and <em>q</em>[0]-<em>q</em>[2] of tetrahedron <em>u</em> respectively.</p>
<pre>
    *---&gt;&gt;--*
    |0  2 / |
    |    / 1|
    v   /   v
    |1 /    |
    | / 2  0|
    *---&gt;&gt;--*
</pre><p >Assuming both boundaries are tori, edges <em>x</em> and <em>y</em> are generators of the original torus boundary and edges <em>a</em> and <em>b</em> are generators of the given torus boundary. Using additive notation, the matrix <em>upperReln</em> is modified so that</p>
<pre>
    [a]                 [x]
    [ ]  =  upperReln * [ ] .
    [b]                 [y]
</pre><p >In other words, the modified <em>upperReln</em> matrix expresses the generator curves of the given boundary in terms of the generator curves of the old boundary.</p>
<p >If no match is found, the matrix <em>upperReln</em> is not touched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperBdry0</td><td>the tetrahedron providing the first triangle of the given boundary. </td></tr>
    <tr><td class="paramname">upperRoles0</td><td>the permutation describing how this first triangle is formed from three vertices of tetrahedron upperBdry0, as described in the class notes. </td></tr>
    <tr><td class="paramname">upperBdry1</td><td>the tetrahedron providing the second triangle of the given boundary. </td></tr>
    <tr><td class="paramname">upperRoles1</td><td>the permutation describing how this second triangle is formed from three vertices of tetrahedron upperBdry1. </td></tr>
    <tr><td class="paramname">upperReln</td><td>the matrix that is changed to reflect the relationship between the old boundary of this structure and the given boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given boundary is found to matche the new boundary of this structure, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ac4d707028b14c22101af674b7c599dd9" name="ac4d707028b14c22101af674b7c599dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d707028b14c22101af674b7c599dd9">&#9670;&nbsp;</a></span>newBoundaryRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::Layering::newBoundaryRoles </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the permutations that describe the new boundary triangles. </p>
<p >These refer to the final boundary after layerings have been performed.</p>
<p >See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which permutation to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested permutation describing the new boundary. </dd></dl>

</div>
</div>
<a id="a4d80436014cded4542f591cf3f6cd6d7" name="a4d80436014cded4542f591cf3f6cd6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d80436014cded4542f591cf3f6cd6d7">&#9670;&nbsp;</a></span>newBoundaryTet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::Layering::newBoundaryTet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tetrahedra that provide the new boundary triangles. </p>
<p >These belong to the final boundary after layerings have been performed.</p>
<p >See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which tetrahedron to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron of the new boundary. </dd></dl>

</div>
</div>
<a id="a5df4641fc7b186beed57c6d94a31675a" name="a5df4641fc7b186beed57c6d94a31675a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df4641fc7b186beed57c6d94a31675a">&#9670;&nbsp;</a></span>oldBoundaryRoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; regina::Layering::oldBoundaryRoles </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the permutations that describe the old boundary triangles. </p>
<p >These refer to the original boundary before any layerings take place.</p>
<p >See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which permutation to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested permutation describing the old boundary. </dd></dl>

</div>
</div>
<a id="a773898d6782958c71208a0f5d992c4d8" name="a773898d6782958c71208a0f5d992c4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773898d6782958c71208a0f5d992c4d8">&#9670;&nbsp;</a></span>oldBoundaryTet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 3 &gt; * regina::Layering::oldBoundaryTet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tetrahedra that provide the old boundary triangles. </p>
<p >These belong to the original boundary before any layerings take place.</p>
<p >See the <a class="el" href="classregina_1_1Layering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">Layering</a> class notes for details on how a torus boundary is formed from two tetrahedra and two permutations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>specifies which tetrahedron to return; this must be either 0 or 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested tetrahedron of the old boundary. </dd></dl>

</div>
</div>
<a id="aa0ba939259738ad8b2e723e31081aaff" name="aa0ba939259738ad8b2e723e31081aaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ba939259738ad8b2e723e31081aaff">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Layering::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object represent different layerings. </p>
<p >Specifically, for two layerings to compare as equal, they must:</p>
<ul>
<li>use the same numbered tetrahedra in the old boundary, presented in the same order and using the same two permutations;</li>
<li>likewise use the same numbered tetrahedra in the new boundary, presented in the same order and using the same two permutations;</li>
<li>contain the same number of layered tetrahedra, and use the same matrix relating the old and new boundary curves.</li>
</ul>
<p >Since this test looks at tetrahedron numbers and not the specific Tetrahedron objects, it is meaningful to compare layerings within different triangulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the layering to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object represent different layerings, as described above. </dd></dl>

</div>
</div>
<a id="a141e5f9230b3c8f56ba055f2ba3591a2" name="a141e5f9230b3c8f56ba055f2ba3591a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141e5f9230b3c8f56ba055f2ba3591a2">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Layering.html">Layering</a> &amp; regina::Layering::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given layering structure. </p>
<p >The copied structure will describe the same layering within the same underlying triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this structure. </dd></dl>

</div>
</div>
<a id="a2c518ac0e5617f623eb95fd3adcbbd36" name="a2c518ac0e5617f623eb95fd3adcbbd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c518ac0e5617f623eb95fd3adcbbd36">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Layering::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Layering.html">Layering</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object represent the same layering. </p>
<p >Specifically, for two layerings to compare as equal, they must:</p>
<ul>
<li>use the same numbered tetrahedra in the old boundary, presented in the same order and using the same two permutations;</li>
<li>likewise use the same numbered tetrahedra in the new boundary, presented in the same order and using the same two permutations;</li>
<li>contain the same number of layered tetrahedra, and use the same matrix relating the old and new boundary curves.</li>
</ul>
<p >Since this test looks at tetrahedron numbers and not the specific Tetrahedron objects, it is meaningful to compare layerings within different triangulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the layering to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object represent the same layering, as described above. </dd></dl>

</div>
</div>
<a id="ac4217f6e46d0713d1af3b26ba6970c14" name="ac4217f6e46d0713d1af3b26ba6970c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4217f6e46d0713d1af3b26ba6970c14">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::Layering::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of individual tetrahedra that have been layered onto the original boundary, according to the data stored in this structure. </p>
<p >This begins at zero when the class constructor is called, and it increases if the routines <a class="el" href="classregina_1_1Layering.html#aa48e1aabed68a1a39cd69a5c016533d9" title="Examines whether one or more additional tetrahedra have been layered upon the current new boundary.">extend()</a> or <a class="el" href="classregina_1_1Layering.html#a45a97df250ac597168260389eb2c6edc" title="Examines whether a single additional tetrahedron has been layered upon the current new boundary.">extendOne()</a> find that additional layerings have taken place.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of layered tetrahedra. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Layering.html">Layering</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Layering.html">Layering</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1Layering.html">Layering</a> , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae66f87b670c82774f044bbca20ee2bf4" name="ae66f87b670c82774f044bbca20ee2bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66f87b670c82774f044bbca20ee2bf4">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Layering::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="layering_8h.html">layering.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
