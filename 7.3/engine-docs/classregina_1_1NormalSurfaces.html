<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::NormalSurfaces Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1NormalSurfaces-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::NormalSurfaces Class Reference<div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A collection of normal surfaces in a 3-manifold triangulation.  
 <a href="classregina_1_1NormalSurfaces.html#details">More...</a></p>

<p><code>#include &lt;surface/normalsurfaces.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalSurfaces:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalSurfaces.png" usemap="#regina::NormalSurfaces_map" alt=""/>
  <map id="regina::NormalSurfaces_map" name="regina::NormalSurfaces_map">
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; NormalSurfaces &gt;" shape="rect" coords="0,0,233,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NormalSurfaces &gt;" shape="rect" coords="243,0,476,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional iterator that runs through the raw vectors for surfaces in this list.  <a href="classregina_1_1NormalSurfaces_1_1VectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a37c95fbe02bbb1d5973d01cce79f48d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a37c95fbe02bbb1d5973d01cce79f48d9">NormalSurfaces</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="classregina_1_1NormalSurfaces.html#acb106a4b9f159f7a19374268f842ebfa">triangulation</a>, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">coords</a>, <a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">which</a>=<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">NS_LIST_DEFAULT</a>, <a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a> algHints=<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">NS_ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a37c95fbe02bbb1d5973d01cce79f48d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unified "enumeration constructor" for enumerating various classes of normal surfaces within a given triangulation.  <a href="classregina_1_1NormalSurfaces.html#a37c95fbe02bbb1d5973d01cce79f48d9">More...</a><br /></td></tr>
<tr class="separator:a37c95fbe02bbb1d5973d01cce79f48d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3564e4c3bcb3ebc377a3f56655dd0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a2b3564e4c3bcb3ebc377a3f56655dd0c">NormalSurfaces</a> (const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;src, <a class="el" href="group__surfaces.html#gaf3bddca5e5ddf81edfe8b2db4ba133df">NormalTransform</a> transform)</td></tr>
<tr class="memdesc:a2b3564e4c3bcb3ebc377a3f56655dd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unified "transform constructor" for transforming one normal surface list into another.  <a href="classregina_1_1NormalSurfaces.html#a2b3564e4c3bcb3ebc377a3f56655dd0c">More...</a><br /></td></tr>
<tr class="separator:a2b3564e4c3bcb3ebc377a3f56655dd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac780793e0e54c8acb81e8aca981e9137"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ac780793e0e54c8acb81e8aca981e9137">NormalSurfaces</a> (const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;src, const <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> &amp;filter)</td></tr>
<tr class="memdesc:ac780793e0e54c8acb81e8aca981e9137"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "filter constructor" that creates a new list filled with those surfaces from the given list that pass the given filter.  <a href="classregina_1_1NormalSurfaces.html#ac780793e0e54c8acb81e8aca981e9137">More...</a><br /></td></tr>
<tr class="separator:ac780793e0e54c8acb81e8aca981e9137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df59adcf4427e9f7e3939e6a3a85ba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a8df59adcf4427e9f7e3939e6a3a85ba8">NormalSurfaces</a> (const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;)=default</td></tr>
<tr class="memdesc:a8df59adcf4427e9f7e3939e6a3a85ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given list.  <a href="classregina_1_1NormalSurfaces.html#a8df59adcf4427e9f7e3939e6a3a85ba8">More...</a><br /></td></tr>
<tr class="separator:a8df59adcf4427e9f7e3939e6a3a85ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13c7bf85a1067da09c953e224dfda0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a9b13c7bf85a1067da09c953e224dfda0">NormalSurfaces</a> (<a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:a9b13c7bf85a1067da09c953e224dfda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given list into this new list.  <a href="classregina_1_1NormalSurfaces.html#a9b13c7bf85a1067da09c953e224dfda0">More...</a><br /></td></tr>
<tr class="separator:a9b13c7bf85a1067da09c953e224dfda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb59cc46169bc2f3e89bcff49d04bb21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#acb59cc46169bc2f3e89bcff49d04bb21">operator=</a> (const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;src)</td></tr>
<tr class="memdesc:acb59cc46169bc2f3e89bcff49d04bb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given list.  <a href="classregina_1_1NormalSurfaces.html#acb59cc46169bc2f3e89bcff49d04bb21">More...</a><br /></td></tr>
<tr class="separator:acb59cc46169bc2f3e89bcff49d04bb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6473f075f3bd6800cfd3ccff3e777a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a6473f075f3bd6800cfd3ccff3e777a90">operator=</a> (<a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a6473f075f3bd6800cfd3ccff3e777a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given list into this list.  <a href="classregina_1_1NormalSurfaces.html#a6473f075f3bd6800cfd3ccff3e777a90">More...</a><br /></td></tr>
<tr class="separator:a6473f075f3bd6800cfd3ccff3e777a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6ad6281b288ede6f558ed36fb44541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a6a6ad6281b288ede6f558ed36fb44541">swap</a> (<a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;other)</td></tr>
<tr class="memdesc:a6a6ad6281b288ede6f558ed36fb44541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given list.  <a href="classregina_1_1NormalSurfaces.html#a6a6ad6281b288ede6f558ed36fb44541">More...</a><br /></td></tr>
<tr class="separator:a6a6ad6281b288ede6f558ed36fb44541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada70246d67b766fd35a224bd561ee071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">coords</a> () const</td></tr>
<tr class="memdesc:ada70246d67b766fd35a224bd561ee071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate system that was originally used to enumerate the surfaces in this list.  <a href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">More...</a><br /></td></tr>
<tr class="separator:ada70246d67b766fd35a224bd561ee071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a12326b8c6dfebfefe97b34b15920c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">which</a> () const</td></tr>
<tr class="memdesc:a2a12326b8c6dfebfefe97b34b15920c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of which normal surfaces this list represents within the underlying triangulation.  <a href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">More...</a><br /></td></tr>
<tr class="separator:a2a12326b8c6dfebfefe97b34b15920c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb828ac80eb4538f156dfd63b4c30f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a9fb828ac80eb4538f156dfd63b4c30f9">algorithm</a> () const</td></tr>
<tr class="memdesc:a9fb828ac80eb4538f156dfd63b4c30f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the algorithm that was used to enumerate this list.  <a href="classregina_1_1NormalSurfaces.html#a9fb828ac80eb4538f156dfd63b4c30f9">More...</a><br /></td></tr>
<tr class="separator:a9fb828ac80eb4538f156dfd63b4c30f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286441732edb4692736f33e769489dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a286441732edb4692736f33e769489dde">allowsAlmostNormal</a> () const</td></tr>
<tr class="memdesc:a286441732edb4692736f33e769489dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system that was used for enumeration allows for almost normal surfaces.  <a href="classregina_1_1NormalSurfaces.html#a286441732edb4692736f33e769489dde">More...</a><br /></td></tr>
<tr class="separator:a286441732edb4692736f33e769489dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a60d2807fc3c298ccd1dcbf29ceb13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ae9a60d2807fc3c298ccd1dcbf29ceb13">allowsNonCompact</a> () const</td></tr>
<tr class="memdesc:ae9a60d2807fc3c298ccd1dcbf29ceb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system that was used for enumeration allows for non-compact normal surfaces.  <a href="classregina_1_1NormalSurfaces.html#ae9a60d2807fc3c298ccd1dcbf29ceb13">More...</a><br /></td></tr>
<tr class="separator:ae9a60d2807fc3c298ccd1dcbf29ceb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4235db32ccba3f9f49e8b668afb8ad85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a4235db32ccba3f9f49e8b668afb8ad85">isEmbeddedOnly</a> () const</td></tr>
<tr class="memdesc:a4235db32ccba3f9f49e8b668afb8ad85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this list was constructed to contain only properly embedded surfaces.  <a href="classregina_1_1NormalSurfaces.html#a4235db32ccba3f9f49e8b668afb8ad85">More...</a><br /></td></tr>
<tr class="separator:a4235db32ccba3f9f49e8b668afb8ad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb106a4b9f159f7a19374268f842ebfa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#acb106a4b9f159f7a19374268f842ebfa">triangulation</a> () const</td></tr>
<tr class="memdesc:acb106a4b9f159f7a19374268f842ebfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation in which these normal surfaces live.  <a href="classregina_1_1NormalSurfaces.html#acb106a4b9f159f7a19374268f842ebfa">More...</a><br /></td></tr>
<tr class="separator:acb106a4b9f159f7a19374268f842ebfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aae88a4f82d88e1ed542f17d26904d7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a0aae88a4f82d88e1ed542f17d26904d7">size</a> () const</td></tr>
<tr class="memdesc:a0aae88a4f82d88e1ed542f17d26904d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surfaces stored in this list.  <a href="classregina_1_1NormalSurfaces.html#a0aae88a4f82d88e1ed542f17d26904d7">More...</a><br /></td></tr>
<tr class="separator:a0aae88a4f82d88e1ed542f17d26904d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75daf757568e280e406899878914efd7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a75daf757568e280e406899878914efd7">surface</a> (size_t index) const</td></tr>
<tr class="memdesc:a75daf757568e280e406899878914efd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the surface at the requested index in this list.  <a href="classregina_1_1NormalSurfaces.html#a75daf757568e280e406899878914efd7">More...</a><br /></td></tr>
<tr class="separator:a75daf757568e280e406899878914efd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256d4d7d0b76ebbb17fafa751fb5a128"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a256d4d7d0b76ebbb17fafa751fb5a128">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:a256d4d7d0b76ebbb17fafa751fb5a128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the surface at the requested index in this list.  <a href="classregina_1_1NormalSurfaces.html#a256d4d7d0b76ebbb17fafa751fb5a128">More...</a><br /></td></tr>
<tr class="separator:a256d4d7d0b76ebbb17fafa751fb5a128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4179f56ed9853ce214463eb9f03ad5b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ac4179f56ed9853ce214463eb9f03ad5b">begin</a> () const</td></tr>
<tr class="memdesc:ac4179f56ed9853ce214463eb9f03ad5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator at the beginning of this list of surfaces.  <a href="classregina_1_1NormalSurfaces.html#ac4179f56ed9853ce214463eb9f03ad5b">More...</a><br /></td></tr>
<tr class="separator:ac4179f56ed9853ce214463eb9f03ad5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d6ef0f85fc4ab299f6872c5d6057ab"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ad7d6ef0f85fc4ab299f6872c5d6057ab">end</a> () const</td></tr>
<tr class="memdesc:ad7d6ef0f85fc4ab299f6872c5d6057ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator beyond the end of this list of surfaces.  <a href="classregina_1_1NormalSurfaces.html#ad7d6ef0f85fc4ab299f6872c5d6057ab">More...</a><br /></td></tr>
<tr class="separator:ad7d6ef0f85fc4ab299f6872c5d6057ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649527e1b7cfd78c210c4e1484be9e7a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a649527e1b7cfd78c210c4e1484be9e7a">__iter__</a> () const</td></tr>
<tr class="memdesc:a649527e1b7cfd78c210c4e1484be9e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterator over the normal surfaces in this list.  <a href="classregina_1_1NormalSurfaces.html#a649527e1b7cfd78c210c4e1484be9e7a">More...</a><br /></td></tr>
<tr class="separator:a649527e1b7cfd78c210c4e1484be9e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d11cefcc63d004a2a5bedb35684fc57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a3d11cefcc63d004a2a5bedb35684fc57">operator==</a> (const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;other) const</td></tr>
<tr class="memdesc:a3d11cefcc63d004a2a5bedb35684fc57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given list contain the same set of normal (or almost normal) surfaces.  <a href="classregina_1_1NormalSurfaces.html#a3d11cefcc63d004a2a5bedb35684fc57">More...</a><br /></td></tr>
<tr class="separator:a3d11cefcc63d004a2a5bedb35684fc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1362c5187ce205e0d2408eaaca2512ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a1362c5187ce205e0d2408eaaca2512ed">operator!=</a> (const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;other) const</td></tr>
<tr class="memdesc:a1362c5187ce205e0d2408eaaca2512ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given list contain different sets of normal (or almost normal) surfaces.  <a href="classregina_1_1NormalSurfaces.html#a1362c5187ce205e0d2408eaaca2512ed">More...</a><br /></td></tr>
<tr class="separator:a1362c5187ce205e0d2408eaaca2512ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b997db79cdf5367c91660c6ccfe46ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a8b997db79cdf5367c91660c6ccfe46ec">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a8b997db79cdf5367c91660c6ccfe46ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1NormalSurfaces.html#a8b997db79cdf5367c91660c6ccfe46ec">More...</a><br /></td></tr>
<tr class="separator:a8b997db79cdf5367c91660c6ccfe46ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b7e0e3dccfde815a4e9448142f574a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a83b7e0e3dccfde815a4e9448142f574a">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a83b7e0e3dccfde815a4e9448142f574a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1NormalSurfaces.html#a83b7e0e3dccfde815a4e9448142f574a">More...</a><br /></td></tr>
<tr class="separator:a83b7e0e3dccfde815a4e9448142f574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2995d136dc8e575605230cec31dd8c9"><td class="memTemplParams" colspan="2">template&lt;typename Comparison &gt; </td></tr>
<tr class="memitem:ae2995d136dc8e575605230cec31dd8c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ae2995d136dc8e575605230cec31dd8c9">sort</a> (Comparison &amp;&amp;comp)</td></tr>
<tr class="memdesc:ae2995d136dc8e575605230cec31dd8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the surfaces in this list according to the given criterion.  <a href="classregina_1_1NormalSurfaces.html#ae2995d136dc8e575605230cec31dd8c9">More...</a><br /></td></tr>
<tr class="separator:ae2995d136dc8e575605230cec31dd8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e9769e0bb95a10eee0b33c2014192a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ad2e9769e0bb95a10eee0b33c2014192a">recreateMatchingEquations</a> () const</td></tr>
<tr class="memdesc:ad2e9769e0bb95a10eee0b33c2014192a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matching equations that were used to create this normal surface list.  <a href="classregina_1_1NormalSurfaces.html#ad2e9769e0bb95a10eee0b33c2014192a">More...</a><br /></td></tr>
<tr class="separator:ad2e9769e0bb95a10eee0b33c2014192a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600b934ddaecf2d70c8c21d9e9928b13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a600b934ddaecf2d70c8c21d9e9928b13">saveCSVStandard</a> (const char *filename, <a class="el" href="group__surfaces.html#ga23ec276a567978da57ae4f459188806d">SurfaceExport</a> additionalFields=<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a>) const</td></tr>
<tr class="memdesc:a600b934ddaecf2d70c8c21d9e9928b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this list of normal surfaces as a plain text CSV (comma-separated value) file, using standard coordinates.  <a href="classregina_1_1NormalSurfaces.html#a600b934ddaecf2d70c8c21d9e9928b13">More...</a><br /></td></tr>
<tr class="separator:a600b934ddaecf2d70c8c21d9e9928b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f63303236ca57cb6f382f43fd1f12c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a8f63303236ca57cb6f382f43fd1f12c8">saveCSVEdgeWeight</a> (const char *filename, <a class="el" href="group__surfaces.html#ga23ec276a567978da57ae4f459188806d">SurfaceExport</a> additionalFields=<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a>) const</td></tr>
<tr class="memdesc:a8f63303236ca57cb6f382f43fd1f12c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file, using edge weight coordinates.  <a href="classregina_1_1NormalSurfaces.html#a8f63303236ca57cb6f382f43fd1f12c8">More...</a><br /></td></tr>
<tr class="separator:a8f63303236ca57cb6f382f43fd1f12c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8da79103f921bee2f52e6fdb39eb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#adb8da79103f921bee2f52e6fdb39eb2e">beginVectors</a> () const</td></tr>
<tr class="memdesc:adb8da79103f921bee2f52e6fdb39eb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ iterator that gives access to the raw vectors for surfaces in this list, pointing to the beginning of this surface list.  <a href="classregina_1_1NormalSurfaces.html#adb8da79103f921bee2f52e6fdb39eb2e">More...</a><br /></td></tr>
<tr class="separator:adb8da79103f921bee2f52e6fdb39eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268c1848908924fc19644b83309beeba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a268c1848908924fc19644b83309beeba">endVectors</a> () const</td></tr>
<tr class="memdesc:a268c1848908924fc19644b83309beeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ iterator that gives access to the raw vectors for surfaces in this list, pointing past the end of this surface list.  <a href="classregina_1_1NormalSurfaces.html#a268c1848908924fc19644b83309beeba">More...</a><br /></td></tr>
<tr class="separator:a268c1848908924fc19644b83309beeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ecdf4b4f06571143478ac881e47b04"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a13ecdf4b4f06571143478ac881e47b04">vectors</a> () const</td></tr>
<tr class="memdesc:a13ecdf4b4f06571143478ac881e47b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterable object that iterates over the raw vectors for all surfaces in this list.  <a href="classregina_1_1NormalSurfaces.html#a13ecdf4b4f06571143478ac881e47b04">More...</a><br /></td></tr>
<tr class="separator:a13ecdf4b4f06571143478ac881e47b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">More...</a><br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">More...</a><br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <a href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">More...</a><br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a795d05a3c08961475285b54083ac256e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a795d05a3c08961475285b54083ac256e">NormalSurfaces</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">coords</a>, <a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">which</a>, <a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a9fb828ac80eb4538f156dfd63b4c30f9">algorithm</a>, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;<a class="el" href="classregina_1_1NormalSurfaces.html#acb106a4b9f159f7a19374268f842ebfa">triangulation</a>)</td></tr>
<tr class="memdesc:a795d05a3c08961475285b54083ac256e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty list of normal surfaces with the given parameters.  <a href="classregina_1_1NormalSurfaces.html#a795d05a3c08961475285b54083ac256e">More...</a><br /></td></tr>
<tr class="separator:a795d05a3c08961475285b54083ac256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac269e3e8eb91f5c247c54b17f1d71b1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ac269e3e8eb91f5c247c54b17f1d71b1b">NormalSurfaces</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">coords</a>, <a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">which</a>, <a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a9fb828ac80eb4538f156dfd63b4c30f9">algorithm</a>, const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;<a class="el" href="classregina_1_1NormalSurfaces.html#acb106a4b9f159f7a19374268f842ebfa">triangulation</a>)</td></tr>
<tr class="memdesc:ac269e3e8eb91f5c247c54b17f1d71b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty list of normal surfaces with the given parameters.  <a href="classregina_1_1NormalSurfaces.html#ac269e3e8eb91f5c247c54b17f1d71b1b">More...</a><br /></td></tr>
<tr class="separator:ac269e3e8eb91f5c247c54b17f1d71b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adf1bc60b71d27b89ef71891342d0f9f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#adf1bc60b71d27b89ef71891342d0f9f0">surfaces_</a></td></tr>
<tr class="memdesc:adf1bc60b71d27b89ef71891342d0f9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all normal surfaces in this list.  <a href="classregina_1_1NormalSurfaces.html#adf1bc60b71d27b89ef71891342d0f9f0">More...</a><br /></td></tr>
<tr class="separator:adf1bc60b71d27b89ef71891342d0f9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c477a99e3a7058acf7a15c9aba847f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a63c477a99e3a7058acf7a15c9aba847f">triangulation_</a></td></tr>
<tr class="memdesc:a63c477a99e3a7058acf7a15c9aba847f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which these normal surfaces lie.  <a href="classregina_1_1NormalSurfaces.html#a63c477a99e3a7058acf7a15c9aba847f">More...</a><br /></td></tr>
<tr class="separator:a63c477a99e3a7058acf7a15c9aba847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317370303ab0e90b1367b33d57a92e83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a317370303ab0e90b1367b33d57a92e83">coords_</a></td></tr>
<tr class="memdesc:a317370303ab0e90b1367b33d57a92e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate system that was originally used to enumerate the normal surfaces in this list.  <a href="classregina_1_1NormalSurfaces.html#a317370303ab0e90b1367b33d57a92e83">More...</a><br /></td></tr>
<tr class="separator:a317370303ab0e90b1367b33d57a92e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffe4301bf296b37ea8253f242167660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a6ffe4301bf296b37ea8253f242167660">which_</a></td></tr>
<tr class="memdesc:a6ffe4301bf296b37ea8253f242167660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normal surfaces these represent within the underlying triangulation.  <a href="classregina_1_1NormalSurfaces.html#a6ffe4301bf296b37ea8253f242167660">More...</a><br /></td></tr>
<tr class="separator:a6ffe4301bf296b37ea8253f242167660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e72355f8511a648f728fc452ba850a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#aa0e72355f8511a648f728fc452ba850a">algorithm_</a></td></tr>
<tr class="memdesc:aa0e72355f8511a648f728fc452ba850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the details of the enumeration algorithm that was used to generate this list.  <a href="classregina_1_1NormalSurfaces.html#aa0e72355f8511a648f728fc452ba850a">More...</a><br /></td></tr>
<tr class="separator:aa0e72355f8511a648f728fc452ba850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <a href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">More...</a><br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab9b961cf5afa19151031bc345822f39e"><td class="memItemLeft" align="right" valign="top"><a id="ab9b961cf5afa19151031bc345822f39e" name="ab9b961cf5afa19151031bc345822f39e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLNormalSurfacesReader</b></td></tr>
<tr class="separator:ab9b961cf5afa19151031bc345822f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c316a1615fe3d502df8db06cd703e35"><td class="memItemLeft" align="right" valign="top"><a id="a0c316a1615fe3d502df8db06cd703e35" name="a0c316a1615fe3d502df8db06cd703e35"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLegacyNormalSurfacesReader</b></td></tr>
<tr class="separator:a0c316a1615fe3d502df8db06cd703e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cc5bfc1d308c61f5f78a789cce1a35"><td class="memItemLeft" align="right" valign="top"><a id="a78cc5bfc1d308c61f5f78a789cce1a35" name="a78cc5bfc1d308c61f5f78a789cce1a35"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLWriter&lt; NormalSurfaces &gt;</b></td></tr>
<tr class="separator:a78cc5bfc1d308c61f5f78a789cce1a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A collection of normal surfaces in a 3-manifold triangulation. </p>
<p >There are some important changes to this class as of Regina 7.0:</p>
<ul>
<li>A normal surface list does <em>not</em> need to be a child packet of the underlying triangulation, and indeed does not need to interact with the packet tree at all.</li>
<li>You are welcome to modify or even destroy the original triangulation; if you do then this list will automatically make a private copy of the original triangulation as an ongoing reference. Different normal surface lists (and angle structure lists) can all share the same private copy, so this is not an expensive process.</li>
<li>You should now create normal surface lists using the class constructor (but which, unlike the old enumerate(), does not insert the list into the packet tree). There is no need to use enumerate() any more.</li>
</ul>
<p >Since Regina 7.0, this is no longer a "packet type" that can be inserted directly into the packet tree. Instead a normal surface list is now a standalone mathematatical object, which makes it slimmer and faster for ad-hoc use. The consequences of this are:</p>
<ul>
<li>If you create your own <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> object, it will not have any of the usual packet infrastructure. You cannot add it into the packet tree, and it will not support a label, tags, child/parent packets, and/or event listeners.</li>
<li>To include an <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> object in the packet tree, you must create a new PacketOf&lt;NormalSurfaces&gt;. This <em>is</em> a packet type, and supports labels, tags, child/parent packets, and event listeners. It derives from <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a>, and so inherits the full <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> interface.</li>
<li>If you are adding new functions to this class that edit the list, you must still remember to create a ChangeEventSpan. This will ensure that, if the list is being managed by a PacketOf&lt;NormalSurfaces&gt;, then the appropriate packet change events will be fired. All other events (aside from packetToBeChanged() and packetWasChanged() are managed directly by the PacketOf&lt;NormalSurfaces&gt; wrapper class.</li>
</ul>
<p >See the <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> class notes for details of what to do when introducing a new coordinate system.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd><p class="startdd"><em>Feature:</em> Allow custom matching equations. </p>
<p class="interdd"><em>Feature:</em> Allow enumeration with some coordinates explicitly set to zero. </p>
<p class="interdd"><em>Feature:</em> Allow generating only closed surfaces. </p>
<p class="enddd"><em>Feature:</em> Generate facets of the solution space representing embedded surfaces.</p>
</dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a37c95fbe02bbb1d5973d01cce79f48d9" name="a37c95fbe02bbb1d5973d01cce79f48d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c95fbe02bbb1d5973d01cce79f48d9">&#9670;&nbsp;</a></span>NormalSurfaces() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a>&#160;</td>
          <td class="paramname"><em>which</em> = <code><a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">NS_LIST_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a>&#160;</td>
          <td class="paramname"><em>algHints</em> = <code><a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">NS_ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unified "enumeration constructor" for enumerating various classes of normal surfaces within a given triangulation. </p>
<p >The NormalCoords argument allows you to specify an underlying coordinate system in which to do the enumeration (e.g., standard coordinates, quadrilateral coordinates or almost normal coordinates). This choice of coordinate system will affect which surfaces are produced, since vertex/fundamental surfaces in one system are not necessarily vertex/fundamental in another.</p>
<p >The NormalList argument is a combination of flags that allows you to specify exactly which normal surfaces you require. This includes (i) whether you want all vertex surfaces or all fundamental surfaces, which defaults to NS_VERTEX if you specify neither or both; and (ii) whether you want only properly embedded surfaces or you also wish to include immersed and/or singular surfaces, which defaults to NS_EMBEDDED_ONLY if you specify neither or both.</p>
<p >The NormalAlg argument is a combination of flags that allows you to control the underlying enumeration algorithm. These flags are treated as hints only: if your selection of algorithm is invalid, unavailable or unsupported then Regina will choose something more appropriate. Unless you have some specialised need, the default NS_ALG_DEFAULT (which makes no hints at all) will allow Regina to choose what it thinks will be the most efficient method.</p>
<p >The enumerated surfaces will be stored in this new normal surface list, and their representations will be scaled down to use the smallest possible integer coordinates.</p>
<p >Unlike the old enumerate() function, the new normal surface list will <em>not</em> be inserted into the packet tree. Moreover, the given triangulation may change or even be destroyed without causing problems. See the class notes for details.</p>
<p >If a progress tracker is passed, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p >This constructor will not return until the enumeration of surfaces is complete, regardless of whether a progress tracker was passed. If you need the behaviour of the old enumerate() (where passing a progress tracker caused the enumeration to start in the background), simply call this constructor in a new detached thread. Note that this enumeration can be extremely slow for larger triangulations, and so there could be good reasons to do this.</p>
<p >If an error occurs, then this routine will thrown an exception. In this case, no normal surface list will be created, and the progress tracker (if passed) will be marked as finished. See the exception specifications below for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The matching equations could not be created for the given triangulation in the given coordinate system, due to an error that should have been preventable with the right checks in advance. This can only happen in certain coordinate systems, and for all such coordinate systems this is explicitly described in the NormalCoords enum documentation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The list of hypersurfaces could not be be created for the given triangulation in the given coordinate system, due to an error that was "genuinely" unforseeable. Currently there are two scenarios in which this could happen: (i) the matching equations could not be constructed, which can only happen in certain coordinate systems where this is explicitly described in the NormalCoords enum documentation; or (ii) the arguments require enumerating <em>fundamental</em> normal surfaces using the primal Hilbert basis algorithm, and Normaliz was unable to complete its portion of the task, which in theory should never happen at all.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this constructor runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which this list of normal surfaces will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. This must be one of the system that Regina is able to use for enumeration; this is documented alongside each NormalCoords enum value. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal surfaces should be enumerated. </td></tr>
    <tr><td class="paramname">algHints</td><td>passes requests to Regina for which specific enumeration algorithm should be used. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b3564e4c3bcb3ebc377a3f56655dd0c" name="a2b3564e4c3bcb3ebc377a3f56655dd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3564e4c3bcb3ebc377a3f56655dd0c">&#9670;&nbsp;</a></span>NormalSurfaces() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#gaf3bddca5e5ddf81edfe8b2db4ba133df">NormalTransform</a>&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A unified "transform constructor" for transforming one normal surface list into another. </p>
<p >The available transformations include:</p>
<ul>
<li>conversions between vertex surfaces in different coordinate systems (e.g., between the set of all standard vertex surfaces and the typically smaller set of all quad vertex surfaces);</li>
<li>filters that select a subset of surfaces (e.g., only surfaces that have a locally compatible or disjoint partner, or only surfaces that could potentially be incompressible).</li>
</ul>
<p >Each transformation comes with its own set of preconditions, as documented alongside the various NormalTransform enumeration constants. These preconditions will be checked, and if any of them fails then this constructor will throw an exception (see below).</p>
<p >Unlike the old conversion and filter functions, this constructor will <em>not</em> insert the new normal surface list into the packet tree.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>The preconditions for the given transformation were not met. See each NormalTransform enum constant for the corresponding set of preconditions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the normal surface list that we wish to transform; this will not be modified. </td></tr>
    <tr><td class="paramname">transform</td><td>the specific transformation to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac780793e0e54c8acb81e8aca981e9137" name="ac780793e0e54c8acb81e8aca981e9137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac780793e0e54c8acb81e8aca981e9137">&#9670;&nbsp;</a></span>NormalSurfaces() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "filter constructor" that creates a new list filled with those surfaces from the given list that pass the given filter. </p>
<p >Unlike the old filter() function, this constructor will <em>not</em> insert the new normal surface list into the packet tree.</p>
<p >For this new filtered list, <a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7" title="Returns details of which normal surfaces this list represents within the underlying triangulation.">which()</a> will include the NS_CUSTOM flag, and <a class="el" href="classregina_1_1NormalSurfaces.html#a9fb828ac80eb4538f156dfd63b4c30f9" title="Returns details of the algorithm that was used to enumerate this list.">algorithm()</a> will include the NS_ALG_CUSTOM flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the normal surface list that we wish to filter; this will not be modified. </td></tr>
    <tr><td class="paramname">filter</td><td>the filter to apply to the given list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8df59adcf4427e9f7e3939e6a3a85ba8" name="a8df59adcf4427e9f7e3939e6a3a85ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df59adcf4427e9f7e3939e6a3a85ba8">&#9670;&nbsp;</a></span>NormalSurfaces() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given list. </p>

</div>
</div>
<a id="a9b13c7bf85a1067da09c953e224dfda0" name="a9b13c7bf85a1067da09c953e224dfda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b13c7bf85a1067da09c953e224dfda0">&#9670;&nbsp;</a></span>NormalSurfaces() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given list into this new list. </p>
<p >This is a fast (constant time) operation.</p>
<p >The list that is passed will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this list is freshly constructed (and therefore has no listeners yet), and because we assume that <em>src</em> is about to be destroyed (an action that <em>will</em> fire a packet destruction event).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a795d05a3c08961475285b54083ac256e" name="a795d05a3c08961475285b54083ac256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795d05a3c08961475285b54083ac256e">&#9670;&nbsp;</a></span>NormalSurfaces() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty list of normal surfaces with the given parameters. </p>

</div>
</div>
<a id="ac269e3e8eb91f5c247c54b17f1d71b1b" name="ac269e3e8eb91f5c247c54b17f1d71b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac269e3e8eb91f5c247c54b17f1d71b1b">&#9670;&nbsp;</a></span>NormalSurfaces() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty list of normal surfaces with the given parameters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a649527e1b7cfd78c210c4e1484be9e7a" name="a649527e1b7cfd78c210c4e1484be9e7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649527e1b7cfd78c210c4e1484be9e7a">&#9670;&nbsp;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalSurfaces::__iter__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterator over the normal surfaces in this list. </p>
<p >In Python, a normal surface list can be treated as an iterable object:</p>
<div class="fragment"><div class="line">list = NormalSurfaces(...)</div>
<div class="line"><span class="keywordflow">for</span> s <span class="keywordflow">in</span> list:</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> provides the usual <a class="el" href="classregina_1_1NormalSurfaces.html#ac4179f56ed9853ce214463eb9f03ad5b" title="Returns a C++ iterator at the beginning of this list of surfaces.">begin()</a> and <a class="el" href="classregina_1_1NormalSurfaces.html#ad7d6ef0f85fc4ab299f6872c5d6057ab" title="Returns a C++ iterator beyond the end of this list of surfaces.">end()</a> functions instead. In particular, you can iterate over the normal surfaces in this list in the usual way using a range-based <code>for</code> loop.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the normal surfaces in this list. </dd></dl>

</div>
</div>
<a id="a9fb828ac80eb4538f156dfd63b4c30f9" name="a9fb828ac80eb4538f156dfd63b4c30f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb828ac80eb4538f156dfd63b4c30f9">&#9670;&nbsp;</a></span>algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a> regina::NormalSurfaces::algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of the algorithm that was used to enumerate this list. </p>
<p >These may not be the same NormalAlg flags that were passed to the class constructor. In particular, default values will have been explicitly filled in, invalid and/or redundant values will have been removed, and unavailable and/or unsupported combinations of algorithm flags will be replaced with whatever algorithm was actually used.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the algorithm used to enumerate this list. </dd></dl>

</div>
</div>
<a id="a286441732edb4692736f33e769489dde" name="a286441732edb4692736f33e769489dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286441732edb4692736f33e769489dde">&#9670;&nbsp;</a></span>allowsAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the coordinate system that was used for enumeration allows for almost normal surfaces. </p>
<p >This does not test whether any of the surfaces in this list actually contain octagons: it simply returns a basic property of the coordinate system that was used for enumeration.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are supported. </dd></dl>

</div>
</div>
<a id="ae9a60d2807fc3c298ccd1dcbf29ceb13" name="ae9a60d2807fc3c298ccd1dcbf29ceb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a60d2807fc3c298ccd1dcbf29ceb13">&#9670;&nbsp;</a></span>allowsNonCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsNonCompact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the coordinate system that was used for enumeration allows for non-compact normal surfaces. </p>
<p >This does not test whether any of the surfaces in this list are actually non-compact: it simply returns a basic property of the coordinate system that was used for enumeration.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if non-compact normal surfaces are supported. </dd></dl>

</div>
</div>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&nbsp;</a></span>anonID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>  &gt;::anonID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p >This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p >The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p >These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="ac4179f56ed9853ce214463eb9f03ad5b" name="ac4179f56ed9853ce214463eb9f03ad5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4179f56ed9853ce214463eb9f03ad5b">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalSurfaces::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator at the beginning of this list of surfaces. </p>
<p >These <a class="el" href="classregina_1_1NormalSurfaces.html#ac4179f56ed9853ce214463eb9f03ad5b" title="Returns a C++ iterator at the beginning of this list of surfaces.">begin()</a> and <a class="el" href="classregina_1_1NormalSurfaces.html#ad7d6ef0f85fc4ab299f6872c5d6057ab" title="Returns a C++ iterator beyond the end of this list of surfaces.">end()</a> functions allow you to iterate through all surfaces in this list using a range-based <code>for</code> loop:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="classregina_1_1NormalSurfaces.html#a37c95fbe02bbb1d5973d01cce79f48d9">NormalSurfaces</a> list(...);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> NormalSurface&amp; s : list) { ... }</div>
<div class="ttc" id="aclassregina_1_1NormalSurfaces_html_a37c95fbe02bbb1d5973d01cce79f48d9"><div class="ttname"><a href="classregina_1_1NormalSurfaces.html#a37c95fbe02bbb1d5973d01cce79f48d9">regina::NormalSurfaces::NormalSurfaces</a></div><div class="ttdeci">NormalSurfaces(const Triangulation&lt; 3 &gt; &amp;triangulation, NormalCoords coords, NormalList which=NS_LIST_DEFAULT, NormalAlg algHints=NS_ALG_DEFAULT, ProgressTracker *tracker=nullptr)</div><div class="ttdoc">A unified &quot;enumeration constructor&quot; for enumerating various classes of normal surfaces within a given...</div><div class="ttdef"><b>Definition:</b> normalsurfaces.h:1413</div></div>
</div><!-- fragment --><p >The type that is returned will be a lightweight iterator type, guaranteed to satisfy the C++ LegacyRandomAccessIterator requirement. The precise C++ type of the iterator is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> implements the Python iterable interface. You can iterate over the normal surfaces in this list in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this list. </dd></dl>

</div>
</div>
<a id="adb8da79103f921bee2f52e6fdb39eb2e" name="adb8da79103f921bee2f52e6fdb39eb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8da79103f921bee2f52e6fdb39eb2e">&#9670;&nbsp;</a></span>beginVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::beginVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A C++ iterator that gives access to the raw vectors for surfaces in this list, pointing to the beginning of this surface list. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="classregina_1_1NormalSurfaces.html#a13ecdf4b4f06571143478ac881e47b04" title="Returns a Python iterable object that iterates over the raw vectors for all surfaces in this list.">vectors()</a> instead, which returns an iterable object for iterating over these same raw vectors.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this surface list. </dd></dl>

</div>
</div>
<a id="ada70246d67b766fd35a224bd561ee071" name="ada70246d67b766fd35a224bd561ee071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada70246d67b766fd35a224bd561ee071">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> regina::NormalSurfaces::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate system that was originally used to enumerate the surfaces in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>the coordinate system used. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ad7d6ef0f85fc4ab299f6872c5d6057ab" name="ad7d6ef0f85fc4ab299f6872c5d6057ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d6ef0f85fc4ab299f6872c5d6057ab">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalSurfaces::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator beyond the end of this list of surfaces. </p>
<p >These <a class="el" href="classregina_1_1NormalSurfaces.html#ac4179f56ed9853ce214463eb9f03ad5b" title="Returns a C++ iterator at the beginning of this list of surfaces.">begin()</a> and <a class="el" href="classregina_1_1NormalSurfaces.html#ad7d6ef0f85fc4ab299f6872c5d6057ab" title="Returns a C++ iterator beyond the end of this list of surfaces.">end()</a> routines allow you to iterate through all surfaces in this list using a range-based <code>for</code> loop. See the <a class="el" href="classregina_1_1NormalSurfaces.html#ac4179f56ed9853ce214463eb9f03ad5b" title="Returns a C++ iterator at the beginning of this list of surfaces.">begin()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> implements the Python iterable interface. You can iterate over the normal surfaces in this list in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this list. </dd></dl>

</div>
</div>
<a id="a268c1848908924fc19644b83309beeba" name="a268c1848908924fc19644b83309beeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268c1848908924fc19644b83309beeba">&#9670;&nbsp;</a></span>endVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::endVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A C++ iterator that gives access to the raw vectors for surfaces in this list, pointing past the end of this surface list. </p>
<p >This iterator is not dereferenceable.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="classregina_1_1NormalSurfaces.html#a13ecdf4b4f06571143478ac881e47b04" title="Returns a Python iterable object that iterates over the raw vectors for all surfaces in this list.">vectors()</a> instead, which returns an iterable object for iterating over these same raw vectors.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator past the end of this surface list. </dd></dl>

</div>
</div>
<a id="a4235db32ccba3f9f49e8b668afb8ad85" name="a4235db32ccba3f9f49e8b668afb8ad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4235db32ccba3f9f49e8b668afb8ad85">&#9670;&nbsp;</a></span>isEmbeddedOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::isEmbeddedOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this list was constructed to contain only properly embedded surfaces. </p>
<p >If this returns <code>false</code>, it does not guarantee that immersed and/or singular surfaces are present; it merely indicates that they were not deliberately excluded (for instance, the quadrilateral constraints were not enforced).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was constructed to contain only properly embedded surfaces, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a1362c5187ce205e0d2408eaaca2512ed" name="a1362c5187ce205e0d2408eaaca2512ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1362c5187ce205e0d2408eaaca2512ed">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given list contain different sets of normal (or almost normal) surfaces. </p>
<p >The lists will be compared as multisets: the order of the surfaces in each list does not matter; however, in the unusual scenario where a list the same surface multiple times, multiplicity does matter.</p>
<p >Like the comparison operators for <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a>, it does not matter whether the lists work with different triangulations, or different encodings, or if one but not the other supports almost normal and/or spun-normal surfaces. The individual surfaces will simply be compared by examining or computing the number of discs of each type.</p>
<p >In particular, this routine is safe to call even if this and the given list work with different triangulations:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will compare surfaces as though they were transplanted into the same triangulation using the same tetrahedron numbering and the same disc types.</li>
<li>If the two triangulations have different sizes, then this comparison will return <code>true</code> (i.e., the lists will be considered different).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list to be compared with this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both lists do not represent the same multiset of normal or almost normal surfaces, or <code>false</code> if they do. </dd></dl>

</div>
</div>
<a id="acb59cc46169bc2f3e89bcff49d04bb21" name="acb59cc46169bc2f3e89bcff49d04bb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb59cc46169bc2f3e89bcff49d04bb21">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp; regina::NormalSurfaces::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this list. </dd></dl>

</div>
</div>
<a id="a6473f075f3bd6800cfd3ccff3e777a90" name="a6473f075f3bd6800cfd3ccff3e777a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6473f075f3bd6800cfd3ccff3e777a90">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp; regina::NormalSurfaces::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given list into this list. </p>
<p >This is a fast (constant time) operation.</p>
<p >The list that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this list which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this list. </dd></dl>

</div>
</div>
<a id="a3d11cefcc63d004a2a5bedb35684fc57" name="a3d11cefcc63d004a2a5bedb35684fc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d11cefcc63d004a2a5bedb35684fc57">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given list contain the same set of normal (or almost normal) surfaces. </p>
<p >The lists will be compared as multisets: the order of the surfaces in each list does not matter; however, in the unusual scenario where a list the same surface multiple times, multiplicity does matter.</p>
<p >Like the comparison operators for <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a>, it does not matter whether the lists work with different triangulations, or different encodings, or if one but not the other supports almost normal and/or spun-normal surfaces. The individual surfaces will simply be compared by examining or computing the number of discs of each type.</p>
<p >In particular, this routine is safe to call even if this and the given list work with different triangulations:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will compare surfaces as though they were transplanted into the same triangulation using the same tetrahedron numbering and the same disc types.</li>
<li>If the two triangulations have different sizes, then this comparison will return <code>false</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list to be compared with this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both lists represent the same multiset of normal or almost normal surfaces, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="a256d4d7d0b76ebbb17fafa751fb5a128" name="a256d4d7d0b76ebbb17fafa751fb5a128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256d4d7d0b76ebbb17fafa751fb5a128">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp; regina::NormalSurfaces::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the surface at the requested index in this list. </p>
<p >This is identical to calling <a class="el" href="classregina_1_1NormalSurfaces.html#a75daf757568e280e406899878914efd7" title="Returns the surface at the requested index in this list.">surface()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested surface in this list; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaces.html#a0aae88a4f82d88e1ed542f17d26904d7" title="Returns the number of surfaces stored in this list.">size()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal surface at the requested index in this list. </dd></dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&nbsp;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p >There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">Triangulation&lt;3&gt;::inAnyPacket()</a> will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p >The function inAnyPacket() is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&nbsp;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="ad2e9769e0bb95a10eee0b33c2014192a" name="ad2e9769e0bb95a10eee0b33c2014192a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e9769e0bb95a10eee0b33c2014192a">&#9670;&nbsp;</a></span>recreateMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> regina::NormalSurfaces::recreateMatchingEquations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the matching equations that were used to create this normal surface list. </p>
<p >The matrix is not cached: multiple calls to this routine will result in the construction of multiple matrices. This routine in fact merely calls <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> with the appropriate parameters.</p>
<p >The format of the matrix is identical to that returned by <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a>.</p>
<p >Note that there are situations in which <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> throws an exception (because the triangulation is not supported by the chosen coordinate system). However, this routine will always succeed, because if <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> had failed then this normal surface list would not have been created in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd>the matching equations used to create this normal surface list. </dd></dl>

</div>
</div>
<a id="a8f63303236ca57cb6f382f43fd1f12c8" name="a8f63303236ca57cb6f382f43fd1f12c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f63303236ca57cb6f382f43fd1f12c8">&#9670;&nbsp;</a></span>saveCSVEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::saveCSVEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga23ec276a567978da57ae4f459188806d">SurfaceExport</a>&#160;</td>
          <td class="paramname"><em>additionalFields</em> = <code><a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file, using edge weight coordinates. </p>
<p >CSV files are human-readable and human-editable, and are suitable for importing into spreadsheets and databases.</p>
<p >The surfaces will be exported in edge weight coordinates. Thus there will be one coordinate for each edge of the underlying triangulation; each such coordinate will become a separate field in the CSV file.</p>
<p >As well as the normal surface coordinates, additional properties of the normal surfaces (such as Euler characteristic, orientability, and so on) can be included as extra fields in the export. Users can select precisely which properties to include by passing a bitwise OR combination of constants from the <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> enumeration type.</p>
<p >The CSV format used here begins with a header row, and uses commas as field separators. <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a> fields with arbitrary contents are placed inside double quotes, and the double quote character itself is represented by a pair of double quotes. Thus the string <code>my "normal" surface's name</code> would be stored as <code>"my ""normal"" surface's name"</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. Any user strings such as surface names will be written in UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the CSV file to export to. </td></tr>
    <tr><td class="paramname">additionalFields</td><td>a bitwise OR combination of constants from <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> indicating which additional properties of surfaces should be included in the export. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the export was successful, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a600b934ddaecf2d70c8c21d9e9928b13" name="a600b934ddaecf2d70c8c21d9e9928b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600b934ddaecf2d70c8c21d9e9928b13">&#9670;&nbsp;</a></span>saveCSVStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::saveCSVStandard </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga23ec276a567978da57ae4f459188806d">SurfaceExport</a>&#160;</td>
          <td class="paramname"><em>additionalFields</em> = <code><a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this list of normal surfaces as a plain text CSV (comma-separated value) file, using standard coordinates. </p>
<p >CSV files are human-readable and human-editable, and are suitable for importing into spreadsheets and databases.</p>
<p >The surfaces will be exported in standard coordinates (tri-quad coordinates for normal surfaces, or tri-quad-oct coordinates for almost normal surfaces). Each coordinate will become a separate field in the CSV file.</p>
<p >As well as the normal surface coordinates, additional properties of the normal surfaces (such as Euler characteristic, orientability, and so on) can be included as extra fields in the export. Users can select precisely which properties to include by passing a bitwise OR combination of constants from the <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> enumeration type.</p>
<p >The CSV format used here begins with a header row, and uses commas as field separators. <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a> fields with arbitrary contents are placed inside double quotes, and the double quote character itself is represented by a pair of double quotes. Thus the string <code>my "normal" surface's name</code> would be stored as <code>"my ""normal"" surface's name"</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. Any user strings such as surface names will be written in UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the CSV file to export to. </td></tr>
    <tr><td class="paramname">additionalFields</td><td>a bitwise OR combination of constants from <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> indicating which additional properties of surfaces should be included in the export. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the export was successful, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0aae88a4f82d88e1ed542f17d26904d7" name="a0aae88a4f82d88e1ed542f17d26904d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aae88a4f82d88e1ed542f17d26904d7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurfaces::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of surfaces stored in this list. </p>
<dl class="section user"><dt>Python</dt><dd>This is also used to implement the Python special method <b>len</b>().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of surfaces. </dd></dl>

</div>
</div>
<a id="ae2995d136dc8e575605230cec31dd8c9" name="ae2995d136dc8e575605230cec31dd8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2995d136dc8e575605230cec31dd8c9">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::sort </td>
          <td>(</td>
          <td class="paramtype">Comparison &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the surfaces in this list according to the given criterion. </p>
<p >This sort is stable, i.e., surfaces that are equivalent under the given criterion will remain in the same relative order.</p>
<p >The implementation of this routine uses std::stable_sort.</p>
<dl class="section user"><dt>Python</dt><dd>This is available in Python, and <em>comp</em> may be a pure Python function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>a binary function (or other callable object) that accepts two const <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold triangulation.">NormalSurface</a> references, and returns <code>true</code> if and only if the first surface should appear before the second in the sorted list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a75daf757568e280e406899878914efd7" name="a75daf757568e280e406899878914efd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75daf757568e280e406899878914efd7">&#9670;&nbsp;</a></span>surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp; regina::NormalSurfaces::surface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the surface at the requested index in this list. </p>
<p >This is identical to using the square bracket operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested surface in this list; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaces.html#a0aae88a4f82d88e1ed542f17d26904d7" title="Returns the number of surfaces stored in this list.">size()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal surface at the requested index in this list. </dd></dl>

</div>
</div>
<a id="a6a6ad6281b288ede6f558ed36fb44541" name="a6a6ad6281b288ede6f558ed36fb44541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6ad6281b288ede6f558ed36fb44541">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given list. </p>
<p >This routine will behave correctly if <em>other</em> is in fact this list.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both lists which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb106a4b9f159f7a19374268f842ebfa" name="acb106a4b9f159f7a19374268f842ebfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb106a4b9f159f7a19374268f842ebfa">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; &amp; regina::NormalSurfaces::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation in which these normal surfaces live. </p>
<p >This will be a snapshot frozen in time of the triangulation that was originally passed to the <a class="el" href="classregina_1_1NormalSurfaces.html" title="A collection of normal surfaces in a 3-manifold triangulation.">NormalSurfaces</a> constructor.</p>
<p >This will return a correct result even if the original triangulation has since been modified or destroyed. However, in order to ensure this behaviour, it is possible that at different points in time this function may return references to different C++ objects.</p>
<p >The rules for using the <a class="el" href="classregina_1_1NormalSurfaces.html#acb106a4b9f159f7a19374268f842ebfa" title="Returns the triangulation in which these normal surfaces live.">triangulation()</a> reference are:</p>
<ul>
<li>Do not keep the resulting reference as a long-term reference or pointer of your own, since in time you may find yourself referring to the wrong object (see above). Just call this function again.</li>
<li>You must respect the read-only nature of the result (i.e., you must not cast the constness away). The snapshotting process detects modifications, and modifying the frozen snapshot may result in an exception being thrown.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>As of Regina 7.0, you <em>cannot</em> access this triangulation via the packet tree as <a class="el" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0" title="Determines the parent packet in the tree structure.">Packet::parent()</a>. This is because normal surface lists can now be kept anywhere in the packet tree, or can be kept as standalone objects outside the packet tree entirely.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a13ecdf4b4f06571143478ac881e47b04" name="a13ecdf4b4f06571143478ac881e47b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ecdf4b4f06571143478ac881e47b04">&#9670;&nbsp;</a></span>vectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalSurfaces::vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterable object that iterates over the raw vectors for all surfaces in this list. </p>
<p >For example:</p>
<div class="fragment"><div class="line">list = NormalSurfaces(...)</div>
<div class="line"><span class="keywordflow">for</span> v <span class="keywordflow">in</span> list.vectors():</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> provides <a class="el" href="classregina_1_1NormalSurfaces.html#adb8da79103f921bee2f52e6fdb39eb2e" title="A C++ iterator that gives access to the raw vectors for surfaces in this list, pointing to the beginn...">beginVectors()</a> and <a class="el" href="classregina_1_1NormalSurfaces.html#a268c1848908924fc19644b83309beeba" title="A C++ iterator that gives access to the raw vectors for surfaces in this list, pointing past the end ...">endVectors()</a> instead, which together define an iterator range over these same raw vectors.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the normal surfaces in this list. </dd></dl>

</div>
</div>
<a id="a2a12326b8c6dfebfefe97b34b15920c7" name="a2a12326b8c6dfebfefe97b34b15920c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a12326b8c6dfebfefe97b34b15920c7">&#9670;&nbsp;</a></span>which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a> regina::NormalSurfaces::which </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of which normal surfaces this list represents within the underlying triangulation. </p>
<p >This may not be the same NormalList that was passed to the class constructor. In particular, default values will have been explicitly filled in (such as NS_VERTEX and/or NS_EMBEDDED_ONLY), and invalid and/or redundant values will have been removed.</p>
<dl class="section return"><dt>Returns</dt><dd>details of what this list represents. </dd></dl>

</div>
</div>
<a id="a83b7e0e3dccfde815a4e9448142f574a" name="a83b7e0e3dccfde815a4e9448142f574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b7e0e3dccfde815a4e9448142f574a">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b997db79cdf5367c91660c6ccfe46ec" name="a8b997db79cdf5367c91660c6ccfe46ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b997db79cdf5367c91660c6ccfe46ec">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa0e72355f8511a648f728fc452ba850a" name="aa0e72355f8511a648f728fc452ba850a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e72355f8511a648f728fc452ba850a">&#9670;&nbsp;</a></span>algorithm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga683578851f6326bd0c6d30439c401d87">NormalAlg</a> regina::NormalSurfaces::algorithm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the details of the enumeration algorithm that was used to generate this list. </p>
<p >This might not be the same as the <em>algHints</em> flag that was originally passed to the enumeration routine (e.g., if invalid or inappropriate flags were passed). </p>

</div>
</div>
<a id="a317370303ab0e90b1367b33d57a92e83" name="a317370303ab0e90b1367b33d57a92e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317370303ab0e90b1367b33d57a92e83">&#9670;&nbsp;</a></span>coords_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> regina::NormalSurfaces::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The coordinate system that was originally used to enumerate the normal surfaces in this list. </p>

</div>
</div>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&nbsp;</a></span>heldBy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>  &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p >As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<a id="adf1bc60b71d27b89ef71891342d0f9f0" name="adf1bc60b71d27b89ef71891342d0f9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1bc60b71d27b89ef71891342d0f9f0">&#9670;&nbsp;</a></span>surfaces_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&gt; regina::NormalSurfaces::surfaces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains all normal surfaces in this list. </p>

</div>
</div>
<a id="a63c477a99e3a7058acf7a15c9aba847f" name="a63c477a99e3a7058acf7a15c9aba847f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c477a99e3a7058acf7a15c9aba847f">&#9670;&nbsp;</a></span>triangulation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt;<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt; &gt; regina::NormalSurfaces::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which these normal surfaces lie. </p>

</div>
</div>
<a id="a6ffe4301bf296b37ea8253f242167660" name="a6ffe4301bf296b37ea8253f242167660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffe4301bf296b37ea8253f242167660">&#9670;&nbsp;</a></span>which_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga3db2ce7da754da2be8428b5a67c2976f">NormalList</a> regina::NormalSurfaces::which_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which normal surfaces these represent within the underlying triangulation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surface/<a class="el" href="normalsurfaces_8h.html">normalsurfaces.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
