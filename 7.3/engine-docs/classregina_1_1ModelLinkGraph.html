<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::ModelLinkGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1ModelLinkGraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::ModelLinkGraph Class Reference<div class="ingroups"><a class="el" href="group__link.html">Knots and Links</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents an undirected 4-valent planar graph with a specific planar embedding.  
 <a href="classregina_1_1ModelLinkGraph.html#details">More...</a></p>

<p><code>#include &lt;link/modellinkgraph.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::ModelLinkGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1ModelLinkGraph.png" usemap="#regina::ModelLinkGraph_map" alt=""/>
  <map id="regina::ModelLinkGraph_map" name="regina::ModelLinkGraph_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; ModelLinkGraph &gt;" shape="rect" coords="0,0,208,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe9bd8331a5d5de03e0ce35c0ee669a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#abe9bd8331a5d5de03e0ce35c0ee669a0">ModelLinkGraph</a> ()</td></tr>
<tr class="memdesc:abe9bd8331a5d5de03e0ce35c0ee669a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty graph.  <a href="classregina_1_1ModelLinkGraph.html#abe9bd8331a5d5de03e0ce35c0ee669a0">More...</a><br /></td></tr>
<tr class="separator:abe9bd8331a5d5de03e0ce35c0ee669a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfbf94e1751c9f17efb659cf1b7328e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a2dfbf94e1751c9f17efb659cf1b7328e">ModelLinkGraph</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link)</td></tr>
<tr class="memdesc:a2dfbf94e1751c9f17efb659cf1b7328e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the graph that models the given link.  <a href="classregina_1_1ModelLinkGraph.html#a2dfbf94e1751c9f17efb659cf1b7328e">More...</a><br /></td></tr>
<tr class="separator:a2dfbf94e1751c9f17efb659cf1b7328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8824307f9623abdf194742ad462890"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a9a8824307f9623abdf194742ad462890">ModelLinkGraph</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;copy)</td></tr>
<tr class="memdesc:a9a8824307f9623abdf194742ad462890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given graph.  <a href="classregina_1_1ModelLinkGraph.html#a9a8824307f9623abdf194742ad462890">More...</a><br /></td></tr>
<tr class="separator:a9a8824307f9623abdf194742ad462890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ca6920f24e108cf28c0965de1e2e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#abd4ca6920f24e108cf28c0965de1e2e1">ModelLinkGraph</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:abd4ca6920f24e108cf28c0965de1e2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given graph into this new graph.  <a href="classregina_1_1ModelLinkGraph.html#abd4ca6920f24e108cf28c0965de1e2e1">More...</a><br /></td></tr>
<tr class="separator:abd4ca6920f24e108cf28c0965de1e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a6e5615cb448d21f99332ba6ffcbe1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#ac9a6e5615cb448d21f99332ba6ffcbe1">~ModelLinkGraph</a> ()</td></tr>
<tr class="memdesc:ac9a6e5615cb448d21f99332ba6ffcbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this graph.  <a href="classregina_1_1ModelLinkGraph.html#ac9a6e5615cb448d21f99332ba6ffcbe1">More...</a><br /></td></tr>
<tr class="separator:ac9a6e5615cb448d21f99332ba6ffcbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae830ab12408759e526ae15d16e0be5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a8ae830ab12408759e526ae15d16e0be5">size</a> () const</td></tr>
<tr class="memdesc:a8ae830ab12408759e526ae15d16e0be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of nodes in this graph.  <a href="classregina_1_1ModelLinkGraph.html#a8ae830ab12408759e526ae15d16e0be5">More...</a><br /></td></tr>
<tr class="separator:a8ae830ab12408759e526ae15d16e0be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32048d7c0d574234df71c03cf8afcb33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a32048d7c0d574234df71c03cf8afcb33">node</a> (size_t index) const</td></tr>
<tr class="memdesc:a32048d7c0d574234df71c03cf8afcb33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node at the given index within this graph.  <a href="classregina_1_1ModelLinkGraph.html#a32048d7c0d574234df71c03cf8afcb33">More...</a><br /></td></tr>
<tr class="separator:a32048d7c0d574234df71c03cf8afcb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6491eff8e0ab206c0d750bc7bed6abd1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a6491eff8e0ab206c0d750bc7bed6abd1">nodes</a> () const</td></tr>
<tr class="memdesc:a6491eff8e0ab206c0d750bc7bed6abd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all nodes in this graph.  <a href="classregina_1_1ModelLinkGraph.html#a6491eff8e0ab206c0d750bc7bed6abd1">More...</a><br /></td></tr>
<tr class="separator:a6491eff8e0ab206c0d750bc7bed6abd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdc89ae4b81f1415856e3812e48f8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a8cdc89ae4b81f1415856e3812e48f8dd">operator=</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;src)</td></tr>
<tr class="memdesc:a8cdc89ae4b81f1415856e3812e48f8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given graph.  <a href="classregina_1_1ModelLinkGraph.html#a8cdc89ae4b81f1415856e3812e48f8dd">More...</a><br /></td></tr>
<tr class="separator:a8cdc89ae4b81f1415856e3812e48f8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec906b2e6ce954c638dfe21c4b3d49bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#aec906b2e6ce954c638dfe21c4b3d49bc">operator=</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:aec906b2e6ce954c638dfe21c4b3d49bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given graph into this graph.  <a href="classregina_1_1ModelLinkGraph.html#aec906b2e6ce954c638dfe21c4b3d49bc">More...</a><br /></td></tr>
<tr class="separator:aec906b2e6ce954c638dfe21c4b3d49bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28801826ec5d301697db8576eded1f10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a28801826ec5d301697db8576eded1f10">swap</a> (<a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a28801826ec5d301697db8576eded1f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given graph.  <a href="classregina_1_1ModelLinkGraph.html#a28801826ec5d301697db8576eded1f10">More...</a><br /></td></tr>
<tr class="separator:a28801826ec5d301697db8576eded1f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2238ea1d3a224c1737ec6c66bdfd5d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#ae2238ea1d3a224c1737ec6c66bdfd5d5">operator==</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;other) const</td></tr>
<tr class="memdesc:ae2238ea1d3a224c1737ec6c66bdfd5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this graph is combinatorially identical to the given graph.  <a href="classregina_1_1ModelLinkGraph.html#ae2238ea1d3a224c1737ec6c66bdfd5d5">More...</a><br /></td></tr>
<tr class="separator:ae2238ea1d3a224c1737ec6c66bdfd5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17913a39fd8bf03cb6bb06f64d4a65af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a17913a39fd8bf03cb6bb06f64d4a65af">operator!=</a> (const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;other) const</td></tr>
<tr class="memdesc:a17913a39fd8bf03cb6bb06f64d4a65af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this graph is not combinatorially identical to the given graph.  <a href="classregina_1_1ModelLinkGraph.html#a17913a39fd8bf03cb6bb06f64d4a65af">More...</a><br /></td></tr>
<tr class="separator:a17913a39fd8bf03cb6bb06f64d4a65af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89a103eeda5359e83684d10b5f3444d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#ad89a103eeda5359e83684d10b5f3444d">reflect</a> ()</td></tr>
<tr class="memdesc:ad89a103eeda5359e83684d10b5f3444d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this graph into its reflection.  <a href="classregina_1_1ModelLinkGraph.html#ad89a103eeda5359e83684d10b5f3444d">More...</a><br /></td></tr>
<tr class="separator:ad89a103eeda5359e83684d10b5f3444d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b314d226abfebfe9ba4ed26bfaf6b23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a4b314d226abfebfe9ba4ed26bfaf6b23">cells</a> () const</td></tr>
<tr class="memdesc:a4b314d226abfebfe9ba4ed26bfaf6b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the cellular decomposition of the sphere that is induced by this graph.  <a href="classregina_1_1ModelLinkGraph.html#a4b314d226abfebfe9ba4ed26bfaf6b23">More...</a><br /></td></tr>
<tr class="separator:a4b314d226abfebfe9ba4ed26bfaf6b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cd0091a0f179ac81be4c981b97b458"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>, <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#ae3cd0091a0f179ac81be4c981b97b458">findFlype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from) const</td></tr>
<tr class="memdesc:ae3cd0091a0f179ac81be4c981b97b458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the smallest flype that can be performed on this graph from the given starting location.  <a href="classregina_1_1ModelLinkGraph.html#ae3cd0091a0f179ac81be4c981b97b458">More...</a><br /></td></tr>
<tr class="separator:ae3cd0091a0f179ac81be4c981b97b458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eae854058768363de2cc893d24c20ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea">flype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from, const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;left, const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;right) const</td></tr>
<tr class="memdesc:a2eae854058768363de2cc893d24c20ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a flype on this graph at the given location.  <a href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea">More...</a><br /></td></tr>
<tr class="separator:a2eae854058768363de2cc893d24c20ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac565266fea843b1ee7d9f344eddf0c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#ac565266fea843b1ee7d9f344eddf0c4b">flype</a> (const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;from) const</td></tr>
<tr class="memdesc:ac565266fea843b1ee7d9f344eddf0c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the smallest possible flype on this graph from the given starting location.  <a href="classregina_1_1ModelLinkGraph.html#ac565266fea843b1ee7d9f344eddf0c4b">More...</a><br /></td></tr>
<tr class="separator:ac565266fea843b1ee7d9f344eddf0c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="memTemplParams" colspan="2">template&lt;typename Action , typename... Args&gt; </td></tr>
<tr class="memitem:a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a7eebfc992fb1fb0e11a5ba620d88db0a">generateMinimalLinks</a> (Action &amp;&amp;action, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exhaustively generates potentially-minimal knot diagrams that are modelled by this graph.  <a href="classregina_1_1ModelLinkGraph.html#a7eebfc992fb1fb0e11a5ba620d88db0a">More...</a><br /></td></tr>
<tr class="separator:a7eebfc992fb1fb0e11a5ba620d88db0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b794563bcc89728bf2dab6f6952a5c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5">plantri</a> () const</td></tr>
<tr class="memdesc:a3b794563bcc89728bf2dab6f6952a5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this graph in a variant of the ASCII text format used by <em>plantri</em>.  <a href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5">More...</a><br /></td></tr>
<tr class="separator:a3b794563bcc89728bf2dab6f6952a5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab574d5b77af06b93deaf6de05d67b671"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#ab574d5b77af06b93deaf6de05d67b671">canonicalPlantri</a> (bool useReflection=true, bool tight=false) const</td></tr>
<tr class="memdesc:ab574d5b77af06b93deaf6de05d67b671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a text representation of this graph in a variant of the <em>plantri</em> ASCII format, using a canonical relabelling of nodes and arcs, and with optional compression.  <a href="classregina_1_1ModelLinkGraph.html#ab574d5b77af06b93deaf6de05d67b671">More...</a><br /></td></tr>
<tr class="separator:ab574d5b77af06b93deaf6de05d67b671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4b88c8eb92b6c9abe6f557c3221486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#aab4b88c8eb92b6c9abe6f557c3221486">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aab4b88c8eb92b6c9abe6f557c3221486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this graph to the given output stream.  <a href="classregina_1_1ModelLinkGraph.html#aab4b88c8eb92b6c9abe6f557c3221486">More...</a><br /></td></tr>
<tr class="separator:aab4b88c8eb92b6c9abe6f557c3221486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89355292f9354c4d8bfc7d5468ee26f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a89355292f9354c4d8bfc7d5468ee26f5">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a89355292f9354c4d8bfc7d5468ee26f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this graph to the given output stream.  <a href="classregina_1_1ModelLinkGraph.html#a89355292f9354c4d8bfc7d5468ee26f5">More...</a><br /></td></tr>
<tr class="separator:a89355292f9354c4d8bfc7d5468ee26f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a806a72e571ad5c1f2c3e8c79bdbf7af1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1">fromPlantri</a> (const std::string &amp;<a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5">plantri</a>)</td></tr>
<tr class="memdesc:a806a72e571ad5c1f2c3e8c79bdbf7af1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a graph from a line of <em>plantri</em> output, using Regina's variant of the <em>plantri</em> ASCII format.  <a href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1">More...</a><br /></td></tr>
<tr class="separator:a806a72e571ad5c1f2c3e8c79bdbf7af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents an undirected 4-valent planar graph with a specific planar embedding. </p>
<p >This can be used as the model graph for a knot or link diagram, where each node of the graph becomes a crossing.</p>
<p >Current this class does not support circular graph components (which, in a link diagram, would correspond to zero-crossing unknot components of the link).</p>
<p >This class is primarily designed for <em>enumerating</em> knots and links. If you wish to study the underlying graph of an existing link, you do not need to create a <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> - instead the <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> class already gives you direct access to the graph structure. In particular, if you include link/graph.h, you can use a <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a> directly as a directed graph type with the Boost Graph Library.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abe9bd8331a5d5de03e0ce35c0ee669a0" name="abe9bd8331a5d5de03e0ce35c0ee669a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9bd8331a5d5de03e0ce35c0ee669a0">&#9670;&nbsp;</a></span>ModelLinkGraph() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty graph. </p>

</div>
</div>
<a id="a2dfbf94e1751c9f17efb659cf1b7328e" name="a2dfbf94e1751c9f17efb659cf1b7328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dfbf94e1751c9f17efb659cf1b7328e">&#9670;&nbsp;</a></span>ModelLinkGraph() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the graph that models the given link. </p>
<p >Any zero-component unknot components of the link will be ignored.</p>
<p >The nodes of this graph will be numbered in the same way as the crossings of <em>link</em>. For each node, arc 0 will represent the outgoing lower strand of the corresponding crossing.</p>
<p >Using this constructor is identical to calling <a class="el" href="classregina_1_1Link.html#a980602d950e89b20aba2ba16ebc86521" title="Returns the 4-valent planar graph that models this link.">Link::graph()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link that this new graph will model. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8824307f9623abdf194742ad462890" name="a9a8824307f9623abdf194742ad462890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8824307f9623abdf194742ad462890">&#9670;&nbsp;</a></span>ModelLinkGraph() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new copy of the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the graph to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd4ca6920f24e108cf28c0965de1e2e1" name="abd4ca6920f24e108cf28c0965de1e2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4ca6920f24e108cf28c0965de1e2e1">&#9670;&nbsp;</a></span>ModelLinkGraph() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::ModelLinkGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given graph into this new graph. </p>
<p >This is a fast (constant time) operation.</p>
<p >All nodes and cells that belong to <em>src</em> will be moved into this graph, and so any <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> or <a class="el" href="classregina_1_1ModelLinkGraphCells.html" title="Describes the cellular decomposition of the sphere that is induced by a given planar 4-valent graph.">ModelLinkGraphCells</a> pointers or references will remain valid.</p>
<p >The graph that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the graph to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9a6e5615cb448d21f99332ba6ffcbe1" name="ac9a6e5615cb448d21f99332ba6ffcbe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a6e5615cb448d21f99332ba6ffcbe1">&#9670;&nbsp;</a></span>~ModelLinkGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ModelLinkGraph::~ModelLinkGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this graph. </p>
<p >The <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> objects contained in this graph will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab574d5b77af06b93deaf6de05d67b671" name="ab574d5b77af06b93deaf6de05d67b671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab574d5b77af06b93deaf6de05d67b671">&#9670;&nbsp;</a></span>canonicalPlantri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::ModelLinkGraph::canonicalPlantri </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useReflection</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tight</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a text representation of this graph in a variant of the <em>plantri</em> ASCII format, using a canonical relabelling of nodes and arcs, and with optional compression. </p>
<p >This routine is similar to <a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a>, but with two significant differences:</p>
<ul>
<li>This routine does not preserve the labelling of nodes and the order of arcs around each node. Instead it reorders the nodes and arcs so that any two relabellings of the "same" planar embedding will produce the same <a class="el" href="classregina_1_1ModelLinkGraph.html#ab574d5b77af06b93deaf6de05d67b671" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> output. By "same" we allow for relabelling and isotopy (sliding the graph around the sphere); if the argument <em>useReflection</em> is <code>true</code> then we allow for reflection also.</li>
<li>If the argument <em>tight</em> is <code>true</code>, then this routine uses an abbreviated output format. The resulting compression is only trivial (it reduces the length by roughly 40%), but the resulting string is still human-parseable (though with a little more effort required). This compression will simply remove the commas, and for each node it will suppress the destination of the first arc (since this can be deduced from the canonical labelling).</li>
</ul>
<p >Regardless of whether <em>tight</em> is <code>true</code> or <code>false</code>, the resulting string can be parsed by <a class="el" href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a> to reconstruct the original graph. Note however that, due to the canonical labelling, the resulting graph might be a relabelling of the original (and might even be a reflection of the original, if <em>useReflection</em> was passed as <code>true</code>).</p>
<p >See <a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> for further details on the ASCII format itself, including the ways in which Regina's implementation of this format differs from <em>plantri's</em> for graphs with more than 26 nodes.</p>
<p >The running time for this routine is quadratic in the size of the graph.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected. </dd>
<dd>
This graph has between 1 and 52 nodes inclusive. </dd>
<dd>
The dual to this graph is a <em>simple</em> quadrangulation of the sphere. In particular, the dual must not have any parallel edges. Note that any graph that fails this condition will the model graph for a link diagram that is an "obvious" connected sum.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This graph has more than 52 nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useReflection</td><td><code>true</code> if a graph and its reflection should be considered the same (i.e., produce the same canonical output), or <code>false</code> if they should be considered different. Of course, if a graph is symmetric under reflection then the graph and its reflection will produce the same canonical output regardless of this parameter. </td></tr>
    <tr><td class="paramname">tight</td><td><code>false</code> if the usual <em>plantri</em> ASCII format should be used (as described by <a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> and <a class="el" href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a>), or <code>true</code> if the abbreviated format should be used as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an optionally compressed <em>plantri</em> ASCII representation of this graph. </dd></dl>

</div>
</div>
<a id="a4b314d226abfebfe9ba4ed26bfaf6b23" name="a4b314d226abfebfe9ba4ed26bfaf6b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b314d226abfebfe9ba4ed26bfaf6b23">&#9670;&nbsp;</a></span>cells()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1ModelLinkGraphCells.html">ModelLinkGraphCells</a> &amp; regina::ModelLinkGraph::cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of the cellular decomposition of the sphere that is induced by this graph. </p>
<p >This cellular decomposition will only be computed on demand. This means that the first call to this function will take linear time (as the decomposition is computed), but subsequent calls will be constant time (since the decomposition is cached).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the induced cellular decomposition of the sphere. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ae3cd0091a0f179ac81be4c981b97b458" name="ae3cd0091a0f179ac81be4c981b97b458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cd0091a0f179ac81be4c981b97b458">&#9670;&nbsp;</a></span>findFlype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a>, <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &gt; regina::ModelLinkGraph::findFlype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the smallest flype that can be performed on this graph from the given starting location. </p>
<p >Here we use the same notation as in the three-argument <a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> function, where you perform a flype by passing three arcs <em>from</em>, <em>left</em> and <em>right</em>. Read the <a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> documentation now if you have not done so already; this includes a full description of the flype operation as well as diagrams with the arcs <em>from</em>, <em>left</em> and <em>right</em> clearly marked.</p>
<p >The given arc <em>from</em> identifies the node to the left of the flype disc. The aim of this routine is to identify two suitable arcs <em>left</em> and <em>right</em> that exit through the right of the flype disc. Together, these three arcs uniquely identify the entire flype disc, and therefore prescribe the operation precisely.</p>
<p >Here, by "suitable arcs", we mean a pair of arcs (<em>left</em>, <em>right</em>) for which the three arcs (<em>from</em>, <em>left</em>, <em>right</em>) together satisfy the preconditions for the <a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> routine.</p>
<p >There are several possible outcomes:</p>
<ul>
<li>It is possible that there are <em>no</em> suitable arcs <em>left</em> and <em>right</em>. In this case, this routine returns a pair of null arcs.</li>
<li>It is possible that there is exactly one pair of suitable arcs (<em>left</em>, <em>right</em>). In this case, this pair will be returned.</li>
<li>It is possible that there are <em>many</em> pairs of suitable arcs. In this case, it can be shown that the suitable pairs have an ordering <em>P_1</em>, ..., <em>P_k</em> in which the flype disc for <em>P_i</em> is completely contained within the flype disc for <em>P_j</em> whenever <em>i</em> &lt; <em>j</em>. In this case, this routine returns the <em>smallest</em> pair <em>P_1</em>; that is, the pair (<em>left</em>, <em>right</em>) that gives the smallest possible flype disc.</li>
</ul>
<p >It should be noted that choosing only the smallest flype is not a serious restriction: assuming the graph does not model a composition of non-trivial knot diagrams, <em>any</em> suitable flype can be expressed as a composition of minimal flypes in this sense.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the arc that indicates where the flype disc should begin. This is the arc labelled <em>from</em> in the diagrams for the three-argument <a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> function: it is the lower of the two arcs that enter the flype disc from the node <em>X</em> to the left of the disc. This should be presented as an arc of the node <em>X</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pair (<em>left</em>, <em>right</em>) representing the smallest suitable flype beginning at <em>from</em>, or a pair of null arcs if there are no suitable pairs (<em>left</em>, <em>right</em>). </dd></dl>

</div>
</div>
<a id="ac565266fea843b1ee7d9f344eddf0c4b" name="ac565266fea843b1ee7d9f344eddf0c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac565266fea843b1ee7d9f344eddf0c4b">&#9670;&nbsp;</a></span>flype() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::flype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the smallest possible flype on this graph from the given starting location. </p>
<p >This is a convenience routine that simply calls <a class="el" href="classregina_1_1ModelLinkGraph.html#ae3cd0091a0f179ac81be4c981b97b458" title="Identifies the smallest flype that can be performed on this graph from the given starting location.">findFlype()</a> to identify the smallest possible flype from the given starting location, and then calls the three-argument <a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> to actually perform it. If there is no possible flype from the given starting location then this routine throws an exception.</p>
<p >See the documentation for the three-argument <a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> for further details on the flype operation, and see <a class="el" href="classregina_1_1ModelLinkGraph.html#ae3cd0091a0f179ac81be4c981b97b458" title="Identifies the smallest flype that can be performed on this graph from the given starting location.">findFlype()</a> for a discussion on what is meant by "smallest possible".</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>There is no suitable flype on this graph from the given starting location (that is, <a class="el" href="classregina_1_1ModelLinkGraph.html#ae3cd0091a0f179ac81be4c981b97b458" title="Identifies the smallest flype that can be performed on this graph from the given starting location.">findFlype()</a> returns a pair of null arcs).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the arc that indicates where the flype disc should begin. This is the arc labelled <em>from</em> in the diagrams for the three-argument <a class="el" href="classregina_1_1ModelLinkGraph.html#a2eae854058768363de2cc893d24c20ea" title="Performs a flype on this graph at the given location.">flype()</a> function: it is the lower of the two arcs that enter the flype disc from the node <em>X</em> to the left of the disc. This should be presented as an arc of the node <em>X</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the graph obtained by performing the flype. </dd></dl>

</div>
</div>
<a id="a2eae854058768363de2cc893d24c20ea" name="a2eae854058768363de2cc893d24c20ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eae854058768363de2cc893d24c20ea">&#9670;&nbsp;</a></span>flype() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::flype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraphArc.html">ModelLinkGraphArc</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a flype on this graph at the given location. </p>
<p >A <em>flype</em> is an operation on a disc in the plane. The boundary of the disc must cut through four arcs of the graph (and otherwise must not meet the graph at all), as indicated in the diagram below. Moreover, the two arcs that exit the disc on the left must meet at a common node just outside the disc. (The punctuation symbols drawn inside the disc are just to help illustrate how the transformation works.)</p>
<pre class="fragment">         ______                       ______
        /      \                     /      \
__   __| ##  ** |_______     _______| ::  &lt;&gt; |__   __
  \ /  |        |                   |        |  \ /
   X   |  Disc  |        ==&gt;        |        |   X
__/ \__|        |_______     _______|        |__/ \__
       | ::  &lt;&gt; |                   | ##  ** |
        \______/                     \______/
</pre><p >The operation involves:</p>
<ul>
<li>reflecting this disc in a horizontal axis (so the two arcs on the left switch places, and the two arcs on the right switch places);</li>
<li>removing the node outside the disc on the left, where the two arcs meet;</li>
<li>introducing a new node on the right instead, where the two arcs on the right will now meet.</li>
</ul>
<p >The equivalent operation on a knot diagram involves twisting the entire region inside the disc about a horizontal axis, in a way that undoes the crossing on the left but introduces a new crossing on the right instead.</p>
<p >You will need to pass arguments to indicate where the flype should take place. For this, we will label some of the features of the initial diagram (before the move takes place): see the diagram below. Here the labels <em>from</em>, <em>left</em> and <em>right</em> all refer to arcs. The labels <em>A</em>, <em>B</em>, <em>C</em> and <em>D</em> all refer to dual 2-cells in the plane; these are not passed as arguments, but they do appear in the list of preconditions for this routine.</p>
<pre class="fragment">                 ______
Cell A          /      \
__   __________|        |_________ left
  \ /          |        |
   X   Cell B  |        |  Cell D
__/ \__________|        |_________ right
         from  |        |
Cell C          \______/
</pre><p >The arc <em>from</em> must be given as an arc of the node <em>outside</em> the disc (i.e., the node to the left of cell <em>B</em>). The arcs <em>left</em> and <em>right</em> must be given as arcs of their respective nodes <em>inside</em> the disc.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected.</dd>
<dd>
The arcs <em>from</em>, <em>left</em> and <em>right</em> are laid out as in the diagram above. In particular: <em>from</em> and <em>right</em> have the same cell to their right (cell <em>C</em>); <em>left</em> and the arc to the left of <em>from</em> have the same cell to their left (cell <em>A</em>); and <em>left</em> and <em>right</em> have the same cell between them (cell <em>D</em>).</dd>
<dd>
Neither of the arcs <em>left</em> or <em>right</em>, when followed in the direction away from the disc, end back at the node on the left of the diagram. That is, neither <code>left.traverse().<a class="el" href="classregina_1_1ModelLinkGraph.html#a32048d7c0d574234df71c03cf8afcb33" title="Returns the node at the given index within this graph.">node()</a></code> nor <code>right.traverse().<a class="el" href="classregina_1_1ModelLinkGraph.html#a32048d7c0d574234df71c03cf8afcb33" title="Returns the node at the given index within this graph.">node()</a></code> is equal to <code>from.node()</code>. (If this fails, then either the flype simply reflects the entire graph, or else the graph models a composition of two non-trivial knot diagrams.)</dd>
<dd>
Cells <em>A</em> and <em>C</em> are distinct (that is, the node on the left of the diagram is not a cut-vertex of the graph).</dd>
<dd>
Cells <em>B</em> and <em>D</em> are distinct (that is, the disc actually contains one or more nodes, and the graph does not model a composition of two non-trivial knot diagrams).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>One or more of the preconditions above fails to hold. Be warned that the connectivity precondition will not be checked - this is the user's responsibility - but all other preconditions <em>will</em> be checked, and an exception will be thrown if any of them fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>the first arc that indicates where the flype should take place, as labelled on the diagram above. This should be presented as an arc of the node outside the disc, to the left. </td></tr>
    <tr><td class="paramname">left</td><td>the second arc that indicates where the flype should take place, as labelled on the diagram above. This should be presented as an arc of the node that it meets inside the disc. </td></tr>
    <tr><td class="paramname">right</td><td>the third arc that indicates where the flype should take place, as labelled on the diagram above. This should be presented as an arc of the node that it meets inside the disc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the graph obtained by performing the flype. </dd></dl>

</div>
</div>
<a id="a806a72e571ad5c1f2c3e8c79bdbf7af1" name="a806a72e571ad5c1f2c3e8c79bdbf7af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806a72e571ad5c1f2c3e8c79bdbf7af1">&#9670;&nbsp;</a></span>fromPlantri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> regina::ModelLinkGraph::fromPlantri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>plantri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a graph from a line of <em>plantri</em> output, using Regina's variant of the <em>plantri</em> ASCII format. </p>
<p >The software <em>plantri</em>, by Gunnar Brinkmann and Brendan McKay, can be used to enumerate 4-valent planar graphs (amongst many other things). This routine converts a piece of output from <em>plantri</em>, or the encoding of a graph using Regina's own <a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> or <a class="el" href="classregina_1_1ModelLinkGraph.html#ab574d5b77af06b93deaf6de05d67b671" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> functions, into a <a class="el" href="classregina_1_1ModelLinkGraph.html" title="Represents an undirected 4-valent planar graph with a specific planar embedding.">ModelLinkGraph</a> object that Regina can work with directly.</p>
<p >If you are converting output from <em>plantri</em>, this output must be in ASCII format, and must be the dual graph of a simple quadrangulation of the sphere. The corresponding flags that must be passed to <em>plantri</em> to obtain such output are <code>-adq</code> (although you will may wish to pass additional flags to expand or restrict the classes of graphs that <em>plantri</em> builds).</p>
<p >When run with these flags, <em>plantri</em> produces output in the following form:</p>
<pre class="fragment">6 bbcd,adca,abee,affb,cffc,deed
6 bcdd,aeec,abfd,acfa,bffb,ceed
6 bcde,affc,abfd,acee,addf,becb
</pre><p >Each line consists of an integer (the number of nodes in the graph), followed by a comma-separated sequence of alphabetical strings that encode the edges leaving each node.</p>
<p >This function <em>only</em> takes the comma-separated sequence of alphabetical strings. So, for example, to construct the graph corresponding to the second line of output above, you could call:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1">fromPlantri</a>(<span class="stringliteral">&quot;bcdd,aeec,abfd,acfa,bffb,ceed&quot;</span>);</div>
<div class="ttc" id="aclassregina_1_1ModelLinkGraph_html_a806a72e571ad5c1f2c3e8c79bdbf7af1"><div class="ttname"><a href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1">regina::ModelLinkGraph::fromPlantri</a></div><div class="ttdeci">static ModelLinkGraph fromPlantri(const std::string &amp;plantri)</div><div class="ttdoc">Builds a graph from a line of plantri output, using Regina's variant of the plantri ASCII format.</div></div>
</div><!-- fragment --><p >Regina uses its own variant of <em>plantri's</em> output format, which is identical for smaller graphs but which differs from <em>plantri's</em> own output format for larger graphs. In particular:</p>
<ul>
<li>For graphs with 26 nodes, Regina and <em>plantri</em> use identical formats. Here Regina can happily recognise the output from <em>plantri</em> as described above, as well as the output from Regina's own <a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> and <a class="el" href="classregina_1_1ModelLinkGraph.html#ab574d5b77af06b93deaf6de05d67b671" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> functions.</li>
<li>For graphs with 27-52 nodes, Regina's and <em>plantri's</em> formats differ: whereas <em>plantri</em> uses punctuation for higher-index nodes, Regina uses the upper-case letters <code>A</code>,...,<code>Z</code>. For these larger graphs, Regina can only recognise Regina's own <a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> and <a class="el" href="classregina_1_1ModelLinkGraph.html#ab574d5b77af06b93deaf6de05d67b671" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> output, not <em>plantri's</em> punctuation-based encodings.</li>
<li>For graphs with 53 nodes or more, Regina cannot encode or decode such graphs using <em>plantri</em> format at all.</li>
</ul>
<p >Even for graphs with at most 26 nodes, the given string does not <em>need</em> to be come from the program <em>plantri</em> itself. Whereas <em>plantri</em> always outputs graphs with a particular canonical labelling, this function can accept an arbitrary ordering of nodes and arcs - in particular, it can accept the string <code>g.plantri()</code> for any graph <em>g</em> that meets the preconditions below. Nevertheless, the graph must still meet these preconditions, since otherwise the <em>plantri</em> format might not be enough to uniquely reconstruct the graph and its planar embedding.</p>
<p >This routine can also interpret the "tight" format that is optionally produced by the member function <a class="el" href="classregina_1_1ModelLinkGraph.html#ab574d5b77af06b93deaf6de05d67b671" title="Outputs a text representation of this graph in a variant of the plantri ASCII format,...">canonicalPlantri()</a> (even though such output would certainly <em>not</em> be produced by the program <em>plantri</em>).</p>
<dl class="section warning"><dt>Warning</dt><dd>While this routine does some basic error checking on the input, these checks are not exhaustive. In particular, it does <em>not</em> test for planarity of the graph. (Of course <em>plantri</em> does not output non-planar graphs, but a user could still construct one by hand and passes it to this routine, in which case the resulting behaviour is undefined.)</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The graph being described is connected. </dd>
<dd>
The graph being described is dual to a <em>simple</em> quadrangulation of the sphere. In particular, the dual must not have any parallel edges. Note that any graph that fails this condition will the model graph for a link diagram that is an "obvious" connected sum.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The input was not a valid representation of a graph using the <em>plantri</em> output format. As noted above, the checks performed here are not exhaustive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plantri</td><td>a string containing the comma-separated sequence of alphabetical strings in <em>plantri</em> format, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting graph. </dd></dl>

</div>
</div>
<a id="a7eebfc992fb1fb0e11a5ba620d88db0a" name="a7eebfc992fb1fb0e11a5ba620d88db0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eebfc992fb1fb0e11a5ba620d88db0a">&#9670;&nbsp;</a></span>generateMinimalLinks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Action , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::generateMinimalLinks </td>
          <td>(</td>
          <td class="paramtype">Action &amp;&amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exhaustively generates potentially-minimal knot diagrams that are modelled by this graph. </p>
<p >Here <em>potentially-minimal</em> means there are no "obvious" simplification moves (such as a simplifying type II Reidemeister move, for example). The list of "obvious" moves considered here is subject to change in future versions of Regina.</p>
<p >By <em>exhaustive</em>, we mean:</p>
<ul>
<li>Every minimal knot diagram modelled by this graph will be generated by this routine, up to reflection and/or reversal (as noted below).</li>
<li>If a knot diagram is non-minimal and modelled by this graph, it <em>might</em> still be generated by this routine.</li>
</ul>
<p >In other words, this routine will generate all minimal knot diagrams modelled by this graph, but there is no promise that all of the diagrams generated are minimal.</p>
<p >Labelled diagrams are only generated once up to reflection and/or reversal, in that this routine will fix the orientation of the knot (always following arc 0 away from node 0 of the graph) and the sign of the crossing at node 0 (always positive).</p>
<p >In each knot diagram that is generated, crossing <em>k</em> will always correspond to node <em>k</em> of this graph.</p>
<p >For each knot diagram that is generated, this routine will call <em>action</em> (which must be a function or some other callable object).</p>
<ul>
<li>The first argument passed to <em>action</em> will be the knot diagram that was generated (of type <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>). This will be passed as an rvalue; a typical action could (for example) take it by const reference and query it, or take it by value and modify it, or take it by rvalue reference and move it into more permanent storage.</li>
<li>If there are any additional arguments supplied in the list <em>args</em>, then these will be passed as subsequent arguments to <em>action</em>.</li>
<li><em>action</em> must return <code>void</code>.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>This graph does not model multiple-component links (i.e., either it models single-component knots, or it is the empty graph).</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This graph models links with more than one component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class or function has not yet been finalised. This means that the interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please check the detailed changelog with each new release to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is available in Python, and the <em>action</em> argument may be a pure Python function. However, its form is more restricted: the argument <em>args</em> is removed, so you simply call it as generateMinimalLinks(action). Moreover, <em>action</em> must take exactly one argument (the knot diagram).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>a function (or other callable object) to call for each knot diagram that is generated. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>action</em>, following the initial knot diagram argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32048d7c0d574234df71c03cf8afcb33" name="a32048d7c0d574234df71c03cf8afcb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32048d7c0d574234df71c03cf8afcb33">&#9670;&nbsp;</a></span>node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraphNode.html">ModelLinkGraphNode</a> * regina::ModelLinkGraph::node </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the node at the given index within this graph. </p>
<p >For a graph with <em>n</em> nodes, the nodes are numbered from 0 to <em>n</em>-1 inclusive.</p>
<dl class="section warning"><dt>Warning</dt><dd>If some nodes are added or removed then the indices of other nodes might change. If you wish to track a particular node through such operations then you should use the pointer to the relevant <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> object instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested node. This must be between 0 and <a class="el" href="classregina_1_1ModelLinkGraph.html#a8ae830ab12408759e526ae15d16e0be5" title="Returns the number of nodes in this graph.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node at the given index. </dd></dl>

</div>
</div>
<a id="a6491eff8e0ab206c0d750bc7bed6abd1" name="a6491eff8e0ab206c0d750bc7bed6abd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6491eff8e0ab206c0d750bc7bed6abd1">&#9670;&nbsp;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::ModelLinkGraph::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all nodes in this graph. </p>
<p >The object that is returned is lightweight, and can be happily copied by value. The C++ type of the object is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<p >The returned object is guaranteed to be an instance of <a class="el" href="classregina_1_1ListView.html" title="A lightweight object that can be used for iteration and random access to all elements of a given list...">ListView</a>, which means it offers basic container-like functions and supports range-based <code>for</code> loops. Note that the elements of the list will be pointers, so your code might look like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (ModelLinkGraphNode* n : graph.nodes()) { ... }</div>
</div><!-- fragment --><p >The object that is returned will remain up-to-date and valid for as long as the graph exists: even if nodes are added and/or removed, it will always reflect the nodes that are currently in the graph. Nevertheless, it is recommended to treat this object as temporary only, and to call <a class="el" href="classregina_1_1ModelLinkGraph.html#a6491eff8e0ab206c0d750bc7bed6abd1" title="Returns an object that allows iteration through and random access to all nodes in this graph.">nodes()</a> again each time you need it.</p>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all nodes. </dd></dl>

</div>
</div>
<a id="a17913a39fd8bf03cb6bb06f64d4a65af" name="a17913a39fd8bf03cb6bb06f64d4a65af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17913a39fd8bf03cb6bb06f64d4a65af">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraph::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this graph is not combinatorially identical to the given graph. </p>
<p >Here "identical" means that both graphs have the same number of nodes, and in both graphs the same pairs of outgoing arcs of numbered nodes are connected by edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the graph to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two graphs are not combinatorially identical. </dd></dl>

</div>
</div>
<a id="a8cdc89ae4b81f1415856e3812e48f8dd" name="a8cdc89ae4b81f1415856e3812e48f8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdc89ae4b81f1415856e3812e48f8dd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp; regina::ModelLinkGraph::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the graph to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this graph. </dd></dl>

</div>
</div>
<a id="aec906b2e6ce954c638dfe21c4b3d49bc" name="aec906b2e6ce954c638dfe21c4b3d49bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec906b2e6ce954c638dfe21c4b3d49bc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp; regina::ModelLinkGraph::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given graph into this graph. </p>
<p >This is a fast (constant time) operation.</p>
<p >All nodes and cells that belong to <em>src</em> will be moved into this graph, and so any <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> or <a class="el" href="classregina_1_1ModelLinkGraphCells.html" title="Describes the cellular decomposition of the sphere that is induced by a given planar 4-valent graph.">ModelLinkGraphCells</a> pointers or references will remain valid.</p>
<p >The graph that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the graph to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this graph. </dd></dl>

</div>
</div>
<a id="ae2238ea1d3a224c1737ec6c66bdfd5d5" name="ae2238ea1d3a224c1737ec6c66bdfd5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2238ea1d3a224c1737ec6c66bdfd5d5">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ModelLinkGraph::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this graph is combinatorially identical to the given graph. </p>
<p >Here "identical" means that both graphs have the same number of nodes, and in both graphs the same pairs of outgoing arcs of numbered nodes are connected by edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the graph to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two graphs are combinatorially identical. </dd></dl>

</div>
</div>
<a id="a3b794563bcc89728bf2dab6f6952a5c5" name="a3b794563bcc89728bf2dab6f6952a5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b794563bcc89728bf2dab6f6952a5c5">&#9670;&nbsp;</a></span>plantri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::ModelLinkGraph::plantri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this graph in a variant of the ASCII text format used by <em>plantri</em>. </p>
<p >The software <em>plantri</em>, by Gunnar Brinkmann and Brendan McKay, can be used to enumerate 4-valent planar graphs (amongst many other things). This routine outputs this graph in a format that mimics <em>plantri's</em> own dual ASCII format (i.e., the format that <em>plantri</em> outputs when run with the flags <code>-adq</code>).</p>
<p >Specifically, the output will be a comma-separated sequence of alphabetical strings. The <em>i</em>th such string will consist of four letters, encoding the endpoints of the four edges in clockwise order that leave node <em>i</em>. The lower-case letters <code>a</code>,<code>b</code>,...,<code>z</code> represent nodes 0,1,...,25 respectively, and the upper-case letters <code>A</code>,<code>B</code>,...,<code>Z</code> represent nodes 26,27,...,51 respectively. An example of such a string is:</p>
<pre class="fragment">bcdd,aeec,abfd,acfa,bffb,ceed
</pre><p >For graphs with at most 26 nodes, this is identical to <em>plantri's</em> own dual ASCII format. For larger graphs, this format differs: <em>plantri</em> uses punctuation to represent higher-index nodes, whereas Regina uses upper-case letters.</p>
<p >This routine is an inverse to <a class="el" href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a>: for any graph <em>g</em> that satisfies the preconditions below, <code>fromPlantri(g.plantri())</code> is identical to <em>g</em>. Likewise, for any string <em>s</em> that satisfies the preconditions for <a class="el" href="classregina_1_1ModelLinkGraph.html#a806a72e571ad5c1f2c3e8c79bdbf7af1" title="Builds a graph from a line of plantri output, using Regina&#39;s variant of the plantri ASCII format.">fromPlantri()</a>, calling <code>fromPlantri(s).<a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a></code> will recover the original string <em>s</em>.</p>
<p >It is important to note the preconditions below: in particular, that this graph must be dual to a <em>simple</em> quadrangulation of the sphere. This is because the planar embeddings for more general graphs (i.e., the duals of non-simple quadrangulations) cannot always be uniquely reconstructed from their <em>plantri</em> output.</p>
<dl class="section note"><dt>Note</dt><dd>The output of this function might not correspond to any possible output from the program <em>plantri</em> itself, even if only lower-case letters are used. This is because <em>plantri</em> only outputs graphs with a certain canonical labelling. In contrast, <a class="el" href="classregina_1_1ModelLinkGraph.html#a3b794563bcc89728bf2dab6f6952a5c5" title="Outputs this graph in a variant of the ASCII text format used by plantri.">plantri()</a> can be called on any graph that satisfies the preconditions below, and it will preserve the labels of the nodes and the order of the arcs around each node.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This graph is connected. </dd>
<dd>
This graph has between 1 and 52 nodes inclusive. </dd>
<dd>
The dual to this graph is a <em>simple</em> quadrangulation of the sphere. In particular, the dual must not have any parallel edges. Note that any graph that fails this condition will the model graph for a link diagram that is an "obvious" connected sum.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1FailedPrecondition.html" title="An exception thrown when a function detects that its preconditions have been violated.">FailedPrecondition</a></td><td>This graph has more than 52 nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <em>plantri</em> format ASCII representation of this graph. </dd></dl>

</div>
</div>
<a id="ad89a103eeda5359e83684d10b5f3444d" name="ad89a103eeda5359e83684d10b5f3444d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89a103eeda5359e83684d10b5f3444d">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this graph into its reflection. </p>
<p >This routine simply reverses (and also cycles) the order of outgoing arcs around every node. </p>

</div>
</div>
<a id="a8ae830ab12408759e526ae15d16e0be5" name="a8ae830ab12408759e526ae15d16e0be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae830ab12408759e526ae15d16e0be5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::ModelLinkGraph::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of nodes in this graph. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a28801826ec5d301697db8576eded1f10" name="a28801826ec5d301697db8576eded1f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28801826ec5d301697db8576eded1f10">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given graph. </p>
<p >All nodes that belong to this graph will be moved to <em>other</em>, and all nodes that belong to <em>other</em> will be moved to this graph.</p>
<p >In particular, any <a class="el" href="classregina_1_1ModelLinkGraphNode.html" title="Represents a single node in a model graph for a knot or link.">ModelLinkGraphNode</a> pointers or references and any <a class="el" href="classregina_1_1ModelLinkGraphArc.html" title="A reference to an outgoing edge from a node of a model graph for a knot or link.">ModelLinkGraphArc</a> objects will remain valid.</p>
<p >This routine will behave correctly if <em>other</em> is in fact this graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the graph whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1ModelLinkGraph.html">ModelLinkGraph</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a89355292f9354c4d8bfc7d5468ee26f5" name="a89355292f9354c4d8bfc7d5468ee26f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89355292f9354c4d8bfc7d5468ee26f5">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this graph to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab4b88c8eb92b6c9abe6f557c3221486" name="aab4b88c8eb92b6c9abe6f557c3221486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4b88c8eb92b6c9abe6f557c3221486">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::ModelLinkGraph::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this graph to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="modellinkgraph_8h.html">modellinkgraph.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
