<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::HomMarkedAbelianGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1HomMarkedAbelianGroup-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::HomMarkedAbelianGroup Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a homomorphism of finitely generated abelian groups.  
 <a href="classregina_1_1HomMarkedAbelianGroup.html#details">More...</a></p>

<p><code>#include &lt;algebra/markedabeliangroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::HomMarkedAbelianGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1HomMarkedAbelianGroup.png" usemap="#regina::HomMarkedAbelianGroup_map" alt=""/>
  <map id="regina::HomMarkedAbelianGroup_map" name="regina::HomMarkedAbelianGroup_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; HomMarkedAbelianGroup &gt;" shape="rect" coords="0,0,261,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7be18993f642abaa043be01bf5b9023b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a7be18993f642abaa043be01bf5b9023b">HomMarkedAbelianGroup</a> (<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> dom, <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> codom, <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> mat)</td></tr>
<tr class="memdesc:a7be18993f642abaa043be01bf5b9023b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a homomorphism from two marked abelian groups and a matrix that indicates where the generators are sent.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a7be18993f642abaa043be01bf5b9023b">More...</a><br /></td></tr>
<tr class="separator:a7be18993f642abaa043be01bf5b9023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ddef3a46ce80f3b47623e6f5ae05d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a29ddef3a46ce80f3b47623e6f5ae05d4">HomMarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:a29ddef3a46ce80f3b47623e6f5ae05d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a29ddef3a46ce80f3b47623e6f5ae05d4">More...</a><br /></td></tr>
<tr class="separator:a29ddef3a46ce80f3b47623e6f5ae05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4833b15d45392e93119147d16aa59d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ac4833b15d45392e93119147d16aa59d3">HomMarkedAbelianGroup</a> (<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:ac4833b15d45392e93119147d16aa59d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given homomorphism into this new homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#ac4833b15d45392e93119147d16aa59d3">More...</a><br /></td></tr>
<tr class="separator:ac4833b15d45392e93119147d16aa59d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf6b2ec24def953b4574ff1b41b8812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#aabf6b2ec24def953b4574ff1b41b8812">operator=</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;)=default</td></tr>
<tr class="memdesc:aabf6b2ec24def953b4574ff1b41b8812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#aabf6b2ec24def953b4574ff1b41b8812">More...</a><br /></td></tr>
<tr class="separator:aabf6b2ec24def953b4574ff1b41b8812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0c72bf23b3fad88839681cd72f4ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#aed0c72bf23b3fad88839681cd72f4ce7">operator=</a> (<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aed0c72bf23b3fad88839681cd72f4ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given homomorphism to this homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#aed0c72bf23b3fad88839681cd72f4ce7">More...</a><br /></td></tr>
<tr class="separator:aed0c72bf23b3fad88839681cd72f4ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e2b568fb434264c637a4adc3c7a1b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a06e2b568fb434264c637a4adc3c7a1b1">swap</a> (<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a06e2b568fb434264c637a4adc3c7a1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a06e2b568fb434264c637a4adc3c7a1b1">More...</a><br /></td></tr>
<tr class="separator:a06e2b568fb434264c637a4adc3c7a1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d30febe413482babd2ab43d01f6950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad3d30febe413482babd2ab43d01f6950">isChainMap</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:ad3d30febe413482babd2ab43d01f6950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given homomorphism together form a chain map.  <a href="classregina_1_1HomMarkedAbelianGroup.html#ad3d30febe413482babd2ab43d01f6950">More...</a><br /></td></tr>
<tr class="separator:ad3d30febe413482babd2ab43d01f6950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5bd0951ee72da6cd1ce3f3df090389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ada5bd0951ee72da6cd1ce3f3df090389">isCycleMap</a> () const</td></tr>
<tr class="memdesc:ada5bd0951ee72da6cd1ce3f3df090389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this at least a cycle map? If not, pretty much any further computations you try with this class will be give you nothing more than carefully-crafted garbage.  <a href="classregina_1_1HomMarkedAbelianGroup.html#ada5bd0951ee72da6cd1ce3f3df090389">More...</a><br /></td></tr>
<tr class="separator:ada5bd0951ee72da6cd1ce3f3df090389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97881fce1ecb435c23f9aac5ee2d5f15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a97881fce1ecb435c23f9aac5ee2d5f15">isEpic</a> () const</td></tr>
<tr class="memdesc:a97881fce1ecb435c23f9aac5ee2d5f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an epic homomorphism?  <a href="classregina_1_1HomMarkedAbelianGroup.html#a97881fce1ecb435c23f9aac5ee2d5f15">More...</a><br /></td></tr>
<tr class="separator:a97881fce1ecb435c23f9aac5ee2d5f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ed7cbfa00a9a9ca3a63cd9e046cfda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad4ed7cbfa00a9a9ca3a63cd9e046cfda">isMonic</a> () const</td></tr>
<tr class="memdesc:ad4ed7cbfa00a9a9ca3a63cd9e046cfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a monic homomorphism?  <a href="classregina_1_1HomMarkedAbelianGroup.html#ad4ed7cbfa00a9a9ca3a63cd9e046cfda">More...</a><br /></td></tr>
<tr class="separator:ad4ed7cbfa00a9a9ca3a63cd9e046cfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8303e2ed95989253fb385a8e2207d4f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a8303e2ed95989253fb385a8e2207d4f6">isIsomorphism</a> () const</td></tr>
<tr class="memdesc:a8303e2ed95989253fb385a8e2207d4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an isomorphism?  <a href="classregina_1_1HomMarkedAbelianGroup.html#a8303e2ed95989253fb385a8e2207d4f6">More...</a><br /></td></tr>
<tr class="separator:a8303e2ed95989253fb385a8e2207d4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65f49b1eb7f9cdf8319addb2346d6cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ad65f49b1eb7f9cdf8319addb2346d6cf">isZero</a> () const</td></tr>
<tr class="memdesc:ad65f49b1eb7f9cdf8319addb2346d6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the zero map?  <a href="classregina_1_1HomMarkedAbelianGroup.html#ad65f49b1eb7f9cdf8319addb2346d6cf">More...</a><br /></td></tr>
<tr class="separator:ad65f49b1eb7f9cdf8319addb2346d6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd7a747825f74d559cb7d4201f3d304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a3fd7a747825f74d559cb7d4201f3d304">isIdentity</a> () const</td></tr>
<tr class="memdesc:a3fd7a747825f74d559cb7d4201f3d304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the identity automorphism?  <a href="classregina_1_1HomMarkedAbelianGroup.html#a3fd7a747825f74d559cb7d4201f3d304">More...</a><br /></td></tr>
<tr class="separator:a3fd7a747825f74d559cb7d4201f3d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4af77bb38803daeda947b6e1f0a38f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#abc4af77bb38803daeda947b6e1f0a38f">kernel</a> () const</td></tr>
<tr class="memdesc:abc4af77bb38803daeda947b6e1f0a38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kernel of this homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#abc4af77bb38803daeda947b6e1f0a38f">More...</a><br /></td></tr>
<tr class="separator:abc4af77bb38803daeda947b6e1f0a38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12613d8f2b01aa14ee4dda57a0eebef3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a12613d8f2b01aa14ee4dda57a0eebef3">cokernel</a> () const</td></tr>
<tr class="memdesc:a12613d8f2b01aa14ee4dda57a0eebef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cokernel of this homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a12613d8f2b01aa14ee4dda57a0eebef3">More...</a><br /></td></tr>
<tr class="separator:a12613d8f2b01aa14ee4dda57a0eebef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737a67b0c00ae7811e2b41c7cb1700ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a737a67b0c00ae7811e2b41c7cb1700ac">image</a> () const</td></tr>
<tr class="memdesc:a737a67b0c00ae7811e2b41c7cb1700ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the image of this homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a737a67b0c00ae7811e2b41c7cb1700ac">More...</a><br /></td></tr>
<tr class="separator:a737a67b0c00ae7811e2b41c7cb1700ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147df2f57189a2039473fa0450549273"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a147df2f57189a2039473fa0450549273">summary</a> () const</td></tr>
<tr class="memdesc:a147df2f57189a2039473fa0450549273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a very brief summary of the type of map.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a147df2f57189a2039473fa0450549273">More...</a><br /></td></tr>
<tr class="separator:a147df2f57189a2039473fa0450549273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9520648138138bf2f4804d03a42a6b5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a9520648138138bf2f4804d03a42a6b5f">summary</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a9520648138138bf2f4804d03a42a6b5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a very brief summary of the type of map to the given output stream.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a9520648138138bf2f4804d03a42a6b5f">More...</a><br /></td></tr>
<tr class="separator:a9520648138138bf2f4804d03a42a6b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2779b4feadb621b496a2ec8e6f8eadc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2779b4feadb621b496a2ec8e6f8eadc4">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a2779b4feadb621b496a2ec8e6f8eadc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a2779b4feadb621b496a2ec8e6f8eadc4">More...</a><br /></td></tr>
<tr class="separator:a2779b4feadb621b496a2ec8e6f8eadc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd028394928cbaba6ce8cfe28c96f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#aafd028394928cbaba6ce8cfe28c96f97">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aafd028394928cbaba6ce8cfe28c96f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1HomMarkedAbelianGroup.html#aafd028394928cbaba6ce8cfe28c96f97">More...</a><br /></td></tr>
<tr class="separator:aafd028394928cbaba6ce8cfe28c96f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6ad98271d7a7e95931ead6e727309c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5b6ad98271d7a7e95931ead6e727309c">domain</a> () const</td></tr>
<tr class="memdesc:a5b6ad98271d7a7e95931ead6e727309c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the domain of this homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a5b6ad98271d7a7e95931ead6e727309c">More...</a><br /></td></tr>
<tr class="separator:a5b6ad98271d7a7e95931ead6e727309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098130bb9d929eb125f93de20008619"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ab098130bb9d929eb125f93de20008619">codomain</a> () const</td></tr>
<tr class="memdesc:ab098130bb9d929eb125f93de20008619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the codomain of this homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#ab098130bb9d929eb125f93de20008619">More...</a><br /></td></tr>
<tr class="separator:ab098130bb9d929eb125f93de20008619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d1d62efe5d42f9914693969e3e4b6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a81d1d62efe5d42f9914693969e3e4b6f">definingMatrix</a> () const</td></tr>
<tr class="memdesc:a81d1d62efe5d42f9914693969e3e4b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the defining matrix for the homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a81d1d62efe5d42f9914693969e3e4b6f">More...</a><br /></td></tr>
<tr class="separator:a81d1d62efe5d42f9914693969e3e4b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106dcb279e4294694478447f2dc06639"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a106dcb279e4294694478447f2dc06639">reducedMatrix</a> () const</td></tr>
<tr class="memdesc:a106dcb279e4294694478447f2dc06639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the internal reduced matrix representing the homomorphism.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a106dcb279e4294694478447f2dc06639">More...</a><br /></td></tr>
<tr class="separator:a106dcb279e4294694478447f2dc06639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556d13e904b6fb7716b1f0e767fb009c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a556d13e904b6fb7716b1f0e767fb009c">evalCC</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:a556d13e904b6fb7716b1f0e767fb009c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the image of a vector under this homomorphism, using the original chain complexes' coordinates.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a556d13e904b6fb7716b1f0e767fb009c">More...</a><br /></td></tr>
<tr class="separator:a556d13e904b6fb7716b1f0e767fb009c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8888ac88c4c68bc8737a6824a3024df4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a8888ac88c4c68bc8737a6824a3024df4">evalSNF</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:a8888ac88c4c68bc8737a6824a3024df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the image of a vector under this homomorphism, using the Smith normal form coordinates.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a8888ac88c4c68bc8737a6824a3024df4">More...</a><br /></td></tr>
<tr class="separator:a8888ac88c4c68bc8737a6824a3024df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98817af093689b1c8ec4af15c253cd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ae98817af093689b1c8ec4af15c253cd2">inverseHom</a> () const</td></tr>
<tr class="memdesc:ae98817af093689b1c8ec4af15c253cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse to a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>.  <a href="classregina_1_1HomMarkedAbelianGroup.html#ae98817af093689b1c8ec4af15c253cd2">More...</a><br /></td></tr>
<tr class="separator:ae98817af093689b1c8ec4af15c253cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bbc1c2ab790e207534ab1ac092fd29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a05bbc1c2ab790e207534ab1ac092fd29">operator*</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;X) const</td></tr>
<tr class="memdesc:a05bbc1c2ab790e207534ab1ac092fd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the composition of two homomorphisms.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a05bbc1c2ab790e207534ab1ac092fd29">More...</a><br /></td></tr>
<tr class="separator:a05bbc1c2ab790e207534ab1ac092fd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5100354c55ea8e1339233f225d0d214f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5100354c55ea8e1339233f225d0d214f">operator*</a> (<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&amp;X) const</td></tr>
<tr class="memdesc:a5100354c55ea8e1339233f225d0d214f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the composition of two homomorphisms.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a5100354c55ea8e1339233f225d0d214f">More...</a><br /></td></tr>
<tr class="separator:a5100354c55ea8e1339233f225d0d214f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e1621082ba71e03eeb72562051497c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a65e1621082ba71e03eeb72562051497c">torsionSubgroup</a> () const</td></tr>
<tr class="memdesc:a65e1621082ba71e03eeb72562051497c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the induced map on the torsion subgroups.  <a href="classregina_1_1HomMarkedAbelianGroup.html#a65e1621082ba71e03eeb72562051497c">More...</a><br /></td></tr>
<tr class="separator:a65e1621082ba71e03eeb72562051497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a homomorphism of finitely generated abelian groups. </p>
<p >One initializes such a homomorphism by providing:</p>
<ul>
<li>two finitely generated abelian groups, which act as domain and codomain;</li>
<li>a matrix describing the linear map between the free abelian groups in the centres of the respective chain complexes that were used to define the domain and codomain. If the abelian groups are computed via homology with coefficients, the codomain coefficients must be a quotient of the domain coefficients.</li>
</ul>
<p >So for example, if the domain was initialized by the chain complex <code>Z^a --A--&gt; Z^b --B--&gt; Z^c</code> with mod p coefficients, and the codomain was initialized by <code>Z^d --D--&gt; Z^e --E--&gt; Z^f</code> with mod q coefficients, then the matrix needs to be an e-by-b matrix. Furthermore, you only obtain a well-defined homomorphism if this matrix extends to a cycle map, which this class assumes but which the user can confirm with <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ada5bd0951ee72da6cd1ce3f3df090389" title="Is this at least a cycle map? If not, pretty much any further computations you try with this class wi...">isCycleMap()</a>. Moreover, <em>q</em> should divide <em>p:</em> this allows for <em>q</em> &gt; 0 and <em>p</em> = 0, which means the domain has Z coefficients and the codomain has mod <em>q</em> coefficients.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> preImageOf in CC and SNF coordinates. This routine would return a generating list of elements in the preimage, thought of as an affine subspace. Or maybe just one element together with the kernel inclusion. IMO smarter to be a list because that way there's a more pleasant way to make it empty. Or we could have a variety of routines among these themes. Store some minimal data for efficient computations of preImage, eventually replacing the internals of <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ae98817af093689b1c8ec4af15c253cd2" title="Returns the inverse to a HomMarkedAbelianGroup.">inverseHom()</a> with a more flexible set of tools. Also add an isInImage() in various coordinates.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a2779b4feadb621b496a2ec8e6f8eadc4" title="Writes a short text representation of this object to the given output stream.">writeTextShort()</a> have completely different set of descriptors if an endomorphism domain = codomain (not so important at the moment though). New descriptors would include things like automorphism, projection, differential, finite order, etc.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Add map factorization, so that every homomorphism can be split as a composite of a projection followed by an inclusion. Add kernelInclusion(), coKerMap(), etc. Add a liftMap() call, i.e., a procedure to find a lift of a map if one exists.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7be18993f642abaa043be01bf5b9023b" name="a7be18993f642abaa043be01bf5b9023b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be18993f642abaa043be01bf5b9023b">&#9670;&nbsp;</a></span>HomMarkedAbelianGroup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td>
          <td class="paramname"><em>codom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a homomorphism from two marked abelian groups and a matrix that indicates where the generators are sent. </p>
<p >The roles of the two groups and the matrix are described in detail in the <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> class overview.</p>
<p >The matrix must be given in the chain-complex coordinates. Specifically, if the domain was defined via the chain complex <code>Z^a --N1--&gt; Z^b --M1--&gt; Z^c</code> and the codomain was defined via <code>Z^d --N2--&gt; Z^e --M2--&gt; Z^f</code>, then <em>mat</em> is an e-by-b matrix that describes a homomorphism from Z^b to Z^e.</p>
<p >In order for this to make sense as a homomorphism of the groups represented by the domain and codomain respectively, one requires <code>img(mat×N1)</code> to be a subset of img(N2). Similarly, ker(M1) must be sent into ker(M2). These facts are not checked, but are assumed as preconditions of this constructor.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The matrix <em>mat</em> has the required dimensions e-by-b, gives <code>img(mat×N1)</code> as a subset of img(N2), and sends ker(M1) into ker(M2), as explained in the detailed notes above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dom</td><td>the domain group. </td></tr>
    <tr><td class="paramname">codom</td><td>the codomain group. </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix that describes the homomorphism from <em>dom</em> to <em>ran</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29ddef3a46ce80f3b47623e6f5ae05d4" name="a29ddef3a46ce80f3b47623e6f5ae05d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ddef3a46ce80f3b47623e6f5ae05d4">&#9670;&nbsp;</a></span>HomMarkedAbelianGroup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given homomorphism. </p>

</div>
</div>
<a id="ac4833b15d45392e93119147d16aa59d3" name="ac4833b15d45392e93119147d16aa59d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4833b15d45392e93119147d16aa59d3">&#9670;&nbsp;</a></span>HomMarkedAbelianGroup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given homomorphism into this new homomorphism. </p>
<p >This is a fast (constant time) operation.</p>
<p >The homomorphism that was passed will no longer be usable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab098130bb9d929eb125f93de20008619" name="ab098130bb9d929eb125f93de20008619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab098130bb9d929eb125f93de20008619">&#9670;&nbsp;</a></span>codomain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::codomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the codomain of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the codomain that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a id="a12613d8f2b01aa14ee4dda57a0eebef3" name="a12613d8f2b01aa14ee4dda57a0eebef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12613d8f2b01aa14ee4dda57a0eebef3">&#9670;&nbsp;</a></span>cokernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::cokernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the cokernel of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the cokernel of the homomorphism. </dd></dl>

</div>
</div>
<a id="a81d1d62efe5d42f9914693969e3e4b6f" name="a81d1d62efe5d42f9914693969e3e4b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d1d62efe5d42f9914693969e3e4b6f">&#9670;&nbsp;</a></span>definingMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::HomMarkedAbelianGroup::definingMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the defining matrix for the homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the matrix that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a5b6ad98271d7a7e95931ead6e727309c" name="a5b6ad98271d7a7e95931ead6e727309c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6ad98271d7a7e95931ead6e727309c">&#9670;&nbsp;</a></span>domain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the domain of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the domain that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a id="a556d13e904b6fb7716b1f0e767fb009c" name="a556d13e904b6fb7716b1f0e767fb009c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556d13e904b6fb7716b1f0e767fb009c">&#9670;&nbsp;</a></span>evalCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::HomMarkedAbelianGroup::evalCC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the image of a vector under this homomorphism, using the original chain complexes' coordinates. </p>
<p >This involves multiplication by the defining matrix.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given vector was not in the original chain complex coordinates; that is, its length was not <code><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5b6ad98271d7a7e95931ead6e727309c" title="Returns the domain of this homomorphism.">domain()</a>.M().columns()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in the domain chain complex's coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5b6ad98271d7a7e95931ead6e727309c" title="Returns the domain of this homomorphism.">domain()</a>.M().columns(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this vector in the codomain chain complex's coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ab098130bb9d929eb125f93de20008619" title="Returns the codomain of this homomorphism.">codomain()</a>.M().columns(). </dd></dl>

</div>
</div>
<a id="a8888ac88c4c68bc8737a6824a3024df4" name="a8888ac88c4c68bc8737a6824a3024df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8888ac88c4c68bc8737a6824a3024df4">&#9670;&nbsp;</a></span>evalSNF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; regina::HomMarkedAbelianGroup::evalSNF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#gaf4fe1fc0f2a3c4ac640ba856e3f50fa6">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the image of a vector under this homomorphism, using the Smith normal form coordinates. </p>
<p >This is just multiplication by the reduced matrix.</p>
<dl class="section warning"><dt>Warning</dt><dd>Smith normal form coordinates are sensitive to the implementation of the Smith Normal Form, i.e., they are not canonical.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The given vector was not in domain SNF coordinates; that is, its length was not <code><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5b6ad98271d7a7e95931ead6e727309c" title="Returns the domain of this homomorphism.">domain()</a>.snfRank()</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in the domain SNF coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a5b6ad98271d7a7e95931ead6e727309c" title="Returns the domain of this homomorphism.">domain()</a>.snfRank(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this vector in the codomain chain complex's coordinates, of length <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#ab098130bb9d929eb125f93de20008619" title="Returns the codomain of this homomorphism.">codomain()</a>.snfRank(). </dd></dl>

</div>
</div>
<a id="a737a67b0c00ae7811e2b41c7cb1700ac" name="a737a67b0c00ae7811e2b41c7cb1700ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737a67b0c00ae7811e2b41c7cb1700ac">&#9670;&nbsp;</a></span>image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the image of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the image of the homomorphism. </dd></dl>

</div>
</div>
<a id="ae98817af093689b1c8ec4af15c253cd2" name="ae98817af093689b1c8ec4af15c253cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98817af093689b1c8ec4af15c253cd2">&#9670;&nbsp;</a></span>inverseHom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> regina::HomMarkedAbelianGroup::inverseHom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inverse to a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>. </p>
<p >If this homomorphism is not invertible, this routine returns the zero homomorphism.</p>
<p >If you are computing with mod-p coefficients, this routine will further require that this invertible map preserves the UCT splitting of the group, i.e., it gives an isomorphism of the tensor product parts and the TOR parts. At present this suffices since we're only using this to construct maps between homology groups in different coordinate systems.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse homomorphism, or the zero homomorphism if this is not invertible. </dd></dl>

</div>
</div>
<a id="ad3d30febe413482babd2ab43d01f6950" name="ad3d30febe413482babd2ab43d01f6950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d30febe413482babd2ab43d01f6950">&#9670;&nbsp;</a></span>isChainMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isChainMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given homomorphism together form a chain map. </p>
<p >Given two HomMarkedAbelianGroups, you have two diagrams: </p><pre>
Z^a --N1--&gt; Z^b --M1--&gt; Z^c   Z^g --N3--&gt; Z^h --M3--&gt; Z^i
                  ^                             ^
                  |this.matrix                  |other.matrix
Z^d --N2--&gt; Z^e --M2--&gt; Z^f   Z^j --N4--&gt; Z^k --M4--&gt; Z^l
</pre><p> If c=g and f=j and M1=N3 and M2=N4, you can ask if these maps commute, i.e., whether you have a map of chain complexes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other homomorphism to analyse in conjunction with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if c=g, M1=N3, f=j, M2=N4, and the diagram commutes. </dd></dl>

</div>
</div>
<a id="ada5bd0951ee72da6cd1ce3f3df090389" name="ada5bd0951ee72da6cd1ce3f3df090389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5bd0951ee72da6cd1ce3f3df090389">&#9670;&nbsp;</a></span>isCycleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isCycleMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this at least a cycle map? If not, pretty much any further computations you try with this class will be give you nothing more than carefully-crafted garbage. </p>
<p >Technically, this routine only checks that cycles are sent to cycles, since it only has access to three of the four maps you need to verify you have a cycle map.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a chain map. </dd></dl>

</div>
</div>
<a id="a97881fce1ecb435c23f9aac5ee2d5f15" name="a97881fce1ecb435c23f9aac5ee2d5f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97881fce1ecb435c23f9aac5ee2d5f15">&#9670;&nbsp;</a></span>isEpic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isEpic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this an epic homomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is epic. </dd></dl>

</div>
</div>
<a id="a3fd7a747825f74d559cb7d4201f3d304" name="a3fd7a747825f74d559cb7d4201f3d304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd7a747825f74d559cb7d4201f3d304">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this the identity automorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the domain and codomain are defined via the same chain complexes and the induced map on homology is the identity. </dd></dl>

</div>
</div>
<a id="a8303e2ed95989253fb385a8e2207d4f6" name="a8303e2ed95989253fb385a8e2207d4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8303e2ed95989253fb385a8e2207d4f6">&#9670;&nbsp;</a></span>isIsomorphism()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isIsomorphism </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this an isomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is an isomorphism. </dd></dl>

</div>
</div>
<a id="ad4ed7cbfa00a9a9ca3a63cd9e046cfda" name="ad4ed7cbfa00a9a9ca3a63cd9e046cfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ed7cbfa00a9a9ca3a63cd9e046cfda">&#9670;&nbsp;</a></span>isMonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isMonic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a monic homomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is monic. </dd></dl>

</div>
</div>
<a id="ad65f49b1eb7f9cdf8319addb2346d6cf" name="ad65f49b1eb7f9cdf8319addb2346d6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65f49b1eb7f9cdf8319addb2346d6cf">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this the zero map? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is the zero map. </dd></dl>

</div>
</div>
<a id="abc4af77bb38803daeda947b6e1f0a38f" name="abc4af77bb38803daeda947b6e1f0a38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4af77bb38803daeda947b6e1f0a38f">&#9670;&nbsp;</a></span>kernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::kernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the kernel of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the kernel of the homomorphism. </dd></dl>

</div>
</div>
<a id="a05bbc1c2ab790e207534ab1ac092fd29" name="a05bbc1c2ab790e207534ab1ac092fd29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bbc1c2ab790e207534ab1ac092fd29">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> regina::HomMarkedAbelianGroup::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the composition of two homomorphisms. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the homomorphisms must be composable, meaning that the codomain of X must have the same presentation matrices as the domain of this homomorphism.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the homomorphism to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composite homomorphism. </dd></dl>

</div>
</div>
<a id="a5100354c55ea8e1339233f225d0d214f" name="a5100354c55ea8e1339233f225d0d214f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5100354c55ea8e1339233f225d0d214f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> regina::HomMarkedAbelianGroup::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the composition of two homomorphisms. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the homomorphisms must be composable, meaning that the codomain of X must have the same presentation matrices as the domain of this homomorphism.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the homomorphism to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composite homomorphism. </dd></dl>

</div>
</div>
<a id="aabf6b2ec24def953b4574ff1b41b8812" name="aabf6b2ec24def953b4574ff1b41b8812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf6b2ec24def953b4574ff1b41b8812">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this homomorphism. </dd></dl>

</div>
</div>
<a id="aed0c72bf23b3fad88839681cd72f4ce7" name="aed0c72bf23b3fad88839681cd72f4ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0c72bf23b3fad88839681cd72f4ce7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given homomorphism to this homomorphism. </p>
<p >This is a fast (constant time) operation.</p>
<p >The homomorphism that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this homomorphism. </dd></dl>

</div>
</div>
<a id="a106dcb279e4294694478447f2dc06639" name="a106dcb279e4294694478447f2dc06639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106dcb279e4294694478447f2dc06639">&#9670;&nbsp;</a></span>reducedMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::HomMarkedAbelianGroup::reducedMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the internal reduced matrix representing the homomorphism. </p>
<p >This is where the rows/columns of the matrix represent first the torsion summands in the order of the invariant factors, and then the free generators: </p><pre class="fragment">        Z_{d0} + ... + Z_{dk} + Z^r
</pre><p> where:</p>
<ul>
<li><em>r</em> is the number of free generators, as returned by rank();</li>
<li><em>d1</em>, ..., <em>dk</em> are the invariant factors that describe the torsion elements of the group, where 1 &lt; <em>d1</em> | <em>d2</em> | ... | <em>dk</em>.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a copy of the internal representation of the homomorphism. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a147df2f57189a2039473fa0450549273" name="a147df2f57189a2039473fa0450549273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147df2f57189a2039473fa0450549273">&#9670;&nbsp;</a></span>summary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::HomMarkedAbelianGroup::summary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a very brief summary of the type of map. </p>
<p >This will state some basic properties of the homomorphism, such as:</p>
<ul>
<li>whether the map is the identity;</li>
<li>whether the map is an isomorphism;</li>
<li>whether the map is monic or epic;</li>
<li>if it is not monic, describes the kernel;</li>
<li>if it is not epic, describes the co-kernel;</li>
<li>if it is neither monic nor epic, describes the image.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a brief summary. </dd></dl>

</div>
</div>
<a id="a9520648138138bf2f4804d03a42a6b5f" name="a9520648138138bf2f4804d03a42a6b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9520648138138bf2f4804d03a42a6b5f">&#9670;&nbsp;</a></span>summary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::summary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a very brief summary of the type of map to the given output stream. </p>
<p >This writes exactly the same information as the no-argument variant of <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a147df2f57189a2039473fa0450549273" title="Returns a very brief summary of the type of map.">summary()</a> returns; see that routine for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call the no-argument variant of <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html#a147df2f57189a2039473fa0450549273" title="Returns a very brief summary of the type of map.">summary()</a>, which returns this same information in string form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06e2b568fb434264c637a4adc3c7a1b1" name="a06e2b568fb434264c637a4adc3c7a1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e2b568fb434264c637a4adc3c7a1b1">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given homomorphism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the homomorphism whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65e1621082ba71e03eeb72562051497c" name="a65e1621082ba71e03eeb72562051497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e1621082ba71e03eeb72562051497c">&#9670;&nbsp;</a></span>torsionSubgroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> regina::HomMarkedAbelianGroup::torsionSubgroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the induced map on the torsion subgroups. </p>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aafd028394928cbaba6ce8cfe28c96f97" name="aafd028394928cbaba6ce8cfe28c96f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd028394928cbaba6ce8cfe28c96f97">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2779b4feadb621b496a2ec8e6f8eadc4" name="a2779b4feadb621b496a2ec8e6f8eadc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2779b4feadb621b496a2ec8e6f8eadc4">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="markedabeliangroup_8h.html">markedabeliangroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
