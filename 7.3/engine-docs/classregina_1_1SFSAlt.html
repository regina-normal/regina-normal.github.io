<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::SFSAlt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1SFSAlt-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SFSAlt Class Reference<div class="ingroups"><a class="el" href="group__manifold.html">Standard 3-Manifolds</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Provides an alternative representation of a single bounded Seifert fibred space.  
 <a href="classregina_1_1SFSAlt.html#details">More...</a></p>

<p><code>#include &lt;manifold/sfsalt.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SFSAlt:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SFSAlt.png" usemap="#regina::SFSAlt_map" alt=""/>
  <map id="regina::SFSAlt_map" name="regina::SFSAlt_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; SFSAlt &gt;" shape="rect" coords="0,56,190,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SFSAlt, false &gt;" shape="rect" coords="0,0,190,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abf11a201d10b93255060e1257ef1e429"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#abf11a201d10b93255060e1257ef1e429">SFSAlt</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;original)</td></tr>
<tr class="memdesc:abf11a201d10b93255060e1257ef1e429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a "basic" alternative representation for the given Seifert fibred space.  <a href="classregina_1_1SFSAlt.html#abf11a201d10b93255060e1257ef1e429">More...</a><br /></td></tr>
<tr class="separator:abf11a201d10b93255060e1257ef1e429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e87d1ac9d586390216878801d8c686d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a0e87d1ac9d586390216878801d8c686d">SFSAlt</a> (const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;base, bool reflect, bool negate=false)</td></tr>
<tr class="memdesc:a0e87d1ac9d586390216878801d8c686d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new alternative representation from the given alternative representation.  <a href="classregina_1_1SFSAlt.html#a0e87d1ac9d586390216878801d8c686d">More...</a><br /></td></tr>
<tr class="separator:a0e87d1ac9d586390216878801d8c686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85db4e295884d65245c6e2f33cfb2f25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a85db4e295884d65245c6e2f33cfb2f25">SFSAlt</a> (const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;)=default</td></tr>
<tr class="memdesc:a85db4e295884d65245c6e2f33cfb2f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given alternative.  <a href="classregina_1_1SFSAlt.html#a85db4e295884d65245c6e2f33cfb2f25">More...</a><br /></td></tr>
<tr class="separator:a85db4e295884d65245c6e2f33cfb2f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87dbb1f9400a8f5a4b9e8798e2f8539"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#ac87dbb1f9400a8f5a4b9e8798e2f8539">SFSAlt</a> (<a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ac87dbb1f9400a8f5a4b9e8798e2f8539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given alternative into this new alternative.  <a href="classregina_1_1SFSAlt.html#ac87dbb1f9400a8f5a4b9e8798e2f8539">More...</a><br /></td></tr>
<tr class="separator:ac87dbb1f9400a8f5a4b9e8798e2f8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434a2543711910d769a642d359c17b99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a434a2543711910d769a642d359c17b99">operator=</a> (const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;)=default</td></tr>
<tr class="memdesc:a434a2543711910d769a642d359c17b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given alternative.  <a href="classregina_1_1SFSAlt.html#a434a2543711910d769a642d359c17b99">More...</a><br /></td></tr>
<tr class="separator:a434a2543711910d769a642d359c17b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a8d1614e3c892b8d7181966ff0c192"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#aa3a8d1614e3c892b8d7181966ff0c192">operator=</a> (<a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aa3a8d1614e3c892b8d7181966ff0c192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given alternative into this alternative.  <a href="classregina_1_1SFSAlt.html#aa3a8d1614e3c892b8d7181966ff0c192">More...</a><br /></td></tr>
<tr class="separator:aa3a8d1614e3c892b8d7181966ff0c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d27bcc17c1d4560221c5632fbf348af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a7d27bcc17c1d4560221c5632fbf348af">swap</a> (<a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a7d27bcc17c1d4560221c5632fbf348af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given alternative.  <a href="classregina_1_1SFSAlt.html#a7d27bcc17c1d4560221c5632fbf348af">More...</a><br /></td></tr>
<tr class="separator:a7d27bcc17c1d4560221c5632fbf348af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dee651649cd65ca58a9fc3fe5bc5ecc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a8dee651649cd65ca58a9fc3fe5bc5ecc">alt</a> () const &amp;</td></tr>
<tr class="memdesc:a8dee651649cd65ca58a9fc3fe5bc5ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the alternative representation of the original Seifert fibred space.  <a href="classregina_1_1SFSAlt.html#a8dee651649cd65ca58a9fc3fe5bc5ecc">More...</a><br /></td></tr>
<tr class="separator:a8dee651649cd65ca58a9fc3fe5bc5ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc6dc41cc2dfc1a74a6eb2332530a30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#acbc6dc41cc2dfc1a74a6eb2332530a30">alt</a> () &amp;</td></tr>
<tr class="memdesc:acbc6dc41cc2dfc1a74a6eb2332530a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-const reference to the alternative representation of the original Seifert fibred space.  <a href="classregina_1_1SFSAlt.html#acbc6dc41cc2dfc1a74a6eb2332530a30">More...</a><br /></td></tr>
<tr class="separator:acbc6dc41cc2dfc1a74a6eb2332530a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa922588c5b094afb12a297ca98e12b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#aa922588c5b094afb12a297ca98e12b15">alt</a> () &amp;&amp;</td></tr>
<tr class="memdesc:aa922588c5b094afb12a297ca98e12b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an rvalue reference to the alternative representation of the original Seifert fibred space.  <a href="classregina_1_1SFSAlt.html#aa922588c5b094afb12a297ca98e12b15">More...</a><br /></td></tr>
<tr class="separator:aa922588c5b094afb12a297ca98e12b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd8fa46839a3f2b34d8cdfa41432182"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#abbd8fa46839a3f2b34d8cdfa41432182">conversion</a> () const</td></tr>
<tr class="memdesc:abbd8fa46839a3f2b34d8cdfa41432182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conversion matrix for this alternative space.  <a href="classregina_1_1SFSAlt.html#abbd8fa46839a3f2b34d8cdfa41432182">More...</a><br /></td></tr>
<tr class="separator:abbd8fa46839a3f2b34d8cdfa41432182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac783b0015ec5fbbecee58a22fa908624"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#ac783b0015ec5fbbecee58a22fa908624">reflected</a> () const</td></tr>
<tr class="memdesc:ac783b0015ec5fbbecee58a22fa908624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a reflection was used when creating this alternative space.  <a href="classregina_1_1SFSAlt.html#ac783b0015ec5fbbecee58a22fa908624">More...</a><br /></td></tr>
<tr class="separator:ac783b0015ec5fbbecee58a22fa908624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2f0764223c052864d51da1fa7bd3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#aa6d2f0764223c052864d51da1fa7bd3e">operator==</a> (const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;other) const</td></tr>
<tr class="memdesc:aa6d2f0764223c052864d51da1fa7bd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given alternative representation have identical presentations.  <a href="classregina_1_1SFSAlt.html#aa6d2f0764223c052864d51da1fa7bd3e">More...</a><br /></td></tr>
<tr class="separator:aa6d2f0764223c052864d51da1fa7bd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e61b3cd7a75e6686c19ccdd58d17e44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a7e61b3cd7a75e6686c19ccdd58d17e44">operator!=</a> (const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;other) const</td></tr>
<tr class="memdesc:a7e61b3cd7a75e6686c19ccdd58d17e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given alternative representation do not have identical presentations.  <a href="classregina_1_1SFSAlt.html#a7e61b3cd7a75e6686c19ccdd58d17e44">More...</a><br /></td></tr>
<tr class="separator:a7e61b3cd7a75e6686c19ccdd58d17e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac9fe00f2787a253642f8c193f99080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a1ac9fe00f2787a253642f8c193f99080">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a1ac9fe00f2787a253642f8c193f99080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1SFSAlt.html#a1ac9fe00f2787a253642f8c193f99080">More...</a><br /></td></tr>
<tr class="separator:a1ac9fe00f2787a253642f8c193f99080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:aa4d98fc96d56eb36254e9cce64d8662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="structregina_1_1ShortOutput.html#aa4d98fc96d56eb36254e9cce64d8662d">More...</a><br /></td></tr>
<tr class="separator:aa4d98fc96d56eb36254e9cce64d8662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7144d0df136acf840704b63cad0f59ec"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#a7144d0df136acf840704b63cad0f59ec">altSet</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs)</td></tr>
<tr class="memdesc:a7144d0df136acf840704b63cad0f59ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of alternatives for the given Seifert fibred space.  <a href="classregina_1_1SFSAlt.html#a7144d0df136acf840704b63cad0f59ec">More...</a><br /></td></tr>
<tr class="separator:a7144d0df136acf840704b63cad0f59ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add93ab77d11dae3b95a9ee8ae4d48250"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSAlt.html#add93ab77d11dae3b95a9ee8ae4d48250">canNegate</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;sfs)</td></tr>
<tr class="memdesc:add93ab77d11dae3b95a9ee8ae4d48250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the <a class="el" href="classregina_1_1SFSAlt.html" title="Provides an alternative representation of a single bounded Seifert fibred space.">SFSAlt</a> class constructor will be able to negate all exceptional fibres without reflecting the underlying Seifert fibred space.  <a href="classregina_1_1SFSAlt.html#add93ab77d11dae3b95a9ee8ae4d48250">More...</a><br /></td></tr>
<tr class="separator:add93ab77d11dae3b95a9ee8ae4d48250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Provides an alternative representation of a single bounded Seifert fibred space. </p>
<p >Such alternatives are made possible by altering the curves made by the fibre and base orbifold on a boundary torus.</p>
<p >This class is designed to help in finding simple representations of graph manifolds (or, indeed, any non-geometric manifolds containing Seifert fibred blocks).</p>
<p >Each alternative comes with its own representation of the original Seifert fibred space, along with instructions for converting fibre/base curves on the boundary tori between the original and alternative spaces.</p>
<p >The alternative representation will generally be as simple as possible (and indeed the hope is that it will be simpler than the original). In particular, each alternative space is guaranteed to have obstruction constant zero. The base orbifold may be changed entirely (for instance, an orientable Seifert fibred space over the Mobius band with no exceptional fibres will be converted to a Seifert fibred space over the disc with two exceptional fibres).</p>
<p >The conversions between boundary curves are described by a conversion matrix <em>M</em> as follows. Consider the first boundary torus. Let <em>f_old</em> and <em>o_old</em> be directed curves on this boundary representing the fibre and base orbifold of the original space, and let <em>f_alt</em> and <em>o_alt</em> be directed curves on this same boundary representing the fibre and base orbifold of the new alternative space. Then</p>
<pre>
    [f_alt]         [f_old]
    [     ]  =  M * [     ].
    [o_alt]         [o_old]
</pre><p >Note that this <em>only</em> applies to the first boundary torus! If the Seifert fibred space has more than one boundary, then for the remaining boundaries the unoriented fibre and base curves remain the same. More specifically, the directed fibre remains identical, and the directed curve representing the base orbifold is reversed if and only if a reflection was used in creating the alternative space, as returned by <a class="el" href="classregina_1_1SFSAlt.html#ac783b0015ec5fbbecee58a22fa908624" title="Returns whether or not a reflection was used when creating this alternative space.">reflected()</a>.</p>
<p >See the page on <a class="el" href="sfsnotation.html">Notation for Seifert fibred spaces</a> for details on some of the terminology used above.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. Note, however, that <a class="el" href="classregina_1_1SFSAlt.html" title="Provides an alternative representation of a single bounded Seifert fibred space.">SFSAlt</a> still requires a non-trivial (but constant sized) amount of data to be copied even in a move operation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abf11a201d10b93255060e1257ef1e429" name="abf11a201d10b93255060e1257ef1e429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf11a201d10b93255060e1257ef1e429">&#9670;&nbsp;</a></span>SFSAlt() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSAlt::SFSAlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a "basic" alternative representation for the given Seifert fibred space. </p>
<p >This will:</p>
<ul>
<li>reduce the parameters via <a class="el" href="classregina_1_1SFSpace.html#ab28f4b1aeac0b2105233f4293509c492" title="Reduces the parameters of this Seifert fibred space to a simpler form if possible,...">SFSpace::reduce()</a>, without reflecting;</li>
<li>add twists to the first boundary torus so that the obstruction constant <em>b</em> in the Seifert fibred space becomes zero;</li>
<li>if the Seifert fibred space is over <code>M/n2</code> with no exceptional fibres (where <code>M</code> represents the Mobius band), it will switch the fibre and orbifold curves to give a Seifert fibred space over the disc with two exception fibres.</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given Seifert fibred space has at least one torus boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the original Seifert fibred space for which we are creating a set of alternative representations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e87d1ac9d586390216878801d8c686d" name="a0e87d1ac9d586390216878801d8c686d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e87d1ac9d586390216878801d8c686d">&#9670;&nbsp;</a></span>SFSAlt() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSAlt::SFSAlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>negate</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new alternative representation from the given alternative representation. </p>
<p >The changes will include:</p>
<ul>
<li>if <em>reflect</em> is <code>true</code>, then this will reflect the Seifert fibred space;</li>
<li>if <em>negate</em> is <code>true</code>, then this will attempt to replace all fibres (<em>alpha</em>, <em>beta</em>) with (<em>alpha</em>, <em>alpha</em> - <em>beta</em>), <em>without</em> any further reflections (but see below for conditions on when this is possible);</li>
<li>in all cases, this will reduce the parameters via <a class="el" href="classregina_1_1SFSpace.html#ab28f4b1aeac0b2105233f4293509c492" title="Reduces the parameters of this Seifert fibred space to a simpler form if possible,...">SFSpace::reduce()</a> and add twists to give obstruction constant zero.</li>
</ul>
<p >Asking for reflection is always valid. However, the option to negate without reflection is possible only if:</p>
<ul>
<li>it is possible to negate an exceptional fibre by sliding it around the base orbifold (as in <a class="el" href="classregina_1_1SFSpace.html#aa5b9d08bdd55767057aa12d5a21fa0eb" title="Returns whether or not we can negate an exceptional fibre by passing it around the interior of the ba...">SFSpace::fibreNegating()</a>); and</li>
<li>the number of exceptional fibres is odd.</li>
</ul>
<p >For convenience, you can test these conditions using the static function <a class="el" href="classregina_1_1SFSAlt.html#add93ab77d11dae3b95a9ee8ae4d48250" title="Determines whether the SFSAlt class constructor will be able to negate all exceptional fibres without...">canNegate()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>negate</em> is <code>true</code>, then the underlying Seifert fibred space satisfies the requirements outlined above, or equivalently, <code>canNegate(base.sfs())</code> is <code>true</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This constructor only makes sense if at least one of <code>reflect</code> or <code>negate</code> is <code>true</code>, since <em>base</em> should already be in a reduced form with zero obstruction constant.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the Seifert fibred space representation that will be used as a starting point for this new alternative. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if we should reflect the Seifert fibred space. </td></tr>
    <tr><td class="paramname">negate</td><td><code>true</code> if we should attempt to negate all exceptional fibres without reflecting, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85db4e295884d65245c6e2f33cfb2f25" name="a85db4e295884d65245c6e2f33cfb2f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85db4e295884d65245c6e2f33cfb2f25">&#9670;&nbsp;</a></span>SFSAlt() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSAlt::SFSAlt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given alternative. </p>

</div>
</div>
<a id="ac87dbb1f9400a8f5a4b9e8798e2f8539" name="ac87dbb1f9400a8f5a4b9e8798e2f8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87dbb1f9400a8f5a4b9e8798e2f8539">&#9670;&nbsp;</a></span>SFSAlt() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSAlt::SFSAlt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given alternative into this new alternative. </p>
<p >This is a fast (constant time) operation.</p>
<p >The alternative that was passed will no longer be usable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acbc6dc41cc2dfc1a74a6eb2332530a30" name="acbc6dc41cc2dfc1a74a6eb2332530a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc6dc41cc2dfc1a74a6eb2332530a30">&#9670;&nbsp;</a></span>alt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::SFSAlt::alt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-const reference to the alternative representation of the original Seifert fibred space. </p>
<dl class="section return"><dt>Returns</dt><dd>the alternative representation. </dd></dl>

</div>
</div>
<a id="aa922588c5b094afb12a297ca98e12b15" name="aa922588c5b094afb12a297ca98e12b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa922588c5b094afb12a297ca98e12b15">&#9670;&nbsp;</a></span>alt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&amp; regina::SFSAlt::alt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an rvalue reference to the alternative representation of the original Seifert fibred space. </p>
<dl class="section return"><dt>Returns</dt><dd>the alternative representation. </dd></dl>

</div>
</div>
<a id="a8dee651649cd65ca58a9fc3fe5bc5ecc" name="a8dee651649cd65ca58a9fc3fe5bc5ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dee651649cd65ca58a9fc3fe5bc5ecc">&#9670;&nbsp;</a></span>alt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::SFSAlt::alt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the alternative representation of the original Seifert fibred space. </p>
<dl class="section return"><dt>Returns</dt><dd>the alternative representation. </dd></dl>

</div>
</div>
<a id="a7144d0df136acf840704b63cad0f59ec" name="a7144d0df136acf840704b63cad0f59ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7144d0df136acf840704b63cad0f59ec">&#9670;&nbsp;</a></span>altSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &gt; regina::SFSAlt::altSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a set of alternatives for the given Seifert fibred space. </p>
<p >These will consist of (1) the alternative <em>base</em> created by passing the original Seifert fibred space to the <a class="el" href="classregina_1_1SFSAlt.html" title="Provides an alternative representation of a single bounded Seifert fibred space.">SFSAlt</a> constructor; and (2) all alternatives created by passing <em>base</em> with appropriate reflection and negation arguments to the <a class="el" href="classregina_1_1SFSAlt.html" title="Provides an alternative representation of a single bounded Seifert fibred space.">SFSAlt</a> constructor. The combinations of reflection and negation arguments that are used (and hence the size of the set that is returned) will depend on the properties of the original space.</p>
<p >Note that in general, none of the alternatives will have a representation identical to the original (generally these alternative representations will be simpler if possible).</p>
<p >It is guaranteed that the set that is returned will be non-empty.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Seifert fibred space has at least one torus boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the original Seifert fibred space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting set of alternative representations for <em>sfs</em>. </dd></dl>

</div>
</div>
<a id="add93ab77d11dae3b95a9ee8ae4d48250" name="add93ab77d11dae3b95a9ee8ae4d48250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add93ab77d11dae3b95a9ee8ae4d48250">&#9670;&nbsp;</a></span>canNegate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSAlt::canNegate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the <a class="el" href="classregina_1_1SFSAlt.html" title="Provides an alternative representation of a single bounded Seifert fibred space.">SFSAlt</a> class constructor will be able to negate all exceptional fibres without reflecting the underlying Seifert fibred space. </p>
<p >See the constructor <a class="el" href="classregina_1_1SFSAlt.html#a0e87d1ac9d586390216878801d8c686d" title="Creates a new alternative representation from the given alternative representation.">SFSAlt(const SFSAlt&amp;, bool, bool)</a> for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Seifert fibred space has at least one torus boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space that we are attempting to represent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if it is possible to set the negation argument to <code>true</code> in the <a class="el" href="classregina_1_1SFSAlt.html" title="Provides an alternative representation of a single bounded Seifert fibred space.">SFSAlt</a> class constructor. </dd></dl>

</div>
</div>
<a id="abbd8fa46839a3f2b34d8cdfa41432182" name="abbd8fa46839a3f2b34d8cdfa41432182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd8fa46839a3f2b34d8cdfa41432182">&#9670;&nbsp;</a></span>conversion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Matrix2.html">Matrix2</a> &amp; regina::SFSAlt::conversion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conversion matrix for this alternative space. </p>
<p >This matrix describes the fibre and base curves of the alternative space on the first boundary torus in terms of the fibre and base curves of the original space (which was passed to the <a class="el" href="classregina_1_1SFSAlt.html" title="Provides an alternative representation of a single bounded Seifert fibred space.">SFSAlt</a> constructor). See the class notes above for details.</p>
<p >Note that this conversion matrix applies <em>only</em> to the first boundary torus! If there is more than one boundary, the remaining boundary conversions are simpler and depend only on whether a reflection has been used or not. See <a class="el" href="classregina_1_1SFSAlt.html#ac783b0015ec5fbbecee58a22fa908624" title="Returns whether or not a reflection was used when creating this alternative space.">reflected()</a> or the class notes for details.</p>
<dl class="section return"><dt>Returns</dt><dd>the conversion matrix for this alternative space. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a7e61b3cd7a75e6686c19ccdd58d17e44" name="a7e61b3cd7a75e6686c19ccdd58d17e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e61b3cd7a75e6686c19ccdd58d17e44">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSAlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given alternative representation do not have identical presentations. </p>
<p >To be considered <em>identical</em>, the two alternatives must have equal alternative <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> representations, equal conversion matrices, and either both must have used a reflection or both must have not used a reflection. In other words, this is equivalent to testing all of <a class="el" href="classregina_1_1SFSAlt.html#a8dee651649cd65ca58a9fc3fe5bc5ecc" title="Returns the alternative representation of the original Seifert fibred space.">alt()</a>, <a class="el" href="classregina_1_1SFSAlt.html#abbd8fa46839a3f2b34d8cdfa41432182" title="Returns the conversion matrix for this alternative space.">conversion()</a> and <a class="el" href="classregina_1_1SFSAlt.html#ac783b0015ec5fbbecee58a22fa908624" title="Returns whether or not a reflection was used when creating this alternative space.">reflected()</a> for equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the alternative to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given alternative do not have identical presentations, as described above. </dd></dl>

</div>
</div>
<a id="a434a2543711910d769a642d359c17b99" name="a434a2543711910d769a642d359c17b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434a2543711910d769a642d359c17b99">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp; regina::SFSAlt::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given alternative. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this alternative. </dd></dl>

</div>
</div>
<a id="aa3a8d1614e3c892b8d7181966ff0c192" name="aa3a8d1614e3c892b8d7181966ff0c192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a8d1614e3c892b8d7181966ff0c192">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp; regina::SFSAlt::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given alternative into this alternative. </p>
<p >This is a fast (constant time) operation.</p>
<p >The alternative that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this alternative. </dd></dl>

</div>
</div>
<a id="aa6d2f0764223c052864d51da1fa7bd3e" name="aa6d2f0764223c052864d51da1fa7bd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d2f0764223c052864d51da1fa7bd3e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSAlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given alternative representation have identical presentations. </p>
<p >To be considered <em>identical</em>, the two alternatives must have equal alternative <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> representations, equal conversion matrices, and either both must have used a reflection or both must have not used a reflection. In other words, this is equivalent to testing all of <a class="el" href="classregina_1_1SFSAlt.html#a8dee651649cd65ca58a9fc3fe5bc5ecc" title="Returns the alternative representation of the original Seifert fibred space.">alt()</a>, <a class="el" href="classregina_1_1SFSAlt.html#abbd8fa46839a3f2b34d8cdfa41432182" title="Returns the conversion matrix for this alternative space.">conversion()</a> and <a class="el" href="classregina_1_1SFSAlt.html#ac783b0015ec5fbbecee58a22fa908624" title="Returns whether or not a reflection was used when creating this alternative space.">reflected()</a> for equality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the alternative to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given alternative have identical presentations, as described above. </dd></dl>

</div>
</div>
<a id="ac783b0015ec5fbbecee58a22fa908624" name="ac783b0015ec5fbbecee58a22fa908624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac783b0015ec5fbbecee58a22fa908624">&#9670;&nbsp;</a></span>reflected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSAlt::reflected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not a reflection was used when creating this alternative space. </p>
<p >This determines the conversion between boundary curves for all boundary tori after the first.</p>
<p >More specifically, if no reflection was used then the directed fibre and base curves are identical for the original and alternative spaces. If a reflection was used, then the directed fibres are identical but the directed base curves are reversed.</p>
<p >The conversion between curves on the first boundary torus is generally more complex, and is returned as a matrix by the <a class="el" href="classregina_1_1SFSAlt.html#abbd8fa46839a3f2b34d8cdfa41432182" title="Returns the conversion matrix for this alternative space.">conversion()</a> routine.</p>
<p >You can also test whether a reflection was used by examining whether the conversion matrix has determinant 1 or -1. However, calling <a class="el" href="classregina_1_1SFSAlt.html#ac783b0015ec5fbbecee58a22fa908624" title="Returns whether or not a reflection was used when creating this alternative space.">reflected()</a> is both simpler and a little faster.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a reflection was used in creating this alternative space, or <code>false</code> if no reflection was used. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a7d27bcc17c1d4560221c5632fbf348af" name="a7d27bcc17c1d4560221c5632fbf348af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d27bcc17c1d4560221c5632fbf348af">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSAlt::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given alternative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the alternative whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa4d98fc96d56eb36254e9cce64d8662d" name="aa4d98fc96d56eb36254e9cce64d8662d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d98fc96d56eb36254e9cce64d8662d">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1SFSAlt.html">SFSAlt</a> , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p >This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead you can call <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> from the subclass <em>T</em>, which returns this output as a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ac9fe00f2787a253642f8c193f99080" name="a1ac9fe00f2787a253642f8c193f99080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac9fe00f2787a253642f8c193f99080">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSAlt::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>manifold/<a class="el" href="sfsalt_8h.html">sfsalt.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
