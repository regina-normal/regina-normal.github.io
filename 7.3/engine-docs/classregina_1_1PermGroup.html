<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::PermGroup&lt; n, cached &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1PermGroup.html">PermGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classregina_1_1PermGroup-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::PermGroup&lt; n, cached &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__maths.html">Mathematical Support</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a group of permutations on <em>n</em> elements.  
 <a href="classregina_1_1PermGroup.html#details">More...</a></p>

<p><code>#include &lt;maths/permgroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::PermGroup&lt; n, cached &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1PermGroup.png" usemap="#regina::PermGroup_3C_20n_2C_20cached_20_3E_map" alt=""/>
  <map id="regina::PermGroup_3C_20n_2C_20cached_20_3E_map" name="regina::PermGroup_3C_20n_2C_20cached_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; PermGroup&lt; n, false &gt; &gt;" shape="rect" coords="0,0,246,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type for this group.  <a href="classregina_1_1PermGroup_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a322407a1a90156a932f85091107f6eeb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a322407a1a90156a932f85091107f6eeb">const_iterator</a> = <a class="el" href="classregina_1_1PermGroup_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:a322407a1a90156a932f85091107f6eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator type for this group.  <a href="classregina_1_1PermGroup.html#a322407a1a90156a932f85091107f6eeb">More...</a><br /></td></tr>
<tr class="separator:a322407a1a90156a932f85091107f6eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a981f80af70818b307494894815d9276c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a981f80af70818b307494894815d9276c">PermGroup</a> ()</td></tr>
<tr class="memdesc:a981f80af70818b307494894815d9276c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the trivial group, containing only the identity permutation.  <a href="classregina_1_1PermGroup.html#a981f80af70818b307494894815d9276c">More...</a><br /></td></tr>
<tr class="separator:a981f80af70818b307494894815d9276c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77847af9c552b15cec5f7c39778c9704"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a77847af9c552b15cec5f7c39778c9704">PermGroup</a> (<a class="el" href="namespaceregina.html#af4c4383afc33aa677fc6d82afae6e820">NamedPermGroup</a> group)</td></tr>
<tr class="memdesc:a77847af9c552b15cec5f7c39778c9704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the given well-known permutation group.  <a href="classregina_1_1PermGroup.html#a77847af9c552b15cec5f7c39778c9704">More...</a><br /></td></tr>
<tr class="separator:a77847af9c552b15cec5f7c39778c9704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6994a92f5b5587262da05dc717d9eea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#ae6994a92f5b5587262da05dc717d9eea">PermGroup</a> (int k)</td></tr>
<tr class="memdesc:ae6994a92f5b5587262da05dc717d9eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the symmetric group <code>S_k</code>, formed from all permutations of 1,...,<em>k</em>.  <a href="classregina_1_1PermGroup.html#ae6994a92f5b5587262da05dc717d9eea">More...</a><br /></td></tr>
<tr class="separator:ae6994a92f5b5587262da05dc717d9eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a41f62f62c639726d6f2f7aba94015"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#ad4a41f62f62c639726d6f2f7aba94015">PermGroup</a> (const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> &amp;src)=default</td></tr>
<tr class="memdesc:ad4a41f62f62c639726d6f2f7aba94015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given group.  <a href="classregina_1_1PermGroup.html#ad4a41f62f62c639726d6f2f7aba94015">More...</a><br /></td></tr>
<tr class="separator:ad4a41f62f62c639726d6f2f7aba94015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702eb6d50c9c68df470f24946f109e7f"><td class="memTemplParams" colspan="2">template&lt;typename Test , typename... Args&gt; </td></tr>
<tr class="memitem:a702eb6d50c9c68df470f24946f109e7f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a702eb6d50c9c68df470f24946f109e7f">PermGroup</a> (const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> &amp;parent, Test &amp;&amp;test, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a702eb6d50c9c68df470f24946f109e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the subgroup of all elements in the given group that pass the given membership test.  <a href="classregina_1_1PermGroup.html#a702eb6d50c9c68df470f24946f109e7f">More...</a><br /></td></tr>
<tr class="separator:a702eb6d50c9c68df470f24946f109e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab21f6a64617892a73e753a43da4f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#afab21f6a64617892a73e753a43da4f96">operator=</a> (const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> &amp;src)=default</td></tr>
<tr class="memdesc:afab21f6a64617892a73e753a43da4f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given group.  <a href="classregina_1_1PermGroup.html#afab21f6a64617892a73e753a43da4f96">More...</a><br /></td></tr>
<tr class="separator:afab21f6a64617892a73e753a43da4f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09ef4cd39eb3c5c12b432f617868227"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt;::Index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#ad09ef4cd39eb3c5c12b432f617868227">size</a> () const</td></tr>
<tr class="memdesc:ad09ef4cd39eb3c5c12b432f617868227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of elements in this group.  <a href="classregina_1_1PermGroup.html#ad09ef4cd39eb3c5c12b432f617868227">More...</a><br /></td></tr>
<tr class="separator:ad09ef4cd39eb3c5c12b432f617868227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04da4593aa1bdee442da0b0972824649"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a04da4593aa1bdee442da0b0972824649">contains</a> (<a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt; p) const</td></tr>
<tr class="memdesc:a04da4593aa1bdee442da0b0972824649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given permutation belongs to this group.  <a href="classregina_1_1PermGroup.html#a04da4593aa1bdee442da0b0972824649">More...</a><br /></td></tr>
<tr class="separator:a04da4593aa1bdee442da0b0972824649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf7396385c4621425868f6ac175b6db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#afdf7396385c4621425868f6ac175b6db">operator==</a> (const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:afdf7396385c4621425868f6ac175b6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this and the given group are identical.  <a href="classregina_1_1PermGroup.html#afdf7396385c4621425868f6ac175b6db">More...</a><br /></td></tr>
<tr class="separator:afdf7396385c4621425868f6ac175b6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10cb18b8ad3c9b5fafa212291c87abd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#aa10cb18b8ad3c9b5fafa212291c87abd">operator!=</a> (const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:aa10cb18b8ad3c9b5fafa212291c87abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this and the given group are different.  <a href="classregina_1_1PermGroup.html#aa10cb18b8ad3c9b5fafa212291c87abd">More...</a><br /></td></tr>
<tr class="separator:aa10cb18b8ad3c9b5fafa212291c87abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35268917811a8e99111575dc1a35fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PermGroup_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#afc35268917811a8e99111575dc1a35fd">begin</a> () const</td></tr>
<tr class="memdesc:afc35268917811a8e99111575dc1a35fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator pointing to the first element of this group.  <a href="classregina_1_1PermGroup.html#afc35268917811a8e99111575dc1a35fd">More...</a><br /></td></tr>
<tr class="separator:afc35268917811a8e99111575dc1a35fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a68a26f54ca4e79c2a9f5d9e2037c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PermGroup_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#ab0a68a26f54ca4e79c2a9f5d9e2037c3">end</a> () const</td></tr>
<tr class="memdesc:ab0a68a26f54ca4e79c2a9f5d9e2037c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator beyond the last element of this group.  <a href="classregina_1_1PermGroup.html#ab0a68a26f54ca4e79c2a9f5d9e2037c3">More...</a><br /></td></tr>
<tr class="separator:ab0a68a26f54ca4e79c2a9f5d9e2037c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afbc6e564c3c87e8c3c8a904c91ea8a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a7afbc6e564c3c87e8c3c8a904c91ea8a">__iter__</a> () const</td></tr>
<tr class="memdesc:a7afbc6e564c3c87e8c3c8a904c91ea8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterator over the elements of this group.  <a href="classregina_1_1PermGroup.html#a7afbc6e564c3c87e8c3c8a904c91ea8a">More...</a><br /></td></tr>
<tr class="separator:a7afbc6e564c3c87e8c3c8a904c91ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219751575db0fc95e8187cfe200b292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a219751575db0fc95e8187cfe200b292f">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a219751575db0fc95e8187cfe200b292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1PermGroup.html#a219751575db0fc95e8187cfe200b292f">More...</a><br /></td></tr>
<tr class="separator:a219751575db0fc95e8187cfe200b292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147fadeaa3292bdd000446bec5b8ab84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a147fadeaa3292bdd000446bec5b8ab84">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a147fadeaa3292bdd000446bec5b8ab84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1PermGroup.html#a147fadeaa3292bdd000446bec5b8ab84">More...</a><br /></td></tr>
<tr class="separator:a147fadeaa3292bdd000446bec5b8ab84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3bffeabc148f2c2767dc148fd789ddef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PermGroup.html#a3bffeabc148f2c2767dc148fd789ddef">centraliser</a> (const <a class="el" href="classregina_1_1PermClass.html">PermClass</a>&lt; n &gt; &amp;conj)</td></tr>
<tr class="memdesc:a3bffeabc148f2c2767dc148fd789ddef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the group of all permutations that fix the minimal representative of the given conjugacy class under conjugation.  <a href="classregina_1_1PermGroup.html#a3bffeabc148f2c2767dc148fd789ddef">More...</a><br /></td></tr>
<tr class="separator:a3bffeabc148f2c2767dc148fd789ddef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int n, bool cached = false&gt;<br />
class regina::PermGroup&lt; n, cached &gt;</div><p >Represents a group of permutations on <em>n</em> elements. </p>
<p >This is a subgroup of the symmetric group <code>S_n</code>.</p>
<p >Groups are stored internally using Sims tables (see Knuth volume 4A for a description of how these work); these are called <em>stabiliser chains</em> in many places. This storage mechanism means that, even though a permutation group could have size factorial in <em>n</em>, the storage space required is only quadratic in <em>n</em>.</p>
<p ><a class="el" href="classregina_1_1PermGroup.html" title="Represents a group of permutations on n elements.">PermGroup</a> objects are, in their current implementation, entirely stack-based. This means they cannot support fast move or swap operations. However, since their size is quadratic in <em>n</em>, copy operations involve significantly more overhead than (for example) just copying a <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a> object (which just holds a single machine-native integer). This decision is a deliberate trade-off between speed versus space; the implication for end users is that you should be economical about copying <a class="el" href="classregina_1_1PermGroup.html" title="Represents a group of permutations on n elements.">PermGroup</a> objects, and work with them in-place where possible.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. In Python, the "vanilla" non-cached variants <code><a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;n&gt;</code> are available under the names PermGroup2, PermGroup3, ..., PermGroup16, and the cached variants <code><a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;n, true&gt;</code> are available under the names PermGroup2_Cached, PermGroup3_Cached, ..., PermGroup16_Cached.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">n</td><td>the number of objects being permuted. This must be between 2 and 16 inclusive. </td></tr>
    <tr><td class="paramname">cached</td><td><code>true</code> if we should use precomputation-assisted routines such as <a class="el" href="classregina_1_1Perm.html#a933651038ffc99dfd7c2113420fcd58f" title="An alias for the composition operator, provided to assist with writing generic code.">Perm&lt;n&gt;::cachedComp()</a> and <a class="el" href="classregina_1_1Perm.html#a3acdb4b01aa1b2fe4467e225db79a714" title="Finds the inverse of this permutation, optimised using precomputed &quot;partial lookup tables&quot;.">Perm&lt;n&gt;::cachedInverse()</a>, or <code>false</code> (the default) if we should just use the composition operator, inverse(), and so on. If this argument is <code>true</code>, you <em>must</em> have called <a class="el" href="classregina_1_1Perm.html#a90eb879e7ec2bc1fd4dd9269a632fbc6" title="Performs the precomputation necessary for using the optimised cachedInverse() routine.">Perm&lt;n&gt;::precompute()</a> at least once in the lifetime of the program before using this class. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a322407a1a90156a932f85091107f6eeb" name="a322407a1a90156a932f85091107f6eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322407a1a90156a932f85091107f6eeb">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::const_iterator =  <a class="el" href="classregina_1_1PermGroup_1_1iterator.html">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The iterator type for this group. </p>
<p >Both <em>iterator</em> and <em>const_iterator</em> are the same type, since a <a class="el" href="classregina_1_1PermGroup.html" title="Represents a group of permutations on n elements.">PermGroup</a> only offers read-only access to its group members. See the <a class="el" href="classregina_1_1PermGroup_1_1iterator.html" title="The iterator type for this group.">PermGroup::iterator</a> class for further details. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a981f80af70818b307494894815d9276c" name="a981f80af70818b307494894815d9276c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981f80af70818b307494894815d9276c">&#9670;&nbsp;</a></span>PermGroup() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::PermGroup</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the trivial group, containing only the identity permutation. </p>

</div>
</div>
<a id="a77847af9c552b15cec5f7c39778c9704" name="a77847af9c552b15cec5f7c39778c9704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77847af9c552b15cec5f7c39778c9704">&#9670;&nbsp;</a></span>PermGroup() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::PermGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceregina.html#af4c4383afc33aa677fc6d82afae6e820">NamedPermGroup</a>&lt; n, cached &gt;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the given well-known permutation group. </p>
<p >This constructor can (for example) be used to easily construct the symmetric or alternating group on <em>n</em> elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>indicates which well-known permutation group to construct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6994a92f5b5587262da05dc717d9eea" name="ae6994a92f5b5587262da05dc717d9eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6994a92f5b5587262da05dc717d9eea">&#9670;&nbsp;</a></span>PermGroup() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::PermGroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the symmetric group <code>S_k</code>, formed from all permutations of 1,...,<em>k</em>. </p>
<p >The elements (<em>k</em> + 1),...,<em>n</em> will remain fixed under all permutations in this group.</p>
<p >The size of this group will be <code>k!</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>indicates how many elements should be permuted; this must be between 0 and <em>n</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4a41f62f62c639726d6f2f7aba94015" name="ad4a41f62f62c639726d6f2f7aba94015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a41f62f62c639726d6f2f7aba94015">&#9670;&nbsp;</a></span>PermGroup() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::PermGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, cached &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the group to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a702eb6d50c9c68df470f24946f109e7f" name="a702eb6d50c9c68df470f24946f109e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702eb6d50c9c68df470f24946f109e7f">&#9670;&nbsp;</a></span>PermGroup() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached&gt; </div>
<div class="memtemplate">
template&lt;typename Test , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::PermGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, cached &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Test &amp;&amp;&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the subgroup of all elements in the given group that pass the given membership test. </p>
<p >Specifically, this generates the subgroup of all permutations <em>p</em> in <em>parent</em> for which <code>test(p, args...)</code> returns <code>true</code>.</p>
<p >The argument <em>test</em> should be a function or some other callable object. It must return a boolean, and its first argument should be a permutation (either by value as type <code><a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;n&gt;</code>, or by const reference as type <code>const <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;n&gt;&amp;</code>). If there are any additional arguments supplied in the list <em>args</em>, these will be forwarded through as additional arguments to <em>test</em>.</p>
<p >Note that <em>test</em> will not necessarily be called for <em>all</em> permutations in <em>parent</em>, since this routine will deduce some subgroup members using the standard subgroup properties (e.g., closure and inverse). It is, however, guaranteed that the <em>only</em> permutations passed to <em>test</em> will be permutations that are already known to belong to <em>parent</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given membership test does actually define a subgroup (that is, it behaves appropriately with respect to identity, inverse and closure).</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This constructor is available in Python, and the <em>test</em> argument may be a pure Python function. However, its form is more restricted: <em>test</em> must take exactly one argument (the permutation), and the <em>args</em> argument to this constructor is not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the "starting" group of all permutations under consideration. </td></tr>
    <tr><td class="paramname">test</td><td>a function (or other callable object) that determines which permutations in <em>parent</em> become members of this subgroup. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments that should be passed to <em>test</em>, following the initial permutation argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7afbc6e564c3c87e8c3c8a904c91ea8a" name="a7afbc6e564c3c87e8c3c8a904c91ea8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afbc6e564c3c87e8c3c8a904c91ea8a">&#9670;&nbsp;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::__iter__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterator over the elements of this group. </p>
<p >The order of iteration is arbitrary, and may change in future releases of Regina.</p>
<dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1PermGroup.html" title="Represents a group of permutations on n elements.">PermGroup</a> provides the usual <a class="el" href="classregina_1_1PermGroup.html#afc35268917811a8e99111575dc1a35fd" title="Returns a C++ iterator pointing to the first element of this group.">begin()</a> and <a class="el" href="classregina_1_1PermGroup.html#ab0a68a26f54ca4e79c2a9f5d9e2037c3" title="Returns a C++ iterator beyond the last element of this group.">end()</a> functions instead. In particular, you can iterate over the elements of this group in the usual way using a range-based <code>for</code> loop.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the elements of this group. </dd></dl>

</div>
</div>
<a id="afc35268917811a8e99111575dc1a35fd" name="afc35268917811a8e99111575dc1a35fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc35268917811a8e99111575dc1a35fd">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, cached &gt;::iterator <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator pointing to the first element of this group. </p>
<p >The iterator range from <a class="el" href="classregina_1_1PermGroup.html#afc35268917811a8e99111575dc1a35fd" title="Returns a C++ iterator pointing to the first element of this group.">begin()</a> to <a class="el" href="classregina_1_1PermGroup.html#ab0a68a26f54ca4e79c2a9f5d9e2037c3" title="Returns a C++ iterator beyond the last element of this group.">end()</a> runs through all permutations in this group. The order of iteration is arbitrary, and may change in future releases of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1PermGroup.html" title="Represents a group of permutations on n elements.">PermGroup</a> implements the Python iterable interface. You can iterate over the elements of this group in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator pointing to the first element of this group. </dd></dl>

</div>
</div>
<a id="a3bffeabc148f2c2767dc148fd789ddef" name="a3bffeabc148f2c2767dc148fd789ddef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bffeabc148f2c2767dc148fd789ddef">&#9670;&nbsp;</a></span>centraliser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::centraliser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PermClass.html">PermClass</a>&lt; n &gt; &amp;&#160;</td>
          <td class="paramname"><em>conj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the group of all permutations that fix the minimal representative of the given conjugacy class under conjugation. </p>
<p >Specifically, if <em>r</em> is the minimal representative of the given class as returned by <code>conj.rep()</code>, then this routine constructs the subgroup of all permutations <em>p</em> for which <code>p.inverse() * r * p == r</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>While "most" such centraliser groups are small, they <em>could</em> get very large. For example, if <em>conj</em> represents the identity permutation, then the centraliser will be all of S_n. For <em>n</em> ≥ 5, it can be show that the next-worst case is where <em>conj</em> represents a single pair swap, in which case the centraliser has size <code>2⋅(n-2)!</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>conj</em> is not the past-the-end conjugacy class.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the group of all permutations that leave rep() fixed under conjugation. </dd></dl>

</div>
</div>
<a id="a04da4593aa1bdee442da0b0972824649" name="a04da4593aa1bdee442da0b0972824649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04da4593aa1bdee442da0b0972824649">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether the given permutation belongs to this group. </p>
<p >Regardless of the size of this group, the running time for this routine is small polynomial in <em>n</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the permutation whose membership we wish to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if <em>p</em> belongs to this group. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, false &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="ab0a68a26f54ca4e79c2a9f5d9e2037c3" name="ab0a68a26f54ca4e79c2a9f5d9e2037c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a68a26f54ca4e79c2a9f5d9e2037c3">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, cached &gt;::iterator <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator beyond the last element of this group. </p>
<p >The iterator range from <a class="el" href="classregina_1_1PermGroup.html#afc35268917811a8e99111575dc1a35fd" title="Returns a C++ iterator pointing to the first element of this group.">begin()</a> to <a class="el" href="classregina_1_1PermGroup.html#ab0a68a26f54ca4e79c2a9f5d9e2037c3" title="Returns a C++ iterator beyond the last element of this group.">end()</a> runs through all permutations in this group. The order of iteration is arbitrary, and may change in future releases of Regina.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1PermGroup.html" title="Represents a group of permutations on n elements.">PermGroup</a> implements the Python iterable interface. You can iterate over the elements of this group in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the last element of this group. </dd></dl>

</div>
</div>
<a id="aa10cb18b8ad3c9b5fafa212291c87abd" name="aa10cb18b8ad3c9b5fafa212291c87abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10cb18b8ad3c9b5fafa212291c87abd">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, cached &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this and the given group are different. </p>
<p >This does <em>not</em> test group isomorphism, and it does <em>not</em> test whether the two groups use the same internal representation. Instead it tests <em>membership</em>; that is, whether or not the two groups contain precisely the same set of permutations.</p>
<p >As a result, this test is not trivial. It <em>is</em> small polynomial time in <em>n</em>, but it is not as fast as (for example) directly comparing the internal representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group to compare this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is some permutation that belongs to one group but not the other. </dd></dl>

</div>
</div>
<a id="afab21f6a64617892a73e753a43da4f96" name="afab21f6a64617892a73e753a43da4f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab21f6a64617892a73e753a43da4f96">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PermGroup.html">PermGroup</a> &amp; <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, cached &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the group to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group. </dd></dl>

</div>
</div>
<a id="afdf7396385c4621425868f6ac175b6db" name="afdf7396385c4621425868f6ac175b6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf7396385c4621425868f6ac175b6db">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, cached &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether this and the given group are identical. </p>
<p >This does <em>not</em> test group isomorphism, and it does <em>not</em> test whether the two groups use the same internal representation. Instead it tests <em>membership</em>; that is, whether or not the two groups contain precisely the same set of permutations.</p>
<p >As a result, this test is not trivial. It <em>is</em> small polynomial time in <em>n</em>, but it is not as fast as (for example) directly comparing the internal representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group to compare this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given group contain the same permutations. </dd></dl>

</div>
</div>
<a id="ad09ef4cd39eb3c5c12b432f617868227" name="ad09ef4cd39eb3c5c12b432f617868227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09ef4cd39eb3c5c12b432f617868227">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; n &gt;::Index <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of elements in this group. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of this group. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, false &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1PermGroup.html">PermGroup</a>&lt; n, false &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a147fadeaa3292bdd000446bec5b8ab84" name="a147fadeaa3292bdd000446bec5b8ab84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147fadeaa3292bdd000446bec5b8ab84">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a219751575db0fc95e8187cfe200b292f" name="a219751575db0fc95e8187cfe200b292f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219751575db0fc95e8187cfe200b292f">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n, bool cached&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1PermGroup.html">regina::PermGroup</a>&lt; n, cached &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>maths/<a class="el" href="permgroup_8h.html">permgroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
