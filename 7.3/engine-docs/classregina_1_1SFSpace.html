<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::SFSpace Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1SFSpace-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::SFSpace Class Reference<div class="ingroups"><a class="el" href="group__manifold.html">Standard 3-Manifolds</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Represents a general Seifert fibred space, which may be orientable or non-orientable.  
 <a href="classregina_1_1SFSpace.html#details">More...</a></p>

<p><code>#include &lt;manifold/sfs.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SFSpace:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SFSpace.png" usemap="#regina::SFSpace_map" alt=""/>
  <map id="regina::SFSpace_map" name="regina::SFSpace_map">
<area href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold, independent of how it might be triangulated." alt="regina::Manifold" shape="rect" coords="0,56,164,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Manifold &gt;" shape="rect" coords="0,0,164,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5fab224a34630ff6be799258d3999543"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543">ClassType</a> { <br />
&#160;&#160;<a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543aee6551a605ca5c2257265ae389a8ad49">o1</a> = 101
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a5d35a6be3a142c543fec1e3e53d362a6">o2</a> = 102
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a20296b965f715f5c8d705ba59e39c408">n1</a> = 201
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a2ff57c6837334c6b20769ca49b0db5c1">n2</a> = 202
, <br />
&#160;&#160;<a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543aac79eded7f2f568c7f1f8bc461c99c40">n3</a> = 203
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a0407c4c93466e1b07016a53b14674384">n4</a> = 204
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a1654d3e2dace8737bec604781355ecfc">bo1</a> = 301
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a663bb34f4339e3041e80cfb67be260e1">bo2</a> = 302
, <br />
&#160;&#160;<a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a58c4517e4b1116a250580b8d72c1acd0">bn1</a> = 401
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a5f6b58c0ede57bcfdaced07f2e9415e4">bn2</a> = 402
, <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543a4e6ff4256bd817e0cf2f0bb0c61a97e9">bn3</a> = 403
<br />
 }</td></tr>
<tr class="memdesc:a5fab224a34630ff6be799258d3999543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code>, <code>n4</code> for base orbifolds without boundaries, plus five classes <code>bo1</code>, <code>b02</code>, <code>bn1</code>, <code>bn2</code>, <code>bn3</code> for base orbifolds with boundaries.  <a href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543">More...</a><br /></td></tr>
<tr class="separator:a5fab224a34630ff6be799258d3999543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a577f3044abc53a580a0bf8e7c2c072d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a577f3044abc53a580a0bf8e7c2c072d0">SFSpace</a> ()</td></tr>
<tr class="memdesc:a577f3044abc53a580a0bf8e7c2c072d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space with base orbifold the 2-sphere and no exceptional fibres.  <a href="classregina_1_1SFSpace.html#a577f3044abc53a580a0bf8e7c2c072d0">More...</a><br /></td></tr>
<tr class="separator:a577f3044abc53a580a0bf8e7c2c072d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983243fc8ff28b7faf562bdfbdeaa940"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a983243fc8ff28b7faf562bdfbdeaa940">SFSpace</a> (<a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543">ClassType</a> useClass, unsigned long genus, unsigned long <a class="el" href="classregina_1_1SFSpace.html#a5543c0208bf70b3209cfa5baa741c67f">punctures</a>=0, unsigned long puncturesTwisted=0, unsigned long <a class="el" href="classregina_1_1SFSpace.html#a3c825b5e07e3899d32f02f5fbdcb7268">reflectors</a>=0, unsigned long reflectorsTwisted=0)</td></tr>
<tr class="memdesc:a983243fc8ff28b7faf562bdfbdeaa940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space of the given class with the given base orbifold and no exceptional fibres.  <a href="classregina_1_1SFSpace.html#a983243fc8ff28b7faf562bdfbdeaa940">More...</a><br /></td></tr>
<tr class="separator:a983243fc8ff28b7faf562bdfbdeaa940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920437dd4f93aa450fc32353bc405247"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a920437dd4f93aa450fc32353bc405247">SFSpace</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;)=default</td></tr>
<tr class="memdesc:a920437dd4f93aa450fc32353bc405247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given Seifert fibred space.  <a href="classregina_1_1SFSpace.html#a920437dd4f93aa450fc32353bc405247">More...</a><br /></td></tr>
<tr class="separator:a920437dd4f93aa450fc32353bc405247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38afd50a1388b736e0b9d659dbbea0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ac38afd50a1388b736e0b9d659dbbea0f">SFSpace</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:ac38afd50a1388b736e0b9d659dbbea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given Seifert fibred space into this new Seifert fibred space.  <a href="classregina_1_1SFSpace.html#ac38afd50a1388b736e0b9d659dbbea0f">More...</a><br /></td></tr>
<tr class="separator:ac38afd50a1388b736e0b9d659dbbea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e717eb693b02d2cbe2292a22683fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ad5e717eb693b02d2cbe2292a22683fae">operator=</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;)=default</td></tr>
<tr class="memdesc:ad5e717eb693b02d2cbe2292a22683fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given Seifert fibred space.  <a href="classregina_1_1SFSpace.html#ad5e717eb693b02d2cbe2292a22683fae">More...</a><br /></td></tr>
<tr class="separator:ad5e717eb693b02d2cbe2292a22683fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18d3dc5230cf57074a256160dafc618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aa18d3dc5230cf57074a256160dafc618">operator=</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="memdesc:aa18d3dc5230cf57074a256160dafc618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given Seifert fibred space into this Seifert fibred space.  <a href="classregina_1_1SFSpace.html#aa18d3dc5230cf57074a256160dafc618">More...</a><br /></td></tr>
<tr class="separator:aa18d3dc5230cf57074a256160dafc618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44699c824fd9d9b1932cd820836d2fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aa44699c824fd9d9b1932cd820836d2fd">swap</a> (<a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:aa44699c824fd9d9b1932cd820836d2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given Seifert fibred space.  <a href="classregina_1_1SFSpace.html#aa44699c824fd9d9b1932cd820836d2fd">More...</a><br /></td></tr>
<tr class="separator:aa44699c824fd9d9b1932cd820836d2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa60c848a33713a531c608645d70619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543">ClassType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#abaa60c848a33713a531c608645d70619">baseClass</a> () const</td></tr>
<tr class="memdesc:abaa60c848a33713a531c608645d70619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns which of the eleven predefined classes this space belongs to.  <a href="classregina_1_1SFSpace.html#abaa60c848a33713a531c608645d70619">More...</a><br /></td></tr>
<tr class="separator:abaa60c848a33713a531c608645d70619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa610d605949c98b6360a87227d0da1a2"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aa610d605949c98b6360a87227d0da1a2">baseGenus</a> () const</td></tr>
<tr class="memdesc:aa610d605949c98b6360a87227d0da1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the genus of the base orbifold.  <a href="classregina_1_1SFSpace.html#aa610d605949c98b6360a87227d0da1a2">More...</a><br /></td></tr>
<tr class="separator:aa610d605949c98b6360a87227d0da1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873210dabde6c5a56e2dfa284e6707ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a873210dabde6c5a56e2dfa284e6707ae">baseOrientable</a> () const</td></tr>
<tr class="memdesc:a873210dabde6c5a56e2dfa284e6707ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the base surface is orientable.  <a href="classregina_1_1SFSpace.html#a873210dabde6c5a56e2dfa284e6707ae">More...</a><br /></td></tr>
<tr class="separator:a873210dabde6c5a56e2dfa284e6707ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc882d6795358f5e96eaa0c423fb4b1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#abc882d6795358f5e96eaa0c423fb4b1d">fibreReversing</a> () const</td></tr>
<tr class="memdesc:abc882d6795358f5e96eaa0c423fb4b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this space contains any fibre-reversing paths.  <a href="classregina_1_1SFSpace.html#abc882d6795358f5e96eaa0c423fb4b1d">More...</a><br /></td></tr>
<tr class="separator:abc882d6795358f5e96eaa0c423fb4b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b9d08bdd55767057aa12d5a21fa0eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aa5b9d08bdd55767057aa12d5a21fa0eb">fibreNegating</a> () const</td></tr>
<tr class="memdesc:aa5b9d08bdd55767057aa12d5a21fa0eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not we can negate an exceptional fibre by passing it around the interior of the base orbifold.  <a href="classregina_1_1SFSpace.html#aa5b9d08bdd55767057aa12d5a21fa0eb">More...</a><br /></td></tr>
<tr class="separator:aa5b9d08bdd55767057aa12d5a21fa0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5543c0208bf70b3209cfa5baa741c67f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a5543c0208bf70b3209cfa5baa741c67f">punctures</a> () const</td></tr>
<tr class="memdesc:a5543c0208bf70b3209cfa5baa741c67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of punctures in the base orbifold.  <a href="classregina_1_1SFSpace.html#a5543c0208bf70b3209cfa5baa741c67f">More...</a><br /></td></tr>
<tr class="separator:a5543c0208bf70b3209cfa5baa741c67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2995dbf0df3c0d89a1af68bec6cc6003"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a2995dbf0df3c0d89a1af68bec6cc6003">punctures</a> (bool twisted) const</td></tr>
<tr class="memdesc:a2995dbf0df3c0d89a1af68bec6cc6003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of punctures of the given type in the base orbifold.  <a href="classregina_1_1SFSpace.html#a2995dbf0df3c0d89a1af68bec6cc6003">More...</a><br /></td></tr>
<tr class="separator:a2995dbf0df3c0d89a1af68bec6cc6003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c825b5e07e3899d32f02f5fbdcb7268"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a3c825b5e07e3899d32f02f5fbdcb7268">reflectors</a> () const</td></tr>
<tr class="memdesc:a3c825b5e07e3899d32f02f5fbdcb7268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of reflector boundary components of the base orbifold.  <a href="classregina_1_1SFSpace.html#a3c825b5e07e3899d32f02f5fbdcb7268">More...</a><br /></td></tr>
<tr class="separator:a3c825b5e07e3899d32f02f5fbdcb7268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45bd427305037e276106095cec3c62b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ac45bd427305037e276106095cec3c62b">reflectors</a> (bool twisted) const</td></tr>
<tr class="memdesc:ac45bd427305037e276106095cec3c62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of reflector boundary components of the given type in the base orbifold.  <a href="classregina_1_1SFSpace.html#ac45bd427305037e276106095cec3c62b">More...</a><br /></td></tr>
<tr class="separator:ac45bd427305037e276106095cec3c62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0fbc352bf9f9f680dc4622760099c5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#acd0fbc352bf9f9f680dc4622760099c5">fibreCount</a> () const</td></tr>
<tr class="memdesc:acd0fbc352bf9f9f680dc4622760099c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of exceptional fibres in this Seifert fibred space.  <a href="classregina_1_1SFSpace.html#acd0fbc352bf9f9f680dc4622760099c5">More...</a><br /></td></tr>
<tr class="separator:acd0fbc352bf9f9f680dc4622760099c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b92f5e9498ac3393481893c104bd6a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a4b92f5e9498ac3393481893c104bd6a0">fibre</a> (unsigned long which) const</td></tr>
<tr class="memdesc:a4b92f5e9498ac3393481893c104bd6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested exceptional fibre.  <a href="classregina_1_1SFSpace.html#a4b92f5e9498ac3393481893c104bd6a0">More...</a><br /></td></tr>
<tr class="separator:a4b92f5e9498ac3393481893c104bd6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f1c254d3237073e5ba12978162ad76"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a96f1c254d3237073e5ba12978162ad76">obstruction</a> () const</td></tr>
<tr class="memdesc:a96f1c254d3237073e5ba12978162ad76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the obstruction constant <em>b</em> for this Seifert fibred space.  <a href="classregina_1_1SFSpace.html#a96f1c254d3237073e5ba12978162ad76">More...</a><br /></td></tr>
<tr class="separator:a96f1c254d3237073e5ba12978162ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6811f7faaddfc8024244ad326a8b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#adb6811f7faaddfc8024244ad326a8b2f">addHandle</a> (bool <a class="el" href="classregina_1_1SFSpace.html#abc882d6795358f5e96eaa0c423fb4b1d">fibreReversing</a>=false)</td></tr>
<tr class="memdesc:adb6811f7faaddfc8024244ad326a8b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new handle into the base orbifold.  <a href="classregina_1_1SFSpace.html#adb6811f7faaddfc8024244ad326a8b2f">More...</a><br /></td></tr>
<tr class="separator:adb6811f7faaddfc8024244ad326a8b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd42f80225f7c7e0c2af0933baeb338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a9dd42f80225f7c7e0c2af0933baeb338">addCrosscap</a> (bool <a class="el" href="classregina_1_1SFSpace.html#abc882d6795358f5e96eaa0c423fb4b1d">fibreReversing</a>=false)</td></tr>
<tr class="memdesc:a9dd42f80225f7c7e0c2af0933baeb338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new crosscap into the base orbifold.  <a href="classregina_1_1SFSpace.html#a9dd42f80225f7c7e0c2af0933baeb338">More...</a><br /></td></tr>
<tr class="separator:a9dd42f80225f7c7e0c2af0933baeb338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b831e36639d0182ce5fc4f89b9a218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a77b831e36639d0182ce5fc4f89b9a218">addPuncture</a> (bool twisted=false, unsigned long nPunctures=1)</td></tr>
<tr class="memdesc:a77b831e36639d0182ce5fc4f89b9a218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts one or more new punctures into the base orbifold.  <a href="classregina_1_1SFSpace.html#a77b831e36639d0182ce5fc4f89b9a218">More...</a><br /></td></tr>
<tr class="separator:a77b831e36639d0182ce5fc4f89b9a218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaef6a5a9f7187c315817b222e6cf28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#affaef6a5a9f7187c315817b222e6cf28">addReflector</a> (bool twisted=false, unsigned long nReflectors=1)</td></tr>
<tr class="memdesc:affaef6a5a9f7187c315817b222e6cf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one or more new reflector boundary components to the base orbifold.  <a href="classregina_1_1SFSpace.html#affaef6a5a9f7187c315817b222e6cf28">More...</a><br /></td></tr>
<tr class="separator:affaef6a5a9f7187c315817b222e6cf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cabfe8efaeb3c370e74abf2f50a09be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a9cabfe8efaeb3c370e74abf2f50a09be">insertFibre</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;<a class="el" href="classregina_1_1SFSpace.html#a4b92f5e9498ac3393481893c104bd6a0">fibre</a>)</td></tr>
<tr class="memdesc:a9cabfe8efaeb3c370e74abf2f50a09be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given fibre to this Seifert fibred space.  <a href="classregina_1_1SFSpace.html#a9cabfe8efaeb3c370e74abf2f50a09be">More...</a><br /></td></tr>
<tr class="separator:a9cabfe8efaeb3c370e74abf2f50a09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35622fc87c75f221bff99ce9ad5db238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a35622fc87c75f221bff99ce9ad5db238">insertFibre</a> (long alpha, long beta)</td></tr>
<tr class="memdesc:a35622fc87c75f221bff99ce9ad5db238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given fibre to this Seifert fibred space.  <a href="classregina_1_1SFSpace.html#a35622fc87c75f221bff99ce9ad5db238">More...</a><br /></td></tr>
<tr class="separator:a35622fc87c75f221bff99ce9ad5db238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e0759c61a8b7d8816ca10bbee42a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a070e0759c61a8b7d8816ca10bbee42a8">reflect</a> ()</td></tr>
<tr class="memdesc:a070e0759c61a8b7d8816ca10bbee42a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces this space with its mirror image.  <a href="classregina_1_1SFSpace.html#a070e0759c61a8b7d8816ca10bbee42a8">More...</a><br /></td></tr>
<tr class="separator:a070e0759c61a8b7d8816ca10bbee42a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699dd395b4b242cd4d6157b705f65123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a699dd395b4b242cd4d6157b705f65123">complementAllFibres</a> ()</td></tr>
<tr class="memdesc:a699dd395b4b242cd4d6157b705f65123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each exceptional fibre of the form (<em>alpha</em>, <em>beta</em>) with a fibre of the form (<em>alpha</em>, <em>alpha</em> - <em>beta</em>).  <a href="classregina_1_1SFSpace.html#a699dd395b4b242cd4d6157b705f65123">More...</a><br /></td></tr>
<tr class="separator:a699dd395b4b242cd4d6157b705f65123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f4b1aeac0b2105233f4293509c492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ab28f4b1aeac0b2105233f4293509c492">reduce</a> (bool mayReflect=true)</td></tr>
<tr class="memdesc:ab28f4b1aeac0b2105233f4293509c492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the parameters of this Seifert fibred space to a simpler form if possible, without changing the underlying fibration.  <a href="classregina_1_1SFSpace.html#ab28f4b1aeac0b2105233f4293509c492">More...</a><br /></td></tr>
<tr class="separator:ab28f4b1aeac0b2105233f4293509c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a3ed0997f6d88e195e5bc3cabf5294"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ab2a3ed0997f6d88e195e5bc3cabf5294">isLensSpace</a> () const</td></tr>
<tr class="memdesc:ab2a3ed0997f6d88e195e5bc3cabf5294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this Seifert fibred space is a Lens space.  <a href="classregina_1_1SFSpace.html#ab2a3ed0997f6d88e195e5bc3cabf5294">More...</a><br /></td></tr>
<tr class="separator:ab2a3ed0997f6d88e195e5bc3cabf5294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55dbc5a9fa80611d6cff6724ead915be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a55dbc5a9fa80611d6cff6724ead915be">operator==</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:a55dbc5a9fa80611d6cff6724ead915be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object contain precisely the same presentations of the same Seifert fibred space.  <a href="classregina_1_1SFSpace.html#a55dbc5a9fa80611d6cff6724ead915be">More...</a><br /></td></tr>
<tr class="separator:a55dbc5a9fa80611d6cff6724ead915be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e3a984ec3bceb32a8ada29ff58460b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a12e3a984ec3bceb32a8ada29ff58460b">operator!=</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:a12e3a984ec3bceb32a8ada29ff58460b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given object do not contain precisely the same presentations of the same Seifert fibred space.  <a href="classregina_1_1SFSpace.html#a12e3a984ec3bceb32a8ada29ff58460b">More...</a><br /></td></tr>
<tr class="separator:a12e3a984ec3bceb32a8ada29ff58460b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade28e31e2a1e6c0cafb39c26213c6055"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ade28e31e2a1e6c0cafb39c26213c6055">operator&lt;</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const</td></tr>
<tr class="memdesc:ade28e31e2a1e6c0cafb39c26213c6055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space.  <a href="classregina_1_1SFSpace.html#ade28e31e2a1e6c0cafb39c26213c6055">More...</a><br /></td></tr>
<tr class="separator:ade28e31e2a1e6c0cafb39c26213c6055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93cdcbb9342d2621f993bea1d2589e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ac93cdcbb9342d2621f993bea1d2589e8">construct</a> () const override</td></tr>
<tr class="memdesc:ac93cdcbb9342d2621f993bea1d2589e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a triangulation of this 3-manifold, if such a construction has been implemented.  <a href="classregina_1_1SFSpace.html#ac93cdcbb9342d2621f993bea1d2589e8">More...</a><br /></td></tr>
<tr class="separator:ac93cdcbb9342d2621f993bea1d2589e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94f84d6dacbdbc6113318bc5b44cdd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ad94f84d6dacbdbc6113318bc5b44cdd0">homology</a> () const override</td></tr>
<tr class="memdesc:ad94f84d6dacbdbc6113318bc5b44cdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="classregina_1_1SFSpace.html#ad94f84d6dacbdbc6113318bc5b44cdd0">More...</a><br /></td></tr>
<tr class="separator:ad94f84d6dacbdbc6113318bc5b44cdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef1686791fb43a8e4d0b5221c53fd31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a8ef1686791fb43a8e4d0b5221c53fd31">isHyperbolic</a> () const override</td></tr>
<tr class="memdesc:a8ef1686791fb43a8e4d0b5221c53fd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not this is a finite-volume hyperbolic manifold.  <a href="classregina_1_1SFSpace.html#a8ef1686791fb43a8e4d0b5221c53fd31">More...</a><br /></td></tr>
<tr class="separator:a8ef1686791fb43a8e4d0b5221c53fd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370fcf932fcdb4beacf04e4e0bdfc123"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a370fcf932fcdb4beacf04e4e0bdfc123">writeName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a370fcf932fcdb4beacf04e4e0bdfc123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="classregina_1_1SFSpace.html#a370fcf932fcdb4beacf04e4e0bdfc123">More...</a><br /></td></tr>
<tr class="separator:a370fcf932fcdb4beacf04e4e0bdfc123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74307d1ef9a53354aacb00e32fde0555"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a74307d1ef9a53354aacb00e32fde0555">writeTeXName</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a74307d1ef9a53354aacb00e32fde0555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="classregina_1_1SFSpace.html#a74307d1ef9a53354aacb00e32fde0555">More...</a><br /></td></tr>
<tr class="separator:a74307d1ef9a53354aacb00e32fde0555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4246776c806d4bf771067bf1d956500"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aa4246776c806d4bf771067bf1d956500">writeStructure</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:aa4246776c806d4bf771067bf1d956500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream.  <a href="classregina_1_1SFSpace.html#aa4246776c806d4bf771067bf1d956500">More...</a><br /></td></tr>
<tr class="separator:aa4246776c806d4bf771067bf1d956500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d702e878c4a5e17dc17245b8e3d667"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a93d702e878c4a5e17dc17245b8e3d667">name</a> () const</td></tr>
<tr class="memdesc:a93d702e878c4a5e17dc17245b8e3d667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the common name of this 3-manifold as a human-readable string.  <a href="classregina_1_1Manifold.html#a93d702e878c4a5e17dc17245b8e3d667">More...</a><br /></td></tr>
<tr class="separator:a93d702e878c4a5e17dc17245b8e3d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ee2d6d382b01c938d3b948e732cad9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a35ee2d6d382b01c938d3b948e732cad9">texName</a> () const</td></tr>
<tr class="memdesc:a35ee2d6d382b01c938d3b948e732cad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the common name of this 3-manifold in TeX format.  <a href="classregina_1_1Manifold.html#a35ee2d6d382b01c938d3b948e732cad9">More...</a><br /></td></tr>
<tr class="separator:a35ee2d6d382b01c938d3b948e732cad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c9d3c3cbce470e4ecb69e91384d02c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#ad5c9d3c3cbce470e4ecb69e91384d02c">structure</a> () const</td></tr>
<tr class="memdesc:ad5c9d3c3cbce470e4ecb69e91384d02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the structure of this 3-manifold that might not be evident from its common name.  <a href="classregina_1_1Manifold.html#ad5c9d3c3cbce470e4ecb69e91384d02c">More...</a><br /></td></tr>
<tr class="separator:ad5c9d3c3cbce470e4ecb69e91384d02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340ae7f9e981a404667a1383366c114c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a340ae7f9e981a404667a1383366c114c">operator&lt;</a> (const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;compare) const</td></tr>
<tr class="memdesc:a340ae7f9e981a404667a1383366c114c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this 3-manifold is "smaller" than the given representation of the given 3-manifold.  <a href="classregina_1_1Manifold.html#a340ae7f9e981a404667a1383366c114c">More...</a><br /></td></tr>
<tr class="separator:a340ae7f9e981a404667a1383366c114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239a494eef37497d14d963ab2d0ad9f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a239a494eef37497d14d963ab2d0ad9f9">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a239a494eef37497d14d963ab2d0ad9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1Manifold.html#a239a494eef37497d14d963ab2d0ad9f9">More...</a><br /></td></tr>
<tr class="separator:a239a494eef37497d14d963ab2d0ad9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c18dbf18c57378e979f81220ebd6eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a9c18dbf18c57378e979f81220ebd6eb9">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a9c18dbf18c57378e979f81220ebd6eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1Manifold.html#a9c18dbf18c57378e979f81220ebd6eb9">More...</a><br /></td></tr>
<tr class="separator:a9c18dbf18c57378e979f81220ebd6eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Represents a general Seifert fibred space, which may be orientable or non-orientable. </p>
<p >Punctures and reflector boundaries in the base orbifold are supported.</p>
<p >A Seifert fibred space whose base orbifold has no punctures or reflector boundaries can be placed into one of the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code> and <code>n4</code>, as detailed on page 88 of "Seifert Manifolds", Peter Orlik, Springer-Verlag, 1972. These classes describe whether this base surface is orientable, as well as how many of its generators give fibre-reversing paths in the 3-manifold.</p>
<p >In the case where the base orbifold has punctures and/or reflector boundaries, we use the five simplified classes <code>bo1</code>, <code>bo2</code>, <code>bn1</code>, <code>bn2</code> and <code>bn3</code>. These classes are not standard terminology (i.e., they have been created explicitly for Regina), and generally they do not provide enough information to uniquely identify the 3-manifold. They do however identify whether or not the base orbifold is orientable, and whether or not it contains any fibre-reversing paths.</p>
<p >When describing punctures and reflector boundaries, a <em>twisted</em> boundary is one that gives a fibre-reversing path, and an <em>untwisted</em> boundary is one around which the direction of fibres is preserved.</p>
<p >Exceptional fibres are sorted first by <em>alpha</em> (the index) and then by <em>beta</em>. The obstruction constant <em>b</em> is stored separately, though in output routines such as <a class="el" href="classregina_1_1Manifold.html#a93d702e878c4a5e17dc17245b8e3d667" title="Returns the common name of this 3-manifold as a human-readable string.">name()</a> and <a class="el" href="classregina_1_1Manifold.html#ad5c9d3c3cbce470e4ecb69e91384d02c" title="Returns details of the structure of this 3-manifold that might not be evident from its common name.">structure()</a> it is merged in with the exceptional fibres. Specifically, it is merged in with the <em>beta</em> of the final exceptional fibre (replacing it with <code>beta + b.alpha</code>), or if there are no exceptional fibres then it is presented as a single (1,b) fibre.</p>
<p >The <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold, independent of how it might be triangulated.">Manifold</a> routines <a class="el" href="classregina_1_1SFSpace.html#ad94f84d6dacbdbc6113318bc5b44cdd0" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homology()</a> and <a class="el" href="classregina_1_1SFSpace.html#ac93cdcbb9342d2621f993bea1d2589e8" title="Returns a triangulation of this 3-manifold, if such a construction has been implemented.">construct()</a> are only implemented in some cases. The <a class="el" href="classregina_1_1SFSpace.html#ad94f84d6dacbdbc6113318bc5b44cdd0" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homology()</a> routine is implemented if and only if the base orbifold has no punctures. The <a class="el" href="classregina_1_1SFSpace.html#ac93cdcbb9342d2621f993bea1d2589e8" title="Returns a triangulation of this 3-manifold, if such a construction has been implemented.">construct()</a> routine is implemented only for lens spaces and Seifert fibred spaces over the 2-sphere without punctures or reflector boundaries.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. Note, however, that <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> still requires a non-trivial (but constant sized) amount of data to be copied even in a move operation.</p>
<dl class="section warning"><dt>Warning</dt><dd>In Regina 4.2.1 and earlier, this class was named NSFS. As of Regina 4.3, this class was renamed due to significant changes of behaviour (it became more general, and also now keeps the obstruction parameter <em>b</em> separate). Code that was written to work with the old NSFS class should be looked at closely before being adapted to the new <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class (i.e., it may require more than just substituting class names).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd><p class="startdd"><em>Feature (long-term):</em> Implement recognition of more common names. </p>
<p class="enddd"><em>Feature (long-term):</em> Implement triangulation construction and homology calculation for more Seifert fibred spaces.</p>
</dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5fab224a34630ff6be799258d3999543" name="a5fab224a34630ff6be799258d3999543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fab224a34630ff6be799258d3999543">&#9670;&nbsp;</a></span>ClassType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543">regina::SFSpace::ClassType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code>, <code>n4</code> for base orbifolds without boundaries, plus five classes <code>bo1</code>, <code>b02</code>, <code>bn1</code>, <code>bn2</code>, <code>bn3</code> for base orbifolds with boundaries. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543aee6551a605ca5c2257265ae389a8ad49" name="a5fab224a34630ff6be799258d3999543aee6551a605ca5c2257265ae389a8ad49"></a>o1&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold is orientable with no punctures or reflector boundaries, and that none of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a5d35a6be3a142c543fec1e3e53d362a6" name="a5fab224a34630ff6be799258d3999543a5d35a6be3a142c543fec1e3e53d362a6"></a>o2&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold is orientable with no punctures or reflector boundaries, and that all of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a20296b965f715f5c8d705ba59e39c408" name="a5fab224a34630ff6be799258d3999543a20296b965f715f5c8d705ba59e39c408"></a>n1&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, and that none of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a2ff57c6837334c6b20769ca49b0db5c1" name="a5fab224a34630ff6be799258d3999543a2ff57c6837334c6b20769ca49b0db5c1"></a>n2&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, and that all of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543aac79eded7f2f568c7f1f8bc461c99c40" name="a5fab224a34630ff6be799258d3999543aac79eded7f2f568c7f1f8bc461c99c40"></a>n3&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, that it has non-orientable genus at least two, and that precisely one of its generators gives a fibre-reversing path. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a0407c4c93466e1b07016a53b14674384" name="a5fab224a34630ff6be799258d3999543a0407c4c93466e1b07016a53b14674384"></a>n4&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, that it has non-orientable genus at least three, and that precisely two of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a1654d3e2dace8737bec604781355ecfc" name="a5fab224a34630ff6be799258d3999543a1654d3e2dace8737bec604781355ecfc"></a>bo1&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is orientable, and that it contains no fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a663bb34f4339e3041e80cfb67be260e1" name="a5fab224a34630ff6be799258d3999543a663bb34f4339e3041e80cfb67be260e1"></a>bo2&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is orientable, and that it contains at least one fibre-reversing path. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a58c4517e4b1116a250580b8d72c1acd0" name="a5fab224a34630ff6be799258d3999543a58c4517e4b1116a250580b8d72c1acd0"></a>bn1&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, and that it contains no fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a5f6b58c0ede57bcfdaced07f2e9415e4" name="a5fab224a34630ff6be799258d3999543a5f6b58c0ede57bcfdaced07f2e9415e4"></a>bn2&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, and that its fibre-reversing paths correspond precisely to its orientation-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5fab224a34630ff6be799258d3999543a4e6ff4256bd817e0cf2f0bb0c61a97e9" name="a5fab224a34630ff6be799258d3999543a4e6ff4256bd817e0cf2f0bb0c61a97e9"></a>bn3&#160;</td><td class="fielddoc"><p >Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, that it contains at least one fibre-reversing path, and that its fibre-reversing paths do not correspond precisely to its orientation-reversing paths. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a577f3044abc53a580a0bf8e7c2c072d0" name="a577f3044abc53a580a0bf8e7c2c072d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577f3044abc53a580a0bf8e7c2c072d0">&#9670;&nbsp;</a></span>SFSpace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space with base orbifold the 2-sphere and no exceptional fibres. </p>

</div>
</div>
<a id="a983243fc8ff28b7faf562bdfbdeaa940" name="a983243fc8ff28b7faf562bdfbdeaa940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983243fc8ff28b7faf562bdfbdeaa940">&#9670;&nbsp;</a></span>SFSpace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543">SFSpace::ClassType</a>&#160;</td>
          <td class="paramname"><em>useClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>genus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>punctures</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>puncturesTwisted</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>reflectors</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>reflectorsTwisted</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space of the given class with the given base orbifold and no exceptional fibres. </p>
<dl class="section pre"><dt>Precondition</dt><dd>If there are no punctures or reflector boundary components, then <em>useClass</em> is one of the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code> or <code>n4</code>. Likewise, if there are punctures and/or reflector boundary components, then <em>useClass</em> is one of the five classes <code>bo1</code>, <code>bo2</code>, <code>bn1</code>, <code>bn2</code> or <code>bn3</code>. </dd>
<dd>
If there are any twisted punctures or reflector boundary components, then <em>useClass</em> is either <code>bo2</code> or <code>bn3</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useClass</td><td>indicates whether the base orbifold is closed and/or orientable, and gives information about fibre-reversing paths in the 3-manifold. See the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes and the ClassType enumeration notes for details. </td></tr>
    <tr><td class="paramname">genus</td><td>the genus of the base orbifold (the number of tori or projective planes that it contains). Note that for non-orientable base surfaces, this is the non-orientable genus. </td></tr>
    <tr><td class="paramname">punctures</td><td>the number of untwisted ordinary boundary components of the base orbifold. Here "ordinary" means that the puncture gives rise to a real 3-manifold boundary (i.e., this is not a reflector boundary of the base orbifold). </td></tr>
    <tr><td class="paramname">puncturesTwisted</td><td>the number of twisted ordinary boundary components of the base orbifold. Here "ordinary" means that the puncture gives rise to a real 3-manifold boundary (i.e., this is not a reflector boundary of the base orbifold). </td></tr>
    <tr><td class="paramname">reflectors</td><td>the number of untwisted reflector boundary components of the base orbifold. These are in addition to the ordinary boundary components described by <em>punctures</em>. </td></tr>
    <tr><td class="paramname">reflectorsTwisted</td><td>the number of twisted reflector boundary components of the base orbifold. These are in addition to the ordinary boundary components described by <em>puncturesTwisted</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a920437dd4f93aa450fc32353bc405247" name="a920437dd4f93aa450fc32353bc405247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a920437dd4f93aa450fc32353bc405247">&#9670;&nbsp;</a></span>SFSpace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given Seifert fibred space. </p>

</div>
</div>
<a id="ac38afd50a1388b736e0b9d659dbbea0f" name="ac38afd50a1388b736e0b9d659dbbea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac38afd50a1388b736e0b9d659dbbea0f">&#9670;&nbsp;</a></span>SFSpace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given Seifert fibred space into this new Seifert fibred space. </p>
<p >This is a fast (constant time) operation.</p>
<p >The space that was passed will no longer be usable. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9dd42f80225f7c7e0c2af0933baeb338" name="a9dd42f80225f7c7e0c2af0933baeb338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd42f80225f7c7e0c2af0933baeb338">&#9670;&nbsp;</a></span>addCrosscap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addCrosscap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fibreReversing</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new crosscap into the base orbifold. </p>
<p >This makes the base orbifold non-orientable, and increases its non-orientable genus by one. It is equivalent to removing a disc from the base orbifold and replacing it with a Mobius band.</p>
<p >Note that this operation may alter which of the classes described by ClassType this space belongs to.</p>
<p >The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibreReversing</td><td><code>true</code> if the generator of the new crosscap should give a fibre-reversing curve in the overall 3-manifold, or <code>false</code> (the default) if it should preserve the directions of the fibres. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6811f7faaddfc8024244ad326a8b2f" name="adb6811f7faaddfc8024244ad326a8b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6811f7faaddfc8024244ad326a8b2f">&#9670;&nbsp;</a></span>addHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addHandle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fibreReversing</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new handle into the base orbifold. </p>
<p >This increases the orientable genus of the base orbifold by one, or the non-orientable genus by two. It is equivalent to removing a disc from the base orbifold and replacing it with a punctured torus.</p>
<p >Note that this operation may alter which of the classes described by ClassType this space belongs to.</p>
<p >The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibreReversing</td><td><code>true</code> if one or both generators of the new handle should give fibre-reversing curves in the overall 3-manifold, or <code>false</code> (the default) if both generators should preserve the directions of the fibres. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77b831e36639d0182ce5fc4f89b9a218" name="a77b831e36639d0182ce5fc4f89b9a218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b831e36639d0182ce5fc4f89b9a218">&#9670;&nbsp;</a></span>addPuncture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addPuncture </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nPunctures</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts one or more new punctures into the base orbifold. </p>
<p >The punctures may be twisted or untwisted.</p>
<p >Each puncture insertion is equivalent to removing a disc from the base orbifold. In the untwisted case this results in a new torus boundary for the 3-manifold, and in the twisted case it results in a new Klein bottle boundary.</p>
<p >The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new punctures should be twisted (i.e., their boundaries should be fibre-reversing), or <code>false</code> if the new punctures should be untwisted. </td></tr>
    <tr><td class="paramname">nPunctures</td><td>the number of new punctures to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affaef6a5a9f7187c315817b222e6cf28" name="affaef6a5a9f7187c315817b222e6cf28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaef6a5a9f7187c315817b222e6cf28">&#9670;&nbsp;</a></span>addReflector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addReflector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nReflectors</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one or more new reflector boundary components to the base orbifold. </p>
<p >The new reflector boundaries may be twisted or untwisted.</p>
<p >Each addition of a reflector boundary component is equivalent to removing a disc from the base orbifold and replacing it with an annulus with one reflector boundary.</p>
<p >In the untwisted case, it has the effect of removing a trivially fibred solid torus from the overall 3-manifold and replacing it with an appropriately fibred twisted I-bundle over the torus.</p>
<p >The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new reflector boundaries should be twisted (i.e., the boundaries should be fibre-reversing), or <code>false</code> if the new reflector boundaries should be untwisted. </td></tr>
    <tr><td class="paramname">nReflectors</td><td>the number of new reflector boundaries to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaa60c848a33713a531c608645d70619" name="abaa60c848a33713a531c608645d70619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa60c848a33713a531c608645d70619">&#9670;&nbsp;</a></span>baseClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html#a5fab224a34630ff6be799258d3999543">SFSpace::ClassType</a> regina::SFSpace::baseClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns which of the eleven predefined classes this space belongs to. </p>
<p >The specific class indicates whether the base orbifold has punctures and/or reflector boundaries, whether the base orbifold is orientable, and gives information on fibre-reversing paths.</p>
<p >The class can be (indirectly) modified by calling <a class="el" href="classregina_1_1SFSpace.html#adb6811f7faaddfc8024244ad326a8b2f" title="Inserts a new handle into the base orbifold.">addHandle()</a>, <a class="el" href="classregina_1_1SFSpace.html#a9dd42f80225f7c7e0c2af0933baeb338" title="Inserts a new crosscap into the base orbifold.">addCrosscap()</a>, <a class="el" href="classregina_1_1SFSpace.html#a77b831e36639d0182ce5fc4f89b9a218" title="Inserts one or more new punctures into the base orbifold.">addPuncture()</a> or <a class="el" href="classregina_1_1SFSpace.html#affaef6a5a9f7187c315817b222e6cf28" title="Adds one or more new reflector boundary components to the base orbifold.">addReflector()</a>.</p>
<p >For more information on the eleven predefined classes, see the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes or the ClassType enumeration notes.</p>
<dl class="section return"><dt>Returns</dt><dd>the particular class to which this space belongs. </dd></dl>

</div>
</div>
<a id="aa610d605949c98b6360a87227d0da1a2" name="aa610d605949c98b6360a87227d0da1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa610d605949c98b6360a87227d0da1a2">&#9670;&nbsp;</a></span>baseGenus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::baseGenus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the genus of the base orbifold. </p>
<p >All punctures and reflector boundaries in the base orbifold are ignored (i.e., they are treated as though they had been replaced with ordinary filled discs).</p>
<p >The genus is the number of tori or projective planes that the base surface is formed from. In particular, if the base surface is non-orientable then this is the non-orientable genus.</p>
<dl class="section return"><dt>Returns</dt><dd>the genus of the base orbifold. </dd></dl>

</div>
</div>
<a id="a873210dabde6c5a56e2dfa284e6707ae" name="a873210dabde6c5a56e2dfa284e6707ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873210dabde6c5a56e2dfa284e6707ae">&#9670;&nbsp;</a></span>baseOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::baseOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the base surface is orientable. </p>
<p >Reflector boundary components of the base orbifold are not considered here.</p>
<p >The orientability of the base surface can be (indirectly) modified by calling <a class="el" href="classregina_1_1SFSpace.html#a9dd42f80225f7c7e0c2af0933baeb338" title="Inserts a new crosscap into the base orbifold.">addCrosscap()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the base surface is orientable. </dd></dl>

</div>
</div>
<a id="a699dd395b4b242cd4d6157b705f65123" name="a699dd395b4b242cd4d6157b705f65123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699dd395b4b242cd4d6157b705f65123">&#9670;&nbsp;</a></span>complementAllFibres()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::complementAllFibres </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each exceptional fibre of the form (<em>alpha</em>, <em>beta</em>) with a fibre of the form (<em>alpha</em>, <em>alpha</em> - <em>beta</em>). </p>
<p >The obstruction constant <em>b</em> is not touched. </p>

</div>
</div>
<a id="ac93cdcbb9342d2621f993bea1d2589e8" name="ac93cdcbb9342d2621f993bea1d2589e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93cdcbb9342d2621f993bea1d2589e8">&#9670;&nbsp;</a></span>construct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; regina::SFSpace::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a triangulation of this 3-manifold, if such a construction has been implemented. </p>
<p >For details of which types of 3-manifolds have implemented this routine, see the class notes for each corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold, independent of how it might be triangulated.">Manifold</a>.</p>
<p >The default implemention of this routine just throws a <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Explicit construction has not yet been implemented for this particular 3-manifold.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FileError.html" title="An exception thrown when trying to access data from the filesystem.">FileError</a></td><td>The construction needs to be read from file (as opposed to computed on the fly), but the file is inaccessible or its contents cannot be read and parsed correctly. Currently this can only happen for the subclass <a class="el" href="classregina_1_1SnapPeaCensusManifold.html" title="Represents a 3-manifold from the SnapPea cusped census.">SnapPeaCensusManifold</a>, which reads its triangulations from the SnapPea census databases that are installed with Regina.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this 3-manifold, if this construction has been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1Manifold.html#a9578f9b626af266f7666617e647bb3f7">regina::Manifold</a>.</p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a4b92f5e9498ac3393481893c104bd6a0" name="a4b92f5e9498ac3393481893c104bd6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b92f5e9498ac3393481893c104bd6a0">&#9670;&nbsp;</a></span>fibre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> regina::SFSpace::fibre </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the requested exceptional fibre. </p>
<p >Fibres are stored in sorted order by <em>alpha</em> (the index) and then by <em>beta</em>. See the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes for details.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine takes linear time (specifically, linear in the argument <em>which</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>determines which fibre to return; this must be between 0 and getFibreCount()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested fibre. </dd></dl>

</div>
</div>
<a id="acd0fbc352bf9f9f680dc4622760099c5" name="acd0fbc352bf9f9f680dc4622760099c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0fbc352bf9f9f680dc4622760099c5">&#9670;&nbsp;</a></span>fibreCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::fibreCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of exceptional fibres in this Seifert fibred space. </p>
<p >Note that the obstruction parameter <em>b</em> is not included in this count. That is, any (1,k) fibres are ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of exceptional fibres. </dd></dl>

</div>
</div>
<a id="aa5b9d08bdd55767057aa12d5a21fa0eb" name="aa5b9d08bdd55767057aa12d5a21fa0eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b9d08bdd55767057aa12d5a21fa0eb">&#9670;&nbsp;</a></span>fibreNegating()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::fibreNegating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not we can negate an exceptional fibre by passing it around the interior of the base orbifold. </p>
<p >That is, this routine determines whether a (<em>p</em>, <em>q</em>) exceptional fibre can become a (<em>p</em>, -<em>q</em>) exceptional fibre simply by sliding it around.</p>
<p >This is possible if either</p><ul>
<li>the base orbifold has an orientation-reversing loop that does not reverse fibres in the 3-manifold, or</li>
<li>the base orbifold has an orientation-preserving loop that does reverse fibres in the 3-manifold.</li>
</ul>
<p >Note that reflector boundary components, whilst making the overall 3-manifold non-orientable, have no bearing on the outcome of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only an exceptional fibre can be reflected as described above. </dd></dl>

</div>
</div>
<a id="abc882d6795358f5e96eaa0c423fb4b1d" name="abc882d6795358f5e96eaa0c423fb4b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc882d6795358f5e96eaa0c423fb4b1d">&#9670;&nbsp;</a></span>fibreReversing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::fibreReversing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this space contains any fibre-reversing paths. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a fibre-reversing path exists. </dd></dl>

</div>
</div>
<a id="ad94f84d6dacbdbc6113318bc5b44cdd0" name="ad94f84d6dacbdbc6113318bc5b44cdd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94f84d6dacbdbc6113318bc5b44cdd0">&#9670;&nbsp;</a></span>homology()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> regina::SFSpace::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p >For details of which types of 3-manifolds have implemented this routine, see the class notes for each corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold, independent of how it might be triangulated.">Manifold</a>.</p>
<p >The default implemention of this routine just throws a <a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a> exception.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1NotImplemented.html" title="An exception thrown when some functionality is not yet implemented.">NotImplemented</a></td><td>Homology calculation has not yet been implemented for this particular 3-manifold.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1FileError.html" title="An exception thrown when trying to access data from the filesystem.">FileError</a></td><td>The homology needs to be read from file (as opposed to computed), but the file is inaccessible or its contents cannot be read and parsed correctly. Currently this can only happen for the subclass <a class="el" href="classregina_1_1SnapPeaCensusManifold.html" title="Represents a 3-manifold from the SnapPea cusped census.">SnapPeaCensusManifold</a>, which reads its results from the SnapPea census databases that are installed with Regina.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, if this functionality has been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1Manifold.html#a62e559b2d76e47798b799ffe495e6bc9">regina::Manifold</a>.</p>

</div>
</div>
<a id="a9cabfe8efaeb3c370e74abf2f50a09be" name="a9cabfe8efaeb3c370e74abf2f50a09be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cabfe8efaeb3c370e74abf2f50a09be">&#9670;&nbsp;</a></span>insertFibre() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::insertFibre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>fibre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given fibre to this Seifert fibred space. </p>
<p >This may be an exceptional fibre (<em>alpha</em> &gt; 1) or it may be a regular fibre (<em>alpha</em> = 1). If it is a regular fibre, the obstruction constant <em>b</em> will be adjusted according to the value of <em>beta</em>.</p>
<p >Note that there is no restriction on the range of the second parameter <em>beta</em>. If it is out of the usual range 0 ≤ <em>beta</em> &lt; <em>alpha</em>, it will be pulled back into this range and the excess will be pushed into the obstruction constant <em>b</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td><em>alpha</em> is zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibre</td><td>the fibre to insert. The first parameter of this fibre (i.e., its index) must be strictly positive, and the two parameters of this fibre must be coprime. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35622fc87c75f221bff99ce9ad5db238" name="a35622fc87c75f221bff99ce9ad5db238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35622fc87c75f221bff99ce9ad5db238">&#9670;&nbsp;</a></span>insertFibre() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::insertFibre </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given fibre to this Seifert fibred space. </p>
<p >This may be an exceptional fibre (<em>alpha</em> &gt; 1) or it may be a regular fibre (<em>alpha</em> = 1). If it is a regular fibre, the obstruction constant <em>b</em> will be adjusted according to the value of <em>beta</em>.</p>
<p >Note that there is no restriction on the range of the second parameter <em>beta</em>. If it is out of the usual range 0 ≤ <em>beta</em> &lt; <em>alpha</em>, it will be pulled back into this range and the excess will be pushed into the obstruction constant <em>b</em>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td><em>alpha</em> is zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the first parameter (i.e., the index) of the fibre to insert; this must be strictly positive. </td></tr>
    <tr><td class="paramname">beta</td><td>the second parameter of the fibre to insert; this must have no common factors with the first parameter <em>alpha</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ef1686791fb43a8e4d0b5221c53fd31" name="a8ef1686791fb43a8e4d0b5221c53fd31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef1686791fb43a8e4d0b5221c53fd31">&#9670;&nbsp;</a></span>isHyperbolic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Manifold.html#a8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a id="ab2a3ed0997f6d88e195e5bc3cabf5294" name="ab2a3ed0997f6d88e195e5bc3cabf5294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a3ed0997f6d88e195e5bc3cabf5294">&#9670;&nbsp;</a></span>isLensSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> &gt; regina::SFSpace::isLensSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this Seifert fibred space is a Lens space. </p>
<dl class="section return"><dt>Returns</dt><dd>a structure containing the details of this Lens space, or no value if this is not a Lens space. </dd></dl>

</div>
</div>
<a id="a93d702e878c4a5e17dc17245b8e3d667" name="a93d702e878c4a5e17dc17245b8e3d667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d702e878c4a5e17dc17245b8e3d667">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the common name of this 3-manifold as a human-readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>the common name of this 3-manifold. </dd></dl>

</div>
</div>
<a id="a96f1c254d3237073e5ba12978162ad76" name="a96f1c254d3237073e5ba12978162ad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f1c254d3237073e5ba12978162ad76">&#9670;&nbsp;</a></span>obstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::SFSpace::obstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the obstruction constant <em>b</em> for this Seifert fibred space. </p>
<p >The obstruction constant corresponds to the insertion of an additional (1,<em>b</em>) fibre. It can be modified by calling <a class="el" href="classregina_1_1SFSpace.html#a9cabfe8efaeb3c370e74abf2f50a09be" title="Adds the given fibre to this Seifert fibred space.">insertFibre()</a> with a value of <em>alpha</em> = 1. It will also be modified whenever <a class="el" href="classregina_1_1SFSpace.html#a9cabfe8efaeb3c370e74abf2f50a09be" title="Adds the given fibre to this Seifert fibred space.">insertFibre()</a> is called with <em>beta</em> out of range (<em>beta</em> &lt; 0 or <em>beta</em> ≥ <em>alpha</em>), since each exceptional fibre must be stored in standard form (0 ≤ <em>beta</em> &lt; <em>alpha</em>).</p>
<dl class="section return"><dt>Returns</dt><dd>the obstruction constant <em>b</em>. </dd></dl>

</div>
</div>
<a id="a12e3a984ec3bceb32a8ada29ff58460b" name="a12e3a984ec3bceb32a8ada29ff58460b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e3a984ec3bceb32a8ada29ff58460b">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given object do not contain precisely the same presentations of the same Seifert fibred space. </p>
<p >This routine does <em>not</em> test for homeomorphism. Instead it compares the exact presentations, including the precise details of the base orbifold and the exact parameters of the exceptional fibres, and determines whether or not these <em>presentations</em> are identical. If you have two different presentations of the same Seifert fibred space, they will be treated as not equal by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the presentation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object do not contain identical presentations of the same Seifert fibred space. </dd></dl>

</div>
</div>
<a id="a340ae7f9e981a404667a1383366c114c" name="a340ae7f9e981a404667a1383366c114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340ae7f9e981a404667a1383366c114c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Manifold::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this 3-manifold is "smaller" than the given representation of the given 3-manifold. </p>
<p >The ordering imposed on 3-manifolds is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<p >The ordering also depends on the particular representation of the 3-manifold that is used. As an example, different representations of the same Seifert fibred space might well be ordered differently.</p>
<p >All that this routine really offers is a well-defined way of ordering 3-manifold representations.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently this routine is only implemented in full for closed 3-manifolds. For most classes of bounded 3-manifolds, this routine simply compares the strings returned by <a class="el" href="classregina_1_1Manifold.html#a93d702e878c4a5e17dc17245b8e3d667" title="Returns the common name of this 3-manifold as a human-readable string.">name()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the 3-manifold representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given 3-manifold representation. </dd></dl>

</div>
</div>
<a id="ade28e31e2a1e6c0cafb39c26213c6055" name="ade28e31e2a1e6c0cafb39c26213c6055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade28e31e2a1e6c0cafb39c26213c6055">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space. </p>
<p >The ordering imposed on Seifert fibred space representations is purely aesthetic on the part of the author, and is subject to change in future versions of Regina. It also depends upon the particular representation, so that different representations of the same space may be ordered differently.</p>
<p >All that this routine really offers is a well-defined way of ordering Seifert fibred space representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given Seifert fibred space representation. </dd></dl>

</div>
</div>
<a id="ad5e717eb693b02d2cbe2292a22683fae" name="ad5e717eb693b02d2cbe2292a22683fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e717eb693b02d2cbe2292a22683fae">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::SFSpace::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given Seifert fibred space. </p>

</div>
</div>
<a id="aa18d3dc5230cf57074a256160dafc618" name="aa18d3dc5230cf57074a256160dafc618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18d3dc5230cf57074a256160dafc618">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp; regina::SFSpace::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given Seifert fibred space into this Seifert fibred space. </p>
<p >This is a fast (constant time) operation.</p>
<p >The space that was passed will no longer be usable.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this space. </dd></dl>

</div>
</div>
<a id="a55dbc5a9fa80611d6cff6724ead915be" name="a55dbc5a9fa80611d6cff6724ead915be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55dbc5a9fa80611d6cff6724ead915be">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given object contain precisely the same presentations of the same Seifert fibred space. </p>
<p >This routine does <em>not</em> test for homeomorphism. Instead it compares the exact presentations, including the precise details of the base orbifold and the exact parameters of the exceptional fibres, and determines whether or not these <em>presentations</em> are identical. If you have two different presentations of the same Seifert fibred space, they will be treated as not equal by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the presentation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given object contain identical presentations of the same Seifert fibred space. </dd></dl>

</div>
</div>
<a id="a5543c0208bf70b3209cfa5baa741c67f" name="a5543c0208bf70b3209cfa5baa741c67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5543c0208bf70b3209cfa5baa741c67f">&#9670;&nbsp;</a></span>punctures() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::punctures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of punctures in the base orbifold. </p>
<p >In other words, this routine returns the total number of real torus or Klein bottle boundary components in the overall 3-manifold.</p>
<p >Note that reflector boundaries on the base orbifold are <em>not</em> counted here; only the ordinary boundary components that give rise to real 3-manifold boundaries are included.</p>
<p >Both untwisted and twisted punctures (giving rise to torus and Klein bottle boundaries respectively in the 3-manifold) are counted by this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of punctures. </dd></dl>

</div>
</div>
<a id="a2995dbf0df3c0d89a1af68bec6cc6003" name="a2995dbf0df3c0d89a1af68bec6cc6003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2995dbf0df3c0d89a1af68bec6cc6003">&#9670;&nbsp;</a></span>punctures() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::punctures </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of punctures of the given type in the base orbifold. </p>
<p >In other words, this routine returns the number of real boundary components of the given type in the overall 3-manifold.</p>
<p >This routine either counts only twisted punctures (which give rise to Klein bottle boundaries), or only untwisted punctures (which give rise to torus boundaries).</p>
<p >Either way, reflector boundaries on the base orbifold are <em>not</em> counted here; only ordinary boundary components that give rise to real 3-manifold boundaries are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if only twisted punctures should be counted (those that give fibre-reversing paths and Klein bottle boundaries), or <code>false</code> if only untwisted punctures should be counted (those that are fibre-preserving and give torus boundaries). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of punctures of the given type. </dd></dl>

</div>
</div>
<a id="ab28f4b1aeac0b2105233f4293509c492" name="ab28f4b1aeac0b2105233f4293509c492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28f4b1aeac0b2105233f4293509c492">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::reduce </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mayReflect</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the parameters of this Seifert fibred space to a simpler form if possible, without changing the underlying fibration. </p>
<p >In some cases the parameters of the Seifert fibred space may be simplified by taking a mirror image of the entire 3-manifold. The argument <em>mayReflect</em> signifies whether this is allowed.</p>
<p >This routine will not change the curves made by the fibres and the base orbifold on any boundary components (i.e., boundaries caused by punctures in the base orbifold).</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>mayReflect</em> is <code>true</code> then the entire 3-manifold might be replaced with its mirror image, in which case any subsequent modifications (such as inserting additional fibres or altering the base orbifold) may give unexpected results.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mayReflect</td><td><code>true</code> if we are allowed to take a mirror image of the entire 3-manifold, or <code>false</code> if we are not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a070e0759c61a8b7d8816ca10bbee42a8" name="a070e0759c61a8b7d8816ca10bbee42a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070e0759c61a8b7d8816ca10bbee42a8">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces this space with its mirror image. </p>
<p >Specifically, all exceptional fibres and the obstruction constant <em>b</em> will be negated. Note that the obstruction constant will generally undergo further change as the exceptional fibres are standardised into the usual 0 ≤ <em>beta</em> &lt; <em>alpha</em> form.</p>
<p >This routine will not change the curves made by the fibres and the base orbifold on any boundary components (i.e., boundaries caused by punctures in the base orbifold), with the exception that each base curve will be reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>The space is <em>not</em> reduced after reflecting. It may be that the space can be further simplified (especially in the case of non-orientable manifolds). </dd></dl>

</div>
</div>
<a id="a3c825b5e07e3899d32f02f5fbdcb7268" name="a3c825b5e07e3899d32f02f5fbdcb7268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c825b5e07e3899d32f02f5fbdcb7268">&#9670;&nbsp;</a></span>reflectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::reflectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of reflector boundary components of the base orbifold. </p>
<p >This includes both twisted and untwisted reflector boundaries.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of reflector boundary components. </dd></dl>

</div>
</div>
<a id="ac45bd427305037e276106095cec3c62b" name="ac45bd427305037e276106095cec3c62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45bd427305037e276106095cec3c62b">&#9670;&nbsp;</a></span>reflectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::reflectors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of reflector boundary components of the given type in the base orbifold. </p>
<p >This either counts only twisted reflector boundaries, or only untwisted reflector boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if only twisted reflector boundaries should be counted (those that give fibre-reversing paths), or <code>false</code> if only untwisted reflector boundaries should be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of reflector boundaries of the given type. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ad5c9d3c3cbce470e4ecb69e91384d02c" name="ad5c9d3c3cbce470e4ecb69e91384d02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c9d3c3cbce470e4ecb69e91384d02c">&#9670;&nbsp;</a></span>structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::structure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of the structure of this 3-manifold that might not be evident from its common name. </p>
<p >For instance, for an orbit space S³/G this routine might return the full Seifert structure.</p>
<p >This routine may return the empty string if no additional details are deemed necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>a string describing additional structural details. </dd></dl>

</div>
</div>
<a id="aa44699c824fd9d9b1932cd820836d2fd" name="aa44699c824fd9d9b1932cd820836d2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44699c824fd9d9b1932cd820836d2fd">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given Seifert fibred space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the space whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35ee2d6d382b01c938d3b948e732cad9" name="a35ee2d6d382b01c938d3b948e732cad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ee2d6d382b01c938d3b948e732cad9">&#9670;&nbsp;</a></span>texName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::texName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the common name of this 3-manifold in TeX format. </p>
<p >No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the common name of this 3-manifold in TeX format. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a370fcf932fcdb4beacf04e4e0bdfc123" name="a370fcf932fcdb4beacf04e4e0bdfc123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a370fcf932fcdb4beacf04e4e0bdfc123">&#9670;&nbsp;</a></span>writeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Manifold.html#a93d702e878c4a5e17dc17245b8e3d667" title="Returns the common name of this 3-manifold as a human-readable string.">name()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Manifold.html#aa2812cf8fd22402a2b3603a46d2ed5b3">regina::Manifold</a>.</p>

</div>
</div>
<a id="aa4246776c806d4bf771067bf1d956500" name="aa4246776c806d4bf771067bf1d956500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4246776c806d4bf771067bf1d956500">&#9670;&nbsp;</a></span>writeStructure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeStructure </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream. </p>
<p >For instance, for an orbit space S³/G this routine might write the full Seifert structure.</p>
<p >This routine may write nothing if no additional details are deemed necessary. The default implementation of this routine behaves in this way.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Manifold.html#ad5c9d3c3cbce470e4ecb69e91384d02c" title="Returns details of the structure of this 3-manifold that might not be evident from its common name.">structure()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1Manifold.html#a6629373d88ce55bc4a3e12d3cd64a481">regina::Manifold</a>.</p>

</div>
</div>
<a id="a74307d1ef9a53354aacb00e32fde0555" name="a74307d1ef9a53354aacb00e32fde0555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74307d1ef9a53354aacb00e32fde0555">&#9670;&nbsp;</a></span>writeTeXName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p >No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. Instead use the variant <a class="el" href="classregina_1_1Manifold.html#a35ee2d6d382b01c938d3b948e732cad9" title="Returns the common name of this 3-manifold in TeX format.">texName()</a> that takes no arguments and returns a string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Manifold.html#aca8f5101022ce0e2532a6ce9e9df037c">regina::Manifold</a>.</p>

</div>
</div>
<a id="a9c18dbf18c57378e979f81220ebd6eb9" name="a9c18dbf18c57378e979f81220ebd6eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c18dbf18c57378e979f81220ebd6eb9">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Manifold::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p >Subclasses must not override this routine. They should override <a class="el" href="classregina_1_1SFSpace.html#a370fcf932fcdb4beacf04e4e0bdfc123" title="Writes the common name of this 3-manifold as a human-readable string to the given output stream.">writeName()</a> and <a class="el" href="classregina_1_1SFSpace.html#aa4246776c806d4bf771067bf1d956500" title="Writes details of the structure of this 3-manifold that might not be evident from its common name to ...">writeStructure()</a> instead.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a239a494eef37497d14d963ab2d0ad9f9" name="a239a494eef37497d14d963ab2d0ad9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239a494eef37497d14d963ab2d0ad9f9">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Manifold::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p >Subclasses must not override this routine. They should override <a class="el" href="classregina_1_1SFSpace.html#a370fcf932fcdb4beacf04e4e0bdfc123" title="Writes the common name of this 3-manifold as a human-readable string to the given output stream.">writeName()</a> instead.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>manifold/<a class="el" href="sfs_8h.html">sfs.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
