<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina 7.3 Calculation Engine: regina::NormalHypersurfaces Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Regina 7.3 Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1NormalHypersurfaces-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">regina::NormalHypersurfaces Class Reference<div class="ingroups"><a class="el" href="group__hypersurface.html">Normal Hypersurfaces</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>A collection of normal hypersurfaces in a 4-manifold triangulation.  
 <a href="classregina_1_1NormalHypersurfaces.html#details">More...</a></p>

<p><code>#include &lt;hypersurface/normalhypersurfaces.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalHypersurfaces:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalHypersurfaces.png" usemap="#regina::NormalHypersurfaces_map" alt=""/>
  <map id="regina::NormalHypersurfaces_map" name="regina::NormalHypersurfaces_map">
<area href="classregina_1_1PacketData.html" alt="regina::PacketData&lt; NormalHypersurfaces &gt;" shape="rect" coords="0,0,266,24"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NormalHypersurfaces &gt;" shape="rect" coords="276,0,542,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional iterator that runs through the raw vectors for hypersurfaces in this list.  <a href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abc5572b7cc4b2b06f7f33d4a775a4091"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#abc5572b7cc4b2b06f7f33d4a775a4091">NormalHypersurfaces</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;<a class="el" href="classregina_1_1NormalHypersurfaces.html#a187d56a4306c0596567c7f94aa901a34">triangulation</a>, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#adc5c6c7aeab32d4d2d80425c9f8ad108">coords</a>, <a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#aebbdf01911361353b206a761af4ffa17">which</a>=<a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da643102f0d9b8754127659c0da6110e0c">HS_LIST_DEFAULT</a>, <a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a> algHints=<a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5da36197ace99a8d471fd85411e76238ec2">HS_ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:abc5572b7cc4b2b06f7f33d4a775a4091"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unified constructor for enumerating various classes of normal hypersurfaces within a given triangulation.  <a href="classregina_1_1NormalHypersurfaces.html#abc5572b7cc4b2b06f7f33d4a775a4091">More...</a><br /></td></tr>
<tr class="separator:abc5572b7cc4b2b06f7f33d4a775a4091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a18ae8e141a0381b96c72b4e60a2ac0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a1a18ae8e141a0381b96c72b4e60a2ac0">NormalHypersurfaces</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;)=default</td></tr>
<tr class="memdesc:a1a18ae8e141a0381b96c72b4e60a2ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new copy of the given list.  <a href="classregina_1_1NormalHypersurfaces.html#a1a18ae8e141a0381b96c72b4e60a2ac0">More...</a><br /></td></tr>
<tr class="separator:a1a18ae8e141a0381b96c72b4e60a2ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afda780189d4cc9fe2a68f368c0365f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a9afda780189d4cc9fe2a68f368c0365f">NormalHypersurfaces</a> (<a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&amp;src) noexcept=default</td></tr>
<tr class="memdesc:a9afda780189d4cc9fe2a68f368c0365f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given list into this new list.  <a href="classregina_1_1NormalHypersurfaces.html#a9afda780189d4cc9fe2a68f368c0365f">More...</a><br /></td></tr>
<tr class="separator:a9afda780189d4cc9fe2a68f368c0365f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32663705bf6533a5548e35b8974c2eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a32663705bf6533a5548e35b8974c2eb8">operator=</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;src)</td></tr>
<tr class="memdesc:a32663705bf6533a5548e35b8974c2eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a (deep) copy of the given list.  <a href="classregina_1_1NormalHypersurfaces.html#a32663705bf6533a5548e35b8974c2eb8">More...</a><br /></td></tr>
<tr class="separator:a32663705bf6533a5548e35b8974c2eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c62f69162d2a1231761fdbf831e6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a4e3c62f69162d2a1231761fdbf831e6b">operator=</a> (<a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&amp;src)</td></tr>
<tr class="memdesc:a4e3c62f69162d2a1231761fdbf831e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of the given list into this list.  <a href="classregina_1_1NormalHypersurfaces.html#a4e3c62f69162d2a1231761fdbf831e6b">More...</a><br /></td></tr>
<tr class="separator:a4e3c62f69162d2a1231761fdbf831e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b87efd352f068edf6aa2abdeab2b8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#af7b87efd352f068edf6aa2abdeab2b8e">swap</a> (<a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;other)</td></tr>
<tr class="memdesc:af7b87efd352f068edf6aa2abdeab2b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given list.  <a href="classregina_1_1NormalHypersurfaces.html#af7b87efd352f068edf6aa2abdeab2b8e">More...</a><br /></td></tr>
<tr class="separator:af7b87efd352f068edf6aa2abdeab2b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5c6c7aeab32d4d2d80425c9f8ad108"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#adc5c6c7aeab32d4d2d80425c9f8ad108">coords</a> () const</td></tr>
<tr class="memdesc:adc5c6c7aeab32d4d2d80425c9f8ad108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinate system that was originally used to enumerate the hypersurfaces in this list.  <a href="classregina_1_1NormalHypersurfaces.html#adc5c6c7aeab32d4d2d80425c9f8ad108">More...</a><br /></td></tr>
<tr class="separator:adc5c6c7aeab32d4d2d80425c9f8ad108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbdf01911361353b206a761af4ffa17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#aebbdf01911361353b206a761af4ffa17">which</a> () const</td></tr>
<tr class="memdesc:aebbdf01911361353b206a761af4ffa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of which normal hypersurfaces this list represents within the underlying triangulation.  <a href="classregina_1_1NormalHypersurfaces.html#aebbdf01911361353b206a761af4ffa17">More...</a><br /></td></tr>
<tr class="separator:aebbdf01911361353b206a761af4ffa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01cd9910600cf3f0dc578f00faf37c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#ae01cd9910600cf3f0dc578f00faf37c2">algorithm</a> () const</td></tr>
<tr class="memdesc:ae01cd9910600cf3f0dc578f00faf37c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the algorithm that was used to enumerate this list.  <a href="classregina_1_1NormalHypersurfaces.html#ae01cd9910600cf3f0dc578f00faf37c2">More...</a><br /></td></tr>
<tr class="separator:ae01cd9910600cf3f0dc578f00faf37c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba946d1346a403a6dd164d5dd06f113"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a3ba946d1346a403a6dd164d5dd06f113">allowsNonCompact</a> () const</td></tr>
<tr class="memdesc:a3ba946d1346a403a6dd164d5dd06f113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system that was used for enumeration allows for non-compact hypersurfaces.  <a href="classregina_1_1NormalHypersurfaces.html#a3ba946d1346a403a6dd164d5dd06f113">More...</a><br /></td></tr>
<tr class="separator:a3ba946d1346a403a6dd164d5dd06f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13eb348cfcd3070e215de79d735ddd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#ab13eb348cfcd3070e215de79d735ddd0">isEmbeddedOnly</a> () const</td></tr>
<tr class="memdesc:ab13eb348cfcd3070e215de79d735ddd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether this list is known to contain only embedded normal hypersurfaces.  <a href="classregina_1_1NormalHypersurfaces.html#ab13eb348cfcd3070e215de79d735ddd0">More...</a><br /></td></tr>
<tr class="separator:ab13eb348cfcd3070e215de79d735ddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187d56a4306c0596567c7f94aa901a34"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a187d56a4306c0596567c7f94aa901a34">triangulation</a> () const</td></tr>
<tr class="memdesc:a187d56a4306c0596567c7f94aa901a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation in which these normal hypersurfaces live.  <a href="classregina_1_1NormalHypersurfaces.html#a187d56a4306c0596567c7f94aa901a34">More...</a><br /></td></tr>
<tr class="separator:a187d56a4306c0596567c7f94aa901a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b6c5deda3b5f72c5a29567b1812f20"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a23b6c5deda3b5f72c5a29567b1812f20">size</a> () const</td></tr>
<tr class="memdesc:a23b6c5deda3b5f72c5a29567b1812f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of hypersurfaces stored in this list.  <a href="classregina_1_1NormalHypersurfaces.html#a23b6c5deda3b5f72c5a29567b1812f20">More...</a><br /></td></tr>
<tr class="separator:a23b6c5deda3b5f72c5a29567b1812f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacba530d591ff0f91920716982d71a94"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#aacba530d591ff0f91920716982d71a94">hypersurface</a> (size_t index) const</td></tr>
<tr class="memdesc:aacba530d591ff0f91920716982d71a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hypersurface at the requested index in this list.  <a href="classregina_1_1NormalHypersurfaces.html#aacba530d591ff0f91920716982d71a94">More...</a><br /></td></tr>
<tr class="separator:aacba530d591ff0f91920716982d71a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe018b1749159d20d91a6b68e424a6e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#abe018b1749159d20d91a6b68e424a6e6">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:abe018b1749159d20d91a6b68e424a6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hypersurface at the requested index in this list.  <a href="classregina_1_1NormalHypersurfaces.html#abe018b1749159d20d91a6b68e424a6e6">More...</a><br /></td></tr>
<tr class="separator:abe018b1749159d20d91a6b68e424a6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4253d748f5e772f1f000a27c9b74dd3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#aa4253d748f5e772f1f000a27c9b74dd3">begin</a> () const</td></tr>
<tr class="memdesc:aa4253d748f5e772f1f000a27c9b74dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator at the beginning of this list of hypersurfaces.  <a href="classregina_1_1NormalHypersurfaces.html#aa4253d748f5e772f1f000a27c9b74dd3">More...</a><br /></td></tr>
<tr class="separator:aa4253d748f5e772f1f000a27c9b74dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c1bfda801e928d15e5706340eb2bd8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a47c1bfda801e928d15e5706340eb2bd8">end</a> () const</td></tr>
<tr class="memdesc:a47c1bfda801e928d15e5706340eb2bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a C++ iterator beyond the end of this list of hypersurfaces.  <a href="classregina_1_1NormalHypersurfaces.html#a47c1bfda801e928d15e5706340eb2bd8">More...</a><br /></td></tr>
<tr class="separator:a47c1bfda801e928d15e5706340eb2bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7e806a693a1941e1d82a6fc715f053"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#abf7e806a693a1941e1d82a6fc715f053">__iter__</a> () const</td></tr>
<tr class="memdesc:abf7e806a693a1941e1d82a6fc715f053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterator over the normal hypersurfaces in this list.  <a href="classregina_1_1NormalHypersurfaces.html#abf7e806a693a1941e1d82a6fc715f053">More...</a><br /></td></tr>
<tr class="separator:abf7e806a693a1941e1d82a6fc715f053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee354b980503215466fadb7c38019b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a6ee354b980503215466fadb7c38019b7">operator==</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;other) const</td></tr>
<tr class="memdesc:a6ee354b980503215466fadb7c38019b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given list contain the same set of normal hypersurfaces.  <a href="classregina_1_1NormalHypersurfaces.html#a6ee354b980503215466fadb7c38019b7">More...</a><br /></td></tr>
<tr class="separator:a6ee354b980503215466fadb7c38019b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fe0febbb540a20b8436274ddfd5de0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a70fe0febbb540a20b8436274ddfd5de0">operator!=</a> (const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;other) const</td></tr>
<tr class="memdesc:a70fe0febbb540a20b8436274ddfd5de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given list contain different sets of normal hypersurfaces.  <a href="classregina_1_1NormalHypersurfaces.html#a70fe0febbb540a20b8436274ddfd5de0">More...</a><br /></td></tr>
<tr class="separator:a70fe0febbb540a20b8436274ddfd5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892d908978a554c87566a22476dfd3a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a892d908978a554c87566a22476dfd3a1">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a892d908978a554c87566a22476dfd3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="classregina_1_1NormalHypersurfaces.html#a892d908978a554c87566a22476dfd3a1">More...</a><br /></td></tr>
<tr class="separator:a892d908978a554c87566a22476dfd3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20fa7238cc21f47676428d15582ccbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#ac20fa7238cc21f47676428d15582ccbd">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ac20fa7238cc21f47676428d15582ccbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="classregina_1_1NormalHypersurfaces.html#ac20fa7238cc21f47676428d15582ccbd">More...</a><br /></td></tr>
<tr class="separator:ac20fa7238cc21f47676428d15582ccbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf49a8aee54383f5641341b9471a307"><td class="memTemplParams" colspan="2">template&lt;typename Comparison &gt; </td></tr>
<tr class="memitem:a1bf49a8aee54383f5641341b9471a307"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a1bf49a8aee54383f5641341b9471a307">sort</a> (Comparison &amp;&amp;comp)</td></tr>
<tr class="memdesc:a1bf49a8aee54383f5641341b9471a307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the hypersurfaces in this list according to the given criterion.  <a href="classregina_1_1NormalHypersurfaces.html#a1bf49a8aee54383f5641341b9471a307">More...</a><br /></td></tr>
<tr class="separator:a1bf49a8aee54383f5641341b9471a307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc59447098b71719a62770f7336ee97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a3cc59447098b71719a62770f7336ee97">recreateMatchingEquations</a> () const</td></tr>
<tr class="memdesc:a3cc59447098b71719a62770f7336ee97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matching equations that were used to create this normal hypersurface list.  <a href="classregina_1_1NormalHypersurfaces.html#a3cc59447098b71719a62770f7336ee97">More...</a><br /></td></tr>
<tr class="separator:a3cc59447098b71719a62770f7336ee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefed5920d1b387e5d3b0f35b390ebec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#acefed5920d1b387e5d3b0f35b390ebec">beginVectors</a> () const</td></tr>
<tr class="memdesc:acefed5920d1b387e5d3b0f35b390ebec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ iterator that gives access to the raw vectors for hypersurfaces in this list, pointing to the beginning of this hypersurface list.  <a href="classregina_1_1NormalHypersurfaces.html#acefed5920d1b387e5d3b0f35b390ebec">More...</a><br /></td></tr>
<tr class="separator:acefed5920d1b387e5d3b0f35b390ebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d5da33f4ac4f4a2ed4296a4a0395b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a48d5da33f4ac4f4a2ed4296a4a0395b5">endVectors</a> () const</td></tr>
<tr class="memdesc:a48d5da33f4ac4f4a2ed4296a4a0395b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C++ iterator that gives access to the raw vectors for hypersurfaces in this list, pointing past the end of this hypersurface list.  <a href="classregina_1_1NormalHypersurfaces.html#a48d5da33f4ac4f4a2ed4296a4a0395b5">More...</a><br /></td></tr>
<tr class="separator:a48d5da33f4ac4f4a2ed4296a4a0395b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa708c0a673f1e58d7329e20f912fe6"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a1aa708c0a673f1e58d7329e20f912fe6">vectors</a> () const</td></tr>
<tr class="memdesc:a1aa708c0a673f1e58d7329e20f912fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Python iterable object that iterates over the raw vectors for all hypersurfaces in this list.  <a href="classregina_1_1NormalHypersurfaces.html#a1aa708c0a673f1e58d7329e20f912fe6">More...</a><br /></td></tr>
<tr class="separator:a1aa708c0a673f1e58d7329e20f912fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55a7c7230f417159d55beaef98d3247"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">packet</a> ()</td></tr>
<tr class="memdesc:ab55a7c7230f417159d55beaef98d3247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247">More...</a><br /></td></tr>
<tr class="separator:ab55a7c7230f417159d55beaef98d3247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f2f48664785da277fac60d654b2f88"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">packet</a> () const</td></tr>
<tr class="memdesc:a87f2f48664785da277fac60d654b2f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the packet that holds this data, if there is one.  <a href="classregina_1_1PacketData.html#a87f2f48664785da277fac60d654b2f88">More...</a><br /></td></tr>
<tr class="separator:a87f2f48664785da277fac60d654b2f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">anonID</a> () const</td></tr>
<tr class="memdesc:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unique string ID that can be used in place of a packet ID.  <a href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1">More...</a><br /></td></tr>
<tr class="separator:ae9be4ab40d5be63e818f2d76a1294ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a341e0997c5b5fc8f750b6c85cf1db05f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a341e0997c5b5fc8f750b6c85cf1db05f">NormalHypersurfaces</a> (<a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#adc5c6c7aeab32d4d2d80425c9f8ad108">coords</a>, <a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#aebbdf01911361353b206a761af4ffa17">which</a>, <a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#ae01cd9910600cf3f0dc578f00faf37c2">algorithm</a>, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;<a class="el" href="classregina_1_1NormalHypersurfaces.html#a187d56a4306c0596567c7f94aa901a34">triangulation</a>)</td></tr>
<tr class="memdesc:a341e0997c5b5fc8f750b6c85cf1db05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty list of normal hypersurfaces with the given parameters.  <a href="classregina_1_1NormalHypersurfaces.html#a341e0997c5b5fc8f750b6c85cf1db05f">More...</a><br /></td></tr>
<tr class="separator:a341e0997c5b5fc8f750b6c85cf1db05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2c25383ad596fbb3815aa535584a50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a5a2c25383ad596fbb3815aa535584a50">NormalHypersurfaces</a> (<a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#adc5c6c7aeab32d4d2d80425c9f8ad108">coords</a>, <a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#aebbdf01911361353b206a761af4ffa17">which</a>, <a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a> <a class="el" href="classregina_1_1NormalHypersurfaces.html#ae01cd9910600cf3f0dc578f00faf37c2">algorithm</a>, const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;<a class="el" href="classregina_1_1NormalHypersurfaces.html#a187d56a4306c0596567c7f94aa901a34">triangulation</a>)</td></tr>
<tr class="memdesc:a5a2c25383ad596fbb3815aa535584a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty list of normal hypersurfaces with the given parameters.  <a href="classregina_1_1NormalHypersurfaces.html#a5a2c25383ad596fbb3815aa535584a50">More...</a><br /></td></tr>
<tr class="separator:a5a2c25383ad596fbb3815aa535584a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8cfd99e5c5cc41991ff85cfa082fb82b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a8cfd99e5c5cc41991ff85cfa082fb82b">surfaces_</a></td></tr>
<tr class="memdesc:a8cfd99e5c5cc41991ff85cfa082fb82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all normal hypersurfaces in this list.  <a href="classregina_1_1NormalHypersurfaces.html#a8cfd99e5c5cc41991ff85cfa082fb82b">More...</a><br /></td></tr>
<tr class="separator:a8cfd99e5c5cc41991ff85cfa082fb82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8c677cdd3ee2f9e6ed3f9a1c501661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#acf8c677cdd3ee2f9e6ed3f9a1c501661">triangulation_</a></td></tr>
<tr class="memdesc:acf8c677cdd3ee2f9e6ed3f9a1c501661"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which these normal hypersurfaces lie.  <a href="classregina_1_1NormalHypersurfaces.html#acf8c677cdd3ee2f9e6ed3f9a1c501661">More...</a><br /></td></tr>
<tr class="separator:acf8c677cdd3ee2f9e6ed3f9a1c501661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9ba4d21f39dc2340ea896f9b5e65b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a6c9ba4d21f39dc2340ea896f9b5e65b1">coords_</a></td></tr>
<tr class="memdesc:a6c9ba4d21f39dc2340ea896f9b5e65b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The coordinate system that was originally used to enumerate the normal hypersurfaces in this list.  <a href="classregina_1_1NormalHypersurfaces.html#a6c9ba4d21f39dc2340ea896f9b5e65b1">More...</a><br /></td></tr>
<tr class="separator:a6c9ba4d21f39dc2340ea896f9b5e65b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0441ca3f6753979a988d5f392e2687aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a0441ca3f6753979a988d5f392e2687aa">which_</a></td></tr>
<tr class="memdesc:a0441ca3f6753979a988d5f392e2687aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normal hypersurfaces these represent within the underlying triangulation.  <a href="classregina_1_1NormalHypersurfaces.html#a0441ca3f6753979a988d5f392e2687aa">More...</a><br /></td></tr>
<tr class="separator:a0441ca3f6753979a988d5f392e2687aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b995dbbf568ef31acb23cb86e512ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurfaces.html#a2b995dbbf568ef31acb23cb86e512ea9">algorithm_</a></td></tr>
<tr class="memdesc:a2b995dbbf568ef31acb23cb86e512ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the details of the enumeration algorithm that was used to generate this list.  <a href="classregina_1_1NormalHypersurfaces.html#a2b995dbbf568ef31acb23cb86e512ea9">More...</a><br /></td></tr>
<tr class="separator:a2b995dbbf568ef31acb23cb86e512ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977558e565df8fd3a567561a69541f3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">heldBy_</a></td></tr>
<tr class="memdesc:a977558e565df8fd3a567561a69541f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;.  <a href="classregina_1_1PacketData.html#a977558e565df8fd3a567561a69541f3b">More...</a><br /></td></tr>
<tr class="separator:a977558e565df8fd3a567561a69541f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a82843fd0e0d3899ab41dedd2346a44a1"><td class="memItemLeft" align="right" valign="top"><a id="a82843fd0e0d3899ab41dedd2346a44a1" name="a82843fd0e0d3899ab41dedd2346a44a1"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLNormalHypersurfacesReader</b></td></tr>
<tr class="separator:a82843fd0e0d3899ab41dedd2346a44a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2164d8d4d00bbfaec851fc5be5a49300"><td class="memItemLeft" align="right" valign="top"><a id="a2164d8d4d00bbfaec851fc5be5a49300" name="a2164d8d4d00bbfaec851fc5be5a49300"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLLegacyNormalHypersurfacesReader</b></td></tr>
<tr class="separator:a2164d8d4d00bbfaec851fc5be5a49300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d152aaf02f107186bc900a1f089793"><td class="memItemLeft" align="right" valign="top"><a id="a26d152aaf02f107186bc900a1f089793" name="a26d152aaf02f107186bc900a1f089793"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLWriter&lt; NormalHypersurfaces &gt;</b></td></tr>
<tr class="separator:a26d152aaf02f107186bc900a1f089793"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A collection of normal hypersurfaces in a 4-manifold triangulation. </p>
<p >There are some important changes to this class as of Regina 7.0:</p>
<ul>
<li>A normal hypersurface list does <em>not</em> need to be a child packet of the underlying triangulation, and indeed does not need to interact with the packet tree at all.</li>
<li>You are welcome to modify or even destroy the original triangulation; if you do then this list will automatically make a private copy of the original triangulation as an ongoing reference. Different normal hypersurface lists can all share the same private copy, so this is not an expensive process.</li>
<li>You should now create normal hypersurface lists using the class constructor (but which, unlike the old enumerate(), does not insert the list into the packet tree). There is no need to use enumerate() any more.</li>
</ul>
<p >Since Regina 7.0, this is no longer a "packet type" that can be inserted directly into the packet tree. Instead a normal hypersurface list is now a standalone mathematatical object, which makes it slimmer and faster for ad-hoc use. The consequences of this are:</p>
<ul>
<li>If you create your own <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> object, it will not have any of the usual packet infrastructure. You cannot add it into the packet tree, and it will not support a label, tags, child/parent packets, and/or event listeners.</li>
<li>To include an <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> object in the packet tree, you must create a new PacketOf&lt;NormalHypersurfaces&gt;. This <em>is</em> a packet type, and supports labels, tags, child/parent packets, and event listeners. It derives from <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>, and so inherits the full <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> interface.</li>
<li>If you are adding new functions to this class that edit the list, you must still remember to create a ChangeEventSpan. This will ensure that, if the list is being managed by a PacketOf&lt;NormalHypersurfaces&gt;, then the appropriate packet change events will be fired. All other events (aside from packetToBeChanged() and packetWasChanged() are managed directly by the PacketOf&lt;NormalHypersurfaces&gt; wrapper class.</li>
</ul>
<p >See the <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> class notes for details of what to do when introducing a new coordinate system.</p>
<p >This class implements C++ move semantics and adheres to the C++ Swappable requirement. It is designed to avoid deep copies wherever possible, even when passing or returning objects by value. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abc5572b7cc4b2b06f7f33d4a775a4091" name="abc5572b7cc4b2b06f7f33d4a775a4091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5572b7cc4b2b06f7f33d4a775a4091">&#9670;&nbsp;</a></span>NormalHypersurfaces() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::NormalHypersurfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a>&#160;</td>
          <td class="paramname"><em>which</em> = <code><a class="el" href="group__hypersurface.html#gga3504d968f57efcd4379122ce3e37404da643102f0d9b8754127659c0da6110e0c">HS_LIST_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a>&#160;</td>
          <td class="paramname"><em>algHints</em> = <code><a class="el" href="group__hypersurface.html#ggaaecd2a8d25ac496722f2d8d56ceced5da36197ace99a8d471fd85411e76238ec2">HS_ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unified constructor for enumerating various classes of normal hypersurfaces within a given triangulation. </p>
<p >The HyperCoords argument allows you to specify an underlying coordinate system in which to do the enumeration (e.g., standard coordinates or prism coordinates). This choice of coordinate system will affect which surfaces are produced, since vertex/fundamental surfaces in one system are not necessarily vertex/fundamental in another.</p>
<p >The HyperList argument is a combination of flags that allows you to specify exactly which normal hypersurfaces you require. This includes (i) whether you want all vertex hypersurfaces or all fundamental hypersurfaces, which defaults to HS_VERTEX if you specify neither or both; and (ii) whether you want only properly embedded surfaces or you also wish to include immersed and/or singular hypersurfaces, which defaults to HS_EMBEDDED_ONLY if you specify neither or both.</p>
<p >The HyperAlg argument is a combination of flags that allows you to control the underlying enumeration algorithm. These flags are treated as hints only: if your selection of algorithm is invalid, unavailable or unsupported then Regina will choose something more appropriate. Unless you have some specialised need, the default HS_ALG_DEFAULT (which makes no hints at all) will allow Regina to choose what it thinks will be the most efficient method.</p>
<p >The enumerated hypersurfaces will be stored in this new normal hypersurface list, and their representations will be scaled down to use the smallest possible integer coordinates.</p>
<p >Unlike the old enumerate() function, the new normal hypersurface list will <em>not</em> be inserted into the packet tree. Moreover, the given triangulation may change or even be destroyed without causing problems. See the class notes for details.</p>
<p >If a progress tracker is passed, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p >This constructor will not return until the enumeration of hypersurfaces is complete, regardless of whether a progress tracker was passed. If you need the behaviour of the old enumerate() (where passing a progress tracker caused the enumeration to start in the background), simply call this constructor in a new detached thread. Note that this enumeration can be extremely slow for larger triangulations, and so there could be good reasons to do this.</p>
<p >If an error occurs, then this routine will thrown an exception. In this case, no normal hypersurface list will be created, and the progress tracker (if passed) will be marked as finished. See the exception specifications below for details.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classregina_1_1InvalidArgument.html" title="An exception thrown when invalid or unsupported arguments are passed into a function.">InvalidArgument</a></td><td>The matching equations could not be created for the given triangulation in the given coordinate system, due to an error that should have been preventable with the right checks in advance. This can only happen in certain coordinate systems, and for all such coordinate systems this is explicitly described in the HyperCoords enum documentation.</td></tr>
    <tr><td class="paramname"><a class="el" href="classregina_1_1UnsolvedCase.html" title="An exception thrown when a mathematical function is not able to solve a particular instance of a prob...">UnsolvedCase</a></td><td>The list of hypersurfaces could not be be created for the given triangulation in the given coordinate system, due to an error that was "genuinely" unforseeable. Currently there are two scenarios in which this could happen: (i) the matching equations could not be constructed, which can only happen in certain coordinate systems where this is explicitly described in the HyperCoords enum documentation; or (ii) the arguments require enumerating <em>fundamental</em> normal surfaces using the primal Hilbert basis algorithm, and Normaliz was unable to complete its portion of the task, which in theory should never happen at all.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>The global interpreter lock will be released while this constructor runs, so you can use it with Python-based multithreading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which this list of normal hypersurfaces will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. This must be one of the system that Regina is able to use for enumeration; this is documented alongside each HyperCoords enum value. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal hypersurfaces should be enumerated. </td></tr>
    <tr><td class="paramname">algHints</td><td>passes requests to Regina for which specific enumeration algorithm should be used. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a18ae8e141a0381b96c72b4e60a2ac0" name="a1a18ae8e141a0381b96c72b4e60a2ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a18ae8e141a0381b96c72b4e60a2ac0">&#9670;&nbsp;</a></span>NormalHypersurfaces() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::NormalHypersurfaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new copy of the given list. </p>

</div>
</div>
<a id="a9afda780189d4cc9fe2a68f368c0365f" name="a9afda780189d4cc9fe2a68f368c0365f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afda780189d4cc9fe2a68f368c0365f">&#9670;&nbsp;</a></span>NormalHypersurfaces() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::NormalHypersurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given list into this new list. </p>
<p >This is a fast (constant time) operation.</p>
<p >The list that is passed will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is marked <code>noexcept</code>, and in particular does not fire any change events. This is because this list is freshly constructed (and therefore has no listeners yet), and because we assume that <em>src</em> is about to be destroyed (an action that <em>will</em> fire a packet destruction event).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a341e0997c5b5fc8f750b6c85cf1db05f" name="a341e0997c5b5fc8f750b6c85cf1db05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341e0997c5b5fc8f750b6c85cf1db05f">&#9670;&nbsp;</a></span>NormalHypersurfaces() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::NormalHypersurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty list of normal hypersurfaces with the given parameters. </p>

</div>
</div>
<a id="a5a2c25383ad596fbb3815aa535584a50" name="a5a2c25383ad596fbb3815aa535584a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2c25383ad596fbb3815aa535584a50">&#9670;&nbsp;</a></span>NormalHypersurfaces() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurfaces::NormalHypersurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt; <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty list of normal hypersurfaces with the given parameters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf7e806a693a1941e1d82a6fc715f053" name="abf7e806a693a1941e1d82a6fc715f053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7e806a693a1941e1d82a6fc715f053">&#9670;&nbsp;</a></span>__iter__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalHypersurfaces::__iter__ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterator over the normal hypersurfaces in this list. </p>
<p >In Python, a normal hypersurface list can be treated as an iterable object:</p>
<div class="fragment"><div class="line">list = NormalHypersurfaces(...)</div>
<div class="line"><span class="keywordflow">for</span> s <span class="keywordflow">in</span> list:</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> provides the usual <a class="el" href="classregina_1_1NormalHypersurfaces.html#aa4253d748f5e772f1f000a27c9b74dd3" title="Returns a C++ iterator at the beginning of this list of hypersurfaces.">begin()</a> and <a class="el" href="classregina_1_1NormalHypersurfaces.html#a47c1bfda801e928d15e5706340eb2bd8" title="Returns a C++ iterator beyond the end of this list of hypersurfaces.">end()</a> functions instead. In particular, you can iterate over the normal hypersurfaces in this list in the usual way using a range-based <code>for</code> loop.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the normal hypersurfaces in this list. </dd></dl>

</div>
</div>
<a id="ae01cd9910600cf3f0dc578f00faf37c2" name="ae01cd9910600cf3f0dc578f00faf37c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01cd9910600cf3f0dc578f00faf37c2">&#9670;&nbsp;</a></span>algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a> regina::NormalHypersurfaces::algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of the algorithm that was used to enumerate this list. </p>
<p >These may not be the same HyperAlg flags that were passed to the class constructor. In particular, default values will have been explicitly filled in, invalid and/or redundant values will have been removed, and unavailable and/or unsupported combinations of algorithm flags will be replaced with whatever algorithm was actually used.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the algorithm used to enumerate this list. </dd></dl>

</div>
</div>
<a id="a3ba946d1346a403a6dd164d5dd06f113" name="a3ba946d1346a403a6dd164d5dd06f113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba946d1346a403a6dd164d5dd06f113">&#9670;&nbsp;</a></span>allowsNonCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::allowsNonCompact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the coordinate system that was used for enumeration allows for non-compact hypersurfaces. </p>
<p >This does not test whether any of the hypersurfaces in this list are actually non-compact; it simply returns a basic property of the coordinate system that was used for enumeration.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if non-compact normal hypersurfaces are supported. </dd></dl>

</div>
</div>
<a id="ae9be4ab40d5be63e818f2d76a1294ae1" name="ae9be4ab40d5be63e818f2d76a1294ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9be4ab40d5be63e818f2d76a1294ae1">&#9670;&nbsp;</a></span>anonID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>  &gt;::anonID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unique string ID that can be used in place of a packet ID. </p>
<p >This is an alternative to <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, and is designed for use when <em>Held</em> is not actually wrapped by a PacketOf&lt;Held&gt;. (An example of such a scenario is when a normal surface list needs to write its triangulation to file, but the triangulation is a standalone object that is not stored in a packet.)</p>
<p >The ID that is returned will:</p>
<ul>
<li>remain fixed throughout the lifetime of the program for a given object, even if the contents of the object are changed;</li>
<li>not clash with the <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> returned from any other object, or with the internalID() returned from any packet of any type;</li>
</ul>
<p >These IDs are <em>not</em> preserved when copying or moving one object to another, and are not preserved when writing to a Regina data file and then reloading the file contents.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this object <em>is</em> wrapped in a PacketOf&lt;Held&gt;, then <a class="el" href="classregina_1_1PacketData.html#ae9be4ab40d5be63e818f2d76a1294ae1" title="A unique string ID that can be used in place of a packet ID.">anonID()</a> and <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> may return <em>different</em> values.</dd></dl>
<p>See <a class="el" href="classregina_1_1Packet.html#a0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this object. </dd></dl>

</div>
</div>
<a id="aa4253d748f5e772f1f000a27c9b74dd3" name="aa4253d748f5e772f1f000a27c9b74dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4253d748f5e772f1f000a27c9b74dd3">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalHypersurfaces::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator at the beginning of this list of hypersurfaces. </p>
<p >These <a class="el" href="classregina_1_1NormalHypersurfaces.html#aa4253d748f5e772f1f000a27c9b74dd3" title="Returns a C++ iterator at the beginning of this list of hypersurfaces.">begin()</a> and <a class="el" href="classregina_1_1NormalHypersurfaces.html#a47c1bfda801e928d15e5706340eb2bd8" title="Returns a C++ iterator beyond the end of this list of hypersurfaces.">end()</a> functions allow you to iterate through all hypersurfaces in this list using a range-based <code>for</code> loop:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="classregina_1_1NormalHypersurfaces.html#abc5572b7cc4b2b06f7f33d4a775a4091">NormalHypersurfaces</a> list(...);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> NormalHypersurface&amp; s : list) { ... }</div>
<div class="ttc" id="aclassregina_1_1NormalHypersurfaces_html_abc5572b7cc4b2b06f7f33d4a775a4091"><div class="ttname"><a href="classregina_1_1NormalHypersurfaces.html#abc5572b7cc4b2b06f7f33d4a775a4091">regina::NormalHypersurfaces::NormalHypersurfaces</a></div><div class="ttdeci">NormalHypersurfaces(const Triangulation&lt; 4 &gt; &amp;triangulation, HyperCoords coords, HyperList which=HS_LIST_DEFAULT, HyperAlg algHints=HS_ALG_DEFAULT, ProgressTracker *tracker=nullptr)</div><div class="ttdoc">A unified constructor for enumerating various classes of normal hypersurfaces within a given triangul...</div><div class="ttdef"><b>Definition:</b> normalhypersurfaces.h:1011</div></div>
</div><!-- fragment --><p >The type that is returned will be a lightweight iterator type, guaranteed to satisfy the C++ LegacyRandomAccessIterator requirement. The precise C++ type of the iterator is subject to change, so C++ users should use <code>auto</code> (just like this declaration does).</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> implements the Python iterable interface. You can iterate over the normal hypersurfaces in this list in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this list. </dd></dl>

</div>
</div>
<a id="acefed5920d1b387e5d3b0f35b390ebec" name="acefed5920d1b387e5d3b0f35b390ebec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acefed5920d1b387e5d3b0f35b390ebec">&#9670;&nbsp;</a></span>beginVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> regina::NormalHypersurfaces::beginVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A C++ iterator that gives access to the raw vectors for hypersurfaces in this list, pointing to the beginning of this hypersurface list. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="classregina_1_1NormalHypersurfaces.html#a1aa708c0a673f1e58d7329e20f912fe6" title="Returns a Python iterable object that iterates over the raw vectors for all hypersurfaces in this lis...">vectors()</a> instead, which returns an iterable object for iterating over these same raw vectors.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this hypersurface list. </dd></dl>

</div>
</div>
<a id="adc5c6c7aeab32d4d2d80425c9f8ad108" name="adc5c6c7aeab32d4d2d80425c9f8ad108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5c6c7aeab32d4d2d80425c9f8ad108">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> regina::NormalHypersurfaces::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the coordinate system that was originally used to enumerate the hypersurfaces in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>the coordinate system used. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda" name="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p >This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a47c1bfda801e928d15e5706340eb2bd8" name="a47c1bfda801e928d15e5706340eb2bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c1bfda801e928d15e5706340eb2bd8">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalHypersurfaces::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a C++ iterator beyond the end of this list of hypersurfaces. </p>
<p >These <a class="el" href="classregina_1_1NormalHypersurfaces.html#aa4253d748f5e772f1f000a27c9b74dd3" title="Returns a C++ iterator at the beginning of this list of hypersurfaces.">begin()</a> and <a class="el" href="classregina_1_1NormalHypersurfaces.html#a47c1bfda801e928d15e5706340eb2bd8" title="Returns a C++ iterator beyond the end of this list of hypersurfaces.">end()</a> routines allow you to iterate through all hypersurfaces in this list using a range-based <code>for</code> loop. See the <a class="el" href="classregina_1_1NormalHypersurfaces.html#aa4253d748f5e772f1f000a27c9b74dd3" title="Returns a C++ iterator at the beginning of this list of hypersurfaces.">begin()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. For Python users, <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> implements the Python iterable interface. You can iterate over the normal hypersurfaces in this list in the same way that you would iterate over any native Python container.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this list. </dd></dl>

</div>
</div>
<a id="a48d5da33f4ac4f4a2ed4296a4a0395b5" name="a48d5da33f4ac4f4a2ed4296a4a0395b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d5da33f4ac4f4a2ed4296a4a0395b5">&#9670;&nbsp;</a></span>endVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces_1_1VectorIterator.html">NormalHypersurfaces::VectorIterator</a> regina::NormalHypersurfaces::endVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A C++ iterator that gives access to the raw vectors for hypersurfaces in this list, pointing past the end of this hypersurface list. </p>
<p >This iterator is not dereferenceable.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="classregina_1_1NormalHypersurfaces.html#a1aa708c0a673f1e58d7329e20f912fe6" title="Returns a Python iterable object that iterates over the raw vectors for all hypersurfaces in this lis...">vectors()</a> instead, which returns an iterable object for iterating over these same raw vectors.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator past the end of this hypersurface list. </dd></dl>

</div>
</div>
<a id="aacba530d591ff0f91920716982d71a94" name="aacba530d591ff0f91920716982d71a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacba530d591ff0f91920716982d71a94">&#9670;&nbsp;</a></span>hypersurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp; regina::NormalHypersurfaces::hypersurface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hypersurface at the requested index in this list. </p>
<p >This is identical to using the square bracket operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested hypersurface in this list; this must be between 0 and <a class="el" href="classregina_1_1NormalHypersurfaces.html#a23b6c5deda3b5f72c5a29567b1812f20" title="Returns the number of hypersurfaces stored in this list.">size()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal hypersurface at the requested index in this list. </dd></dl>

</div>
</div>
<a id="ab13eb348cfcd3070e215de79d735ddd0" name="ab13eb348cfcd3070e215de79d735ddd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13eb348cfcd3070e215de79d735ddd0">&#9670;&nbsp;</a></span>isEmbeddedOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::isEmbeddedOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether this list is known to contain only embedded normal hypersurfaces. </p>
<p >If this returns <code>false</code>, it does not guarantee that immersed and/or singular hypersurfaces are present; it merely indicates that they were not deliberately excluded (for instance, the prism constraints were not enforced).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was constructed to contain only properly embedded hypersurfaces, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a70fe0febbb540a20b8436274ddfd5de0" name="a70fe0febbb540a20b8436274ddfd5de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70fe0febbb540a20b8436274ddfd5de0">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given list contain different sets of normal hypersurfaces. </p>
<p >The lists will be compared as multisets: the order of the hypersurfaces in each list does not matter; however, in the unusual scenario where a list the same hypersurface multiple times, multiplicity does matter.</p>
<p >Like the comparison operators for <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a>, it does not matter whether the lists work with different triangulations, or different encodings, or if one but not the other supports non-compact hypersurfaces. The individual hypersurfaces will simply be compared by examining or computing the number of normal pieces of each type.</p>
<p >In particular, this routine is safe to call even if this and the given list work with different triangulations:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will compare hypersurfaces as though they were transplanted into the same triangulation using the same pentachoron numbering and the same normal piece types.</li>
<li>If the two triangulations have different sizes, then this comparison will return <code>true</code> (i.e., the lists will be considered different).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list to be compared with this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both lists do not represent the same multiset of normal hypersurfaces, or <code>false</code> if they do. </dd></dl>

</div>
</div>
<a id="a32663705bf6533a5548e35b8974c2eb8" name="a32663705bf6533a5548e35b8974c2eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32663705bf6533a5548e35b8974c2eb8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp; regina::NormalHypersurfaces::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a (deep) copy of the given list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this list. </dd></dl>

</div>
</div>
<a id="a4e3c62f69162d2a1231761fdbf831e6b" name="a4e3c62f69162d2a1231761fdbf831e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3c62f69162d2a1231761fdbf831e6b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp; regina::NormalHypersurfaces::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of the given list into this list. </p>
<p >This is a fast (constant time) operation.</p>
<p >The list that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="section note"><dt>Note</dt><dd>This operator is <em>not</em> marked <code>noexcept</code>, since it fires change events on this list which may in turn call arbitrary code via any registered packet listeners. It deliberately does <em>not</em> fire change events on <em>src</em>, since it assumes that <em>src</em> is about to be destroyed (which will fire a destruction event instead).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the list to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this list. </dd></dl>

</div>
</div>
<a id="a6ee354b980503215466fadb7c38019b7" name="a6ee354b980503215466fadb7c38019b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee354b980503215466fadb7c38019b7">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurfaces::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given list contain the same set of normal hypersurfaces. </p>
<p >The lists will be compared as multisets: the order of the hypersurfaces in each list does not matter; however, in the unusual scenario where a list the same hypersurface multiple times, multiplicity does matter.</p>
<p >Like the comparison operators for <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a>, it does not matter whether the lists work with different triangulations, or different encodings, or if one but not the other supports non-compact hypersurfaces. The individual hypersurfaces will simply be compared by examining or computing the number of normal pieces of each type.</p>
<p >In particular, this routine is safe to call even if this and the given list work with different triangulations:</p>
<ul>
<li>If the two triangulations have the same size, then this routine will compare hypersurfaces as though they were transplanted into the same triangulation using the same pentachoron numbering and the same normal piece types.</li>
<li>If the two triangulations have different sizes, then this comparison will return <code>false</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list to be compared with this list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both lists represent the same multiset of normal hypersurfaces, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="abe018b1749159d20d91a6b68e424a6e6" name="abe018b1749159d20d91a6b68e424a6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe018b1749159d20d91a6b68e424a6e6">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp; regina::NormalHypersurfaces::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hypersurface at the requested index in this list. </p>
<p >This is identical to calling <a class="el" href="classregina_1_1NormalHypersurfaces.html#aacba530d591ff0f91920716982d71a94" title="Returns the hypersurface at the requested index in this list.">hypersurface()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested hypersurface in this list; this must be between 0 and <a class="el" href="classregina_1_1NormalHypersurfaces.html#a23b6c5deda3b5f72c5a29567b1812f20" title="Returns the number of hypersurfaces stored in this list.">size()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal hypersurface at the requested index in this list. </dd></dl>

</div>
</div>
<a id="ab55a7c7230f417159d55beaef98d3247" name="ab55a7c7230f417159d55beaef98d3247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7c7230f417159d55beaef98d3247">&#9670;&nbsp;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >If this object is being held by a packet <em>p</em> of type PacketOf&lt;Held&gt;, then that packet <em>p</em> will be returned. Otherwise, if this is a "standalone" object of type Held, then this routine will return <code>null</code>.</p>
<p >There is a special case when dealing with a packet <em>q</em> that holds a SnapPea triangulation. Here <em>q</em> is of type PacketOf&lt;SnapPeaTriangulation&gt;, and it holds a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> "indirectly" in the sense that Packetof&lt;SnapPeaTriangulation&gt; derives from <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, which in turn derives from <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. In this scenario:</p>
<ul>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">Triangulation&lt;3&gt;::packet()</a> will return <code>null</code>, since there is no "direct" PacketOf&lt;Triangulation&lt;3&gt;&gt;;</li>
<li>calling <a class="el" href="classregina_1_1PacketData.html#ab55a7c7230f417159d55beaef98d3247" title="Returns the packet that holds this data, if there is one.">SnapPeaTriangulation::packet()</a> will return the enclosing packet <em>q</em>, since there is a PacketOf&lt;SnapPeaTriangulation&gt;;</li>
<li>calling the special routine <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ab44e8aa8e6a1e0723767b94d60ce59d7" title="Returns the packet that holds this data, even if it is held indirectly via a SnapPea triangulation.">Triangulation&lt;3&gt;::inAnyPacket()</a> will also return the "indirect" enclosing packet <em>q</em>.</li>
</ul>
<p >The function inAnyPacket() is specific to <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>, and is not offered for other <em>Held</em> types.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a87f2f48664785da277fac60d654b2f88" name="a87f2f48664785da277fac60d654b2f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f2f48664785da277fac60d654b2f88">&#9670;&nbsp;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="classregina_1_1PacketOf.html">PacketOf</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>  &gt; &gt; <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>  &gt;::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the packet that holds this data, if there is one. </p>
<p >See the non-const version of this function for further details, and in particular for how this functions operations in the special case of a packet that holds a SnapPea triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that holds this data, or <code>null</code> if this data is not (directly) held by a packet. </dd></dl>

</div>
</div>
<a id="a3cc59447098b71719a62770f7336ee97" name="a3cc59447098b71719a62770f7336ee97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cc59447098b71719a62770f7336ee97">&#9670;&nbsp;</a></span>recreateMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> regina::NormalHypersurfaces::recreateMatchingEquations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the matching equations that were used to create this normal hypersurface list. </p>
<p >This matrix is not cached: multiple calls to this routine will result in the construction of multiple matrices. This routine in fact merely calls <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> with the appropriate parameters.</p>
<p >The format of the matrix is identical to that returned by <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a>.</p>
<p >Note that there are situations in which <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> throws an exception (because the triangulation is not supported by the chosen coordinate system). However, this routine will always succeed, because if <a class="el" href="group__hypersurface.html#ga3a4cdfcedc85720f461b89f1a869cfe1" title="Generates the set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> had failed then this normal hypersurface list would not have been created in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd>the matching equations used to create this normal hypersurface list. </dd></dl>

</div>
</div>
<a id="a23b6c5deda3b5f72c5a29567b1812f20" name="a23b6c5deda3b5f72c5a29567b1812f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b6c5deda3b5f72c5a29567b1812f20">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalHypersurfaces::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of hypersurfaces stored in this list. </p>
<dl class="section user"><dt>Python</dt><dd>This is also used to implement the Python special method <b>len</b>().</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of hypersurfaces. </dd></dl>

</div>
</div>
<a id="a1bf49a8aee54383f5641341b9471a307" name="a1bf49a8aee54383f5641341b9471a307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf49a8aee54383f5641341b9471a307">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaces::sort </td>
          <td>(</td>
          <td class="paramtype">Comparison &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the hypersurfaces in this list according to the given criterion. </p>
<p >This sort is stable, i.e., hypersurfaces that are equivalent under the given criterion will remain in the same relative order.</p>
<p >The implementation of this routine uses std::stable_sort.</p>
<dl class="section user"><dt>Python</dt><dd>This is available in Python, and <em>comp</em> may be a pure Python function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>a binary function (or other callable object) that accepts two const HyperSurface references, and returns <code>true</code> if and only if the first hypersurface should appear before the second in the sorted list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad" name="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p >This text should be human-readable, should use plain ASCII characters where possible, and should not contain any newlines.</p>
<p >Within these limits, this short text ouptut should be as information-rich as possible, since in most cases this forms the basis for the Python <code>__str__()</code> and <code>__repr__()</code> functions.</p>
<dl class="section user"><dt>Python</dt><dd>The Python "stringification" function <code>__str__()</code> will use precisely this function, and for most classes the Python <code>__repr__()</code> function will incorporate this into its output.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="af7b87efd352f068edf6aa2abdeab2b8e" name="af7b87efd352f068edf6aa2abdeab2b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b87efd352f068edf6aa2abdeab2b8e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaces::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given list. </p>
<p >This routine will behave correctly if <em>other</em> is in fact this list.</p>
<dl class="section note"><dt>Note</dt><dd>This swap function is <em>not</em> marked <code>noexcept</code>, since it fires change events on both lists which may in turn call arbitrary code via any registered packet listeners.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the list whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187d56a4306c0596567c7f94aa901a34" name="a187d56a4306c0596567c7f94aa901a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187d56a4306c0596567c7f94aa901a34">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp; regina::NormalHypersurfaces::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the triangulation in which these normal hypersurfaces live. </p>
<p >This will be a snapshot frozen in time of the triangulation that was originally passed to the <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> constructor.</p>
<p >This will return a correct result even if the original triangulation has since been modified or destroyed. However, in order to ensure this behaviour, it is possible that at different points in time this function may return references to different C++ objects.</p>
<p >The rules for using the <a class="el" href="classregina_1_1NormalHypersurfaces.html#a187d56a4306c0596567c7f94aa901a34" title="Returns the triangulation in which these normal hypersurfaces live.">triangulation()</a> reference are:</p>
<ul>
<li>Do not keep the resulting reference as a long-term reference or pointer of your own, since in time you may find yourself referring to the wrong object (see above). Just call this function again.</li>
<li>You must respect the read-only nature of the result (i.e., you must not cast the constness away). The snapshotting process detects modifications, and modifying the frozen snapshot may result in an exception being thrown.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>As of Regina 7.0, you <em>cannot</em> access this triangulation via the packet tree as <a class="el" href="classregina_1_1Packet.html#a315cfc82357f74190fc01644aaee62a0" title="Determines the parent packet in the tree structure.">Packet::parent()</a>. This is because normal hypersurface lists can now be kept anywhere in the packet tree, or can be kept as standalone objects outside the packet tree entirely.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2" name="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p >Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should not contain any newlines, and (within these constraints) should be as information-rich as is reasonable.</p>
<p >Unlike <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this function may use unicode characters to make the output more pleasant to read. The string that is returned will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a1aa708c0a673f1e58d7329e20f912fe6" name="a1aa708c0a673f1e58d7329e20f912fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa708c0a673f1e58d7329e20f912fe6">&#9670;&nbsp;</a></span>vectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto regina::NormalHypersurfaces::vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a Python iterable object that iterates over the raw vectors for all hypersurfaces in this list. </p>
<p >For example:</p>
<div class="fragment"><div class="line">list = NormalHypersurfaces(...)</div>
<div class="line"><span class="keywordflow">for</span> v <span class="keywordflow">in</span> list.vectors():</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section user"><dt>C++</dt><dd>Not present. For C++ users, <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a> provides <a class="el" href="classregina_1_1NormalHypersurfaces.html#acefed5920d1b387e5d3b0f35b390ebec" title="A C++ iterator that gives access to the raw vectors for hypersurfaces in this list,...">beginVectors()</a> and <a class="el" href="classregina_1_1NormalHypersurfaces.html#a48d5da33f4ac4f4a2ed4296a4a0395b5" title="A C++ iterator that gives access to the raw vectors for hypersurfaces in this list,...">endVectors()</a> instead, which together define an iterator range over these same raw vectors.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over the normal hypersurfaces in this list. </dd></dl>

</div>
</div>
<a id="aebbdf01911361353b206a761af4ffa17" name="aebbdf01911361353b206a761af4ffa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbdf01911361353b206a761af4ffa17">&#9670;&nbsp;</a></span>which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a> regina::NormalHypersurfaces::which </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns details of which normal hypersurfaces this list represents within the underlying triangulation. </p>
<p >This may not be the same HyperList that was passed to the class constructor. In particular, default values will have been explicitly filled in (such as HS_VERTEX and/or HS_EMBEDDED_ONLY), and invalid and/or redundant values will have been removed.</p>
<dl class="section return"><dt>Returns</dt><dd>details of what this list represents. </dd></dl>

</div>
</div>
<a id="ac20fa7238cc21f47676428d15582ccbd" name="ac20fa7238cc21f47676428d15582ccbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20fa7238cc21f47676428d15582ccbd">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaces::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda" title="Returns a detailed text representation of this object.">detail()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a892d908978a554c87566a22476dfd3a1" name="a892d908978a554c87566a22476dfd3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892d908978a554c87566a22476dfd3a1">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurfaces::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. Use <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2b995dbbf568ef31acb23cb86e512ea9" name="a2b995dbbf568ef31acb23cb86e512ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b995dbbf568ef31acb23cb86e512ea9">&#9670;&nbsp;</a></span>algorithm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga7bbec480a12abdfe3d308676a50cfe3f">HyperAlg</a> regina::NormalHypersurfaces::algorithm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the details of the enumeration algorithm that was used to generate this list. </p>
<p >This might not be the same as the <em>algorithmHints</em> flag that was originally passed to the enumeration routine (e.g., if invalid or inappropriate flags were passed). </p>

</div>
</div>
<a id="a6c9ba4d21f39dc2340ea896f9b5e65b1" name="a6c9ba4d21f39dc2340ea896f9b5e65b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9ba4d21f39dc2340ea896f9b5e65b1">&#9670;&nbsp;</a></span>coords_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> regina::NormalHypersurfaces::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The coordinate system that was originally used to enumerate the normal hypersurfaces in this list. </p>

</div>
</div>
<a id="a977558e565df8fd3a567561a69541f3b" name="a977558e565df8fd3a567561a69541f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977558e565df8fd3a567561a69541f3b">&#9670;&nbsp;</a></span>heldBy_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceregina.html#a1646adc461393abe5faadad1c4e15c38">PacketHeldBy</a> <a class="el" href="classregina_1_1PacketData.html">regina::PacketData</a>&lt; <a class="el" href="classregina_1_1NormalHypersurfaces.html">NormalHypersurfaces</a>  &gt;::heldBy_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether this <em>Held</em> object is in fact the inherited data for a PacketOf&lt;Held&gt;. </p>
<p >As a special case, this field is also used to indicate when a <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> is in fact the inherited data for a <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. See the PacketHeldBy enumeration for more details on the different values that this data member can take. </p>

</div>
</div>
<a id="a8cfd99e5c5cc41991ff85cfa082fb82b" name="a8cfd99e5c5cc41991ff85cfa082fb82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd99e5c5cc41991ff85cfa082fb82b">&#9670;&nbsp;</a></span>surfaces_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>&gt; regina::NormalHypersurfaces::surfaces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains all normal hypersurfaces in this list. </p>

</div>
</div>
<a id="acf8c677cdd3ee2f9e6ed3f9a1c501661" name="acf8c677cdd3ee2f9e6ed3f9a1c501661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8c677cdd3ee2f9e6ed3f9a1c501661">&#9670;&nbsp;</a></span>triangulation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SnapshotRef.html">SnapshotRef</a>&lt;<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt; &gt; regina::NormalHypersurfaces::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which these normal hypersurfaces lie. </p>

</div>
</div>
<a id="a0441ca3f6753979a988d5f392e2687aa" name="a0441ca3f6753979a988d5f392e2687aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0441ca3f6753979a988d5f392e2687aa">&#9670;&nbsp;</a></span>which_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#ga79b78ca3086478c8fde56004c47f02b2">HyperList</a> regina::NormalHypersurfaces::which_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which normal hypersurfaces these represent within the underlying triangulation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hypersurface/<a class="el" href="normalhypersurfaces_8h.html">normalhypersurfaces.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2023, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
