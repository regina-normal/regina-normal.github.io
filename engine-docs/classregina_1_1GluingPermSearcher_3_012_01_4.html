<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::GluingPermSearcher&lt; 2 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html">GluingPermSearcher< 2 ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1GluingPermSearcher_3_012_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::GluingPermSearcher&lt; 2 &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class for searching through all possible gluing permutation sets that correspond to a given triangle edge pairing.  
 <a href="classregina_1_1GluingPermSearcher_3_012_01_4.html#details">More...</a></p>

<p><code>#include &lt;census/gluingpermsearcher2.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::GluingPermSearcher&lt; 2 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1GluingPermSearcher_3_012_01_4.png" usemap="#regina::GluingPermSearcher&lt; 2 &gt;_map" alt=""/>
  <map id="regina::GluingPermSearcher&lt; 2 &gt;_map" name="regina::GluingPermSearcher&lt; 2 &gt;_map">
<area href="classregina_1_1GluingPerms.html" alt="regina::GluingPerms&lt; 2 &gt;" shape="rect" coords="0,0,203,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a06b7398f8c62681711e41503cb8ebc43"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a> )(const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *, void *)</td></tr>
<tr class="memdesc:a06b7398f8c62681711e41503cb8ebc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a set of gluing permutations.  <a href="#a06b7398f8c62681711e41503cb8ebc43">More...</a><br/></td></tr>
<tr class="separator:a06b7398f8c62681711e41503cb8ebc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a385345c086bce00163471f973fc86e95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a385345c086bce00163471f973fc86e95">GluingPermSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a385345c086bce00163471f973fc86e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search for gluing permutation sets.  <a href="#a385345c086bce00163471f973fc86e95">More...</a><br/></td></tr>
<tr class="separator:a385345c086bce00163471f973fc86e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a6f0651ec9f0d269d5e1e8d094f75d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a79a6f0651ec9f0d269d5e1e8d094f75d">GluingPermSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a79a6f0651ec9f0d269d5e1e8d094f75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="#a79a6f0651ec9f0d269d5e1e8d094f75d">More...</a><br/></td></tr>
<tr class="separator:a79a6f0651ec9f0d269d5e1e8d094f75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694a3184398855d061d3391e372abaf7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a694a3184398855d061d3391e372abaf7">~GluingPermSearcher</a> ()</td></tr>
<tr class="memdesc:a694a3184398855d061d3391e372abaf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="#a694a3184398855d061d3391e372abaf7">More...</a><br/></td></tr>
<tr class="separator:a694a3184398855d061d3391e372abaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8e405571d84d85002ffe55a40726db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db">runSearch</a> (long maxDepth=-1)</td></tr>
<tr class="memdesc:a8b8e405571d84d85002ffe55a40726db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="#a8b8e405571d84d85002ffe55a40726db">More...</a><br/></td></tr>
<tr class="separator:a8b8e405571d84d85002ffe55a40726db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d955c2599cf51c2c0b457b3860baed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a89d955c2599cf51c2c0b457b3860baed">completePermSet</a> () const </td></tr>
<tr class="memdesc:a89d955c2599cf51c2c0b457b3860baed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <a href="#a89d955c2599cf51c2c0b457b3860baed">More...</a><br/></td></tr>
<tr class="separator:a89d955c2599cf51c2c0b457b3860baed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc132f81900923e12cdbd3084b7ca5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a1cc132f81900923e12cdbd3084b7ca5a">dumpTaggedData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a1cc132f81900923e12cdbd3084b7ca5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <a href="#a1cc132f81900923e12cdbd3084b7ca5a">More...</a><br/></td></tr>
<tr class="separator:a1cc132f81900923e12cdbd3084b7ca5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9f9dee5c22c5137f1ac8aeb9a61d6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a4b9f9dee5c22c5137f1ac8aeb9a61d6f">dumpData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a4b9f9dee5c22c5137f1ac8aeb9a61d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="#a4b9f9dee5c22c5137f1ac8aeb9a61d6f">More...</a><br/></td></tr>
<tr class="separator:a4b9f9dee5c22c5137f1ac8aeb9a61d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bbad418f06f4822634038eb2a7de95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#ab5bbad418f06f4822634038eb2a7de95">inputError</a> () const</td></tr>
<tr class="memdesc:ab5bbad418f06f4822634038eb2a7de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was an error found during construction from an input stream?  <a href="#ab5bbad418f06f4822634038eb2a7de95">More...</a><br/></td></tr>
<tr class="separator:ab5bbad418f06f4822634038eb2a7de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2bb95b2c9ea1c28e2f4091dcbceb66"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a6a2bb95b2c9ea1c28e2f4091dcbceb66">size</a> () const</td></tr>
<tr class="memdesc:a6a2bb95b2c9ea1c28e2f4091dcbceb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of simplices under consideration.  <a href="#a6a2bb95b2c9ea1c28e2f4091dcbceb66">More...</a><br/></td></tr>
<tr class="separator:a6a2bb95b2c9ea1c28e2f4091dcbceb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb120711ed73fb165bbe248a34301d46"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#acb120711ed73fb165bbe248a34301d46">facetPairing</a> () const</td></tr>
<tr class="memdesc:acb120711ed73fb165bbe248a34301d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="#acb120711ed73fb165bbe248a34301d46">More...</a><br/></td></tr>
<tr class="separator:acb120711ed73fb165bbe248a34301d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca21023c088994b0c1caeb968f995f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#aca21023c088994b0c1caeb968f995f4e">gluingPerm</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:aca21023c088994b0c1caeb968f995f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="#aca21023c088994b0c1caeb968f995f4e">More...</a><br/></td></tr>
<tr class="separator:aca21023c088994b0c1caeb968f995f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34072afb49329d499c028cf843579bea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a34072afb49329d499c028cf843579bea">gluingPerm</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:a34072afb49329d499c028cf843579bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="#a34072afb49329d499c028cf843579bea">More...</a><br/></td></tr>
<tr class="separator:a34072afb49329d499c028cf843579bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5cc3bc26c026b9ab9a82a44ded003c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#adc5cc3bc26c026b9ab9a82a44ded003c">triangulate</a> () const</td></tr>
<tr class="memdesc:adc5cc3bc26c026b9ab9a82a44ded003c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing.  <a href="#adc5cc3bc26c026b9ab9a82a44ded003c">More...</a><br/></td></tr>
<tr class="separator:adc5cc3bc26c026b9ab9a82a44ded003c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa0ec9d10baaa81178d6a104455b347d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2">findAllPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:aa0ec9d10baaa81178d6a104455b347d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given edge pairing.  <a href="#aa0ec9d10baaa81178d6a104455b347d2">More...</a><br/></td></tr>
<tr class="separator:aa0ec9d10baaa81178d6a104455b347d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcc40f8963f47e6059a0c49a115982a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#adbcc40f8963f47e6059a0c49a115982a">bestSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *autos, bool orientableOnly, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:adbcc40f8963f47e6059a0c49a115982a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <a href="#adbcc40f8963f47e6059a0c49a115982a">More...</a><br/></td></tr>
<tr class="separator:adbcc40f8963f47e6059a0c49a115982a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdcfc6c102832450b03bd8a2a36b040"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a2bdcfc6c102832450b03bd8a2a36b040">readTaggedData</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a2bdcfc6c102832450b03bd8a2a36b040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <a href="#a2bdcfc6c102832450b03bd8a2a36b040">More...</a><br/></td></tr>
<tr class="separator:a2bdcfc6c102832450b03bd8a2a36b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a60fa11fd71fce2ac44c97eeb79a723e6"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a60fa11fd71fce2ac44c97eeb79a723e6">dataTag_</a></td></tr>
<tr class="memdesc:a60fa11fd71fce2ac44c97eeb79a723e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="#a60fa11fd71fce2ac44c97eeb79a723e6">More...</a><br/></td></tr>
<tr class="separator:a60fa11fd71fce2ac44c97eeb79a723e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acb5d6fd15a5e7d16de825a715f79febc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#acb5d6fd15a5e7d16de825a715f79febc">isCanonical</a> () const </td></tr>
<tr class="memdesc:acb5d6fd15a5e7d16de825a715f79febc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying edge pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <a href="#acb5d6fd15a5e7d16de825a715f79febc">More...</a><br/></td></tr>
<tr class="separator:acb5d6fd15a5e7d16de825a715f79febc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af925455d41f9d5c2dce4cbc04d758bfb"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#af925455d41f9d5c2dce4cbc04d758bfb">dataTag</a> () const </td></tr>
<tr class="memdesc:af925455d41f9d5c2dce4cbc04d758bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="#af925455d41f9d5c2dce4cbc04d758bfb">More...</a><br/></td></tr>
<tr class="separator:af925455d41f9d5c2dce4cbc04d758bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f6711eb803742af936b68a0680888f"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a28f6711eb803742af936b68a0680888f">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a28f6711eb803742af936b68a0680888f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a28f6711eb803742af936b68a0680888f">More...</a><br/></td></tr>
<tr class="separator:a28f6711eb803742af936b68a0680888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#aa1eb17b2d09a1fc64176b5eda1e057e4">permIndex</a> (unsigned simp, unsigned facet)</td></tr>
<tr class="memdesc:aa1eb17b2d09a1fc64176b5eda1e057e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#aa1eb17b2d09a1fc64176b5eda1e057e4">More...</a><br/></td></tr>
<tr class="separator:aa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa4fd5a9fa072efe8318ebe6fef632f"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#abaa4fd5a9fa072efe8318ebe6fef632f">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:abaa4fd5a9fa072efe8318ebe6fef632f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#abaa4fd5a9fa072efe8318ebe6fef632f">More...</a><br/></td></tr>
<tr class="separator:abaa4fd5a9fa072efe8318ebe6fef632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae534308e45fc5d77400f393646b93c"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a1ae534308e45fc5d77400f393646b93c">permIndex</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:a1ae534308e45fc5d77400f393646b93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a1ae534308e45fc5d77400f393646b93c">More...</a><br/></td></tr>
<tr class="separator:a1ae534308e45fc5d77400f393646b93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638cd32d383ca0c0517331eb3536f0db"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a638cd32d383ca0c0517331eb3536f0db">gluingToIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:a638cd32d383ca0c0517331eb3536f0db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#a638cd32d383ca0c0517331eb3536f0db">More...</a><br/></td></tr>
<tr class="separator:a638cd32d383ca0c0517331eb3536f0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7826914d40eab7cbb40c92f64dc84869"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a7826914d40eab7cbb40c92f64dc84869">gluingToIndex</a> (unsigned simp, unsigned facet, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:a7826914d40eab7cbb40c92f64dc84869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#a7826914d40eab7cbb40c92f64dc84869">More...</a><br/></td></tr>
<tr class="separator:a7826914d40eab7cbb40c92f64dc84869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec0b9eff3280d05b7bb1be971f3b202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#abec0b9eff3280d05b7bb1be971f3b202">indexToGluing</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, int index) const</td></tr>
<tr class="memdesc:abec0b9eff3280d05b7bb1be971f3b202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array Perm&lt;dim+1&gt;::Sn_1.  <a href="#abec0b9eff3280d05b7bb1be971f3b202">More...</a><br/></td></tr>
<tr class="separator:abec0b9eff3280d05b7bb1be971f3b202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd48b741abeb1822f9c5a172dbcf1594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#acd48b741abeb1822f9c5a172dbcf1594">indexToGluing</a> (unsigned simp, unsigned facet, int index) const</td></tr>
<tr class="memdesc:acd48b741abeb1822f9c5a172dbcf1594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array Perm&lt;dim+1&gt;::Sn_1.  <a href="#acd48b741abeb1822f9c5a172dbcf1594">More...</a><br/></td></tr>
<tr class="separator:acd48b741abeb1822f9c5a172dbcf1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a212ff03da851218638fb2a958aa2a13b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a212ff03da851218638fb2a958aa2a13b">autos_</a></td></tr>
<tr class="memdesc:a212ff03da851218638fb2a958aa2a13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <a href="#a212ff03da851218638fb2a958aa2a13b">More...</a><br/></td></tr>
<tr class="separator:a212ff03da851218638fb2a958aa2a13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739f16439d7567092d2929bc8f3fe65d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a739f16439d7567092d2929bc8f3fe65d">autosNew</a></td></tr>
<tr class="memdesc:a739f16439d7567092d2929bc8f3fe65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)?  <a href="#a739f16439d7567092d2929bc8f3fe65d">More...</a><br/></td></tr>
<tr class="separator:a739f16439d7567092d2929bc8f3fe65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60ee67149b8f7e69ad70e073e5ab977"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#ae60ee67149b8f7e69ad70e073e5ab977">orientableOnly_</a></td></tr>
<tr class="memdesc:ae60ee67149b8f7e69ad70e073e5ab977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <a href="#ae60ee67149b8f7e69ad70e073e5ab977">More...</a><br/></td></tr>
<tr class="separator:ae60ee67149b8f7e69ad70e073e5ab977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4c3890c45451a0fd3872a2dd09bc0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a3d4c3890c45451a0fd3872a2dd09bc0b">use_</a></td></tr>
<tr class="memdesc:a3d4c3890c45451a0fd3872a2dd09bc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to call each time a gluing permutation set is found during the search.  <a href="#a3d4c3890c45451a0fd3872a2dd09bc0b">More...</a><br/></td></tr>
<tr class="separator:a3d4c3890c45451a0fd3872a2dd09bc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326ae3e5b54a478e682ec4d3a1116f61"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a326ae3e5b54a478e682ec4d3a1116f61">useArgs_</a></td></tr>
<tr class="memdesc:a326ae3e5b54a478e682ec4d3a1116f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine.  <a href="#a326ae3e5b54a478e682ec4d3a1116f61">More...</a><br/></td></tr>
<tr class="separator:a326ae3e5b54a478e682ec4d3a1116f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845dee0fb289ae31732acdbbebe4396c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a845dee0fb289ae31732acdbbebe4396c">started</a></td></tr>
<tr class="memdesc:a845dee0fb289ae31732acdbbebe4396c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <a href="#a845dee0fb289ae31732acdbbebe4396c">More...</a><br/></td></tr>
<tr class="separator:a845dee0fb289ae31732acdbbebe4396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1466828ee218e55095bf0e476d625a"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aaf1466828ee218e55095bf0e476d625a">orientation</a></td></tr>
<tr class="memdesc:aaf1466828ee218e55095bf0e476d625a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each triangle in the underlying triangulation.  <a href="#aaf1466828ee218e55095bf0e476d625a">More...</a><br/></td></tr>
<tr class="separator:aaf1466828ee218e55095bf0e476d625a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ead7f5285666965fbc9d28826d82677"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a9ead7f5285666965fbc9d28826d82677">order</a></td></tr>
<tr class="memdesc:a9ead7f5285666965fbc9d28826d82677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to edges.  <a href="#a9ead7f5285666965fbc9d28826d82677">More...</a><br/></td></tr>
<tr class="separator:a9ead7f5285666965fbc9d28826d82677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ebe801472975c7fce7b7c0557ee2ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a24ebe801472975c7fce7b7c0557ee2ff">orderSize</a></td></tr>
<tr class="memdesc:a24ebe801472975c7fce7b7c0557ee2ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the edge pairing graph, i.e., the number of elements of interest in the order[] array.  <a href="#a24ebe801472975c7fce7b7c0557ee2ff">More...</a><br/></td></tr>
<tr class="separator:a24ebe801472975c7fce7b7c0557ee2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccdb731602614ebfb5435d539f13dad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#abccdb731602614ebfb5435d539f13dad">orderElt</a></td></tr>
<tr class="memdesc:abccdb731602614ebfb5435d539f13dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <a href="#abccdb731602614ebfb5435d539f13dad">More...</a><br/></td></tr>
<tr class="separator:abccdb731602614ebfb5435d539f13dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fb5bb6ec20f8822927d49c100738e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#ad9fb5bb6ec20f8822927d49c100738e5">pairing_</a></td></tr>
<tr class="memdesc:ad9fb5bb6ec20f8822927d49c100738e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet pairing that this permutation set complements.  <a href="#ad9fb5bb6ec20f8822927d49c100738e5">More...</a><br/></td></tr>
<tr class="separator:ad9fb5bb6ec20f8822927d49c100738e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae038d32acaf9c1fc1f086dc8a344417"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#aae038d32acaf9c1fc1f086dc8a344417">permIndices_</a></td></tr>
<tr class="memdesc:aae038d32acaf9c1fc1f086dc8a344417"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index into array Perm&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner.  <a href="#aae038d32acaf9c1fc1f086dc8a344417">More...</a><br/></td></tr>
<tr class="separator:aae038d32acaf9c1fc1f086dc8a344417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df91f50200ff5d6e76ede8c123e8ce6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GluingPerms.html#a4df91f50200ff5d6e76ede8c123e8ce6">inputError_</a></td></tr>
<tr class="memdesc:a4df91f50200ff5d6e76ede8c123e8ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has an error occurred during construction from an input stream?  <a href="#a4df91f50200ff5d6e76ede8c123e8ce6">More...</a><br/></td></tr>
<tr class="separator:a4df91f50200ff5d6e76ede8c123e8ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;&gt;<br/>
class regina::GluingPermSearcher&lt; 2 &gt;</h3>

<p>A utility class for searching through all possible gluing permutation sets that correspond to a given triangle edge pairing. </p>
<p>In the future, there may be subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> that correspond to specialised search algorithms for use in certain scenarios. The main class <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> offers a default search algorithm that may be used in a general context.</p>
<p>The simplest way of performing a search through all possible gluing permutations is by calling the static method <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a>. This will examine the search parameters and ensure that the best possible algorithm is used. For finer control over the program flow, the static method <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#adbcc40f8963f47e6059a0c49a115982a" title="Constructs a search manager of the best possible class for the given search parameters.">bestSearcher()</a> can be used to create a search manager of the most suitable class and then <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> can be called on this object directly. For absolute control, a specific algorithm can be forced by explicitly constructing an object of the corresponding class (and again calling <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on that object directly).</p>
<p>Note that this class derives from <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;2&gt;</a>. The search will involve building and repeatedly modifying the inherited <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;2&gt;</a> data in-place.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a06b7398f8c62681711e41503cb8ebc43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::Use)(const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt; *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that can do arbitrary processing upon a set of gluing permutations. </p>
<p>Such routines are used to process permutation sets that are found when running census-building routines such as <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a>.</p>
<p>The first parameter passed will be a set of gluing permutations (as this class derives from <a class="el" href="classregina_1_1GluingPerms.html">GluingPerms&lt;2&gt;</a>). This set of gluing permutations must not be deallocated by this routine, since it may be used again later by the caller. The second parameter may contain arbitrary data; typically this will be the data passed to the relevant search routine, such as <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a> or the <a class="el" href="classregina_1_1GluingPermSearcher.html" title="A utility class used to build a census of triangulations, by searching through all possible sets of g...">GluingPermSearcher</a> class constructor.</p>
<p>Note that the first parameter passed might be <code>null</code> to signal that gluing permutation generation has finished. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a385345c086bce00163471f973fc86e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search for gluing permutation sets. </p>
<p>The search is started by calling <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. Note that the static method <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a> handles both construction and searching, and is the preferred entry point for end users.</p>
<p>The arguments to this constructor describe the search parameters in detail, as well as what should be done with each gluing permutation set that is found.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge pairing is connected, i.e., it is possible to reach any triangle from any other triangle via a series of matched edge pairs. </dd>
<dd>
The given edge pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;2&gt;::isCanonical()</a>. Note that all edge pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;2&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of triangle edges that the generated permutation sets will complement. </td></tr>
    <tr><td class="paramname">autos</td><td>the collection of isomorphisms that define equivalence of permutation sets. These are used by <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>, which produces each permutation set precisely once up to equivalence. These isomorphisms must all be automorphisms of the given edge pairing, and will generally be the set of all such automorphisms. This parameter may be 0, in which case the set of all automorphisms of the given edge pairing will be generated and used. </td></tr>
    <tr><td class="paramname">orientableOnly</td><td><code>true</code> if only gluing permutations corresponding to orientable triangulations should be generated, or <code>false</code> if no such restriction should be imposed. </td></tr>
    <tr><td class="paramname">use</td><td>the function to call upon each permutation set that is found. The first parameter passed to this function will be a gluing permutation set. The second parameter will be parameter <em>useArgs</em> as was passed to this routine. </td></tr>
    <tr><td class="paramname">useArgs</td><td>the pointer to pass as the final parameter for the function <em>use</em> which will be called upon each permutation set found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79a6f0651ec9f0d269d5e1e8d094f75d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a4b9f9dee5c22c5137f1ac8aeb9a61d6f" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a1cc132f81900923e12cdbd3084b7ca5a" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a2bdcfc6c102832450b03bd8a2a36b040" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="classregina_1_1GluingPerms.html#ab5bbad418f06f4822634038eb2a7de95" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">use</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor. </td></tr>
    <tr><td class="paramname">useArgs</td><td>as for the main <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a694a3184398855d061d3391e372abaf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::~<a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adbcc40f8963f47e6059a0c49a115982a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::bestSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a> instead.</p>
<p>The resulting object is newly created, and must be destroyed by the caller of this routine.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge pairing is connected, i.e., it is possible to reach any triangle from any other triangle via a series of matched edge pairs. </dd>
<dd>
The given edge pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;2&gt;::isCanonical()</a>. Note that all edge pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;2&gt;::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created search manager. </dd></dl>

</div>
</div>
<a class="anchor" id="a89d955c2599cf51c2c0b457b3860baed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::completePermSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>use_</em> routine when running partial depth-based searches. See <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af925455d41f9d5c2dce4cbc04d758bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b9f9dee5c22c5137f1ac8aeb9a61d6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1GluingPerms.html#ac029524ff940df5de09e02f3ee77e6ca">regina::GluingPerms&lt; 2 &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1cc132f81900923e12cdbd3084b7ca5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a2bdcfc6c102832450b03bd8a2a36b040" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb120711ed73fb165bbe248a34301d46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::facetPairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding simplex facet pairing. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0ec9d10baaa81178d6a104455b347d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::findAllPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt; *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 2 &gt;::IsoList *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given edge pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> and then calls <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given edge pairing is connected, i.e., it is possible to reach any triangle from any other triangle via a series of matched edge pairs. </dd>
<dd>
The given edge pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">FacetPairing&lt;2&gt;::isCanonical()</a>. Note that all edge pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#af37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">FacetPairing&lt;2&gt;::findAllPairings()</a> are of this form. </dd></dl>

</div>
</div>
<a class="anchor" id="aca21023c088994b0c1caeb968f995f4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine facetPairing()). </dd>
<dd>
The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a34072afb49329d499c028cf843579bea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine facetPairing()).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a638cd32d383ca0c0517331eb3536f0db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into Perm&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array Perm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="a7826914d40eab7cbb40c92f64dc84869"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into Perm&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array Perm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="abec0b9eff3280d05b7bb1be971f3b202"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array Perm&lt;dim+1&gt;::Sn_1. </p>
<p>This index into Perm&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array Perm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">index</td><td>an index into Perm&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into Perm&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="acd48b741abeb1822f9c5a172dbcf1594"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array Perm&lt;dim+1&gt;::Sn_1. </p>
<p>This index into Perm&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array Perm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>an index into Perm&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into Perm&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5bbad418f06f4822634038eb2a7de95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was an error found during construction from an input stream? </p>
<p>This routine returns <code>true</code> if an input stream constructor was used to create this object but the data in the input stream was invalid or incorrectly formatted.</p>
<p>If a different constructor was called (i.e., no input stream was used), then this routine will always return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an error occurred during construction from an input stream, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acb5d6fd15a5e7d16de825a715f79febc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying edge pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a28f6711eb803742af936b68a0680888f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1eb17b2d09a1fc64176b5eda1e057e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="abaa4fd5a9fa072efe8318ebe6fef632f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae534308e45fc5d77400f393646b93c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bdcfc6c102832450b03bd8a2a36b040"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::readTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 2 &gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a1cc132f81900923e12cdbd3084b7ca5a" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a4b9f9dee5c22c5137f1ac8aeb9a61d6f" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, a null pointer will be returned. Otherwise a newly constructed search manager will be returned, and it is the responsibility of the caller of this routine to destroy it after use.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b8e405571d84d85002ffe55a40726db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#aa0ec9d10baaa81178d6a104455b347d2" title="The main entry routine for running a search for all gluing permutation sets that complement a given e...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given edge pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">GluingPermSearcher&lt;2&gt;</a> objects. These partial searches may then be restarted by calling <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a89d955c2599cf51c2c0b457b3860baed" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a8b8e405571d84d85002ffe55a40726db" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a2bb95b2c9ea1c28e2f4091dcbceb66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of simplices under consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a class="anchor" id="adc5cc3bc26c026b9ab9a82a44ded003c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing. </p>
<p>Each matched pair of facets and their associated permutations will be realised as two simplex facets in the triangulation glued together with the corresponding gluing permutation. Each unmatched facet will be realised as a boundary facet in the triangulation.</p>
<p>It is the responsibility of the caller of this routine to delete this triangulation once it is no longer required.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created triangulation modelled by this structure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a212ff03da851218638fb2a958aa2a13b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;2&gt;::IsoList* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying edge pairing. </p>

</div>
</div>
<a class="anchor" id="a739f16439d7567092d2929bc8f3fe65d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::autosNew</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)? </p>

</div>
</div>
<a class="anchor" id="a60fa11fd71fce2ac44c97eeb79a723e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a class="anchor" id="a4df91f50200ff5d6e76ede8c123e8ce6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has an error occurred during construction from an input stream? </p>

</div>
</div>
<a class="anchor" id="a9ead7f5285666965fbc9d28826d82677"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;2&gt;* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to edges. </p>
<p>Specifically, this order is order[0], order[1], ..., order[orderSize-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying edge pairing graph, which in turn represents a triangle edge and its image under the given edge pairing.</p>
<p>The specific triangle edge stored in this array for each edge of the underlying edge pairing graph will be the smaller of the two identified triangle edges (unless otherwise specified by a subclass that uses a specialised search algorithm. </p>

</div>
</div>
<a class="anchor" id="abccdb731602614ebfb5435d539f13dad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orderElt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a class="anchor" id="a24ebe801472975c7fce7b7c0557ee2ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orderSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the edge pairing graph, i.e., the number of elements of interest in the order[] array. </p>

</div>
</div>
<a class="anchor" id="ae60ee67149b8f7e69ad70e073e5ab977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a class="anchor" id="aaf1466828ee218e55095bf0e476d625a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each triangle in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply +/-1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a class="anchor" id="ad9fb5bb6ec20f8822927d49c100738e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::pairing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The facet pairing that this permutation set complements. </p>
<p>This is guaranteed to be the minimal representative of its facet pairing isomorphism class. </p>

</div>
</div>
<a class="anchor" id="aae038d32acaf9c1fc1f086dc8a344417"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index into array Perm&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner. </p>
<p>Note that this is not a gluing permutation as such but rather a permutation of 0,...,<em>dim-1</em> only (see the routines gluingToIndex() and indexToGluing() for conversions). If a permutation has not yet been selected (e.g., if this permutation set is still under construction) then this index is -1. </p>

</div>
</div>
<a class="anchor" id="a845dee0fb289ae31732acdbbebe4396c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<a class="anchor" id="a3d4c3890c45451a0fd3872a2dd09bc0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt;2&gt;::<a class="el" href="classregina_1_1GluingPermSearcher_3_012_01_4.html#a06b7398f8c62681711e41503cb8ebc43">Use</a> <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::use_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to call each time a gluing permutation set is found during the search. </p>

</div>
</div>
<a class="anchor" id="a326ae3e5b54a478e682ec4d3a1116f61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classregina_1_1GluingPermSearcher.html">regina::GluingPermSearcher</a>&lt; 2 &gt;::useArgs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="gluingpermsearcher2_8h.html">gluingpermsearcher2.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
