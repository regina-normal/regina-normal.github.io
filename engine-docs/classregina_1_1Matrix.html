<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::Matrix&lt; T, ring &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classregina_1_1Matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::Matrix&lt; T, ring &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__hypersurface.html">Normal Hypersurfaces</a> &#124; <a class="el" href="group__maths.html">Mathematical Support</a> &#124; <a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a matrix of elements of the given type <em>T</em>.  
 <a href="classregina_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;maths/matrix.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Matrix&lt; T, ring &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Matrix.png" usemap="#regina::Matrix_3C_20T_2C_20ring_20_3E_map" alt=""/>
  <map id="regina::Matrix_3C_20T_2C_20ring_20_3E_map" name="regina::Matrix_3C_20T_2C_20ring_20_3E_map">
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Matrix&lt; T &gt; &gt;" shape="rect" coords="0,0,225,24"/>
<area href="structregina_1_1MatrixRingIdentities.html" title="Provides additive and multiplicative identity constants for the Matrix class." alt="regina::MatrixRingIdentities&lt; T, ring &gt;" shape="rect" coords="235,0,460,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8b4cd2d23d741532903f931c237af050"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a8b4cd2d23d741532903f931c237af050">Coefficient</a></td></tr>
<tr class="memdesc:a8b4cd2d23d741532903f931c237af050"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of each entry in the matrix.  <a href="#a8b4cd2d23d741532903f931c237af050">More...</a><br /></td></tr>
<tr class="separator:a8b4cd2d23d741532903f931c237af050"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc99891c1b2d33bbb99c8b9d3f4d14bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#afc99891c1b2d33bbb99c8b9d3f4d14bd">Matrix</a> (unsigned long <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28">rows</a>, unsigned long cols)</td></tr>
<tr class="memdesc:afc99891c1b2d33bbb99c8b9d3f4d14bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix of the given size.  <a href="#afc99891c1b2d33bbb99c8b9d3f4d14bd">More...</a><br /></td></tr>
<tr class="separator:afc99891c1b2d33bbb99c8b9d3f4d14bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78dfe46d992a2cdec7ac48032ec0de3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a78dfe46d992a2cdec7ac48032ec0de3f">Matrix</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;src)</td></tr>
<tr class="memdesc:a78dfe46d992a2cdec7ac48032ec0de3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new matrix that is a clone of the given matrix.  <a href="#a78dfe46d992a2cdec7ac48032ec0de3f">More...</a><br /></td></tr>
<tr class="separator:a78dfe46d992a2cdec7ac48032ec0de3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402006c9b71e99ffe86ee809af492383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a402006c9b71e99ffe86ee809af492383">Matrix</a> (<a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a402006c9b71e99ffe86ee809af492383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given matrix into this new matrix.  <a href="#a402006c9b71e99ffe86ee809af492383">More...</a><br /></td></tr>
<tr class="separator:a402006c9b71e99ffe86ee809af492383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0626c71c7a3d36bbd6223b4b8ddff81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ad0626c71c7a3d36bbd6223b4b8ddff81">~Matrix</a> ()</td></tr>
<tr class="memdesc:ad0626c71c7a3d36bbd6223b4b8ddff81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix.  <a href="#ad0626c71c7a3d36bbd6223b4b8ddff81">More...</a><br /></td></tr>
<tr class="separator:ad0626c71c7a3d36bbd6223b4b8ddff81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1c88c6ec5aac7830d0e3c6b5e55867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a9b1c88c6ec5aac7830d0e3c6b5e55867">operator=</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;src)</td></tr>
<tr class="memdesc:a9b1c88c6ec5aac7830d0e3c6b5e55867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given matrix into this matrix.  <a href="#a9b1c88c6ec5aac7830d0e3c6b5e55867">More...</a><br /></td></tr>
<tr class="separator:a9b1c88c6ec5aac7830d0e3c6b5e55867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0605f8e230984ee14c3ebf25af6f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a8b0605f8e230984ee14c3ebf25af6f03">operator=</a> (<a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:a8b0605f8e230984ee14c3ebf25af6f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given matrix into this matrix.  <a href="#a8b0605f8e230984ee14c3ebf25af6f03">More...</a><br /></td></tr>
<tr class="separator:a8b0605f8e230984ee14c3ebf25af6f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f3cbb6b3a5eece191d00ec6966ac6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a11f3cbb6b3a5eece191d00ec6966ac6a">initialise</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a11f3cbb6b3a5eece191d00ec6966ac6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets every entry in the matrix to the given value.  <a href="#a11f3cbb6b3a5eece191d00ec6966ac6a">More...</a><br /></td></tr>
<tr class="separator:a11f3cbb6b3a5eece191d00ec6966ac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00ec376dd6be8e84e3bbe2c76f7ad96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ac00ec376dd6be8e84e3bbe2c76f7ad96">initialise</a> (List allValues)</td></tr>
<tr class="memdesc:ac00ec376dd6be8e84e3bbe2c76f7ad96"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that fills the matrix with the given set of elements.  <a href="#ac00ec376dd6be8e84e3bbe2c76f7ad96">More...</a><br /></td></tr>
<tr class="separator:ac00ec376dd6be8e84e3bbe2c76f7ad96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5408505810c3b56f8b6486a48de3cf28"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28">rows</a> () const</td></tr>
<tr class="memdesc:a5408505810c3b56f8b6486a48de3cf28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of rows in this matrix.  <a href="#a5408505810c3b56f8b6486a48de3cf28">More...</a><br /></td></tr>
<tr class="separator:a5408505810c3b56f8b6486a48de3cf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbf3d77d75e97cb34804d6de3997542"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542">columns</a> () const</td></tr>
<tr class="memdesc:a4cbf3d77d75e97cb34804d6de3997542"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix.  <a href="#a4cbf3d77d75e97cb34804d6de3997542">More...</a><br /></td></tr>
<tr class="separator:a4cbf3d77d75e97cb34804d6de3997542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869787e273044c1051a22afdab8263bd"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a869787e273044c1051a22afdab8263bd">entry</a> (unsigned long row, unsigned long column)</td></tr>
<tr class="memdesc:a869787e273044c1051a22afdab8263bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the entry at the given row and column.  <a href="#a869787e273044c1051a22afdab8263bd">More...</a><br /></td></tr>
<tr class="separator:a869787e273044c1051a22afdab8263bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f1fb88101da5b067c307421b1260fa"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a69f1fb88101da5b067c307421b1260fa">entry</a> (unsigned long row, unsigned long column) const</td></tr>
<tr class="memdesc:a69f1fb88101da5b067c307421b1260fa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the entry at the given row and column.  <a href="#a69f1fb88101da5b067c307421b1260fa">More...</a><br /></td></tr>
<tr class="separator:a69f1fb88101da5b067c307421b1260fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91205870817a52b6729fac999907422e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a91205870817a52b6729fac999907422e">operator==</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a91205870817a52b6729fac999907422e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given matrix are identical.  <a href="#a91205870817a52b6729fac999907422e">More...</a><br /></td></tr>
<tr class="separator:a91205870817a52b6729fac999907422e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1282dcd6aa4a20fe41b83865ec80472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ae1282dcd6aa4a20fe41b83865ec80472">operator !=</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;other) const</td></tr>
<tr class="memdesc:ae1282dcd6aa4a20fe41b83865ec80472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given matrix are different.  <a href="#ae1282dcd6aa4a20fe41b83865ec80472">More...</a><br /></td></tr>
<tr class="separator:ae1282dcd6aa4a20fe41b83865ec80472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46c6ce3529a8519bc8b22a331be3b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ad46c6ce3529a8519bc8b22a331be3b93">writeMatrix</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ad46c6ce3529a8519bc8b22a331be3b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a complete representation of the matrix to the given output stream.  <a href="#ad46c6ce3529a8519bc8b22a331be3b93">More...</a><br /></td></tr>
<tr class="separator:ad46c6ce3529a8519bc8b22a331be3b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc42753dfc2e4fa0a1a2fd2700ffddd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#acc42753dfc2e4fa0a1a2fd2700ffddd8">swapRows</a> (unsigned long first, unsigned long second)</td></tr>
<tr class="memdesc:acc42753dfc2e4fa0a1a2fd2700ffddd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the elements of the two given rows in the matrix.  <a href="#acc42753dfc2e4fa0a1a2fd2700ffddd8">More...</a><br /></td></tr>
<tr class="separator:acc42753dfc2e4fa0a1a2fd2700ffddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2ddcf54ab2d3bd32e4fa5abb9e5352"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a3e2ddcf54ab2d3bd32e4fa5abb9e5352">swapColumns</a> (unsigned long first, unsigned long second)</td></tr>
<tr class="memdesc:a3e2ddcf54ab2d3bd32e4fa5abb9e5352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the elements of the two given columns in the matrix.  <a href="#a3e2ddcf54ab2d3bd32e4fa5abb9e5352">More...</a><br /></td></tr>
<tr class="separator:a3e2ddcf54ab2d3bd32e4fa5abb9e5352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fd05050d69382c1f07de6b3a8a7d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a51fd05050d69382c1f07de6b3a8a7d91">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a51fd05050d69382c1f07de6b3a8a7d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a51fd05050d69382c1f07de6b3a8a7d91">More...</a><br /></td></tr>
<tr class="separator:a51fd05050d69382c1f07de6b3a8a7d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48476f1ac9ac9d9731f0074277ed59c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a48476f1ac9ac9d9731f0074277ed59c0">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a48476f1ac9ac9d9731f0074277ed59c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a48476f1ac9ac9d9731f0074277ed59c0">More...</a><br /></td></tr>
<tr class="separator:a48476f1ac9ac9d9731f0074277ed59c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f6a9a4b5966864ce3028f02ba8852d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ab4f6a9a4b5966864ce3028f02ba8852d">makeIdentity</a> ()</td></tr>
<tr class="memdesc:ab4f6a9a4b5966864ce3028f02ba8852d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns this matrix into an identity matrix.  <a href="#ab4f6a9a4b5966864ce3028f02ba8852d">More...</a><br /></td></tr>
<tr class="separator:ab4f6a9a4b5966864ce3028f02ba8852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae416e03031ead4e9047fb02476ab3c1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#ae416e03031ead4e9047fb02476ab3c1f">isIdentity</a> () const</td></tr>
<tr class="memdesc:ae416e03031ead4e9047fb02476ab3c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this matrix is a square identity matrix.  <a href="#ae416e03031ead4e9047fb02476ab3c1f">More...</a><br /></td></tr>
<tr class="separator:ae416e03031ead4e9047fb02476ab3c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e3e87586de21b6ad443eb156fc026b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a57e3e87586de21b6ad443eb156fc026b">isZero</a> () const</td></tr>
<tr class="memdesc:a57e3e87586de21b6ad443eb156fc026b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the zero matrix.  <a href="#a57e3e87586de21b6ad443eb156fc026b">More...</a><br /></td></tr>
<tr class="separator:a57e3e87586de21b6ad443eb156fc026b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169b85fd910802f7e035b713deb0e7dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a169b85fd910802f7e035b713deb0e7dd">addRow</a> (unsigned long <a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, unsigned long dest)</td></tr>
<tr class="memdesc:a169b85fd910802f7e035b713deb0e7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given source row to the given destination row.  <a href="#a169b85fd910802f7e035b713deb0e7dd">More...</a><br /></td></tr>
<tr class="separator:a169b85fd910802f7e035b713deb0e7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248e96a1bc5e7d09a8c527cd0b674fa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a248e96a1bc5e7d09a8c527cd0b674fa0">addRow</a> (unsigned long <a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, unsigned long dest, T copies)</td></tr>
<tr class="memdesc:a248e96a1bc5e7d09a8c527cd0b674fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given number of copies of the given source row to the given destination row.  <a href="#a248e96a1bc5e7d09a8c527cd0b674fa0">More...</a><br /></td></tr>
<tr class="separator:a248e96a1bc5e7d09a8c527cd0b674fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0f9447f6e71b26e6ea345c27c702ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aaf0f9447f6e71b26e6ea345c27c702ea">addCol</a> (unsigned long <a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, unsigned long dest)</td></tr>
<tr class="memdesc:aaf0f9447f6e71b26e6ea345c27c702ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given source column to the given destination column.  <a href="#aaf0f9447f6e71b26e6ea345c27c702ea">More...</a><br /></td></tr>
<tr class="separator:aaf0f9447f6e71b26e6ea345c27c702ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb680e99ad5e9f0f17a247979b82995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#adcb680e99ad5e9f0f17a247979b82995">addCol</a> (unsigned long <a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, unsigned long dest, T copies)</td></tr>
<tr class="memdesc:adcb680e99ad5e9f0f17a247979b82995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given number of copies of the given source column to the given destination column.  <a href="#adcb680e99ad5e9f0f17a247979b82995">More...</a><br /></td></tr>
<tr class="separator:adcb680e99ad5e9f0f17a247979b82995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8093daac19c10d0487cae42f83f3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a2b8093daac19c10d0487cae42f83f3ee">multRow</a> (unsigned long row, T factor)</td></tr>
<tr class="memdesc:a2b8093daac19c10d0487cae42f83f3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given row by the given factor.  <a href="#a2b8093daac19c10d0487cae42f83f3ee">More...</a><br /></td></tr>
<tr class="separator:a2b8093daac19c10d0487cae42f83f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9187a1aa5e3e317565a99ac6889a0035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a9187a1aa5e3e317565a99ac6889a0035">multCol</a> (unsigned long column, T factor)</td></tr>
<tr class="memdesc:a9187a1aa5e3e317565a99ac6889a0035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the given column by the given factor.  <a href="#a9187a1aa5e3e317565a99ac6889a0035">More...</a><br /></td></tr>
<tr class="separator:a9187a1aa5e3e317565a99ac6889a0035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dfc95f3ba8eedf8ac5cdcfb3bddf85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aa6dfc95f3ba8eedf8ac5cdcfb3bddf85">operator *</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;other) const</td></tr>
<tr class="memdesc:aa6dfc95f3ba8eedf8ac5cdcfb3bddf85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this by the given matrix, and returns the result.  <a href="#aa6dfc95f3ba8eedf8ac5cdcfb3bddf85">More...</a><br /></td></tr>
<tr class="separator:aa6dfc95f3ba8eedf8ac5cdcfb3bddf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c41a03476d8d2e077feebbdad9116b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a35c41a03476d8d2e077feebbdad9116b">multiplyAs</a> (const <a class="el" href="classregina_1_1Matrix.html">Matrix</a> &amp;other) const</td></tr>
<tr class="memdesc:a35c41a03476d8d2e077feebbdad9116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for the multiplication operator.  <a href="#a35c41a03476d8d2e077feebbdad9116b">More...</a><br /></td></tr>
<tr class="separator:a35c41a03476d8d2e077feebbdad9116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa3eb129b7d41b09cf883490e548a0d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a1fa3eb129b7d41b09cf883490e548a0d">det</a> () const</td></tr>
<tr class="memdesc:a1fa3eb129b7d41b09cf883490e548a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the determinant of the matrix.  <a href="#a1fa3eb129b7d41b09cf883490e548a0d">More...</a><br /></td></tr>
<tr class="separator:a1fa3eb129b7d41b09cf883490e548a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628f5fdfca27a68caa0e8057c7a81f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a628f5fdfca27a68caa0e8057c7a81f9d">divRowExact</a> (unsigned long row, const T &amp;divBy)</td></tr>
<tr class="memdesc:a628f5fdfca27a68caa0e8057c7a81f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all elements of the given row by the given integer.  <a href="#a628f5fdfca27a68caa0e8057c7a81f9d">More...</a><br /></td></tr>
<tr class="separator:a628f5fdfca27a68caa0e8057c7a81f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c2d9d79a7af72a9ea1c67b2bd4f993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a10c2d9d79a7af72a9ea1c67b2bd4f993">divColExact</a> (unsigned long col, const T &amp;divBy)</td></tr>
<tr class="memdesc:a10c2d9d79a7af72a9ea1c67b2bd4f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides all elements of the given column by the given integer.  <a href="#a10c2d9d79a7af72a9ea1c67b2bd4f993">More...</a><br /></td></tr>
<tr class="separator:a10c2d9d79a7af72a9ea1c67b2bd4f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4995ce5f11ceb73814b0b56f91e186"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a6d4995ce5f11ceb73814b0b56f91e186">gcdRow</a> (unsigned long row)</td></tr>
<tr class="memdesc:a6d4995ce5f11ceb73814b0b56f91e186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of all elements of the given row.  <a href="#a6d4995ce5f11ceb73814b0b56f91e186">More...</a><br /></td></tr>
<tr class="separator:a6d4995ce5f11ceb73814b0b56f91e186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15612dc9809ed9bf0c4aab091533af13"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a15612dc9809ed9bf0c4aab091533af13">gcdCol</a> (unsigned long col)</td></tr>
<tr class="memdesc:a15612dc9809ed9bf0c4aab091533af13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of all elements of the given column.  <a href="#a15612dc9809ed9bf0c4aab091533af13">More...</a><br /></td></tr>
<tr class="separator:a15612dc9809ed9bf0c4aab091533af13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef63ca25c47028f71a1ba5838239bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a7ef63ca25c47028f71a1ba5838239bd1">reduceRow</a> (unsigned long row)</td></tr>
<tr class="memdesc:a7ef63ca25c47028f71a1ba5838239bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the given row by dividing all its elements by their greatest common divisor.  <a href="#a7ef63ca25c47028f71a1ba5838239bd1">More...</a><br /></td></tr>
<tr class="separator:a7ef63ca25c47028f71a1ba5838239bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfc11a0a5a4b3d03e5c6b38efc7ba71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#aedfc11a0a5a4b3d03e5c6b38efc7ba71">reduceCol</a> (unsigned long col)</td></tr>
<tr class="memdesc:aedfc11a0a5a4b3d03e5c6b38efc7ba71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the given column by dividing all its elements by their greatest common divisor.  <a href="#aedfc11a0a5a4b3d03e5c6b38efc7ba71">More...</a><br /></td></tr>
<tr class="separator:aedfc11a0a5a4b3d03e5c6b38efc7ba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a088293e44b015b3d9944371c7f09e943"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html#a088293e44b015b3d9944371c7f09e943">identity</a> (unsigned long size)</td></tr>
<tr class="memdesc:a088293e44b015b3d9944371c7f09e943"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an identity matrix of the given size.  <a href="#a088293e44b015b3d9944371c7f09e943">More...</a><br /></td></tr>
<tr class="separator:a088293e44b015b3d9944371c7f09e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3235b392fac45ac263bab3e67e8f85c7"><td class="memItemLeft" align="right" valign="top">static const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1MatrixRingIdentities.html#a3235b392fac45ac263bab3e67e8f85c7">zero</a></td></tr>
<tr class="memdesc:a3235b392fac45ac263bab3e67e8f85c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The additive identity in the underlying ring.  <a href="#a3235b392fac45ac263bab3e67e8f85c7">More...</a><br /></td></tr>
<tr class="separator:a3235b392fac45ac263bab3e67e8f85c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa913da679f2a48a6e8c60b5aeb29b9f"><td class="memItemLeft" align="right" valign="top">static const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1MatrixRingIdentities.html#aaa913da679f2a48a6e8c60b5aeb29b9f">one</a></td></tr>
<tr class="memdesc:aaa913da679f2a48a6e8c60b5aeb29b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multiplicative identity in the underlying ring.  <a href="#aaa913da679f2a48a6e8c60b5aeb29b9f">More...</a><br /></td></tr>
<tr class="separator:aaa913da679f2a48a6e8c60b5aeb29b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt;<br />
class regina::Matrix&lt; T, ring &gt;</h3>

<p>Represents a matrix of elements of the given type <em>T</em>. </p>
<p>As of Regina 5.3, the old subclasses of <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> have now been merged into a single <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> class. The additional member functions that the old subclasses MatrixRing and MatrixIntDomain used to provide are now part of <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a>, and are enabled or disabled according to the <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> template parameters.</p>
<p>It is generally safe to just use the type Matrix&lt;T&gt;, since the <code>ring</code> argument has a sensible default. At present, <code>ring</code> defaults to <code>true</code> (thereby enabling member functions designed for matrices over rings) when <em>T</em> is one of the following types:</p>
<ul>
<li>native C++ integer types (i.e., where std::is_integral&lt;T&gt;::value is <code>true</code> and <em>T</em> is not bool); or</li>
<li>Regina's own types Integer, LargeInteger, NativeInteger&lt;...&gt;, and <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a>.</li>
</ul>
<p>Other types may be added to this list in future versions of Regina.</p>
<p>There are several requirements for the underlying type <em>T</em>. For all matrix types:</p>
<ul>
<li><em>T</em> must have a default constructor and an assignment operator.</li>
<li>An element <em>t</em> of type <em>T</em> must be writable to an output stream using the standard stream operator <code>&lt;&lt;</code>.</li>
</ul>
<p>If <em>ring</em> is <code>true</code>, then in addition to this:</p>
<ul>
<li><em>T</em> must support binary operators <code>+</code>, <code>-</code> and <code>*</code>, and unary operators <code>+=</code>, <code>-=</code> and <code>*=</code>.</li>
<li><em>T</em> must be able to be constructed or assigned to from the integers 0 and 1 (representing the additive and multiplicative identities in the ring respectively). Likewise, <em>T</em> must be able to be tested for equality or inequality against 0 or 1 also.</li>
</ul>
<p>In particular, all of Regina's integer and rational types (Integer, LargeInteger, NativeInteger&lt;...&gt; and <a class="el" href="classregina_1_1Rational.html" title="Represents an arbitrary precision rational number.">Rational</a>) satisfy all of these requirements, and will set <em>ring</em> to <code>true</code> by default.</p>
<p>The header <a class="el" href="matrixops_8h.html" title="Provides various complex matrix calculations.">maths/matrixops.h</a> contains several other algorithms that work with the specific class Matrix&lt;Integer&gt;.</p>
<p>This class is designed to avoid deep copies wherever possible. In particular, it supports C++11 move constructors and move assignment. Functions that take or return objects by value are designed to be just as efficient as working with references or pointers, and long chains of operators such as <code>a = b * c * d</code> do not make unwanted deep copies.</p>
<dl class="section user"><dt>Python</dt><dd>Not present in general, although the specific type Matrix&lt;Integer&gt; is available under the name MatrixInt.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of each individual matrix element. </td></tr>
    <tr><td class="paramname">ring</td><td><code>true</code> if we should enable member functions that only work when T represents an element of a ring. This has a sensible default; see above in the class documentation for details. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8b4cd2d23d741532903f931c237af050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4cd2d23d741532903f931c237af050">&#9670;&nbsp;</a></span>Coefficient</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::<a class="el" href="classregina_1_1Matrix.html#a8b4cd2d23d741532903f931c237af050">Coefficient</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of each entry in the matrix. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc99891c1b2d33bbb99c8b9d3f4d14bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc99891c1b2d33bbb99c8b9d3f4d14bd">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::<a class="el" href="classregina_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new matrix of the given size. </p>
<p>All entries will be initialised using their default constructors.</p>
<p>In particular, this means that for Regina's own integer classes (Integer, LargeInteger and <a class="el" href="classregina_1_1NativeInteger.html" title="A wrapper class for a native, fixed-precision integer type of the given size.">NativeInteger</a>), all entries will be initialised to zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>T</em> is a native C++ integer type (such as <code>int</code> or <code>long</code>), then the matrix elements will not be initialised to any particular value.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of rows and columns are both strictly positive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>the number of rows in the new matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>the number of columns in the new matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78dfe46d992a2cdec7ac48032ec0de3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78dfe46d992a2cdec7ac48032ec0de3f">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::<a class="el" href="classregina_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new matrix that is a clone of the given matrix. </p>
<p>This constructor induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a402006c9b71e99ffe86ee809af492383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402006c9b71e99ffe86ee809af492383">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::<a class="el" href="classregina_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given matrix into this new matrix. </p>
<p>This is a fast (constant time) operation.</p>
<p>The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0626c71c7a3d36bbd6223b4b8ddff81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0626c71c7a3d36bbd6223b4b8ddff81">&#9670;&nbsp;</a></span>~Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::~<a class="el" href="classregina_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf0f9447f6e71b26e6ea345c27c702ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0f9447f6e71b26e6ea345c27c702ea">&#9670;&nbsp;</a></span>addCol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addCol </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given source column to the given destination column. </p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the columns to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the column that will be added to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcb680e99ad5e9f0f17a247979b82995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb680e99ad5e9f0f17a247979b82995">&#9670;&nbsp;</a></span>addCol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addCol </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>copies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given number of copies of the given source column to the given destination column. </p>
<p>Note that <em>copies</em> is passed by value in case it is an element of the row to be changed.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the columns to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the column that will be added to. </td></tr>
    <tr><td class="paramname">copies</td><td>the number of copies of <em>source</em> to add to <em>dest</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169b85fd910802f7e035b713deb0e7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169b85fd910802f7e035b713deb0e7dd">&#9670;&nbsp;</a></span>addRow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addRow </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given source row to the given destination row. </p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the row to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the row that will be added to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a248e96a1bc5e7d09a8c527cd0b674fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248e96a1bc5e7d09a8c527cd0b674fa0">&#9670;&nbsp;</a></span>addRow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::addRow </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>copies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given number of copies of the given source row to the given destination row. </p>
<p>Note that <em>copies</em> is passed by value in case it is an element of the row to be changed.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are distinct and between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the row to add. </td></tr>
    <tr><td class="paramname">dest</td><td>the row that will be added to. </td></tr>
    <tr><td class="paramname">copies</td><td>the number of copies of <em>source</em> to add to <em>dest</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cbf3d77d75e97cb34804d6de3997542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbf3d77d75e97cb34804d6de3997542">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="a1fa3eb129b7d41b09cf883490e548a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa3eb129b7d41b09cf883490e548a0d">&#9670;&nbsp;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::det </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the determinant of the matrix. </p>
<p>This algorithm has quartic complexity, and uses the dynamic programming approach of Mahajan and Vinay. For further details, see Meena Mahajan and V. Vinay, "Determinant:
Combinatorics, algorithms, and complexity", Chicago J. Theor. Comput. Sci., Vol. 1997, Article 5.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is a square matrix.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the determinant of this matrix. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a10c2d9d79a7af72a9ea1c67b2bd4f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c2d9d79a7af72a9ea1c67b2bd4f993">&#9670;&nbsp;</a></span>divColExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::divColExact </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>divBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides all elements of the given column by the given integer. </p>
<p>This can only be used when the given integer divides into all column elements exactly (with no remainder). For the Integer class, this may be much faster than ordinary division.</p>
<p>This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>divBy</em> is neither zero nor infinity, and none of the elements of the given column are infinity. </dd>
<dd>
The argument <em>divBy</em> divides exactly into every element of the given column (i.e., it leaves no remainder). </dd>
<dd>
The given column number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the index of the column whose elements should be divided by <em>divBy</em>. </td></tr>
    <tr><td class="paramname">divBy</td><td>the integer to divide each column element by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a628f5fdfca27a68caa0e8057c7a81f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628f5fdfca27a68caa0e8057c7a81f9d">&#9670;&nbsp;</a></span>divRowExact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::divRowExact </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>divBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides all elements of the given row by the given integer. </p>
<p>This can only be used when the given integer divides into all row elements exactly (with no remainder). For the Integer class, this may be much faster than ordinary division.</p>
<p>This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>divBy</em> is neither zero nor infinity, and none of the elements of the given row are infinity. </dd>
<dd>
The argument <em>divBy</em> divides exactly into every element of the given row (i.e., it leaves no remainder). </dd>
<dd>
The given row number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the index of the row whose elements should be divided by <em>divBy</em>. </td></tr>
    <tr><td class="paramname">divBy</td><td>the integer to divide each row element by. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a869787e273044c1051a22afdab8263bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869787e273044c1051a22afdab8263bd">&#9670;&nbsp;</a></span>entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the entry at the given row and column. </p>
<p>Rows and columns are numbered beginning at zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>row</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
<em>column</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Although the <a class="el" href="classregina_1_1Matrix.html#a869787e273044c1051a22afdab8263bd" title="Returns the entry at the given row and column.">entry()</a> routine gives direct read-write access to matrix elements, the syntax <code>matrix.entry(row, column) = value</code> still cannot be used in python to set a matrix element directly. For this, you can use the syntax <code>matrix.set(row, column, value)</code>. This set() routine returns nothing, and is provided for python only (i.e., it is not part of the C++ calculation engine).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the desired entry. </td></tr>
    <tr><td class="paramname">column</td><td>the column of the desired entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the entry in the given row and column. </dd></dl>

</div>
</div>
<a id="a69f1fb88101da5b067c307421b1260fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f1fb88101da5b067c307421b1260fa">&#9670;&nbsp;</a></span>entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::entry </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the entry at the given row and column. </p>
<p>Rows and columns are numbered beginning at zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>row</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive. </dd>
<dd>
<em>column</em> is between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, although the non-const form of this routine is.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row of the desired entry. </td></tr>
    <tr><td class="paramname">column</td><td>the column of the desired entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the entry in the given row and column. </dd></dl>

</div>
</div>
<a id="a15612dc9809ed9bf0c4aab091533af13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15612dc9809ed9bf0c4aab091533af13">&#9670;&nbsp;</a></span>gcdCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::gcdCol </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of all elements of the given column. </p>
<p>The value returned is guaranteed to be non-negative.</p>
<p>This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given column number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the index of the column whose gcd should be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor of all elements of this column. </dd></dl>

</div>
</div>
<a id="a6d4995ce5f11ceb73814b0b56f91e186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4995ce5f11ceb73814b0b56f91e186">&#9670;&nbsp;</a></span>gcdRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::gcdRow </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of all elements of the given row. </p>
<p>The value returned is guaranteed to be non-negative.</p>
<p>This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given row number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the index of the row whose gcd should be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the greatest common divisor of all elements of this row. </dd></dl>

</div>
</div>
<a id="a088293e44b015b3d9944371c7f09e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088293e44b015b3d9944371c7f09e943">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Matrix.html">Matrix</a> <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::identity </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an identity matrix of the given size. </p>
<p>The matrix returned will have <em>size</em> rows and <em>size</em> columns.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of rows and columns of the matrix to build. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an identity matrix of the given size. </dd></dl>

</div>
</div>
<a id="a11f3cbb6b3a5eece191d00ec6966ac6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f3cbb6b3a5eece191d00ec6966ac6a">&#9670;&nbsp;</a></span>initialise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::initialise </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets every entry in the matrix to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to assign to each entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac00ec376dd6be8e84e3bbe2c76f7ad96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac00ec376dd6be8e84e3bbe2c76f7ad96">&#9670;&nbsp;</a></span>initialise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::initialise </td>
          <td>(</td>
          <td class="paramtype">List&#160;</td>
          <td class="paramname"><em>allValues</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that fills the matrix with the given set of elements. </p>
<p>The argument <em>allValues</em> must be a Python list of length <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a> * <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>. Its values will be inserted into the matrix row by row (i.e., the first row will be filled, then the second row, and so on).</p>
<dl class="section user"><dt>C++</dt><dd>Not available; this routine is for Python only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allValues</td><td>the individual elements to place into the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae416e03031ead4e9047fb02476ab3c1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae416e03031ead4e9047fb02476ab3c1f">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this matrix is a square identity matrix. </p>
<p>If this matrix is square, <a class="el" href="classregina_1_1Matrix.html#ae416e03031ead4e9047fb02476ab3c1f" title="Determines whether this matrix is a square identity matrix.">isIdentity()</a> will return <code>true</code> if and only if the matrix has ones in the main diagonal and zeroes everywhere else.</p>
<p>If this matrix is not square, <a class="el" href="classregina_1_1Matrix.html#ae416e03031ead4e9047fb02476ab3c1f" title="Determines whether this matrix is a square identity matrix.">isIdentity()</a> will always return <code>false</code> (even if <a class="el" href="classregina_1_1Matrix.html#ab4f6a9a4b5966864ce3028f02ba8852d" title="Turns this matrix into an identity matrix.">makeIdentity()</a> was called earlier).</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a square identity matrix. </dd></dl>

</div>
</div>
<a id="a57e3e87586de21b6ad443eb156fc026b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e3e87586de21b6ad443eb156fc026b">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::isZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the zero matrix. </p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all entries in the matrix are zero. </dd></dl>

</div>
</div>
<a id="ab4f6a9a4b5966864ce3028f02ba8852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f6a9a4b5966864ce3028f02ba8852d">&#9670;&nbsp;</a></span>makeIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::makeIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns this matrix into an identity matrix. </p>
<p>This matrix need not be square; after this routine it will have <code>entry(r,c)</code> equal to 1 if <code>r == c</code> and 0 otherwise.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>. </p>

</div>
</div>
<a id="a9187a1aa5e3e317565a99ac6889a0035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9187a1aa5e3e317565a99ac6889a0035">&#9670;&nbsp;</a></span>multCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::multCol </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given column by the given factor. </p>
<p>Note that <em>factor</em> is passed by value in case it is an element of the row to be changed.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given column is between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>the column to work with. </td></tr>
    <tr><td class="paramname">factor</td><td>the factor by which to multiply the given column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35c41a03476d8d2e077feebbdad9116b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c41a03476d8d2e077feebbdad9116b">&#9670;&nbsp;</a></span>multiplyAs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::multiplyAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for the multiplication operator. </p>
<p>Multiplies this by the given matrix, and returns a new matrix (of this same class) as a result. This matrix is not changed.</p>
<p>As of Regina 5.3, the template parameter <em>MatrixClass</em> has been removed, since Regina's old matrix class hierarchy has been replaced with a single <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> class. It is harmless if you still pass a template parameter, but your parameter will be ignored.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The number of columns in this matrix equals the number of rows in the given matrix.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000075">Deprecated:</a></b></dt><dd>Simply use the multiplication operator (which is now identical to this routine). This routine <a class="el" href="classregina_1_1Matrix.html#a35c41a03476d8d2e077feebbdad9116b" title="Deprecated alias for the multiplication operator.">multiplyAs()</a> dated back to when <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> had a hierarchy of subclasses that offered different capabilities according to the underlying type <em>T</em>. Now that there is just a single class <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a>, this routine is no longer required.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other matrix to multiply this matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product matrix <code>this * other</code>. </dd></dl>

</div>
</div>
<a id="a2b8093daac19c10d0487cae42f83f3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8093daac19c10d0487cae42f83f3ee">&#9670;&nbsp;</a></span>multRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::multRow </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the given row by the given factor. </p>
<p>Note that <em>factor</em> is passed by value in case it is an element of the row to be changed.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given row is between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the row to work with. </td></tr>
    <tr><td class="paramname">factor</td><td>the factor by which to multiply the given row. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1282dcd6aa4a20fe41b83865ec80472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1282dcd6aa4a20fe41b83865ec80472">&#9670;&nbsp;</a></span>operator !=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given matrix are different. </p>
<p>Two matrices are different if either (i) their dimensions differ, or (ii) the corresponding elements of each matrix differ in at least one location.</p>
<p>Note that this routine can happily deal with two matrices of different dimensions (in which case it will always return <code>true</code>).</p>
<p>This routine returns <code>true</code> if and only if the equality operator (==) returns <code>false</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> provides an equality operator (==).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrices are different as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aa6dfc95f3ba8eedf8ac5cdcfb3bddf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dfc95f3ba8eedf8ac5cdcfb3bddf85">&#9670;&nbsp;</a></span>operator *()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a> <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator * </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this by the given matrix, and returns the result. </p>
<p>This matrix is not changed.</p>
<p>This routine is only available when the template argument <em>ring</em> is <code>true</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The number of columns in this matrix equals the number of rows in the given matrix.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other matrix to multiply this matrix by. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product matrix <code>this * other</code>. </dd></dl>

</div>
</div>
<a id="a9b1c88c6ec5aac7830d0e3c6b5e55867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1c88c6ec5aac7830d0e3c6b5e55867">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the given matrix into this matrix. </p>
<p>It does not matter if this and the given matrix have different sizes; if they do then this matrix will be resized as a result.</p>
<p>This operator induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this matrix. </dd></dl>

</div>
</div>
<a id="a8b0605f8e230984ee14c3ebf25af6f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0605f8e230984ee14c3ebf25af6f03">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&amp; <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given matrix into this matrix. </p>
<p>This is a fast (constant time) operation.</p>
<p>It does not matter if this and the given matrix have different sizes; if they do then this matrix will be resized as a result.</p>
<p>The matrix that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the matrix to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this matrix. </dd></dl>

</div>
</div>
<a id="a91205870817a52b6729fac999907422e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91205870817a52b6729fac999907422e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T, ring &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given matrix are identical. </p>
<p>Two matrices are identical if and only if (i) their dimensions are the same, and (ii) the corresponding elements of each matrix are equal.</p>
<p>Note that this routine can happily deal with two matrices of different dimensions (in which case it will always return <code>false</code>).</p>
<p>This routine returns <code>true</code> if and only if the inequality operator (!=) returns <code>false</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The type <em>T</em> provides an equality operator (==).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the matrix to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matrices are equal as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="aedfc11a0a5a4b3d03e5c6b38efc7ba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfc11a0a5a4b3d03e5c6b38efc7ba71">&#9670;&nbsp;</a></span>reduceCol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::reduceCol </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the given column by dividing all its elements by their greatest common divisor. </p>
<p>It is guaranteed that, if the column is changed at all, it will be divided by a <em>positive</em> integer.</p>
<p>This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given column number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>the index of the column to reduce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ef63ca25c47028f71a1ba5838239bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef63ca25c47028f71a1ba5838239bd1">&#9670;&nbsp;</a></span>reduceRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::reduceRow </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the given row by dividing all its elements by their greatest common divisor. </p>
<p>It is guaranteed that, if the row is changed at all, it will be divided by a <em>positive</em> integer.</p>
<p>This routine is only available when <em>T</em> is one of Regina's own integer classes (Integer, LargeInteger, or NativeIntgeger).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given row number is between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>the index of the row to reduce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5408505810c3b56f8b6486a48de3cf28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5408505810c3b56f8b6486a48de3cf28">&#9670;&nbsp;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of rows in this matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of rows. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python</dt><dd>In addition to <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a3e2ddcf54ab2d3bd32e4fa5abb9e5352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2ddcf54ab2d3bd32e4fa5abb9e5352">&#9670;&nbsp;</a></span>swapColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::swapColumns </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the elements of the two given columns in the matrix. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given columns are between 0 and <a class="el" href="classregina_1_1Matrix.html#a4cbf3d77d75e97cb34804d6de3997542" title="Returns the number of columns in this matrix.">columns()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first column to swap. </td></tr>
    <tr><td class="paramname">second</td><td>the second column to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc42753dfc2e4fa0a1a2fd2700ffddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc42753dfc2e4fa0a1a2fd2700ffddd8">&#9670;&nbsp;</a></span>swapRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::swapRows </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the elements of the two given rows in the matrix. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The two given rows are between 0 and <a class="el" href="classregina_1_1Matrix.html#a5408505810c3b56f8b6486a48de3cf28" title="Returns the number of rows in this matrix.">rows()</a>-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first row to swap. </td></tr>
    <tr><td class="paramname">second</td><td>the second row to swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Matrix.html">Matrix</a>&lt; T &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="ad46c6ce3529a8519bc8b22a331be3b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46c6ce3529a8519bc8b22a331be3b93">&#9670;&nbsp;</a></span>writeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::writeMatrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a complete representation of the matrix to the given output stream. </p>
<p>Each row will be written on a separate line with elements in each row separated by single spaces.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, even if a subclass of <a class="el" href="classregina_1_1Matrix.html" title="Represents a matrix of elements of the given type T.">Matrix</a> is mirrored and its inherited routines are mirrored also.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48476f1ac9ac9d9731f0074277ed59c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48476f1ac9ac9d9731f0074277ed59c0">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51fd05050d69382c1f07de6b3a8a7d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fd05050d69382c1f07de6b3a8a7d91">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, bool ring = ((std::is_integral&lt;T&gt;::value &amp;&amp; ! std::is_same&lt;T, bool&gt;::value) ||        IsReginaInteger&lt;T&gt;::value || std::is_same&lt;T, Rational&gt;::value)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Matrix.html">regina::Matrix</a>&lt; T, ring &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaa913da679f2a48a6e8c60b5aeb29b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa913da679f2a48a6e8c60b5aeb29b9f">&#9670;&nbsp;</a></span>one</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool ring&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="structregina_1_1MatrixRingIdentities.html">regina::MatrixRingIdentities</a>&lt; T, ring &gt;::one</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The multiplicative identity in the underlying ring. </p>

</div>
</div>
<a id="a3235b392fac45ac263bab3e67e8f85c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3235b392fac45ac263bab3e67e8f85c7">&#9670;&nbsp;</a></span>zero</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , bool ring&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="structregina_1_1MatrixRingIdentities.html">regina::MatrixRingIdentities</a>&lt; T, ring &gt;::zero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The additive identity in the underlying ring. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>algebra/<a class="el" href="abeliangroup_8h.html">abeliangroup.h</a></li>
<li>maths/<a class="el" href="matrix_8h.html">matrix.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
