<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::NormalSurfaceVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NormalSurfaceVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NormalSurfaceVector Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores the vector of a single normal surface in a 3-manifold.  
 <a href="classregina_1_1NormalSurfaceVector.html#details">More...</a></p>

<p><code>#include &lt;surfaces/normalsurface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalSurfaceVector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalSurfaceVector.png" usemap="#regina::NormalSurfaceVector_map" alt=""/>
  <map id="regina::NormalSurfaceVector_map" name="regina::NormalSurfaceVector_map">
<area href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates." alt="regina::NSVectorANStandard" shape="rect" coords="0,56,199,80"/>
<area href="classregina_1_1NSVectorMirrored.html" title="A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calcu..." alt="regina::NSVectorMirrored" shape="rect" coords="209,56,408,80"/>
<area href="classregina_1_1NSVectorOriented.html" title="A normal surface vector using transversely oriented standard (triangle-quad) coordinates." alt="regina::NSVectorOriented" shape="rect" coords="418,56,617,80"/>
<area href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates." alt="regina::NSVectorStandard" shape="rect" coords="627,56,826,80"/>
<area href="classregina_1_1NSVectorOrientedQuad.html" title="A normal surface vector using transversely oriented quadrilateral coordinates." alt="regina::NSVectorOrientedQuad" shape="rect" coords="0,112,199,136"/>
<area href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates." alt="regina::NSVectorQuad" shape="rect" coords="209,112,408,136"/>
<area href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates." alt="regina::NSVectorQuadOct" shape="rect" coords="418,112,617,136"/>
<area href="classregina_1_1NSVectorQuadClosed.html" title="The vector for a normal surface in an ideal triangulation, expressed using quad coordinates and enume..." alt="regina::NSVectorQuadClosed" shape="rect" coords="209,168,408,192"/>
<area href="classregina_1_1NSVectorQuadOctClosed.html" title="The vector for an almost normal surface in an ideal triangulation, expressed using quad-oct coordinat..." alt="regina::NSVectorQuadOctClosed" shape="rect" coords="418,168,617,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6da8adb1ae136adf220689fcf75886d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a6da8adb1ae136adf220689fcf75886d8">NormalSurfaceVector</a> (size_t length)</td></tr>
<tr class="memdesc:a6da8adb1ae136adf220689fcf75886d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="#a6da8adb1ae136adf220689fcf75886d8">More...</a><br /></td></tr>
<tr class="separator:a6da8adb1ae136adf220689fcf75886d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dffade0cc17f3caeebdc004ad7295b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aa1dffade0cc17f3caeebdc004ad7295b">NormalSurfaceVector</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:aa1dffade0cc17f3caeebdc004ad7295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="#aa1dffade0cc17f3caeebdc004ad7295b">More...</a><br /></td></tr>
<tr class="separator:aa1dffade0cc17f3caeebdc004ad7295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae178badf17e45e41a5da7eabf8005e22"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ae178badf17e45e41a5da7eabf8005e22">~NormalSurfaceVector</a> ()</td></tr>
<tr class="memdesc:ae178badf17e45e41a5da7eabf8005e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual destructor.  <a href="#ae178badf17e45e41a5da7eabf8005e22">More...</a><br /></td></tr>
<tr class="separator:ae178badf17e45e41a5da7eabf8005e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64145ed248bd3b24af3d65a7500aadb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#af64145ed248bd3b24af3d65a7500aadb">coords</a> () const</td></tr>
<tr class="memdesc:af64145ed248bd3b24af3d65a7500aadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the underlying vector of coordinates.  <a href="#af64145ed248bd3b24af3d65a7500aadb">More...</a><br /></td></tr>
<tr class="separator:af64145ed248bd3b24af3d65a7500aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a919f098d3c43f1e68a5dc3ba9c9da227">clone</a> () const =0</td></tr>
<tr class="memdesc:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="#a919f098d3c43f1e68a5dc3ba9c9da227">More...</a><br /></td></tr>
<tr class="separator:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85">size</a> () const</td></tr>
<tr class="memdesc:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector.  <a href="#a680b7b7ac5f45b6404644ee9fb1afb85">More...</a><br /></td></tr>
<tr class="separator:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238f18a8ba972f206f34a0302dc863cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a238f18a8ba972f206f34a0302dc863cf">operator []</a> (size_t index) const</td></tr>
<tr class="memdesc:a238f18a8ba972f206f34a0302dc863cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector.  <a href="#a238f18a8ba972f206f34a0302dc863cf">More...</a><br /></td></tr>
<tr class="separator:a238f18a8ba972f206f34a0302dc863cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c548a7bcd676dceef9b01ec96ab8da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a24c548a7bcd676dceef9b01ec96ab8da">setElement</a> (size_t index, const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;value)</td></tr>
<tr class="memdesc:a24c548a7bcd676dceef9b01ec96ab8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given normal coordinate to the given value.  <a href="#a24c548a7bcd676dceef9b01ec96ab8da">More...</a><br /></td></tr>
<tr class="separator:a24c548a7bcd676dceef9b01ec96ab8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bf86f895cf3f97281cf98c6e9ac8ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a87bf86f895cf3f97281cf98c6e9ac8ef">operator+=</a> (const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;other)</td></tr>
<tr class="memdesc:a87bf86f895cf3f97281cf98c6e9ac8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="#a87bf86f895cf3f97281cf98c6e9ac8ef">More...</a><br /></td></tr>
<tr class="separator:a87bf86f895cf3f97281cf98c6e9ac8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f95b5cc7d6e00e85cd78283227fb17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a19f95b5cc7d6e00e85cd78283227fb17">scaleDown</a> ()</td></tr>
<tr class="memdesc:a19f95b5cc7d6e00e85cd78283227fb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="#a19f95b5cc7d6e00e85cd78283227fb17">More...</a><br /></td></tr>
<tr class="separator:a19f95b5cc7d6e00e85cd78283227fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b5594a67c7a695ab21adaa862a8d38"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a44b5594a67c7a695ab21adaa862a8d38">allowsAlmostNormal</a> () const =0</td></tr>
<tr class="memdesc:a44b5594a67c7a695ab21adaa862a8d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="#a44b5594a67c7a695ab21adaa862a8d38">More...</a><br /></td></tr>
<tr class="separator:a44b5594a67c7a695ab21adaa862a8d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07d54c737adf4198657a237f31d8851"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ab07d54c737adf4198657a237f31d8851">allowsSpun</a> () const =0</td></tr>
<tr class="memdesc:ab07d54c737adf4198657a237f31d8851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles.  <a href="#ab07d54c737adf4198657a237f31d8851">More...</a><br /></td></tr>
<tr class="separator:ab07d54c737adf4198657a237f31d8851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a8c2541a7dcdecfafd908ad50d98cd9d1">allowsOriented</a> () const =0</td></tr>
<tr class="memdesc:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces.  <a href="#a8c2541a7dcdecfafd908ad50d98cd9d1">More...</a><br /></td></tr>
<tr class="separator:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a207ab6ce67f8c4f322f64fd0494e3a88">hasMultipleOctDiscs</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface has more than one octagonal disc.  <a href="#a207ab6ce67f8c4f322f64fd0494e3a88">More...</a><br /></td></tr>
<tr class="separator:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ace3f3ccef51ec75544ee6cc6875a6cda">isCompact</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is compact (has finitely many discs).  <a href="#ace3f3ccef51ec75544ee6cc6875a6cda">More...</a><br /></td></tr>
<tr class="separator:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf49b14b890535f0deee9d8db62dc4c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aecf49b14b890535f0deee9d8db62dc4c">isVertexLinking</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:aecf49b14b890535f0deee9d8db62dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is vertex linking.  <a href="#aecf49b14b890535f0deee9d8db62dc4c">More...</a><br /></td></tr>
<tr class="separator:aecf49b14b890535f0deee9d8db62dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f860e909873a8ab2449f36c7d3cfb3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a48f860e909873a8ab2449f36c7d3cfb3">isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a48f860e909873a8ab2449f36c7d3cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="#a48f860e909873a8ab2449f36c7d3cfb3">More...</a><br /></td></tr>
<tr class="separator:a48f860e909873a8ab2449f36c7d3cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07535a32a2da710490b864bb23f93ea1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a07535a32a2da710490b864bb23f93ea1">isThinEdgeLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a07535a32a2da710490b864bb23f93ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the thin link of a single edge.  <a href="#a07535a32a2da710490b864bb23f93ea1">More...</a><br /></td></tr>
<tr class="separator:a07535a32a2da710490b864bb23f93ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da454072e9b44e9ccbf23523006dae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ae4da454072e9b44e9ccbf23523006dae">isSplitting</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ae4da454072e9b44e9ccbf23523006dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a splitting surface in the given triangulation.  <a href="#ae4da454072e9b44e9ccbf23523006dae">More...</a><br /></td></tr>
<tr class="separator:ae4da454072e9b44e9ccbf23523006dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f211dde81cc1505e475d48da6f1aafa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a7f211dde81cc1505e475d48da6f1aafa">isCentral</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a7f211dde81cc1505e475d48da6f1aafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a central surface in the given triangulation.  <a href="#a7f211dde81cc1505e475d48da6f1aafa">More...</a><br /></td></tr>
<tr class="separator:a7f211dde81cc1505e475d48da6f1aafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea2312f446f4f7b1c3066925d7f1e2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a3ea2312f446f4f7b1c3066925d7f1e2c">triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:a3ea2312f446f4f7b1c3066925d7f1e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="#a3ea2312f446f4f7b1c3066925d7f1e2c">More...</a><br /></td></tr>
<tr class="separator:a3ea2312f446f4f7b1c3066925d7f1e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce2cc2fbd8b46b97d8ea787535282d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a2ce2cc2fbd8b46b97d8ea787535282d0">orientedTriangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const</td></tr>
<tr class="memdesc:a2ce2cc2fbd8b46b97d8ea787535282d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="#a2ce2cc2fbd8b46b97d8ea787535282d0">More...</a><br /></td></tr>
<tr class="separator:a2ce2cc2fbd8b46b97d8ea787535282d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570ee5188151835875872bb11c5849da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a570ee5188151835875872bb11c5849da">quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:a570ee5188151835875872bb11c5849da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="#a570ee5188151835875872bb11c5849da">More...</a><br /></td></tr>
<tr class="separator:a570ee5188151835875872bb11c5849da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d15dfef9d0dca32bc66c8ac506d196"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ad6d15dfef9d0dca32bc66c8ac506d196">orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const</td></tr>
<tr class="memdesc:ad6d15dfef9d0dca32bc66c8ac506d196"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="#ad6d15dfef9d0dca32bc66c8ac506d196">More...</a><br /></td></tr>
<tr class="separator:ad6d15dfef9d0dca32bc66c8ac506d196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab042b630da0605dfc10845cb4eab2955"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ab042b630da0605dfc10845cb4eab2955">octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:ab042b630da0605dfc10845cb4eab2955"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="#ab042b630da0605dfc10845cb4eab2955">More...</a><br /></td></tr>
<tr class="separator:ab042b630da0605dfc10845cb4eab2955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc14138b82130ad79e60d8585aea3c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a5bc14138b82130ad79e60d8585aea3c5">edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:a5bc14138b82130ad79e60d8585aea3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="#a5bc14138b82130ad79e60d8585aea3c5">More...</a><br /></td></tr>
<tr class="separator:a5bc14138b82130ad79e60d8585aea3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e760f7358e5ab934afca94fcd57138"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ad3e760f7358e5ab934afca94fcd57138">arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:ad3e760f7358e5ab934afca94fcd57138"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="#ad3e760f7358e5ab934afca94fcd57138">More...</a><br /></td></tr>
<tr class="separator:ad3e760f7358e5ab934afca94fcd57138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d91874b24ad5b85e3883a46b580f291"><td class="memItemLeft" align="right" valign="top"><a id="a3d91874b24ad5b85e3883a46b580f291"></a>
<a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;)=delete</td></tr>
<tr class="separator:a3d91874b24ad5b85e3883a46b580f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2208bc38293ec2a64359c2f582868a2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a2208bc38293ec2a64359c2f582868a2f">makeZeroVector</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:a2208bc38293ec2a64359c2f582868a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.  <a href="#a2208bc38293ec2a64359c2f582868a2f">More...</a><br /></td></tr>
<tr class="separator:a2208bc38293ec2a64359c2f582868a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda04c126a8ff0c247429cf4acabdc60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#afda04c126a8ff0c247429cf4acabdc60">makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:afda04c126a8ff0c247429cf4acabdc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal surface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.  <a href="#afda04c126a8ff0c247429cf4acabdc60">More...</a><br /></td></tr>
<tr class="separator:afda04c126a8ff0c247429cf4acabdc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0abea602d297abf6cc61d1281169a4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aa0abea602d297abf6cc61d1281169a4e">makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:aa0abea602d297abf6cc61d1281169a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal surfaces be embedded.  <a href="#aa0abea602d297abf6cc61d1281169a4e">More...</a><br /></td></tr>
<tr class="separator:aa0abea602d297abf6cc61d1281169a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aed283d890443594e39ba1ea13c81046d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Ray.html">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aed283d890443594e39ba1ea13c81046d">coords_</a></td></tr>
<tr class="memdesc:aed283d890443594e39ba1ea13c81046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw vector of normal coordinates.  <a href="#aed283d890443594e39ba1ea13c81046d">More...</a><br /></td></tr>
<tr class="separator:aed283d890443594e39ba1ea13c81046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores the vector of a single normal surface in a 3-manifold. </p>
<p>The different subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> use different underlying coordinate systems for the normal solution space. However, the various coordinate retrieval routines will return values that are independent of the underlying coordinate system. Thus the coordinates of the normal surface in any coordinate system can be determined without knowledge of the specific underlying coordinate system being used.</p>
<p>Note that non-compact surfaces (surfaces with infinitely many discs, such as spun-normal surfaces) are allowed; in these cases, the corresponding coordinate lookup routines should return <a class="el" href="classregina_1_1IntegerBase.html#ac071d748e8a784b5a425b01292aaa76a" title="Globally available infinity.">LargeInteger::infinity</a> where appropriate.</p>
<p>All subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> <b>must</b> have the following properties:</p>
<ul>
<li>Normal surfaces can be enumerated by intersecting the non-negative orthant of the underlying vector space with some linear subspace;</li>
<li>Adding two normal surfaces corresponds to adding the two underlying vectors.</li>
</ul>
<p><b>When deriving classes from <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>:</b> </p><ul>
<li>
A new value must must be added to the NormalCoords enum in <a class="el" href="normalcoords_8h.html" title="Defines constants for normal surface coordinate systems.">normalcoords.h</a> to represent the new coordinate system (do not forget to add this constant to the python bindings also). </li>
<li>
The file coordregistry-impl.h must be updated to reflect the new coordinate system (the file itself contains instructions on how to do this). </li>
<li>
A corresponding specialisation of NormalInfo&lt;&gt; must be defined, typically in the same header as the new vector subclass. </li>
<li>
The macro REGINA_NORMAL_SURFACE_FLAVOUR must be added to the beginning of the new vector subclass. This will declare and define various constants, typedefs and virtual functions (see the REGINA_NORMAL_SURFACE_FLAVOUR macro documentation for details). </li>
<li>
Constructors <code>class(size_t length)</code> and <code>class(const Vector&lt;LargeInteger&gt;&amp; cloneMe)</code> must be declared and implemented; these will usually just call the corresponding superclass constructors. </li>
<li>
All abstract functions must be implemented, except for those already provided by REGINA_NORMAL_SURFACE_FLAVOUR. Note that coordinate functions such as <a class="el" href="classregina_1_1NormalSurfaceVector.html#a3ea2312f446f4f7b1c3066925d7f1e2c" title="Returns the number of triangular discs of the given type in this normal surface.">triangles()</a> must return the <em>total</em> number of discs of the requested type; if your new coordinate system adorns discs with extra information (such as orientation) then your implementation must compute the appropriate sum. </li>
<li>
The orientation-specific coordinate functions <a class="el" href="classregina_1_1NormalSurfaceVector.html#a2ce2cc2fbd8b46b97d8ea787535282d0" title="Returns the number of oriented triangular discs of the given type in this normal surface.">orientedTriangles()</a> and <a class="el" href="classregina_1_1NormalSurfaceVector.html#ad6d15dfef9d0dca32bc66c8ac506d196" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">orientedQuads()</a> must be implemented if your coordinate system supports transverse orientation. Otherwise you can use the default implementations (which returns zero). </li>
<li>
Static public functions <code>void <a class="el" href="classregina_1_1NormalSurfaceVector.html#a2208bc38293ec2a64359c2f582868a2f" title="Returns a new normal surface vector of the appropriate length for the given triangulation and for the...">makeZeroVector(const Triangulation&lt;3&gt;*)</a></code>, <code>MatrixInt* <a class="el" href="classregina_1_1NormalSurfaceVector.html#afda04c126a8ff0c247429cf4acabdc60" title="Creates a new set of normal surface matching equations for the given triangulation using the coordina...">makeMatchingEquations(const Triangulation&lt;3&gt;*)</a></code> and <a class="el" href="classregina_1_1NormalSurfaceVector.html#aa0abea602d297abf6cc61d1281169a4e" title="Creates a new set of validity constraints representing the condition that normal surfaces be embedded...">makeEmbeddedConstraints(const Triangulation&lt;3&gt;*)</a> must be declared and implemented. </li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Investigate using sparse vectors for storage.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6da8adb1ae136adf220689fcf75886d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da8adb1ae136adf220689fcf75886d8">&#9670;&nbsp;</a></span>NormalSurfaceVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaceVector::NormalSurfaceVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1dffade0cc17f3caeebdc004ad7295b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dffade0cc17f3caeebdc004ad7295b">&#9670;&nbsp;</a></span>NormalSurfaceVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaceVector::NormalSurfaceVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae178badf17e45e41a5da7eabf8005e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae178badf17e45e41a5da7eabf8005e22">&#9670;&nbsp;</a></span>~NormalSurfaceVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaceVector::~NormalSurfaceVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A virtual destructor. </p>
<p>This is required because here we introduce virtual functions into the <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> hierarchy. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a44b5594a67c7a695ab21adaa862a8d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b5594a67c7a695ab21adaa862a8d38">&#9670;&nbsp;</a></span>allowsAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> octagonal discs.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="a8c2541a7dcdecfafd908ad50d98cd9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2541a7dcdecfafd908ad50d98cd9d1">&#9670;&nbsp;</a></span>allowsOriented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported. </dd></dl>

</div>
</div>
<a id="ab07d54c737adf4198657a237f31d8851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07d54c737adf4198657a237f31d8851">&#9670;&nbsp;</a></span>allowsSpun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> infinitely many triangles.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun-normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="ad3e760f7358e5ab934afca94fcd57138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e760f7358e5ab934afca94fcd57138">&#9670;&nbsp;</a></span>arcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#acef4cdd091a72db9f5a7bbd37c0c1735">regina::NSVectorMirrored</a>, <a class="el" href="classregina_1_1NSVectorOriented.html#ab5de36fdaeb65ecb4ce02fa95ec8fe30">regina::NSVectorOriented</a>, <a class="el" href="classregina_1_1NSVectorANStandard.html#a98998d0a6b84b8cfb2dfd70a9c0f4359">regina::NSVectorANStandard</a>, and <a class="el" href="classregina_1_1NSVectorStandard.html#a25b92f75058a45943a976e08c595fb02">regina::NSVectorStandard</a>.</p>

</div>
</div>
<a id="a919f098d3c43f1e68a5dc3ba9c9da227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919f098d3c43f1e68a5dc3ba9c9da227">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> as this vector. </p>

</div>
</div>
<a id="af64145ed248bd3b24af3d65a7500aadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64145ed248bd3b24af3d65a7500aadb">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalSurfaceVector::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the underlying vector of coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector of coordinates. </dd></dl>

</div>
</div>
<a id="a5bc14138b82130ad79e60d8585aea3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc14138b82130ad79e60d8585aea3c5">&#9670;&nbsp;</a></span>edgeWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#ab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#aef1074733d1aaa6de9ff8cd8b39ffaba">regina::NSVectorMirrored</a>, <a class="el" href="classregina_1_1NSVectorOriented.html#a4108ca7175f0e6bd106c19373f3fcbf2">regina::NSVectorOriented</a>, <a class="el" href="classregina_1_1NSVectorANStandard.html#aca1df7bce5940c31ba4888ca6b05f946">regina::NSVectorANStandard</a>, and <a class="el" href="classregina_1_1NSVectorStandard.html#a59cd5eadbba63de6b6d001886ab96cef">regina::NSVectorStandard</a>.</p>

</div>
</div>
<a id="a207ab6ce67f8c4f322f64fd0494e3a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207ab6ce67f8c4f322f64fd0494e3a88">&#9670;&nbsp;</a></span>hasMultipleOctDiscs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::hasMultipleOctDiscs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface has more than one octagonal disc. </p>
<p>It may be assumed that at most one octagonal disc <em>type</em> exists in this surface. This routine will return <code>true</code> if an octagonal type does exist and its coordinate is greater than one.</p>
<p>The default implementation for this routine simply calculates all the octagonal coordinates and returns as soon as a positive or negative result can be established. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<p>If a subclass does not allow for almost normal surfaces, this routine will never be called and thus does not need to be overwritten.</p>
<dl class="section pre"><dt>Precondition</dt><dd>At most one octagonal disc <em>type</em> exists in this surface. </dd>
<dd>
This normal surface vector is using a coordinate system that allows for almost normal surfaces.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is an octagonal disc type present and its coordinate is greater than one. </dd></dl>

</div>
</div>
<a id="a7f211dde81cc1505e475d48da6f1aafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f211dde81cc1505e475d48da6f1aafa">&#9670;&nbsp;</a></span>isCentral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::isCentral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a central surface in the given triangulation. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If the surface is central, the number of tetrahedra it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that the surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a id="ace3f3ccef51ec75544ee6cc6875a6cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3f3ccef51ec75544ee6cc6875a6cda">&#9670;&nbsp;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is compact (has finitely many discs). </p>
<p>The default implementation for this routine simply runs through every disc type until a disc type with infinite disc count is found or all disc types have been examined. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is compact. </dd></dl>

</div>
</div>
<a id="ae4da454072e9b44e9ccbf23523006dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da454072e9b44e9ccbf23523006dae">&#9670;&nbsp;</a></span>isSplitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isSplitting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a splitting surface in the given triangulation. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is a splitting surface. </dd></dl>

</div>
</div>
<a id="a07535a32a2da710490b864bb23f93ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07535a32a2da710490b864bb23f93ea1">&#9670;&nbsp;</a></span>isThinEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*&gt; regina::NormalSurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the thin link of a single edge. </p>
<p>If there are two different edges <em>e1</em> and <em>e2</em> for which the surface could be expressed as the thin link of either <em>e1</em> or <em>e2</em>, the pair (<em>e1</em>,<em>e2</em>) will be returned. If the surface is the thin link of only one edge <em>e</em>, the pair (<em>e</em>,0) will be returned. If the surface is not the thin link of any edges, the pair (0,0) will be returned.</p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by this surface, as described above. </dd></dl>

</div>
</div>
<a id="a48f860e909873a8ab2449f36c7d3cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f860e909873a8ab2449f36c7d3cfb3">&#9670;&nbsp;</a></span>isVertexLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt;3&gt;* regina::NormalSurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#a98d612c1b934bd3d64908cbc42e4e81e">regina::NSVectorOrientedQuad</a>, <a class="el" href="classregina_1_1NSVectorQuadOct.html#a34afa9a4f7444f2b985adb80aaf2054f">regina::NSVectorQuadOct</a>, and <a class="el" href="classregina_1_1NSVectorQuad.html#af5b5ea3db1bb195bb2ac85d61c478c6a">regina::NSVectorQuad</a>.</p>

</div>
</div>
<a id="aecf49b14b890535f0deee9d8db62dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf49b14b890535f0deee9d8db62dc4c">&#9670;&nbsp;</a></span>isVertexLinking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>The default implementation for this routine simply runs through every non-triangular disc type ensuring that each has no corresponding discs. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is vertex linking. </dd></dl>

</div>
</div>
<a id="aa0abea602d297abf6cc61d1281169a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0abea602d297abf6cc61d1281169a4e">&#9670;&nbsp;</a></span>makeEmbeddedConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>* regina::NormalSurfaceVector::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal surfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a id="afda04c126a8ff0c247429cf4acabdc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda04c126a8ff0c247429cf4acabdc60">&#9670;&nbsp;</a></span>makeMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalSurfaceVector::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of normal surface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </p>
<p>See <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">regina::makeMatchingEquations()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations. </dd></dl>

</div>
</div>
<a id="a2208bc38293ec2a64359c2f582868a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2208bc38293ec2a64359c2f582868a2f">&#9670;&nbsp;</a></span>makeZeroVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurfaceVector::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </p>
<p>All elements of the new vector will be initialised to zero.</p>
<p>See <a class="el" href="group__hypersurface.html#ga062b6a0fcecd8d05a2193bb98feb8b29" title="Returns a new normal hypersurface vector of the appropriate length for the given triangulation and th...">regina::makeZeroVector()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a id="ab042b630da0605dfc10845cb4eab2955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab042b630da0605dfc10845cb4eab2955">&#9670;&nbsp;</a></span>octs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#abae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a79f510cc1f1fd40f2152803491a3cbf7">regina::NSVectorMirrored</a>, <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#a3bd54cb95a976b0a3139f54b0296fa40">regina::NSVectorOrientedQuad</a>, <a class="el" href="classregina_1_1NSVectorOriented.html#acf522a2ab69035a41dfde5bcc70ab7ea">regina::NSVectorOriented</a>, <a class="el" href="classregina_1_1NSVectorANStandard.html#aced4bb03e87c9d58dd826c2ac32728e6">regina::NSVectorANStandard</a>, <a class="el" href="classregina_1_1NSVectorQuad.html#aa12eb25640ae314520cdb1499d23b9e2">regina::NSVectorQuad</a>, and <a class="el" href="classregina_1_1NSVectorStandard.html#aafa8de789bc534a5806e9b46f708c347">regina::NSVectorStandard</a>.</p>

</div>
</div>
<a id="a238f18a8ba972f206f34a0302dc863cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238f18a8ba972f206f34a0302dc863cf">&#9670;&nbsp;</a></span>operator []()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp; regina::NormalSurfaceVector::operator [] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to retrieve; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinate at the given index. </dd></dl>

</div>
</div>
<a id="a87bf86f895cf3f97281cf98c6e9ac8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bf86f895cf3f97281cf98c6e9ac8ef">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p>This behaves correctly in the case where <em>other</em> is <em>this</em>.</p>
<p>The default implementation simply adds the coordinates of the underlying vectors. Subclasses should reimplement this if they carry any additional information that also needs adjusting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector represent normal surfaces in the same triangulation, and use the same normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a654e738a0d9768a39697c79c8b2e74b7">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ad6d15dfef9d0dca32bc66c8ac506d196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d15dfef9d0dca32bc66c8ac506d196">&#9670;&nbsp;</a></span>orientedQuads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a1782b65da2df0fe8921002d28139938e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">NormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a5318a2c38f37d22b56a05a31bec63592">regina::NSVectorMirrored</a>, <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#aa1e3f2307548c014fb23b2a511632a1d">regina::NSVectorOrientedQuad</a>, and <a class="el" href="classregina_1_1NSVectorOriented.html#a6015659e0c8fee455cea5877c075c47a">regina::NSVectorOriented</a>.</p>

</div>
</div>
<a id="a2ce2cc2fbd8b46b97d8ea787535282d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce2cc2fbd8b46b97d8ea787535282d0">&#9670;&nbsp;</a></span>orientedTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a778a22958ed66c5118c06e8fc861b5b7" title="Returns the number of oriented triangular discs of the given type in this normal surface.">NormalSurface::orientedTriangles()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a2015a06ce4d730919cf5ac29a17936e2">regina::NSVectorMirrored</a>, and <a class="el" href="classregina_1_1NSVectorOriented.html#a3a4137d110e610a9ba8dfa5dbc1c4f1c">regina::NSVectorOriented</a>.</p>

</div>
</div>
<a id="a570ee5188151835875872bb11c5849da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570ee5188151835875872bb11c5849da">&#9670;&nbsp;</a></span>quads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a7212bf949dd892cacfaed8de64115b7a">regina::NSVectorMirrored</a>, <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#ab05acfe295661b31d74571b224b58712">regina::NSVectorOrientedQuad</a>, <a class="el" href="classregina_1_1NSVectorANStandard.html#a2062102f4e6bec5108ce42cbab04b692">regina::NSVectorANStandard</a>, <a class="el" href="classregina_1_1NSVectorOriented.html#a5185cb4b3afd73b98e9a8c8a5eebcb6f">regina::NSVectorOriented</a>, and <a class="el" href="classregina_1_1NSVectorStandard.html#a2dd79b66600f3a0802175e1593fe6c96">regina::NSVectorStandard</a>.</p>

</div>
</div>
<a id="a19f95b5cc7d6e00e85cd78283227fb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f95b5cc7d6e00e85cd78283227fb17">&#9670;&nbsp;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p>The default implementation simply scales down the underlying vector. Subclasses should reimplement this if they carry any additional information that also needs adjusting. </p>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a7607f80141d61419e9fc05bb2c266c97">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="a24c548a7bcd676dceef9b01ec96ab8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c548a7bcd676dceef9b01ec96ab8da">&#9670;&nbsp;</a></span>setElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given normal coordinate to the given value. </p>
<p>The default implementation simply sets the coordinate in the underlying vector. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to set; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the given coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a09f01421c3a687edc63fada1808c063f">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="a680b7b7ac5f45b6404644ee9fb1afb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680b7b7ac5f45b6404644ee9fb1afb85">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurfaceVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="a3ea2312f446f4f7b1c3066925d7f1e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea2312f446f4f7b1c3066925d7f1e2c">&#9670;&nbsp;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NSVectorMirrored.html#a4904b81d01adbe8050c30feb4d0dcee9">regina::NSVectorMirrored</a>, <a class="el" href="classregina_1_1NSVectorANStandard.html#aa883a0ec32b3a0d2440fbc4e3f41e167">regina::NSVectorANStandard</a>, <a class="el" href="classregina_1_1NSVectorOriented.html#ae58437850c881385ebd4c4f5cf4e2e6b">regina::NSVectorOriented</a>, and <a class="el" href="classregina_1_1NSVectorStandard.html#a60aac772b74582662acbf6da924e2769">regina::NSVectorStandard</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aed283d890443594e39ba1ea13c81046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed283d890443594e39ba1ea13c81046d">&#9670;&nbsp;</a></span>coords_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Ray.html">Ray</a> regina::NormalSurfaceVector::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw vector of normal coordinates. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surfaces/<a class="el" href="normalsurface_8h.html">normalsurface.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
