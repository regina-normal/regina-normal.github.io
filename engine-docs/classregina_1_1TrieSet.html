<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::TrieSet&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1TrieSet.html">TrieSet</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1TrieSet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::TrieSet&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__utilities.html">Miscellaneous Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A trie-like data structure for storing and retriving sets.  
 <a href="classregina_1_1TrieSet.html#details">More...</a></p>

<p><code>#include &lt;utilities/trieset.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a34961eca24ca18e8bc5ae976e58d6a79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a34961eca24ca18e8bc5ae976e58d6a79">TrieSet</a> ()</td></tr>
<tr class="memdesc:a34961eca24ca18e8bc5ae976e58d6a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty collection of sets.  <a href="#a34961eca24ca18e8bc5ae976e58d6a79">More...</a><br /></td></tr>
<tr class="separator:a34961eca24ca18e8bc5ae976e58d6a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabb80bec38d52734b0215c625aa3ac7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#afabb80bec38d52734b0215c625aa3ac7">~TrieSet</a> ()</td></tr>
<tr class="memdesc:afabb80bec38d52734b0215c625aa3ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this collection of sets.  <a href="#afabb80bec38d52734b0215c625aa3ac7">More...</a><br /></td></tr>
<tr class="separator:afabb80bec38d52734b0215c625aa3ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b27f0f00ef8f19560f14cd7faf6caea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a2b27f0f00ef8f19560f14cd7faf6caea">insert</a> (const T &amp;entry)</td></tr>
<tr class="memdesc:a2b27f0f00ef8f19560f14cd7faf6caea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the given set into this collection.  <a href="#a2b27f0f00ef8f19560f14cd7faf6caea">More...</a><br /></td></tr>
<tr class="separator:a2b27f0f00ef8f19560f14cd7faf6caea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58741f6c93aeede75d8bba526cff3ed1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#a58741f6c93aeede75d8bba526cff3ed1">hasSubset</a> (const T &amp;superset, unsigned long universeSize) const</td></tr>
<tr class="memdesc:a58741f6c93aeede75d8bba526cff3ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this collection of sets contains any subset of the argument <em>superset</em>.  <a href="#a58741f6c93aeede75d8bba526cff3ed1">More...</a><br /></td></tr>
<tr class="separator:a58741f6c93aeede75d8bba526cff3ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a63d4102262eda00159858a6839f96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TrieSet.html#ab1a63d4102262eda00159858a6839f96">hasExtraSuperset</a> (const T &amp;subset, const T &amp;exc1, const T &amp;exc2, unsigned long universeSize) const</td></tr>
<tr class="memdesc:ab1a63d4102262eda00159858a6839f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the particular superset search required by the double description method.  <a href="#ab1a63d4102262eda00159858a6839f96">More...</a><br /></td></tr>
<tr class="separator:ab1a63d4102262eda00159858a6839f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09015d05dbbcb17b4fa06cb22b432d32"><td class="memItemLeft" align="right" valign="top"><a id="a09015d05dbbcb17b4fa06cb22b432d32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TrieSet</b> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;)=delete</td></tr>
<tr class="separator:a09015d05dbbcb17b4fa06cb22b432d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5358f0d5595ca6064d3e0610db3d61"><td class="memItemLeft" align="right" valign="top"><a id="a3e5358f0d5595ca6064d3e0610db3d61"></a>
<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> &amp;)=delete</td></tr>
<tr class="separator:a3e5358f0d5595ca6064d3e0610db3d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class regina::TrieSet&lt; T &gt;</h3>

<p>A trie-like data structure for storing and retriving sets. </p>
<p>This class is useful when the <em>elements</em> of these sets are taken from a fairly small universe, but where the <em>number</em> of sets being stored can be extremely large.</p>
<p>For simplicity, let the universe consist of the integers 0,...,<em>n</em>. Sets are represented as bitmasks of type <em>T</em> (which must be capable of holding bitmasks of length <em>n</em>). The <em>i</em>th bit of a bitmask indicates whether the integer <em>i</em> belongs to the corresponding set.</p>
<p>To construct an empty trie, simply call the default constructor. To insert a new set into the trie, call <a class="el" href="classregina_1_1TrieSet.html#a2b27f0f00ef8f19560f14cd7faf6caea" title="Insert the given set into this collection.">insert()</a> (whose running time is linear in <em>n</em>). You can insert the same set into the trie multiple times and the trie will record the number of times that it occurs.</p>
<p>Currently the only searching operations are <a class="el" href="classregina_1_1TrieSet.html#a58741f6c93aeede75d8bba526cff3ed1" title="Determines whether this collection of sets contains any subset of the argument superset.">hasSubset()</a> and <a class="el" href="classregina_1_1TrieSet.html#ab1a63d4102262eda00159858a6839f96" title="Performs the particular superset search required by the double description method.">hasExtraSuperset()</a>. These operations are slow, but still much faster than searching through a linear list; see the <a class="el" href="classregina_1_1TrieSet.html#a58741f6c93aeede75d8bba526cff3ed1" title="Determines whether this collection of sets contains any subset of the argument superset.">hasSubset()</a> and <a class="el" href="classregina_1_1TrieSet.html#ab1a63d4102262eda00159858a6839f96" title="Performs the particular superset search required by the double description method.">hasExtraSuperset()</a> documentation for details.</p>
<p>The implementation of this data structure uses a binary tree with depth levels 0,...,<em>n</em>, where each node at level <em>i</em> represents a potential length-<em>i</em> prefix for a bitmask. So, for instance, the root node represents the empty prefix, its children represent prefixes 0 and 1, their children represent prefixes 00, 01, 10 and 11, and so on.</p>
<p>Internally, a set is "stored" at the first node whose prefix in fact describes the entire set. For instance, the bitmask 101100 is stored at the node corresponding to the prefix 1011, which occurs at level 3 of the tree. Regions of the tree that do not store any sets are never explicitly constructed in memory.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument T is one of Regina's bitmask types, such as <a class="el" href="classregina_1_1Bitmask.html" title="A bitmask that can store arbitrarily many true-or-false bits.">Bitmask</a>, <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits.">Bitmask1</a> or <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a34961eca24ca18e8bc5ae976e58d6a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34961eca24ca18e8bc5ae976e58d6a79">&#9670;&nbsp;</a></span>TrieSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty collection of sets. </p>

</div>
</div>
<a id="afabb80bec38d52734b0215c625aa3ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabb80bec38d52734b0215c625aa3ac7">&#9670;&nbsp;</a></span>~TrieSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::~<a class="el" href="classregina_1_1TrieSet.html">TrieSet</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this collection of sets. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab1a63d4102262eda00159858a6839f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a63d4102262eda00159858a6839f96">&#9670;&nbsp;</a></span>hasExtraSuperset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::hasExtraSuperset </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>subset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>exc1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>exc2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>universeSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the particular superset search required by the double description method. </p>
<p>This routine asks the following question: In this collection of sets, is there any superset of the argument <em>subset</em> <em>other</em> than <em>exc1</em> or <em>exc2</em>? Here the sets <em>exc1</em> and <em>exc2</em> are explicitly excluded from our search. Supersets need not be <em>proper</em> supersets (so if an exact copy of <em>subset</em> is found in the tree then this will suffice).</p>
<p>This routine has a slow running time, which in pathological cases can grow to either <code>2^n</code> (where <em>n</em> is the bitmask length) or the number of sets stored in this collection, whichever is smaller. However, for "typical" searches in the context of normal surface enumeration, the running time is often significantly faster.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The sets <em>exc1</em> and <em>exc2</em> are distinct, and each is contained in this collection precisely once.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subset</td><td>the object of the query: we are searching this collection for a (non-strict) superset of this argument. </td></tr>
    <tr><td class="paramname">exc1</td><td>the first set in the collection to be excluded from this search. </td></tr>
    <tr><td class="paramname">exc2</td><td>the second set in the collection to be excluded from this search. </td></tr>
    <tr><td class="paramname">universeSize</td><td>the number of elements in the underlying universe (and therefore the lowest possible level in the search tree). Note that this is always less than or equal to the number of bits that the underlying bitmask type <em>T</em> can support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a superset with the required properties was found, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a58741f6c93aeede75d8bba526cff3ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58741f6c93aeede75d8bba526cff3ed1">&#9670;&nbsp;</a></span>hasSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::hasSubset </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>superset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>universeSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this collection of sets contains any subset of the argument <em>superset</em>. </p>
<p>Subsets need not be <em>proper</em> subsets (so if an exact copy of <em>superset</em> is found in the tree then this will suffice).</p>
<p>This routine has a slow running time, which in pathological cases can grow to either <code>2^n</code> (where <em>n</em> is the bitmask length) or the number of sets stored in this collection, whichever is smaller. However, for "typical" searches in the context of normal surface enumeration, the running time is often significantly faster.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">superset</td><td>the object of the query: we are searching this collection for a (non-strict) subset of this argument. </td></tr>
    <tr><td class="paramname">universeSize</td><td>the number of elements in the underlying universe (and therefore the lowest possible level in the search tree). Note that this is always less than or equal to the number of bits that the underlying bitmask type <em>T</em> can support. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a subset was found, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2b27f0f00ef8f19560f14cd7faf6caea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b27f0f00ef8f19560f14cd7faf6caea">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1TrieSet.html">regina::TrieSet</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert the given set into this collection. </p>
<p>The same set may be insert into this collection multiple times (and this multiplicity will be recorded correctly).</p>
<p>Running time for insertion is O(<em>n</em>), where <em>n</em> is the bitmask length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the new set to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>utilities/<a class="el" href="trieset_8h.html">trieset.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
