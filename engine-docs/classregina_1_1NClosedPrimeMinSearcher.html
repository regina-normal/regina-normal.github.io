<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NClosedPrimeMinSearcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html">NClosedPrimeMinSearcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classregina_1_1NClosedPrimeMinSearcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NClosedPrimeMinSearcher Class Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A gluing permutation search class that offers a specialised search algorithm for when (i) only closed prime minimal P2-irreducible triangulations are required, and (ii) the given face pairing has order at least three.  
 <a href="classregina_1_1NClosedPrimeMinSearcher.html#details">More...</a></p>

<p><code>#include &lt;census/ngluingpermsearcher.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NClosedPrimeMinSearcher:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NClosedPrimeMinSearcher.png" usemap="#regina::NClosedPrimeMinSearcher_map" alt=""/>
  <map id="regina::NClosedPrimeMinSearcher_map" name="regina::NClosedPrimeMinSearcher_map">
<area href="classregina_1_1NCompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f..." alt="regina::NCompactSearcher" shape="rect" coords="0,168,210,192"/>
<area href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given..." alt="regina::NGluingPermSearcher" shape="rect" coords="0,112,210,136"/>
<area href="classregina_1_1NGluingPerms.html" title="Represents a specific set of gluing permutations to complement a particular pairwise matching of tetr..." alt="regina::NGluingPerms" shape="rect" coords="0,56,210,80"/>
<area href="classregina_1_1NGenericGluingPerms.html" alt="regina::NGenericGluingPerms&lt; 3 &gt;" shape="rect" coords="0,0,210,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b4fe1f842f2fbdc4127c19425ab74aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aa">PurgeFlags</a> { <br/>
&#160;&#160;<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaa63d9fc50995427f40ba340a2758c1df7">PURGE_NONE</a> = 0, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaafbbdc0b96694193a77b7de69a933bba0">PURGE_NON_MINIMAL</a> = 1, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaa5e1154ce5cf070cfdc342aad24f8da16">PURGE_NON_PRIME</a> = 2, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaa6088565e664e5fb80ecb14672de9fa4d">PURGE_NON_MINIMAL_PRIME</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaabc030b9b74452791ad59fbf3b06ae070">PURGE_NON_MINIMAL_HYP</a> = 9, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaaf94de7a391554268c9ee058a4f932cc3">PURGE_P2_REDUCIBLE</a> = 4
<br/>
 }</td></tr>
<tr class="memdesc:a0b4fe1f842f2fbdc4127c19425ab74aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a> to indicate that our enumeration may (at the discretion of the enumeration algorithm) ignore certain classes of triangulations.  <a href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aa">More...</a><br/></td></tr>
<tr class="separator:a0b4fe1f842f2fbdc4127c19425ab74aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2995cb0b8bcc83b3de9257a38b7daa64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a2995cb0b8bcc83b3de9257a38b7daa64">NClosedPrimeMinSearcher</a> (const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *pairing, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *autos, bool orientableOnly, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a2995cb0b8bcc83b3de9257a38b7daa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager for use when (i) only closed prime minimal P2-irreducible triangulations are required, and (ii) the given face pairing has order at least three.  <a href="#a2995cb0b8bcc83b3de9257a38b7daa64">More...</a><br/></td></tr>
<tr class="separator:a2995cb0b8bcc83b3de9257a38b7daa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea28753fdf6d7213fca816a132ddc93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#afea28753fdf6d7213fca816a132ddc93">NClosedPrimeMinSearcher</a> (std::istream &amp;in, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:afea28753fdf6d7213fca816a132ddc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="#afea28753fdf6d7213fca816a132ddc93">More...</a><br/></td></tr>
<tr class="separator:afea28753fdf6d7213fca816a132ddc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18899c734964a7f6ff2c2ae91285aba1"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a18899c734964a7f6ff2c2ae91285aba1">~NClosedPrimeMinSearcher</a> ()</td></tr>
<tr class="memdesc:a18899c734964a7f6ff2c2ae91285aba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="#a18899c734964a7f6ff2c2ae91285aba1">More...</a><br/></td></tr>
<tr class="separator:a18899c734964a7f6ff2c2ae91285aba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2988ec8d2deb1938feb5e48c607e951b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a2988ec8d2deb1938feb5e48c607e951b">dumpData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a2988ec8d2deb1938feb5e48c607e951b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="#a2988ec8d2deb1938feb5e48c607e951b">More...</a><br/></td></tr>
<tr class="separator:a2988ec8d2deb1938feb5e48c607e951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4cd23c2e9ff5f4c50d79406dfcd8c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a0c4cd23c2e9ff5f4c50d79406dfcd8c7">runSearch</a> (long maxDepth=-1)</td></tr>
<tr class="memdesc:a0c4cd23c2e9ff5f4c50d79406dfcd8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="#a0c4cd23c2e9ff5f4c50d79406dfcd8c7">More...</a><br/></td></tr>
<tr class="separator:a0c4cd23c2e9ff5f4c50d79406dfcd8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b8f3c344454e8a28d090ee3a0977aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a83b8f3c344454e8a28d090ee3a0977aa">completePermSet</a> () const </td></tr>
<tr class="memdesc:a83b8f3c344454e8a28d090ee3a0977aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <a href="#a83b8f3c344454e8a28d090ee3a0977aa">More...</a><br/></td></tr>
<tr class="separator:a83b8f3c344454e8a28d090ee3a0977aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33d56ed2f7a989f7039b53585d07053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#ac33d56ed2f7a989f7039b53585d07053">dumpTaggedData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac33d56ed2f7a989f7039b53585d07053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <a href="#ac33d56ed2f7a989f7039b53585d07053">More...</a><br/></td></tr>
<tr class="separator:ac33d56ed2f7a989f7039b53585d07053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abed61c4db4c2b3a691d847dd9c19e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPerms.html#a5abed61c4db4c2b3a691d847dd9c19e9">getNumberOfTetrahedra</a> () const </td></tr>
<tr class="memdesc:a5abed61c4db4c2b3a691d847dd9c19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of tetrahedra under consideration.  <a href="#a5abed61c4db4c2b3a691d847dd9c19e9">More...</a><br/></td></tr>
<tr class="separator:a5abed61c4db4c2b3a691d847dd9c19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec77328521bfda984476843059c1c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
<a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPerms.html#afec77328521bfda984476843059c1c13">getFacePairing</a> () const </td></tr>
<tr class="memdesc:afec77328521bfda984476843059c1c13"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of tetrahedron faces that this set of gluing permutations complements.  <a href="#afec77328521bfda984476843059c1c13">More...</a><br/></td></tr>
<tr class="separator:afec77328521bfda984476843059c1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e006672da406bd013168589333714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ad79e006672da406bd013168589333714">inputError</a> () const</td></tr>
<tr class="memdesc:ad79e006672da406bd013168589333714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was an error found during construction from an input stream?  <a href="#ad79e006672da406bd013168589333714">More...</a><br/></td></tr>
<tr class="separator:ad79e006672da406bd013168589333714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7dbf42bf4e74028009acbdd7cc2c98"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#aaf7dbf42bf4e74028009acbdd7cc2c98">size</a> () const</td></tr>
<tr class="memdesc:aaf7dbf42bf4e74028009acbdd7cc2c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of simplices under consideration.  <a href="#aaf7dbf42bf4e74028009acbdd7cc2c98">More...</a><br/></td></tr>
<tr class="separator:aaf7dbf42bf4e74028009acbdd7cc2c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e66510039a93624565943ed42c58a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a75e66510039a93624565943ed42c58a1">facetPairing</a> () const</td></tr>
<tr class="memdesc:a75e66510039a93624565943ed42c58a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="#a75e66510039a93624565943ed42c58a1">More...</a><br/></td></tr>
<tr class="separator:a75e66510039a93624565943ed42c58a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35303fc181f74a7e580a5214048e7e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ae35303fc181f74a7e580a5214048e7e8">getFacetPairing</a> () const</td></tr>
<tr class="memdesc:ae35303fc181f74a7e580a5214048e7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="#ae35303fc181f74a7e580a5214048e7e8">More...</a><br/></td></tr>
<tr class="separator:ae35303fc181f74a7e580a5214048e7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af680fcfa9cce6eb53ad65a312c7faf2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#af680fcfa9cce6eb53ad65a312c7faf2a">gluingPerm</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:af680fcfa9cce6eb53ad65a312c7faf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="#af680fcfa9cce6eb53ad65a312c7faf2a">More...</a><br/></td></tr>
<tr class="separator:af680fcfa9cce6eb53ad65a312c7faf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283008a625a1e535c244f1ebeeb12da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a283008a625a1e535c244f1ebeeb12da6">gluingPerm</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:a283008a625a1e535c244f1ebeeb12da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="#a283008a625a1e535c244f1ebeeb12da6">More...</a><br/></td></tr>
<tr class="separator:a283008a625a1e535c244f1ebeeb12da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03494fffaeb8c00bb44c7b224b10fd2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a03494fffaeb8c00bb44c7b224b10fd2d">triangulate</a> () const</td></tr>
<tr class="memdesc:a03494fffaeb8c00bb44c7b224b10fd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing.  <a href="#a03494fffaeb8c00bb44c7b224b10fd2d">More...</a><br/></td></tr>
<tr class="separator:a03494fffaeb8c00bb44c7b224b10fd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2ca8d1402408e4a2df915d16b8a06617"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617">findAllPerms</a> (const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *pairing, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a2ca8d1402408e4a2df915d16b8a06617"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given face pairing.  <a href="#a2ca8d1402408e4a2df915d16b8a06617">More...</a><br/></td></tr>
<tr class="separator:a2ca8d1402408e4a2df915d16b8a06617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7e9a7e8ef122be71702ae7d32d057"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a49a7e9a7e8ef122be71702ae7d32d057">bestSearcher</a> (const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *pairing, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a49a7e9a7e8ef122be71702ae7d32d057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <a href="#a49a7e9a7e8ef122be71702ae7d32d057">More...</a><br/></td></tr>
<tr class="separator:a49a7e9a7e8ef122be71702ae7d32d057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80981f59f945b24a8eaccb651786a5b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a80981f59f945b24a8eaccb651786a5b1">readTaggedData</a> (std::istream &amp;in, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a80981f59f945b24a8eaccb651786a5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <a href="#a80981f59f945b24a8eaccb651786a5b1">More...</a><br/></td></tr>
<tr class="separator:a80981f59f945b24a8eaccb651786a5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8e39fc904b9e7eaf3c621347ef84075b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a8e39fc904b9e7eaf3c621347ef84075b">dataTag_</a></td></tr>
<tr class="memdesc:a8e39fc904b9e7eaf3c621347ef84075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="#a8e39fc904b9e7eaf3c621347ef84075b">More...</a><br/></td></tr>
<tr class="separator:a8e39fc904b9e7eaf3c621347ef84075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3b1ecf7d778a7b57c17ae5d74f572576"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a3b1ecf7d778a7b57c17ae5d74f572576">dataTag</a> () const </td></tr>
<tr class="memdesc:a3b1ecf7d778a7b57c17ae5d74f572576"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="#a3b1ecf7d778a7b57c17ae5d74f572576">More...</a><br/></td></tr>
<tr class="separator:a3b1ecf7d778a7b57c17ae5d74f572576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9b98017dcf385285337e011bcc889"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a48a9b98017dcf385285337e011bcc889">findEdgeClass</a> (int edgeID) const </td></tr>
<tr class="memdesc:a48a9b98017dcf385285337e011bcc889"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="#a48a9b98017dcf385285337e011bcc889">More...</a><br/></td></tr>
<tr class="separator:a48a9b98017dcf385285337e011bcc889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d295888f4f9ff3d6a19569b1b6972c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a4d295888f4f9ff3d6a19569b1b6972c4">findEdgeClass</a> (int edgeID, char &amp;twisted) const </td></tr>
<tr class="memdesc:a4d295888f4f9ff3d6a19569b1b6972c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="#a4d295888f4f9ff3d6a19569b1b6972c4">More...</a><br/></td></tr>
<tr class="separator:a4d295888f4f9ff3d6a19569b1b6972c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f7318c2b40e15b405d5f218a79588f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a90f7318c2b40e15b405d5f218a79588f">mergeVertexClasses</a> ()</td></tr>
<tr class="memdesc:a90f7318c2b40e15b405d5f218a79588f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="#a90f7318c2b40e15b405d5f218a79588f">More...</a><br/></td></tr>
<tr class="separator:a90f7318c2b40e15b405d5f218a79588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7728b937248460af266734d5ec79e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a9e7728b937248460af266734d5ec79e8">splitVertexClasses</a> ()</td></tr>
<tr class="memdesc:a9e7728b937248460af266734d5ec79e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="#a9e7728b937248460af266734d5ec79e8">More...</a><br/></td></tr>
<tr class="separator:a9e7728b937248460af266734d5ec79e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf35a1fc7db3f7975a49efe5caa1c92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a9bf35a1fc7db3f7975a49efe5caa1c92">vtxBdryJoin</a> (int vertexID, char end, int adjVertexID, char twist)</td></tr>
<tr class="memdesc:a9bf35a1fc7db3f7975a49efe5caa1c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent.  <a href="#a9bf35a1fc7db3f7975a49efe5caa1c92">More...</a><br/></td></tr>
<tr class="separator:a9bf35a1fc7db3f7975a49efe5caa1c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ab5b9e4d3111c26a376fd03122dd11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a71ab5b9e4d3111c26a376fd03122dd11">vtxBdryFixAdj</a> (int vertexID)</td></tr>
<tr class="memdesc:a71ab5b9e4d3111c26a376fd03122dd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex.  <a href="#a71ab5b9e4d3111c26a376fd03122dd11">More...</a><br/></td></tr>
<tr class="separator:a71ab5b9e4d3111c26a376fd03122dd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0f76f1681192c9ec5605f45920d397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a8d0f76f1681192c9ec5605f45920d397">vtxBdryBackup</a> (int vertexID)</td></tr>
<tr class="memdesc:a8d0f76f1681192c9ec5605f45920d397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex.  <a href="#a8d0f76f1681192c9ec5605f45920d397">More...</a><br/></td></tr>
<tr class="separator:a8d0f76f1681192c9ec5605f45920d397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8dfa545cbf2b882b927239b6ca5060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#aed8dfa545cbf2b882b927239b6ca5060">vtxBdryRestore</a> (int vertexID)</td></tr>
<tr class="memdesc:aed8dfa545cbf2b882b927239b6ca5060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex.  <a href="#aed8dfa545cbf2b882b927239b6ca5060">More...</a><br/></td></tr>
<tr class="separator:aed8dfa545cbf2b882b927239b6ca5060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440eafcc96f07de97a6fc212b87d2cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a440eafcc96f07de97a6fc212b87d2cab">vtxBdryNext</a> (int vertexID, int tet, int vertex, int bdryFace, int next[2], char twist[2])</td></tr>
<tr class="memdesc:a440eafcc96f07de97a6fc212b87d2cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction.  <a href="#a440eafcc96f07de97a6fc212b87d2cab">More...</a><br/></td></tr>
<tr class="separator:a440eafcc96f07de97a6fc212b87d2cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875ac145796b90f4adda6c3cc01d3be5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a875ac145796b90f4adda6c3cc01d3be5">vtxBdryLength1</a> (int vertexID)</td></tr>
<tr class="memdesc:a875ac145796b90f4adda6c3cc01d3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link.  <a href="#a875ac145796b90f4adda6c3cc01d3be5">More...</a><br/></td></tr>
<tr class="separator:a875ac145796b90f4adda6c3cc01d3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab954693403bb8e7aad8ceadbb7876"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a36ab954693403bb8e7aad8ceadbb7876">vtxBdryLength2</a> (int vertexID1, int vertexID2)</td></tr>
<tr class="memdesc:a36ab954693403bb8e7aad8ceadbb7876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle.  <a href="#a36ab954693403bb8e7aad8ceadbb7876">More...</a><br/></td></tr>
<tr class="separator:a36ab954693403bb8e7aad8ceadbb7876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa6ade09243389143b09a44e81bc0fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a5aa6ade09243389143b09a44e81bc0fe">vtxBdryConsistencyCheck</a> ()</td></tr>
<tr class="memdesc:a5aa6ade09243389143b09a44e81bc0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class.  <a href="#a5aa6ade09243389143b09a44e81bc0fe">More...</a><br/></td></tr>
<tr class="separator:a5aa6ade09243389143b09a44e81bc0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef25686d979090bad183d55df60923a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a1ef25686d979090bad183d55df60923a">vtxBdryDump</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:a1ef25686d979090bad183d55df60923a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream.  <a href="#a1ef25686d979090bad183d55df60923a">More...</a><br/></td></tr>
<tr class="separator:a1ef25686d979090bad183d55df60923a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706b007b0eb9309ff38ba8b997075d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a706b007b0eb9309ff38ba8b997075d13">isCanonical</a> () const </td></tr>
<tr class="memdesc:a706b007b0eb9309ff38ba8b997075d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <a href="#a706b007b0eb9309ff38ba8b997075d13">More...</a><br/></td></tr>
<tr class="separator:a706b007b0eb9309ff38ba8b997075d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc06b496569b99c7af9ee212404721d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a8fc06b496569b99c7af9ee212404721d">badEdgeLink</a> (const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;face) const </td></tr>
<tr class="memdesc:a8fc06b496569b99c7af9ee212404721d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse.  <a href="#a8fc06b496569b99c7af9ee212404721d">More...</a><br/></td></tr>
<tr class="separator:a8fc06b496569b99c7af9ee212404721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a898776fe549e432c8a043c7205d37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a63a898776fe549e432c8a043c7205d37">lowDegreeEdge</a> (const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;face, bool testDegree12, bool testDegree3) const </td></tr>
<tr class="memdesc:a63a898776fe549e432c8a043c7205d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with a low degree edge.  <a href="#a63a898776fe549e432c8a043c7205d37">More...</a><br/></td></tr>
<tr class="separator:a63a898776fe549e432c8a043c7205d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005b64550034c2217fe588e294f83445"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a005b64550034c2217fe588e294f83445">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a005b64550034c2217fe588e294f83445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a005b64550034c2217fe588e294f83445">More...</a><br/></td></tr>
<tr class="separator:a005b64550034c2217fe588e294f83445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b613e89df2b6518444e04324f517f51"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a7b613e89df2b6518444e04324f517f51">permIndex</a> (unsigned simp, unsigned facet)</td></tr>
<tr class="memdesc:a7b613e89df2b6518444e04324f517f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a7b613e89df2b6518444e04324f517f51">More...</a><br/></td></tr>
<tr class="separator:a7b613e89df2b6518444e04324f517f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5466d31fbc67dd6178955f7ba601bc58"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a5466d31fbc67dd6178955f7ba601bc58">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a5466d31fbc67dd6178955f7ba601bc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a5466d31fbc67dd6178955f7ba601bc58">More...</a><br/></td></tr>
<tr class="separator:a5466d31fbc67dd6178955f7ba601bc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d888f9d8d547441b6f97e1afe9bc9d1"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a5d888f9d8d547441b6f97e1afe9bc9d1">permIndex</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:a5d888f9d8d547441b6f97e1afe9bc9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a5d888f9d8d547441b6f97e1afe9bc9d1">More...</a><br/></td></tr>
<tr class="separator:a5d888f9d8d547441b6f97e1afe9bc9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0884253496c28e84b35cee6c9defeddb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a0884253496c28e84b35cee6c9defeddb">gluingToIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:a0884253496c28e84b35cee6c9defeddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#a0884253496c28e84b35cee6c9defeddb">More...</a><br/></td></tr>
<tr class="separator:a0884253496c28e84b35cee6c9defeddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad063468f01d955ed752ac96355ca3e16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ad063468f01d955ed752ac96355ca3e16">gluingToIndex</a> (unsigned simp, unsigned facet, const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:ad063468f01d955ed752ac96355ca3e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#ad063468f01d955ed752ac96355ca3e16">More...</a><br/></td></tr>
<tr class="separator:ad063468f01d955ed752ac96355ca3e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47522122be0817a6deaf1f70dc4c493e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a47522122be0817a6deaf1f70dc4c493e">indexToGluing</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, int index) const</td></tr>
<tr class="memdesc:a47522122be0817a6deaf1f70dc4c493e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1.  <a href="#a47522122be0817a6deaf1f70dc4c493e">More...</a><br/></td></tr>
<tr class="separator:a47522122be0817a6deaf1f70dc4c493e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c47cfac4faf305d3f7fc9523d13c1a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a7c47cfac4faf305d3f7fc9523d13c1a5">indexToGluing</a> (unsigned simp, unsigned facet, int index) const</td></tr>
<tr class="memdesc:a7c47cfac4faf305d3f7fc9523d13c1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1.  <a href="#a7c47cfac4faf305d3f7fc9523d13c1a5">More...</a><br/></td></tr>
<tr class="separator:a7c47cfac4faf305d3f7fc9523d13c1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad0d4034f7aecce6f4da9d27dd40b8cb6"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#ad0d4034f7aecce6f4da9d27dd40b8cb6">nVertexClasses</a></td></tr>
<tr class="memdesc:ad0d4034f7aecce6f4da9d27dd40b8cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron vertices.  <a href="#ad0d4034f7aecce6f4da9d27dd40b8cb6">More...</a><br/></td></tr>
<tr class="separator:ad0d4034f7aecce6f4da9d27dd40b8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a4ba0b0568155292f55b50816e2a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html">TetVertexState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#ad8a4ba0b0568155292f55b50816e2a21">vertexState</a></td></tr>
<tr class="memdesc:ad8a4ba0b0568155292f55b50816e2a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron vertices.  <a href="#ad8a4ba0b0568155292f55b50816e2a21">More...</a><br/></td></tr>
<tr class="separator:ad8a4ba0b0568155292f55b50816e2a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6e07bfd96343e01ab951b6d8b4704b"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a2a6e07bfd96343e01ab951b6d8b4704b">vertexStateChanged</a></td></tr>
<tr class="memdesc:a2a6e07bfd96343e01ab951b6d8b4704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the vertexState[] array has been updated over time.  <a href="#a2a6e07bfd96343e01ab951b6d8b4704b">More...</a><br/></td></tr>
<tr class="separator:a2a6e07bfd96343e01ab951b6d8b4704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f304e11b7afef976aab3814ccea691"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#aa7f304e11b7afef976aab3814ccea691">nEdgeClasses</a></td></tr>
<tr class="memdesc:aa7f304e11b7afef976aab3814ccea691"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron edges.  <a href="#aa7f304e11b7afef976aab3814ccea691">More...</a><br/></td></tr>
<tr class="separator:aa7f304e11b7afef976aab3814ccea691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4243d5a6554e32084f14847a4c8cb0ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NCompactSearcher_1_1TetEdgeState.html">TetEdgeState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a4243d5a6554e32084f14847a4c8cb0ef">edgeState</a></td></tr>
<tr class="memdesc:a4243d5a6554e32084f14847a4c8cb0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron edges.  <a href="#a4243d5a6554e32084f14847a4c8cb0ef">More...</a><br/></td></tr>
<tr class="separator:a4243d5a6554e32084f14847a4c8cb0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca7f7622007dc33e83aae16c67a957"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#af0ca7f7622007dc33e83aae16c67a957">edgeStateChanged</a></td></tr>
<tr class="memdesc:af0ca7f7622007dc33e83aae16c67a957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the edgeState[] array has been updated over time.  <a href="#af0ca7f7622007dc33e83aae16c67a957">More...</a><br/></td></tr>
<tr class="separator:af0ca7f7622007dc33e83aae16c67a957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e1d796fc14435bda8efbac2b33861d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#ad8e1d796fc14435bda8efbac2b33861d">autos_</a></td></tr>
<tr class="memdesc:ad8e1d796fc14435bda8efbac2b33861d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <a href="#ad8e1d796fc14435bda8efbac2b33861d">More...</a><br/></td></tr>
<tr class="separator:ad8e1d796fc14435bda8efbac2b33861d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c31c8d63273120ba78fabd59d1b9592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a5c31c8d63273120ba78fabd59d1b9592">autosNew</a></td></tr>
<tr class="memdesc:a5c31c8d63273120ba78fabd59d1b9592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)?  <a href="#a5c31c8d63273120ba78fabd59d1b9592">More...</a><br/></td></tr>
<tr class="separator:a5c31c8d63273120ba78fabd59d1b9592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcecf9deb5b145b1a0ba78ada59c42a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#afcecf9deb5b145b1a0ba78ada59c42a1">orientableOnly_</a></td></tr>
<tr class="memdesc:afcecf9deb5b145b1a0ba78ada59c42a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <a href="#afcecf9deb5b145b1a0ba78ada59c42a1">More...</a><br/></td></tr>
<tr class="separator:afcecf9deb5b145b1a0ba78ada59c42a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac196b3dbc150dea2572b000c189cd3fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#ac196b3dbc150dea2572b000c189cd3fc">finiteOnly_</a></td></tr>
<tr class="memdesc:ac196b3dbc150dea2572b000c189cd3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to finite triangulations?  <a href="#ac196b3dbc150dea2572b000c189cd3fc">More...</a><br/></td></tr>
<tr class="separator:ac196b3dbc150dea2572b000c189cd3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33937a8b2d37b296c028fd23fc80d55b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a33937a8b2d37b296c028fd23fc80d55b">whichPurge_</a></td></tr>
<tr class="memdesc:a33937a8b2d37b296c028fd23fc80d55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are there any types of triangulation that we may optionally avoid constructing? This should be a bitwise OR of constants from the PurgeFlags enumeration.  <a href="#a33937a8b2d37b296c028fd23fc80d55b">More...</a><br/></td></tr>
<tr class="separator:a33937a8b2d37b296c028fd23fc80d55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6ec032a1dbfde1b376ad64e9ae3191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#acd6ec032a1dbfde1b376ad64e9ae3191">use_</a></td></tr>
<tr class="memdesc:acd6ec032a1dbfde1b376ad64e9ae3191"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to call each time a gluing permutation set is found during the search.  <a href="#acd6ec032a1dbfde1b376ad64e9ae3191">More...</a><br/></td></tr>
<tr class="separator:acd6ec032a1dbfde1b376ad64e9ae3191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9416290ea2bd8dda6067550f4e2c09"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a9e9416290ea2bd8dda6067550f4e2c09">useArgs_</a></td></tr>
<tr class="memdesc:a9e9416290ea2bd8dda6067550f4e2c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine.  <a href="#a9e9416290ea2bd8dda6067550f4e2c09">More...</a><br/></td></tr>
<tr class="separator:a9e9416290ea2bd8dda6067550f4e2c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94c5ed7eca9105ca5c0e9305a612f0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#af94c5ed7eca9105ca5c0e9305a612f0d">started</a></td></tr>
<tr class="memdesc:af94c5ed7eca9105ca5c0e9305a612f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <a href="#af94c5ed7eca9105ca5c0e9305a612f0d">More...</a><br/></td></tr>
<tr class="separator:af94c5ed7eca9105ca5c0e9305a612f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7624c6d0d928fecde27b515ee7ff792a"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a7624c6d0d928fecde27b515ee7ff792a">orientation</a></td></tr>
<tr class="memdesc:a7624c6d0d928fecde27b515ee7ff792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each tetrahedron in the underlying triangulation.  <a href="#a7624c6d0d928fecde27b515ee7ff792a">More...</a><br/></td></tr>
<tr class="separator:a7624c6d0d928fecde27b515ee7ff792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2318c6a68fd1c8f8f8c75bdb32d7d3de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a2318c6a68fd1c8f8f8c75bdb32d7d3de">order</a></td></tr>
<tr class="memdesc:a2318c6a68fd1c8f8f8c75bdb32d7d3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to faces.  <a href="#a2318c6a68fd1c8f8f8c75bdb32d7d3de">More...</a><br/></td></tr>
<tr class="separator:a2318c6a68fd1c8f8f8c75bdb32d7d3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875ddbcdf6e391c09e811886003e3566"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a875ddbcdf6e391c09e811886003e3566">orderSize</a></td></tr>
<tr class="memdesc:a875ddbcdf6e391c09e811886003e3566"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array.  <a href="#a875ddbcdf6e391c09e811886003e3566">More...</a><br/></td></tr>
<tr class="separator:a875ddbcdf6e391c09e811886003e3566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d5c90d38ffc1d63212f21e79fb710b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a24d5c90d38ffc1d63212f21e79fb710b">orderElt</a></td></tr>
<tr class="memdesc:a24d5c90d38ffc1d63212f21e79fb710b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <a href="#a24d5c90d38ffc1d63212f21e79fb710b">More...</a><br/></td></tr>
<tr class="separator:a24d5c90d38ffc1d63212f21e79fb710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860718c9bfd69ee9580ed59fa1011d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ae860718c9bfd69ee9580ed59fa1011d2">pairing_</a></td></tr>
<tr class="memdesc:ae860718c9bfd69ee9580ed59fa1011d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet pairing that this permutation set complements.  <a href="#ae860718c9bfd69ee9580ed59fa1011d2">More...</a><br/></td></tr>
<tr class="separator:ae860718c9bfd69ee9580ed59fa1011d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae099e06f91c89942ff8bb69071a5b067"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ae099e06f91c89942ff8bb69071a5b067">permIndices_</a></td></tr>
<tr class="memdesc:ae099e06f91c89942ff8bb69071a5b067"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index into array NPerm&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner.  <a href="#ae099e06f91c89942ff8bb69071a5b067">More...</a><br/></td></tr>
<tr class="separator:ae099e06f91c89942ff8bb69071a5b067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df279bd42b9f49e8527774aabf3f6f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a4df279bd42b9f49e8527774aabf3f6f7">inputError_</a></td></tr>
<tr class="memdesc:a4df279bd42b9f49e8527774aabf3f6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has an error occurred during construction from an input stream?  <a href="#a4df279bd42b9f49e8527774aabf3f6f7">More...</a><br/></td></tr>
<tr class="separator:a4df279bd42b9f49e8527774aabf3f6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a18b2d18ce4eec2a7df669a846a3afd29"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a18b2d18ce4eec2a7df669a846a3afd29">VLINK_CLOSED</a></td></tr>
<tr class="memdesc:a18b2d18ce4eec2a7df669a846a3afd29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges).  <a href="#a18b2d18ce4eec2a7df669a846a3afd29">More...</a><br/></td></tr>
<tr class="separator:a18b2d18ce4eec2a7df669a846a3afd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc89df04aa4b4d087b401f8147476a74"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#acc89df04aa4b4d087b401f8147476a74">VLINK_NON_SPHERE</a></td></tr>
<tr class="memdesc:acc89df04aa4b4d087b401f8147476a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been made into something other than a 2-sphere with zero or more punctures.  <a href="#acc89df04aa4b4d087b401f8147476a74">More...</a><br/></td></tr>
<tr class="separator:acc89df04aa4b4d087b401f8147476a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf0196ba54c14e2cf50cc83037a41e8"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#adaf0196ba54c14e2cf50cc83037a41e8">vertexLinkNextFace</a> [4][4]</td></tr>
<tr class="memdesc:adaf0196ba54c14e2cf50cc83037a41e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron.  <a href="#adaf0196ba54c14e2cf50cc83037a41e8">More...</a><br/></td></tr>
<tr class="separator:adaf0196ba54c14e2cf50cc83037a41e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66505da256a33e2d01224756eed9b492"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NCompactSearcher.html#a66505da256a33e2d01224756eed9b492">vertexLinkPrevFace</a> [4][4]</td></tr>
<tr class="memdesc:a66505da256a33e2d01224756eed9b492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>.  <a href="#a66505da256a33e2d01224756eed9b492">More...</a><br/></td></tr>
<tr class="separator:a66505da256a33e2d01224756eed9b492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A gluing permutation search class that offers a specialised search algorithm for when (i) only closed prime minimal P2-irreducible triangulations are required, and (ii) the given face pairing has order at least three. </p>
<p>The search algorithm is significantly different from the default algorithm provided by <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a>. It is heavily optimised and takes advantage of a number of results regarding the underlying face pairing graph.</p>
<p>Note that additional unwanted triangulations (e.g., non-prime or non-minimal triangulations) may still be produced by this search. However, significantly fewer unwanted triangulations will be produced when using this class instead of <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aa">regina::NGluingPermSearcher::PurgeFlags</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a> to indicate that our enumeration may (at the discretion of the enumeration algorithm) ignore certain classes of triangulations. </p>
<p>These flags can be combined using bitwise OR.</p>
<p>See the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor documentation for further details on how these flags are used.</p>
<dl class="section user"><dt>Python:</dt><dd>For convenience, these constants are also made available directly in Python's regina namespace. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaa63d9fc50995427f40ba340a2758c1df7"></a>PURGE_NONE</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that no triangulations should be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaafbbdc0b96694193a77b7de69a933bba0"></a>PURGE_NON_MINIMAL</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that non-minimal triangulations may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaa5e1154ce5cf070cfdc342aad24f8da16"></a>PURGE_NON_PRIME</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation that is not prime (i.e., can be written as a non-trivial connected sum) and any bounded triangulation that is reducible over a disc may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaa6088565e664e5fb80ecb14672de9fa4d"></a>PURGE_NON_MINIMAL_PRIME</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation that is not prime (i.e., can be written as a non-trivial connected sum), any bounded triangulation that is reducible over a disc and any triangulation that is non-minimal may be ignored. </p>
<p>Note that this is simply a combination of the constants <em>PURGE_NON_MINIMAL</em> and <em>PURGE_NON_PRIME</em>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaabc030b9b74452791ad59fbf3b06ae070"></a>PURGE_NON_MINIMAL_HYP</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation that is not a minimal ideal triangulation of a cusped finite-volume hyperbolic 3-manifold may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaaf94de7a391554268c9ee058a4f932cc3"></a>PURGE_P2_REDUCIBLE</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation containing an embedded two-sided projective plane may be ignored. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2995cb0b8bcc83b3de9257a38b7daa64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NClosedPrimeMinSearcher::NClosedPrimeMinSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new search manager for use when (i) only closed prime minimal P2-irreducible triangulations are required, and (ii) the given face pairing has order at least three. </p>
<p>Note that other unwanted triangulations may still be produced (e.g., non-prime or non-minimal triangulations), but there will be far fewer of these than when using the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> class directly.</p>
<p>For details on how a search manager is used, see the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> documentation. Note in particular that this class will be automatically used by <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">NGluingPermSearcher::findAllPerms()</a> if possible, so there is often no need for an end user to instantiate this class directly.</p>
<p>All constructor arguments are the same as for the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor, though some arguments (such as <em>finiteOnly</em> and <em>whichPurge</em>) are not needed here since they are already implied by the specialised search context.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">NFacePairing::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">NFacePairing::findAllPairings()</a> are of this form. </dd>
<dd>
The given face pairing has no boundary faces and has at least three tetrahedra. </dd></dl>

</div>
</div>
<a class="anchor" id="afea28753fdf6d7213fca816a132ddc93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NClosedPrimeMinSearcher::NClosedPrimeMinSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a2988ec8d2deb1938feb5e48c607e951b" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac33d56ed2f7a989f7039b53585d07053" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="classregina_1_1NGluingPermSearcher.html#a80981f59f945b24a8eaccb651786a5b1" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="classregina_1_1NGenericGluingPerms.html#ad79e006672da406bd013168589333714" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18899c734964a7f6ff2c2ae91285aba1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NClosedPrimeMinSearcher::~NClosedPrimeMinSearcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8fc06b496569b99c7af9ee212404721d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::badEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse. </p>
<p>Note that such edges can only occur in non-orientable triangulations.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<p>If <em>finiteOnly_</em> is <code>true</code> in the search criteria, additional tests will be run that can eliminate triangulations with non-orientable vertex links. Although these tests are not searching for bad edge links per se, they can be performed within this routine with very little additional work needing to be done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to an edge identified with itself in reverse, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a class="anchor" id="a49a7e9a7e8ef122be71702ae7d32d057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a>* regina::NGluingPermSearcher::bestSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> instead.</p>
<p>The resulting object is newly created, and must be destroyed by the caller of this routine.</p>
<p>See the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">NFacePairing::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">NFacePairing::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created search manager. </dd></dl>

</div>
</div>
<a class="anchor" id="a83b8f3c344454e8a28d090ee3a0977aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::completePermSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>use_</em> routine when running partial depth-based searches. See <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b1ecf7d778a7b57c17ae5d74f572576"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::NClosedPrimeMinSearcher::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NCompactSearcher.html#ab94b9c6bd819c134e498338406b8e8fa">regina::NCompactSearcher</a>.</p>

</div>
</div>
<a class="anchor" id="a2988ec8d2deb1938feb5e48c607e951b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NClosedPrimeMinSearcher::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NCompactSearcher.html#a14854a0adb0910c8be33949c82bcab59">regina::NCompactSearcher</a>.</p>

</div>
</div>
<a class="anchor" id="ac33d56ed2f7a989f7039b53585d07053"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGluingPermSearcher::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="classregina_1_1NGluingPermSearcher.html#a80981f59f945b24a8eaccb651786a5b1" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75e66510039a93624565943ed42c58a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::facetPairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding simplex facet pairing. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca8d1402408e4a2df915d16b8a06617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::NGluingPermSearcher::findAllPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given face pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> and then calls <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">NFacePairing::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">NFacePairing::findAllPairings()</a> are of this form. </dd></dl>

</div>
</div>
<a class="anchor" id="a48a9b98017dcf385285337e011bcc889"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NCompactSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="classregina_1_1NCompactSearcher.html#a48a9b98017dcf385285337e011bcc889" title="Returns the representative of the equivalence class containing the given tetrahedron edge...">findEdgeClass()</a>, which is slightly slower but which also tracks edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d295888f4f9ff3d6a19569b1b6972c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NCompactSearcher::findEdgeClass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>twisted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge. </p>
<p>The class representative is defined to be the root of the corresponding union-find tree.</p>
<p>The argument <em>twisted</em> is also modified to indicate whether or not the identification of the given edge with the class representative preserves orientation. Note that this arugment is <em>not</em> initialised. Instead, if the identification is orientation-preserving then <em>twisted</em> will be left unmodified, and if it is orientation-reversing then <em>twisted</em> will be changed from 0 to 1 or vice-versa.</p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class for further details. See also the other variant of <a class="el" href="classregina_1_1NCompactSearcher.html#a48a9b98017dcf385285337e011bcc889" title="Returns the representative of the equivalence class containing the given tetrahedron edge...">findEdgeClass()</a>, which is slightly faster but which does not track edge orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeID</td><td>the index of a single tetrahedron edge; this must be between 0 and 6t-1 inclusive, where <em>t</em> is the number of tetrahedra. See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> class notes for details on edge indexing. </td></tr>
    <tr><td class="paramname">twisted</td><td>used to track edge orientation, as described above. This must be either 0 or 1 as it is passed into the function, and it will also be either 0 or 1 upon returning from the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tetrahedron edge at the root of the union-find tree, i.e., the representative of the equivalence class. </dd></dl>

</div>
</div>
<a class="anchor" id="afec77328521bfda984476843059c1c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> * regina::NGluingPerms::getFacePairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of tetrahedron faces that this set of gluing permutations complements. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NGenericGluingPerms.html#a75e66510039a93624565943ed42c58a1" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements...">facetPairing()</a>. This old name has been kept for backward compatibility, but will be removed in some future version of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding tetrahedron face pairing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae35303fc181f74a7e580a5214048e7e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::getFacetPairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>This routine has been renamed to facetPairing(). See the facetPairing() documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a5abed61c4db4c2b3a691d847dd9c19e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NGluingPerms::getNumberOfTetrahedra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of tetrahedra under consideration. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NGenericGluingPerms.html#aaf7dbf42bf4e74028009acbdd7cc2c98" title="Returns the total number of simplices under consideration.">size()</a>. This old name has been kept for backward compatibility, but will be removed in some future version of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra under consideration. </dd></dl>

</div>
</div>
<a class="anchor" id="af680fcfa9cce6eb53ad65a312c7faf2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine facetPairing()). </dd>
<dd>
The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a283008a625a1e535c244f1ebeeb12da6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine facetPairing()).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a0884253496c28e84b35cee6c9defeddb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into NPerm&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="ad063468f01d955ed752ac96355ca3e16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into NPerm&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="a47522122be0817a6deaf1f70dc4c493e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1. </p>
<p>This index into NPerm&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">index</td><td>an index into NPerm&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into NPerm&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c47cfac4faf305d3f7fc9523d13c1a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1. </p>
<p>This index into NPerm&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>an index into NPerm&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into NPerm&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="ad79e006672da406bd013168589333714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::inputError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was an error found during construction from an input stream? </p>
<p>This routine returns <code>true</code> if an input stream constructor was used to create this object but the data in the input stream was invalid or incorrectly formatted.</p>
<p>If a different constructor was called (i.e., no input stream was used), then this routine will always return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an error occurred during construction from an input stream, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a706b007b0eb9309ff38ba8b997075d13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a63a898776fe549e432c8a043c7205d37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::lowDegreeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDegree12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDegree3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with a low degree edge. </p>
<p>Precisely which types of low degree edges are identified must be specified through parameters <em>testDegree12</em> and <em>testDegree3</em>.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
    <tr><td class="paramname">testDegree12</td><td><code>true</code> if we should test for non-boundary edges of degree 1 or 2. </td></tr>
    <tr><td class="paramname">testDegree3</td><td><code>true</code> if we should test for non-boundary edges of degree 3 involving three distinct tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to a low-degree edge as specified by parameters <em>testDegree12</em> and <em>testDegree3</em>, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a class="anchor" id="a90f7318c2b40e15b405d5f218a79588f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NCompactSearcher::mergeVertexClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<p>This routine returns a bitwise (OR) combination of the VLINK_... flags defined earlier in this class. These flags describe what happened to the vertex links during this particular merge. In particular, they note when a vertex link is closed off, or is made into something other than a punctured 2-sphere.</p>
<dl class="section return"><dt>Returns</dt><dd>a combination of VLINK_... flags describing how the vertex links were changed, or 0 if none of the changes described by these flags were observed. </dd></dl>

</div>
</div>
<a class="anchor" id="a005b64550034c2217fe588e294f83445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b613e89df2b6518444e04324f517f51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a5466d31fbc67dd6178955f7ba601bc58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d888f9d8d547441b6f97e1afe9bc9d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a80981f59f945b24a8eaccb651786a5b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a>* regina::NGluingPermSearcher::readTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac33d56ed2f7a989f7039b53585d07053" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="classregina_1_1NGluingPermSearcher.html#abbd93ce988d8498b5ddf9b09a0714660" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, a null pointer will be returned. Otherwise a newly constructed search manager will be returned, and it is the responsibility of the caller of this routine to destroy it after use.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c4cd23c2e9ff5f4c50d79406dfcd8c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NClosedPrimeMinSearcher::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> objects. These partial searches may then be restarted by calling <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a0c4cd23c2e9ff5f4c50d79406dfcd8c7" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="classregina_1_1NGluingPermSearcher.html#a83b8f3c344454e8a28d090ee3a0977aa" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a0c4cd23c2e9ff5f4c50d79406dfcd8c7" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a0c4cd23c2e9ff5f4c50d79406dfcd8c7" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NCompactSearcher.html#a92c0e8398a0a1ece7408254f2bf75a60">regina::NCompactSearcher</a>.</p>

</div>
</div>
<a class="anchor" id="aaf7dbf42bf4e74028009acbdd7cc2c98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of simplices under consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e7728b937248460af266734d5ec79e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::splitVertexClasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details. </p>

</div>
</div>
<a class="anchor" id="a03494fffaeb8c00bb44c7b224b10fd2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing. </p>
<p>Each matched pair of facets and their associated permutations will be realised as two simplex facets in the triangulation glued together with the corresponding gluing permutation. Each unmatched facet will be realised as a boundary facet in the triangulation.</p>
<p>It is the responsibility of the caller of this routine to delete this triangulation once it is no longer required.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created triangulation modelled by this structure. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d0f76f1681192c9ec5605f45920d397"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::vtxBdryBackup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5aa6ade09243389143b09a44e81bc0fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::vtxBdryConsistencyCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class. </p>
<p>Any errors that are identified will be written to standard error. Note that some errors might be harmless (for instance, when a call to <a class="el" href="classregina_1_1NCompactSearcher.html#a90f7318c2b40e15b405d5f218a79588f" title="Merge the classes of tetrahedron vertices as required by the new gluing made at stage orderElt of the...">mergeVertexClasses()</a> leaves processing incomplete because it has located a bad vertex link and expects the merge to be immediately undone). </p>

</div>
</div>
<a class="anchor" id="a1ef25686d979090bad183d55df60923a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::vtxBdryDump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream. </p>
<p>The output format is relatively compact, and is subject to change in future versions of Regina. The output uses one line only, and a final newline is written.</p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71ab5b9e4d3111c26a376fd03122dd11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::vtxBdryFixAdj </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex. </p>
<p>It is assumed that the vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link. Recall from the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class notes that the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given vertex describe the boundary edges that follow on in either direction from the boundary edges supplied by this triangle.</p>
<p>This routine locates the tetrahedron vertices that provide the neighbouring boundary edges, and adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for these neighbouring vertices to point back to the given vertex.</p>
<p>This routine is intended to assist with backtracking. This routine is safe to use if the given tetrahedron vertex points to itself (i.e., it provides a complete boundary cycle of three edges in the vertex link).</p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The vertex linking triangle for the given tetrahedron vertex contributes at least one boundary edge to the vertex link.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bf35a1fc7db3f7975a49efe5caa1c92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::vtxBdryJoin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>adjVertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent. </p>
<p>The <em>bdryNext</em> and <em>bdryTwist</em> arrays for each vertex will be adjusted to point to the other.</p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the first tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">end</td><td>specifies in which direction the adjacent boundary edges lie. This must be either 0 or 1, and its value should correspond to the relevant index in the <em>bdryNext</em> and <em>bdryTwist</em> arrays for vertex <em>vertexID</em>. </td></tr>
    <tr><td class="paramname">adjVertexID</td><td>the tetrahedron vertex whose boundary edges are adjacent to the boundary edges supplied by <em>vertexID</em>; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">twist</td><td>0 if the orientations of the two boundary segments of vertex link are oriented in the same direction, or 1 if they are oriented in opposite directions; see the <em>bdryTwist</em> documentation for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a875ac145796b90f4adda6c3cc01d3be5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NCompactSearcher::vtxBdryLength1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a one-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a36ab954693403bb8e7aad8ceadbb7876"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NCompactSearcher::vtxBdryLength2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID1</td><td>the first tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">vertexID2</td><td>the second tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a two-edge boundary component is formed as described above, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a440eafcc96f07de97a6fc212b87d2cab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::vtxBdryNext </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bdryFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>twist</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction. </p>
<p>The given edge of the vertex linking triangle must belong to one of the two tetrahedron faces currently being joined.</p>
<p>The tetrahedron vertex to examine is passed in <em>vertexID</em>, <em>tet</em> and <em>vertex</em>, and the particular edge of the vertex linking triangle to examine is specified by <em>bdryFace</em>. Details of the adjacent boundary edges are returned in the arrays <em>next</em> and <em>twist</em>.</p>
<p>Note that the values returned might or might not correspond to the <em>bdryNext</em> and <em>bdryTwist</em> arrays of the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class, since the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> arrays skip over adjacent edges belonging to the same vertex linking triangle.</p>
<p>If the given edge of the vertex linking triangle is not a boundary edge of the vertex link, the behaviour of this routine is undefined.</p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The tetrahedron face (<em>tet</em>, <em>bdryFace</em>) is one of the two faces that are currently being joined together. That is, this face is either order[orderElt] or its partner in the underlying face pairing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex to examine; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
    <tr><td class="paramname">tet</td><td>the tetrahedron described by <em>vertexID</em>; this must be (vertexID / 4). It is passed separately to avoid a slow division operation. </td></tr>
    <tr><td class="paramname">vertex</td><td>the tetrahedron vertex number described by <em>vertexID</em>; this must be (vertexID % 4). It is passed separately to avoid a slow modulus operation. </td></tr>
    <tr><td class="paramname">bdryFace</td><td>the face number of the given tetrahedron containing the edge of the vertex linking triangle that is under consideration. This must be between 0 and 3 inclusive, and it may not be equal to <em>vertex</em>. </td></tr>
    <tr><td class="paramname">next</td><td>returns the tetrahedron vertex supplying each adjacent boundary edge; see the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html#aa16803915636a7a450ad0bcb74ec954c" title="If the corresponding triangular piece of vertex link has any boundary edges, bdryNext stores the indi...">TetVertexState::bdryNext</a> notes for details on which directions correspond to array indices 0 and 1. </td></tr>
    <tr><td class="paramname">twist</td><td>returns whether the orientations of the adjacent boundary edges are consistent with the orientation of this boundary edge; see the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html#a491606857aff5eb26ce49cf1008afacc" title="Describes whether the orientation of this boundary segment of the vertex link is consistent with the ...">TetVertexState::bdryTwist</a> notes for further information on orientations in the vertex link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed8dfa545cbf2b882b927239b6ca5060"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NCompactSearcher::vtxBdryRestore </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertexID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class for further information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertexID</td><td>the tetrahedron vertex on which to operate; this must be between 0 and 4n-1 inclusive, where <em>n</em> is the number of tetrahedra. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad8e1d796fc14435bda8efbac2b33861d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a>* regina::NGluingPermSearcher::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying face pairing. </p>

</div>
</div>
<a class="anchor" id="a5c31c8d63273120ba78fabd59d1b9592"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::autosNew</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)? </p>

</div>
</div>
<a class="anchor" id="a8e39fc904b9e7eaf3c621347ef84075b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::NClosedPrimeMinSearcher::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a class="anchor" id="a4243d5a6554e32084f14847a4c8cb0ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NCompactSearcher_1_1TetEdgeState.html">TetEdgeState</a>* regina::NCompactSearcher::edgeState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron edges. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetEdgeState.html" title="A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is c...">TetEdgeState</a> description for details. This array has size 6n, where edge e of tetrahedron t has index 6t+e. </p>

</div>
</div>
<a class="anchor" id="af0ca7f7622007dc33e83aae16c67a957"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::NCompactSearcher::edgeStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the edgeState[] array has been updated over time. </p>
<p>This array has size 8n. Suppose the gluing for order[i] affects face f of tetrahedron t. Then element 4i+v of this array describes how the gluing for order[i] affects the edge of tetrahedron t opposite vertices f and v (note that a quarter of this array will remain unused, since f and v are never equal).</p>
<p>If this identification of edges results in the tree with root edgeState[p] being grafted beneath the tree with root edgeState[q], this array will store the value p. Otherwise it will store the value -1. </p>

</div>
</div>
<a class="anchor" id="ac196b3dbc150dea2572b000c189cd3fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::finiteOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to finite triangulations? </p>

</div>
</div>
<a class="anchor" id="a4df279bd42b9f49e8527774aabf3f6f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::inputError_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has an error occurred during construction from an input stream? </p>

</div>
</div>
<a class="anchor" id="aa7f304e11b7afef976aab3814ccea691"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NCompactSearcher::nEdgeClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron edges. </p>

</div>
</div>
<a class="anchor" id="ad0d4034f7aecce6f4da9d27dd40b8cb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NCompactSearcher::nVertexClasses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of equivalence classes of identified tetrahedron vertices. </p>

</div>
</div>
<a class="anchor" id="a2318c6a68fd1c8f8f8c75bdb32d7d3de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a>* regina::NGluingPermSearcher::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to faces. </p>
<p>Specifically, this order is order[0], order[1], ..., order[orderSize-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying face pairing graph, which in turn represents a tetrahedron face and its image under the given face pairing.</p>
<p>The specific tetrahedron face stored in this array for each edge of the underlying face pairing graph will be the smaller of the two identified tetrahedron faces (unless otherwise specified for a particular edge type; see <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">NClosedPrimeMinSearcher</a> for examples). </p>

</div>
</div>
<a class="anchor" id="a24d5c90d38ffc1d63212f21e79fb710b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NGluingPermSearcher::orderElt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a class="anchor" id="a875ddbcdf6e391c09e811886003e3566"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NGluingPermSearcher::orderSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array. </p>

</div>
</div>
<a class="anchor" id="afcecf9deb5b145b1a0ba78ada59c42a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a class="anchor" id="a7624c6d0d928fecde27b515ee7ff792a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::NGluingPermSearcher::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each tetrahedron in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply +/-1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a class="anchor" id="ae860718c9bfd69ee9580ed59fa1011d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::pairing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The facet pairing that this permutation set complements. </p>
<p>This is guaranteed to be the minimal representative of its facet pairing isomorphism class. </p>

</div>
</div>
<a class="anchor" id="ae099e06f91c89942ff8bb69071a5b067"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index into array NPerm&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner. </p>
<p>Note that this is not a gluing permutation as such but rather a permutation of 0,...,<em>dim-1</em> only (see the routines gluingToIndex() and indexToGluing() for conversions). If a permutation has not yet been selected (e.g., if this permutation set is still under construction) then this index is -1. </p>

</div>
</div>
<a class="anchor" id="af94c5ed7eca9105ca5c0e9305a612f0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<a class="anchor" id="acd6ec032a1dbfde1b376ad64e9ae3191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> regina::NGluingPermSearcher::use_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to call each time a gluing permutation set is found during the search. </p>

</div>
</div>
<a class="anchor" id="a9e9416290ea2bd8dda6067550f4e2c09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* regina::NGluingPermSearcher::useArgs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine. </p>

</div>
</div>
<a class="anchor" id="adaf0196ba54c14e2cf50cc83037a41e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::NCompactSearcher::vertexLinkNextFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron. </p>
<p>This ordering is consistent with the orientations of triangles in the vertex link used by <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html#a240d90466fda0dde6bb14ba8d481f1a1" title="The identification of this object and its parent in the tree corresponds to a gluing of two triangles...">TetVertexState::twistUp</a>.</p>
<p>For vertex v (0..3), the tetrahedron face that follows f (0..3) in this ordering is <em>vertexLinkNextFace</em>[v][f]. The remaining array elements <em>vertexLinkNextFace</em>[v][v] are all -1. </p>

</div>
</div>
<a class="anchor" id="a66505da256a33e2d01224756eed9b492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::NCompactSearcher::vertexLinkPrevFace[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>. </p>
<p>For vertex v (0..3), the tetrahedron face that precedes f (0..3) in this ordering is <em>vertexLinkPrevFace</em>[v][f]. The remaining array elements <em>vertexLinkPrevFace</em>[v][v] are all -1. </p>

</div>
</div>
<a class="anchor" id="ad8a4ba0b0568155292f55b50816e2a21"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html">TetVertexState</a>* regina::NCompactSearcher::vertexState</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for tracking equivalence classes of identified tetrahedron vertices. </p>
<p>See the <a class="el" href="structregina_1_1NCompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> description for details. This array has size 4n, where vertex v of tetrahedron t has index 4t+v. </p>

</div>
</div>
<a class="anchor" id="a2a6e07bfd96343e01ab951b6d8b4704b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::NCompactSearcher::vertexStateChanged</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the way in which the vertexState[] array has been updated over time. </p>
<p>This array has size 8n, where element 4i+v describes how the gluing for order[i] affects vertex v of the corresponding tetrahedron (thus a quarter of this array will remain unused, since only three vertices are affected for each gluing).</p>
<p>If this identification of vertices results in the tree with root vertexState[p] being grafted beneath the tree with root vertexState[q], this array will store the value p. Otherwise it will store the value -1. </p>

</div>
</div>
<a class="anchor" id="a18b2d18ce4eec2a7df669a846a3afd29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::NCompactSearcher::VLINK_CLOSED</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges). </p>

</div>
</div>
<a class="anchor" id="acc89df04aa4b4d087b401f8147476a74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::NCompactSearcher::VLINK_NON_SPHERE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a vertex link has been made into something other than a 2-sphere with zero or more punctures. </p>

</div>
</div>
<a class="anchor" id="a33937a8b2d37b296c028fd23fc80d55b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NGluingPermSearcher::whichPurge_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are there any types of triangulation that we may optionally avoid constructing? This should be a bitwise OR of constants from the PurgeFlags enumeration. </p>
<p>See the constructor documentation for further details on this search parameter. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="ngluingpermsearcher_8h.html">ngluingpermsearcher.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
