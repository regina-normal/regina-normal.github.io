<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NGluingPermSearcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NGluingPermSearcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NGluingPermSearcher Class Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class for searching through all possible gluing permutation sets that correspond to a given tetrahedron face pairing.  
 <a href="classregina_1_1NGluingPermSearcher.html#details">More...</a></p>

<p><code>#include &lt;census/ngluingpermsearcher.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NGluingPermSearcher:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NGluingPermSearcher.png" usemap="#regina::NGluingPermSearcher_map" alt=""/>
  <map id="regina::NGluingPermSearcher_map" name="regina::NGluingPermSearcher_map">
<area href="classregina_1_1NGluingPerms.html" title="Represents a specific set of gluing permutations to complement a particular pairwise matching of tetr..." alt="regina::NGluingPerms" shape="rect" coords="110,56,320,80"/>
<area href="classregina_1_1NGenericGluingPerms.html" alt="regina::NGenericGluingPerms&lt; 3 &gt;" shape="rect" coords="110,0,320,24"/>
<area href="classregina_1_1NCompactSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only compact (f..." alt="regina::NCompactSearcher" shape="rect" coords="0,168,210,192"/>
<area href="classregina_1_1NEulerSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when all vertex link..." alt="regina::NEulerSearcher" shape="rect" coords="220,168,430,192"/>
<area href="classregina_1_1NClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed..." alt="regina::NClosedPrimeMinSearcher" shape="rect" coords="0,224,210,248"/>
<area href="classregina_1_1NHyperbolicMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when only minimal id..." alt="regina::NHyperbolicMinSearcher" shape="rect" coords="220,224,430,248"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b4fe1f842f2fbdc4127c19425ab74aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aa">PurgeFlags</a> { <br/>
&#160;&#160;<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaa63d9fc50995427f40ba340a2758c1df7">PURGE_NONE</a> = 0, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaafbbdc0b96694193a77b7de69a933bba0">PURGE_NON_MINIMAL</a> = 1, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaa5e1154ce5cf070cfdc342aad24f8da16">PURGE_NON_PRIME</a> = 2, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaa6088565e664e5fb80ecb14672de9fa4d">PURGE_NON_MINIMAL_PRIME</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaabc030b9b74452791ad59fbf3b06ae070">PURGE_NON_MINIMAL_HYP</a> = 9, 
<a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aaaf94de7a391554268c9ee058a4f932cc3">PURGE_P2_REDUCIBLE</a> = 4
<br/>
 }</td></tr>
<tr class="memdesc:a0b4fe1f842f2fbdc4127c19425ab74aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a> to indicate that our enumeration may (at the discretion of the enumeration algorithm) ignore certain classes of triangulations.  <a href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aa">More...</a><br/></td></tr>
<tr class="separator:a0b4fe1f842f2fbdc4127c19425ab74aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a10a1d95738c175de32cc6ffcb954c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a5a10a1d95738c175de32cc6ffcb954c1">NGluingPermSearcher</a> (const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *pairing, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a5a10a1d95738c175de32cc6ffcb954c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search for gluing permutation sets.  <a href="#a5a10a1d95738c175de32cc6ffcb954c1">More...</a><br/></td></tr>
<tr class="separator:a5a10a1d95738c175de32cc6ffcb954c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb441c5eef0f07ed21cd45eafbda1a5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#acb441c5eef0f07ed21cd45eafbda1a5e">NGluingPermSearcher</a> (std::istream &amp;in, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:acb441c5eef0f07ed21cd45eafbda1a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="#acb441c5eef0f07ed21cd45eafbda1a5e">More...</a><br/></td></tr>
<tr class="separator:acb441c5eef0f07ed21cd45eafbda1a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af742c6671dbda6170b66aab56f75c476"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#af742c6671dbda6170b66aab56f75c476">~NGluingPermSearcher</a> ()</td></tr>
<tr class="memdesc:af742c6671dbda6170b66aab56f75c476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="#af742c6671dbda6170b66aab56f75c476">More...</a><br/></td></tr>
<tr class="separator:af742c6671dbda6170b66aab56f75c476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a4a386a1eb0c1bed660297d9eaa94f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f">runSearch</a> (long maxDepth=-1)</td></tr>
<tr class="memdesc:ac2a4a386a1eb0c1bed660297d9eaa94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="#ac2a4a386a1eb0c1bed660297d9eaa94f">More...</a><br/></td></tr>
<tr class="separator:ac2a4a386a1eb0c1bed660297d9eaa94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b8f3c344454e8a28d090ee3a0977aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a83b8f3c344454e8a28d090ee3a0977aa">completePermSet</a> () const </td></tr>
<tr class="memdesc:a83b8f3c344454e8a28d090ee3a0977aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <a href="#a83b8f3c344454e8a28d090ee3a0977aa">More...</a><br/></td></tr>
<tr class="separator:a83b8f3c344454e8a28d090ee3a0977aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33d56ed2f7a989f7039b53585d07053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#ac33d56ed2f7a989f7039b53585d07053">dumpTaggedData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac33d56ed2f7a989f7039b53585d07053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <a href="#ac33d56ed2f7a989f7039b53585d07053">More...</a><br/></td></tr>
<tr class="separator:ac33d56ed2f7a989f7039b53585d07053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd93ce988d8498b5ddf9b09a0714660"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#abbd93ce988d8498b5ddf9b09a0714660">dumpData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:abbd93ce988d8498b5ddf9b09a0714660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="#abbd93ce988d8498b5ddf9b09a0714660">More...</a><br/></td></tr>
<tr class="separator:abbd93ce988d8498b5ddf9b09a0714660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abed61c4db4c2b3a691d847dd9c19e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPerms.html#a5abed61c4db4c2b3a691d847dd9c19e9">getNumberOfTetrahedra</a> () const </td></tr>
<tr class="memdesc:a5abed61c4db4c2b3a691d847dd9c19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of tetrahedra under consideration.  <a href="#a5abed61c4db4c2b3a691d847dd9c19e9">More...</a><br/></td></tr>
<tr class="separator:a5abed61c4db4c2b3a691d847dd9c19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec77328521bfda984476843059c1c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
<a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPerms.html#afec77328521bfda984476843059c1c13">getFacePairing</a> () const </td></tr>
<tr class="memdesc:afec77328521bfda984476843059c1c13"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of tetrahedron faces that this set of gluing permutations complements.  <a href="#afec77328521bfda984476843059c1c13">More...</a><br/></td></tr>
<tr class="separator:afec77328521bfda984476843059c1c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79e006672da406bd013168589333714"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ad79e006672da406bd013168589333714">inputError</a> () const</td></tr>
<tr class="memdesc:ad79e006672da406bd013168589333714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was an error found during construction from an input stream?  <a href="#ad79e006672da406bd013168589333714">More...</a><br/></td></tr>
<tr class="separator:ad79e006672da406bd013168589333714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7dbf42bf4e74028009acbdd7cc2c98"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#aaf7dbf42bf4e74028009acbdd7cc2c98">size</a> () const</td></tr>
<tr class="memdesc:aaf7dbf42bf4e74028009acbdd7cc2c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of simplices under consideration.  <a href="#aaf7dbf42bf4e74028009acbdd7cc2c98">More...</a><br/></td></tr>
<tr class="separator:aaf7dbf42bf4e74028009acbdd7cc2c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e66510039a93624565943ed42c58a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a75e66510039a93624565943ed42c58a1">facetPairing</a> () const</td></tr>
<tr class="memdesc:a75e66510039a93624565943ed42c58a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="#a75e66510039a93624565943ed42c58a1">More...</a><br/></td></tr>
<tr class="separator:a75e66510039a93624565943ed42c58a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35303fc181f74a7e580a5214048e7e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
<a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ae35303fc181f74a7e580a5214048e7e8">getFacetPairing</a> () const</td></tr>
<tr class="memdesc:ae35303fc181f74a7e580a5214048e7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="#ae35303fc181f74a7e580a5214048e7e8">More...</a><br/></td></tr>
<tr class="separator:ae35303fc181f74a7e580a5214048e7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af680fcfa9cce6eb53ad65a312c7faf2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#af680fcfa9cce6eb53ad65a312c7faf2a">gluingPerm</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:af680fcfa9cce6eb53ad65a312c7faf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="#af680fcfa9cce6eb53ad65a312c7faf2a">More...</a><br/></td></tr>
<tr class="separator:af680fcfa9cce6eb53ad65a312c7faf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283008a625a1e535c244f1ebeeb12da6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a283008a625a1e535c244f1ebeeb12da6">gluingPerm</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:a283008a625a1e535c244f1ebeeb12da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="#a283008a625a1e535c244f1ebeeb12da6">More...</a><br/></td></tr>
<tr class="separator:a283008a625a1e535c244f1ebeeb12da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03494fffaeb8c00bb44c7b224b10fd2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a03494fffaeb8c00bb44c7b224b10fd2d">triangulate</a> () const</td></tr>
<tr class="memdesc:a03494fffaeb8c00bb44c7b224b10fd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing.  <a href="#a03494fffaeb8c00bb44c7b224b10fd2d">More...</a><br/></td></tr>
<tr class="separator:a03494fffaeb8c00bb44c7b224b10fd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2ca8d1402408e4a2df915d16b8a06617"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617">findAllPerms</a> (const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *pairing, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a2ca8d1402408e4a2df915d16b8a06617"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given face pairing.  <a href="#a2ca8d1402408e4a2df915d16b8a06617">More...</a><br/></td></tr>
<tr class="separator:a2ca8d1402408e4a2df915d16b8a06617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a7e9a7e8ef122be71702ae7d32d057"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a49a7e9a7e8ef122be71702ae7d32d057">bestSearcher</a> (const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *pairing, const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a49a7e9a7e8ef122be71702ae7d32d057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <a href="#a49a7e9a7e8ef122be71702ae7d32d057">More...</a><br/></td></tr>
<tr class="separator:a49a7e9a7e8ef122be71702ae7d32d057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80981f59f945b24a8eaccb651786a5b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a80981f59f945b24a8eaccb651786a5b1">readTaggedData</a> (std::istream &amp;in, <a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:a80981f59f945b24a8eaccb651786a5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <a href="#a80981f59f945b24a8eaccb651786a5b1">More...</a><br/></td></tr>
<tr class="separator:a80981f59f945b24a8eaccb651786a5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a16039d81d15978a663240ae1786e83b9"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a16039d81d15978a663240ae1786e83b9">dataTag_</a></td></tr>
<tr class="memdesc:a16039d81d15978a663240ae1786e83b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="#a16039d81d15978a663240ae1786e83b9">More...</a><br/></td></tr>
<tr class="separator:a16039d81d15978a663240ae1786e83b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a706b007b0eb9309ff38ba8b997075d13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a706b007b0eb9309ff38ba8b997075d13">isCanonical</a> () const </td></tr>
<tr class="memdesc:a706b007b0eb9309ff38ba8b997075d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <a href="#a706b007b0eb9309ff38ba8b997075d13">More...</a><br/></td></tr>
<tr class="separator:a706b007b0eb9309ff38ba8b997075d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc06b496569b99c7af9ee212404721d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a8fc06b496569b99c7af9ee212404721d">badEdgeLink</a> (const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;face) const </td></tr>
<tr class="memdesc:a8fc06b496569b99c7af9ee212404721d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse.  <a href="#a8fc06b496569b99c7af9ee212404721d">More...</a><br/></td></tr>
<tr class="separator:a8fc06b496569b99c7af9ee212404721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a898776fe549e432c8a043c7205d37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a63a898776fe549e432c8a043c7205d37">lowDegreeEdge</a> (const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;face, bool testDegree12, bool testDegree3) const </td></tr>
<tr class="memdesc:a63a898776fe549e432c8a043c7205d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with a low degree edge.  <a href="#a63a898776fe549e432c8a043c7205d37">More...</a><br/></td></tr>
<tr class="separator:a63a898776fe549e432c8a043c7205d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730f3a1f438c12292c6bb5411f1072ae"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a730f3a1f438c12292c6bb5411f1072ae">dataTag</a> () const </td></tr>
<tr class="memdesc:a730f3a1f438c12292c6bb5411f1072ae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="#a730f3a1f438c12292c6bb5411f1072ae">More...</a><br/></td></tr>
<tr class="separator:a730f3a1f438c12292c6bb5411f1072ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005b64550034c2217fe588e294f83445"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a005b64550034c2217fe588e294f83445">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a005b64550034c2217fe588e294f83445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a005b64550034c2217fe588e294f83445">More...</a><br/></td></tr>
<tr class="separator:a005b64550034c2217fe588e294f83445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b613e89df2b6518444e04324f517f51"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a7b613e89df2b6518444e04324f517f51">permIndex</a> (unsigned simp, unsigned facet)</td></tr>
<tr class="memdesc:a7b613e89df2b6518444e04324f517f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a7b613e89df2b6518444e04324f517f51">More...</a><br/></td></tr>
<tr class="separator:a7b613e89df2b6518444e04324f517f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5466d31fbc67dd6178955f7ba601bc58"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a5466d31fbc67dd6178955f7ba601bc58">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source) const</td></tr>
<tr class="memdesc:a5466d31fbc67dd6178955f7ba601bc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a5466d31fbc67dd6178955f7ba601bc58">More...</a><br/></td></tr>
<tr class="separator:a5466d31fbc67dd6178955f7ba601bc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d888f9d8d547441b6f97e1afe9bc9d1"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a5d888f9d8d547441b6f97e1afe9bc9d1">permIndex</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:a5d888f9d8d547441b6f97e1afe9bc9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="#a5d888f9d8d547441b6f97e1afe9bc9d1">More...</a><br/></td></tr>
<tr class="separator:a5d888f9d8d547441b6f97e1afe9bc9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0884253496c28e84b35cee6c9defeddb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a0884253496c28e84b35cee6c9defeddb">gluingToIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:a0884253496c28e84b35cee6c9defeddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#a0884253496c28e84b35cee6c9defeddb">More...</a><br/></td></tr>
<tr class="separator:a0884253496c28e84b35cee6c9defeddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad063468f01d955ed752ac96355ca3e16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ad063468f01d955ed752ac96355ca3e16">gluingToIndex</a> (unsigned simp, unsigned facet, const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:ad063468f01d955ed752ac96355ca3e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="#ad063468f01d955ed752ac96355ca3e16">More...</a><br/></td></tr>
<tr class="separator:ad063468f01d955ed752ac96355ca3e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47522122be0817a6deaf1f70dc4c493e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a47522122be0817a6deaf1f70dc4c493e">indexToGluing</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;source, int index) const</td></tr>
<tr class="memdesc:a47522122be0817a6deaf1f70dc4c493e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1.  <a href="#a47522122be0817a6deaf1f70dc4c493e">More...</a><br/></td></tr>
<tr class="separator:a47522122be0817a6deaf1f70dc4c493e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c47cfac4faf305d3f7fc9523d13c1a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a7c47cfac4faf305d3f7fc9523d13c1a5">indexToGluing</a> (unsigned simp, unsigned facet, int index) const</td></tr>
<tr class="memdesc:a7c47cfac4faf305d3f7fc9523d13c1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1.  <a href="#a7c47cfac4faf305d3f7fc9523d13c1a5">More...</a><br/></td></tr>
<tr class="separator:a7c47cfac4faf305d3f7fc9523d13c1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad8e1d796fc14435bda8efbac2b33861d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#ad8e1d796fc14435bda8efbac2b33861d">autos_</a></td></tr>
<tr class="memdesc:ad8e1d796fc14435bda8efbac2b33861d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <a href="#ad8e1d796fc14435bda8efbac2b33861d">More...</a><br/></td></tr>
<tr class="separator:ad8e1d796fc14435bda8efbac2b33861d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c31c8d63273120ba78fabd59d1b9592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a5c31c8d63273120ba78fabd59d1b9592">autosNew</a></td></tr>
<tr class="memdesc:a5c31c8d63273120ba78fabd59d1b9592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)?  <a href="#a5c31c8d63273120ba78fabd59d1b9592">More...</a><br/></td></tr>
<tr class="separator:a5c31c8d63273120ba78fabd59d1b9592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcecf9deb5b145b1a0ba78ada59c42a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#afcecf9deb5b145b1a0ba78ada59c42a1">orientableOnly_</a></td></tr>
<tr class="memdesc:afcecf9deb5b145b1a0ba78ada59c42a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <a href="#afcecf9deb5b145b1a0ba78ada59c42a1">More...</a><br/></td></tr>
<tr class="separator:afcecf9deb5b145b1a0ba78ada59c42a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac196b3dbc150dea2572b000c189cd3fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#ac196b3dbc150dea2572b000c189cd3fc">finiteOnly_</a></td></tr>
<tr class="memdesc:ac196b3dbc150dea2572b000c189cd3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to finite triangulations?  <a href="#ac196b3dbc150dea2572b000c189cd3fc">More...</a><br/></td></tr>
<tr class="separator:ac196b3dbc150dea2572b000c189cd3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33937a8b2d37b296c028fd23fc80d55b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a33937a8b2d37b296c028fd23fc80d55b">whichPurge_</a></td></tr>
<tr class="memdesc:a33937a8b2d37b296c028fd23fc80d55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are there any types of triangulation that we may optionally avoid constructing? This should be a bitwise OR of constants from the PurgeFlags enumeration.  <a href="#a33937a8b2d37b296c028fd23fc80d55b">More...</a><br/></td></tr>
<tr class="separator:a33937a8b2d37b296c028fd23fc80d55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6ec032a1dbfde1b376ad64e9ae3191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#acd6ec032a1dbfde1b376ad64e9ae3191">use_</a></td></tr>
<tr class="memdesc:acd6ec032a1dbfde1b376ad64e9ae3191"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to call each time a gluing permutation set is found during the search.  <a href="#acd6ec032a1dbfde1b376ad64e9ae3191">More...</a><br/></td></tr>
<tr class="separator:acd6ec032a1dbfde1b376ad64e9ae3191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9416290ea2bd8dda6067550f4e2c09"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a9e9416290ea2bd8dda6067550f4e2c09">useArgs_</a></td></tr>
<tr class="memdesc:a9e9416290ea2bd8dda6067550f4e2c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine.  <a href="#a9e9416290ea2bd8dda6067550f4e2c09">More...</a><br/></td></tr>
<tr class="separator:a9e9416290ea2bd8dda6067550f4e2c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94c5ed7eca9105ca5c0e9305a612f0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#af94c5ed7eca9105ca5c0e9305a612f0d">started</a></td></tr>
<tr class="memdesc:af94c5ed7eca9105ca5c0e9305a612f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <a href="#af94c5ed7eca9105ca5c0e9305a612f0d">More...</a><br/></td></tr>
<tr class="separator:af94c5ed7eca9105ca5c0e9305a612f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7624c6d0d928fecde27b515ee7ff792a"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a7624c6d0d928fecde27b515ee7ff792a">orientation</a></td></tr>
<tr class="memdesc:a7624c6d0d928fecde27b515ee7ff792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each tetrahedron in the underlying triangulation.  <a href="#a7624c6d0d928fecde27b515ee7ff792a">More...</a><br/></td></tr>
<tr class="separator:a7624c6d0d928fecde27b515ee7ff792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2318c6a68fd1c8f8f8c75bdb32d7d3de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a2318c6a68fd1c8f8f8c75bdb32d7d3de">order</a></td></tr>
<tr class="memdesc:a2318c6a68fd1c8f8f8c75bdb32d7d3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to faces.  <a href="#a2318c6a68fd1c8f8f8c75bdb32d7d3de">More...</a><br/></td></tr>
<tr class="separator:a2318c6a68fd1c8f8f8c75bdb32d7d3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875ddbcdf6e391c09e811886003e3566"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a875ddbcdf6e391c09e811886003e3566">orderSize</a></td></tr>
<tr class="memdesc:a875ddbcdf6e391c09e811886003e3566"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array.  <a href="#a875ddbcdf6e391c09e811886003e3566">More...</a><br/></td></tr>
<tr class="separator:a875ddbcdf6e391c09e811886003e3566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d5c90d38ffc1d63212f21e79fb710b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGluingPermSearcher.html#a24d5c90d38ffc1d63212f21e79fb710b">orderElt</a></td></tr>
<tr class="memdesc:a24d5c90d38ffc1d63212f21e79fb710b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <a href="#a24d5c90d38ffc1d63212f21e79fb710b">More...</a><br/></td></tr>
<tr class="separator:a24d5c90d38ffc1d63212f21e79fb710b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860718c9bfd69ee9580ed59fa1011d2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ae860718c9bfd69ee9580ed59fa1011d2">pairing_</a></td></tr>
<tr class="memdesc:ae860718c9bfd69ee9580ed59fa1011d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet pairing that this permutation set complements.  <a href="#ae860718c9bfd69ee9580ed59fa1011d2">More...</a><br/></td></tr>
<tr class="separator:ae860718c9bfd69ee9580ed59fa1011d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae099e06f91c89942ff8bb69071a5b067"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#ae099e06f91c89942ff8bb69071a5b067">permIndices_</a></td></tr>
<tr class="memdesc:ae099e06f91c89942ff8bb69071a5b067"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index into array NPerm&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner.  <a href="#ae099e06f91c89942ff8bb69071a5b067">More...</a><br/></td></tr>
<tr class="separator:ae099e06f91c89942ff8bb69071a5b067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df279bd42b9f49e8527774aabf3f6f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NGenericGluingPerms.html#a4df279bd42b9f49e8527774aabf3f6f7">inputError_</a></td></tr>
<tr class="memdesc:a4df279bd42b9f49e8527774aabf3f6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has an error occurred during construction from an input stream?  <a href="#a4df279bd42b9f49e8527774aabf3f6f7">More...</a><br/></td></tr>
<tr class="separator:a4df279bd42b9f49e8527774aabf3f6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class for searching through all possible gluing permutation sets that correspond to a given tetrahedron face pairing. </p>
<p>Subclasses of <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> correspond to specialised (and heavily optimised) search algorithms that may be used in sufficiently constrained scenarios. The main class <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> offers a default (but slower) search algorithm that may be used in more general contexts.</p>
<p>The simplest way of performing a search through all possible gluing permutations is by calling the static method <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>. This will examine the search parameters and ensure that the best possible algorithm is used. For finer control over the program flow, the static method <a class="el" href="classregina_1_1NGluingPermSearcher.html#a49a7e9a7e8ef122be71702ae7d32d057" title="Constructs a search manager of the best possible class for the given search parameters.">bestSearcher()</a> can be used to create a search manager of the most suitable class and then <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> can be called on this object directly. For absolute control, a specific algorithm can be forced by explicitly constructing an object of the corresponding class (and again calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on that object directly).</p>
<p>Note that this class derives from <a class="el" href="classregina_1_1NGluingPerms.html" title="Represents a specific set of gluing permutations to complement a particular pairwise matching of tetr...">NGluingPerms</a>. The search will involve building and repeatedly modifying the inherited <a class="el" href="classregina_1_1NGluingPerms.html" title="Represents a specific set of gluing permutations to complement a particular pairwise matching of tetr...">NGluingPerms</a> data in-place.</p>
<dl class="section user"><dt>Python:</dt><dd>Only the PurgeFlags enumeration from this class is present, and the PurgeFlags constants are also made directly available through the regina namespace. Therefore there is no need to explicitly access the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> through Python. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1NGluingPermSearcher.html#a0b4fe1f842f2fbdc4127c19425ab74aa">regina::NGluingPermSearcher::PurgeFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a> to indicate that our enumeration may (at the discretion of the enumeration algorithm) ignore certain classes of triangulations. </p>
<p>These flags can be combined using bitwise OR.</p>
<p>See the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor documentation for further details on how these flags are used.</p>
<dl class="section user"><dt>Python:</dt><dd>For convenience, these constants are also made available directly in Python's regina namespace. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaa63d9fc50995427f40ba340a2758c1df7"></a>PURGE_NONE</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that no triangulations should be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaafbbdc0b96694193a77b7de69a933bba0"></a>PURGE_NON_MINIMAL</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that non-minimal triangulations may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaa5e1154ce5cf070cfdc342aad24f8da16"></a>PURGE_NON_PRIME</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation that is not prime (i.e., can be written as a non-trivial connected sum) and any bounded triangulation that is reducible over a disc may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaa6088565e664e5fb80ecb14672de9fa4d"></a>PURGE_NON_MINIMAL_PRIME</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation that is not prime (i.e., can be written as a non-trivial connected sum), any bounded triangulation that is reducible over a disc and any triangulation that is non-minimal may be ignored. </p>
<p>Note that this is simply a combination of the constants <em>PURGE_NON_MINIMAL</em> and <em>PURGE_NON_PRIME</em>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaabc030b9b74452791ad59fbf3b06ae070"></a>PURGE_NON_MINIMAL_HYP</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation that is not a minimal ideal triangulation of a cusped finite-volume hyperbolic 3-manifold may be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a0b4fe1f842f2fbdc4127c19425ab74aaaf94de7a391554268c9ee058a4f932cc3"></a>PURGE_P2_REDUCIBLE</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that any triangulation containing an embedded two-sided projective plane may be ignored. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5a10a1d95738c175de32cc6ffcb954c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NGluingPermSearcher::NGluingPermSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search for gluing permutation sets. </p>
<p>The search is started by calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>. Note that the static method <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> handles both construction and searching, and is the preferred entry point for end users.</p>
<p>The arguments to this constructor describe the search parameters in detail, as well as what should be done with each gluing permutation set that is found.</p>
<p>Parameter <em>whichPurge</em> may be used to avoid constructing permutation sets that correspond to triangulations satisfying certain constraints (such as non-minimality). The use of this parameter, combined with parameters <em>orientableOnly</em> and <em>finiteOnly</em>, can significantly speed up the permutation set generation. For some combinations of these parameters entirely different algorithms are used.</p>
<p>Note that not all permutation sets described by parameter <em>whichPurge</em> will be avoided (i.e., you may get gluing permutation sets that you did not want). It is guaranteed however that every permutation set whose corresonding triangulation does <em>not</em> satisfy the <em>whichPurge</em> constraints will be generated.</p>
<p>Similarly, even if <em>finiteOnly</em> is set to <code>true</code>, some non-finite triangulations might still slip through the net (since the full vertex links are not always constructed). However, like <em>whichPurge</em>, setting <em>finiteOnly</em> to <code>true</code> allow the census algorithm to take shortcuts and therefore run faster. The resulting triangulations may be tested for finiteness (and other properties) by calling <a class="el" href="classregina_1_1NGenericGluingPerms.html#a03494fffaeb8c00bb44c7b224b10fd2d" title="Returns a newly created triangulation as modelled by this set of gluing permutations and the associat...">triangulate()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">NFacePairing::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">NFacePairing::findAllPairings()</a> are of this form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the specific pairing of tetrahedron faces that the generated permutation sets will complement. </td></tr>
    <tr><td class="paramname">autos</td><td>the collection of isomorphisms that define equivalence of permutation sets. These are used by <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>, which produces each permutation set precisely once up to equivalence. These isomorphisms must all be automorphisms of the given face pairing, and will generally be the set of all such automorphisms. This parameter may be 0, in which case the set of all automorphisms of the given face pairing will be generated and used. </td></tr>
    <tr><td class="paramname">orientableOnly</td><td><code>true</code> if only gluing permutations corresponding to orientable triangulations should be generated, or <code>false</code> if no such restriction should be imposed. </td></tr>
    <tr><td class="paramname">finiteOnly</td><td><code>true</code> if only gluing permutations corresponding to finite triangulations are required, or <code>false</code> if there is no such requirement. Note that regardless of this value, some non-finite triangulations might still be produced; see the notes above for details. </td></tr>
    <tr><td class="paramname">whichPurge</td><td>specifies which permutation sets we may avoid constructing (see the function notes above for details). This should be a bitwise OR of constants from the PurgeFlags enumeration, or 0 if we should simply generate every possible permutation set. If a variety of purge constants are bitwise ORed together, a permutation set whose triangulation satisfies <em>any</em> of these constraints may be avoided. Note that not all such permutation sets will be avoided, but enough are avoided that the performance increase is noticeable. </td></tr>
    <tr><td class="paramname">use</td><td>the function to call upon each permutation set that is found. The first parameter passed to this function will be a gluing permutation set. The second parameter will be parameter <em>useArgs</em> as was passed to this routine. </td></tr>
    <tr><td class="paramname">useArgs</td><td>the pointer to pass as the final parameter for the function <em>use</em> which will be called upon each permutation set found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb441c5eef0f07ed21cd45eafbda1a5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NGluingPermSearcher::NGluingPermSearcher </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises a new search manager based on data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>This routine reads data in the format written by <a class="el" href="classregina_1_1NGluingPermSearcher.html#abbd93ce988d8498b5ddf9b09a0714660" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a>. If you wish to read data whose precise class is unknown, consider using <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac33d56ed2f7a989f7039b53585d07053" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a> and <a class="el" href="classregina_1_1NGluingPermSearcher.html#a80981f59f945b24a8eaccb651786a5b1" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> instead.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, the routine <a class="el" href="classregina_1_1NGenericGluingPerms.html#ad79e006672da406bd013168589333714" title="Was an error found during construction from an input stream?">inputError()</a> will return <code>true</code> but the contents of this object will be otherwise undefined.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
    <tr><td class="paramname">use</td><td>as for the main <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor. </td></tr>
    <tr><td class="paramname">useArgs</td><td>as for the main <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af742c6671dbda6170b66aab56f75c476"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::NGluingPermSearcher::~NGluingPermSearcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this search manager and all supporting data structures. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8fc06b496569b99c7af9ee212404721d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::badEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse. </p>
<p>Note that such edges can only occur in non-orientable triangulations.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<p>If <em>finiteOnly_</em> is <code>true</code> in the search criteria, additional tests will be run that can eliminate triangulations with non-orientable vertex links. Although these tests are not searching for bad edge links per se, they can be performed within this routine with very little additional work needing to be done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to an edge identified with itself in reverse, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a class="anchor" id="a49a7e9a7e8ef122be71702ae7d32d057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a>* regina::NGluingPermSearcher::bestSearcher </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a search manager of the best possible class for the given search parameters. </p>
<p>Different subclasses of <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> provide optimised search algorithms for different types of search.</p>
<p>Calling this routine and then calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on the result has the same effect as the all-in-one routine <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>. Unless you have specialised requirements (such as partial searching), you are probably better calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a> instead.</p>
<p>The resulting object is newly created, and must be destroyed by the caller of this routine.</p>
<p>See the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor for documentation on the arguments to this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">NFacePairing::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">NFacePairing::findAllPairings()</a> are of this form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created search manager. </dd></dl>

</div>
</div>
<a class="anchor" id="a83b8f3c344454e8a28d090ee3a0977aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::completePermSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state. </p>
<p>This may assist the <em>use_</em> routine when running partial depth-based searches. See <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a complete gluing permutation set is held, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a730f3a1f438c12292c6bb5411f1072ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char regina::NGluingPermSearcher::dataTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format. </p>
<dl class="section return"><dt>Returns</dt><dd>the class tag. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NHyperbolicMinSearcher.html#a3206903e961664ada967335898dd561b">regina::NHyperbolicMinSearcher</a>, <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a3b1ecf7d778a7b57c17ae5d74f572576">regina::NClosedPrimeMinSearcher</a>, <a class="el" href="classregina_1_1NCompactSearcher.html#ab94b9c6bd819c134e498338406b8e8fa">regina::NCompactSearcher</a>, and <a class="el" href="classregina_1_1NEulerSearcher.html#a8431f06a3b1e6ace24912fef04935f35">regina::NEulerSearcher</a>.</p>

</div>
</div>
<a class="anchor" id="abbd93ce988d8498b5ddf9b09a0714660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NGluingPermSearcher::dumpData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format to the given output stream. </p>
<p>This object can be recreated from this text data by calling the input stream constructor for this class.</p>
<p>This routine may be useful for transferring objects from one processor to another.</p>
<p>Note that subclass data is written after superclass data, so it is safe to dump data from a subclass and then recreate a new superclass object from that data (though subclass-specific information will of course be lost).</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NGenericGluingPerms.html#a1bfca1c3bdc4369f521b938867954111">regina::NGenericGluingPerms&lt; 3 &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classregina_1_1NHyperbolicMinSearcher.html#afc77adc8dc94d7707d2ac96e9550b808">regina::NHyperbolicMinSearcher</a>, <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a2988ec8d2deb1938feb5e48c607e951b">regina::NClosedPrimeMinSearcher</a>, <a class="el" href="classregina_1_1NCompactSearcher.html#a14854a0adb0910c8be33949c82bcab59">regina::NCompactSearcher</a>, and <a class="el" href="classregina_1_1NEulerSearcher.html#ae00687bb6988996fccc578352c18c666">regina::NEulerSearcher</a>.</p>

</div>
</div>
<a class="anchor" id="ac33d56ed2f7a989f7039b53585d07053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NGluingPermSearcher::dumpTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to. </p>
<p>This routine can be used with <a class="el" href="classregina_1_1NGluingPermSearcher.html#a80981f59f945b24a8eaccb651786a5b1" title="Creates a new search manager based on tagged data read from the given input stream.">readTaggedData()</a> to transport objects from place to place whose precise class is unknown.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the data should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75e66510039a93624565943ed42c58a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::facetPairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding simplex facet pairing. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca8d1402408e4a2df915d16b8a06617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::NGluingPermSearcher::findAllPerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> *&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a> *&#160;</td>
          <td class="paramname"><em>autos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientableOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>finiteOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>whichPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The main entry routine for running a search for all gluing permutation sets that complement a given face pairing. </p>
<p>This routine examines the search parameters, chooses the best possible search algorithm, constructs an object of the corresponding subclass of <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> and then calls <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a>.</p>
<p>See the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor for documentation on the arguments to this routine. See the <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> method for documentation on how the search runs and returns its results.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given face pairing is connected, i.e., it is possible to reach any tetrahedron from any other tetrahedron via a series of matched face pairs. </dd>
<dd>
The given face pairing is in canonical form as described by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a49fd05547a2a2d5424ec6a02416cb525" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">NFacePairing::isCanonical()</a>. Note that all face pairings constructed by <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a772451072af1e4e27c39115688d79ced" title="Generates all possible facet pairings satisfying the given constraints.">NFacePairing::findAllPairings()</a> are of this form. </dd></dl>

</div>
</div>
<a class="anchor" id="afec77328521bfda984476843059c1c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__triangulation.html#ga8f7856ba44367811dafd267d9f9e8f1f">NFacePairing</a> * regina::NGluingPerms::getFacePairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of tetrahedron faces that this set of gluing permutations complements. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NGenericGluingPerms.html#a75e66510039a93624565943ed42c58a1" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements...">facetPairing()</a>. This old name has been kept for backward compatibility, but will be removed in some future version of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding tetrahedron face pairing. </dd></dl>

</div>
</div>
<a class="anchor" id="ae35303fc181f74a7e580a5214048e7e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::getFacetPairing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000085">Deprecated:</a></b></dt><dd>This routine has been renamed to facetPairing(). See the facetPairing() documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a5abed61c4db4c2b3a691d847dd9c19e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NGluingPerms::getNumberOfTetrahedra </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of tetrahedra under consideration. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NGenericGluingPerms.html#aaf7dbf42bf4e74028009acbdd7cc2c98" title="Returns the total number of simplices under consideration.">size()</a>. This old name has been kept for backward compatibility, but will be removed in some future version of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra under consideration. </dd></dl>

</div>
</div>
<a class="anchor" id="af680fcfa9cce6eb53ad65a312c7faf2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine facetPairing()). </dd>
<dd>
The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a283008a625a1e535c244f1ebeeb12da6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine facetPairing()).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a class="anchor" id="a0884253496c28e84b35cee6c9defeddb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into NPerm&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="ad063468f01d955ed752ac96355ca3e16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into NPerm&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into NPerm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="a47522122be0817a6deaf1f70dc4c493e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1. </p>
<p>This index into NPerm&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">index</td><td>an index into NPerm&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into NPerm&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c47cfac4faf305d3f7fc9523d13c1a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPerm.html">NPerm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array NPerm&lt;dim+1&gt;::Sn_1. </p>
<p>This index into NPerm&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array NPerm&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>an index into NPerm&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into NPerm&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a class="anchor" id="ad79e006672da406bd013168589333714"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::inputError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was an error found during construction from an input stream? </p>
<p>This routine returns <code>true</code> if an input stream constructor was used to create this object but the data in the input stream was invalid or incorrectly formatted.</p>
<p>If a different constructor was called (i.e., no input stream was used), then this routine will always return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an error occurred during construction from an input stream, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a706b007b0eb9309ff38ba8b997075d13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the current set is in canonical form, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a63a898776fe549e432c8a043c7205d37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::lowDegreeEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDegree12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>testDegree3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the permutations already constructed model a triangulation with a low degree edge. </p>
<p>Precisely which types of low degree edges are identified must be specified through parameters <em>testDegree12</em> and <em>testDegree3</em>.</p>
<p>Tests that do not refer to the gluing permutation for the given face will not be run.</p>
<p>This routine is not fussy about the order in which gluing permutations are selected, as long as permutations not yet selected have the corresponding element of permIndices[] set to -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the specific tetrahedron face upon which tests will be based. </td></tr>
    <tr><td class="paramname">testDegree12</td><td><code>true</code> if we should test for non-boundary edges of degree 1 or 2. </td></tr>
    <tr><td class="paramname">testDegree3</td><td><code>true</code> if we should test for non-boundary edges of degree 3 involving three distinct tetrahedra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the permutations under construction will lead to a low-degree edge as specified by parameters <em>testDegree12</em> and <em>testDegree3</em>, or <code>false</code> if no such edge is found. </dd></dl>

</div>
</div>
<a class="anchor" id="a005b64550034c2217fe588e294f83445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b613e89df2b6518444e04324f517f51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a5466d31fbc67dd6178955f7ba601bc58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d888f9d8d547441b6f97e1afe9bc9d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int&amp; <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index into array NPerm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine gluingPerm().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a class="anchor" id="a80981f59f945b24a8eaccb651786a5b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NGluingPermSearcher.html">NGluingPermSearcher</a>* regina::NGluingPermSearcher::readTaggedData </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new search manager based on tagged data read from the given input stream. </p>
<p>This may be a new search or a partially completed search.</p>
<p>The tagged data should be in the format written by <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac33d56ed2f7a989f7039b53585d07053" title="Dumps all internal data in a plain text format, along with a marker to signify which precise class th...">dumpTaggedData()</a>. The precise class of the search manager will be determined from the tagged data, and does not need to be known in advance. This is in contrast to <a class="el" href="classregina_1_1NGluingPermSearcher.html#abbd93ce988d8498b5ddf9b09a0714660" title="Dumps all internal data in a plain text format to the given output stream.">dumpData()</a> and the input stream constructors, where the class of the data being read must be known at compile time.</p>
<p>If the data found in the input stream is invalid or incorrectly formatted, a null pointer will be returned. Otherwise a newly constructed search manager will be returned, and it is the responsibility of the caller of this routine to destroy it after use.</p>
<p>The arguments <em>use</em> and <em>useArgs</em> are the same as for the <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> constructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>The data format is liable to change between Regina releases. Data in this format should be used on a short-term temporary basis only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream from which to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2a4a386a1eb0c1bed660297d9eaa94f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NGluingPermSearcher::runSearch </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>maxDepth</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible gluing permutation sets that satisfy the current search criteria. </p>
<p>The search criteria are specified in the class constructor, or through the static method <a class="el" href="classregina_1_1NGluingPermSearcher.html#a2ca8d1402408e4a2df915d16b8a06617" title="The main entry routine for running a search for all gluing permutation sets that complement a given f...">findAllPerms()</a>.</p>
<p>Each set of gluing permutations will be produced precisely once up to equivalence, where equivalence is defined by the given set of automorphisms of the given face pairing.</p>
<p>For each permutation set that is generated, routine <em>use_</em> (as passed to the class constructor) will be called with that permutation set as an argument.</p>
<p>Once the generation of permutation sets has finished, routine <em>use_</em> will be called once more, this time with <code>null</code> as its first (permutation set) argument.</p>
<p>Subclasses corresponding to more specialised search criteria should override this routine to use a better optimised algorithm where possible.</p>
<p>It is possible to run only a partial search, branching to a given depth but no further. In this case, rather than producing complete gluing permutation sets, the search will produce a series of partially-complete <a class="el" href="classregina_1_1NGluingPermSearcher.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given...">NGluingPermSearcher</a> objects. These partial searches may then be restarted by calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> once more (usually after being frozen or passed on to a different processor). If necessary, the <em>use_</em> routine may call <a class="el" href="classregina_1_1NGluingPermSearcher.html#a83b8f3c344454e8a28d090ee3a0977aa" title="Determines whether this search manager holds a complete gluing permutation set or just a partially co...">completePermSet()</a> to distinguish between a complete set of gluing permutations and a partial search state.</p>
<p>Note that a restarted search will never drop below its initial depth. That is, calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> with a fixed depth can be used to subdivide the overall search space into many branches, and then calling <a class="el" href="classregina_1_1NGluingPermSearcher.html#ac2a4a386a1eb0c1bed660297d9eaa94f" title="Generates all possible gluing permutation sets that satisfy the current search criteria.">runSearch()</a> on each resulting partial search will complete each of these branches without overlap.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd><em>Feature:</em> Allow cancellation of permutation set generation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxDepth</td><td>the depth of the partial search to run, or a negative number if a full search should be run (the default). </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NHyperbolicMinSearcher.html#a7f597ab3809ffc289f98567dce3758e2">regina::NHyperbolicMinSearcher</a>, <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html#a0c4cd23c2e9ff5f4c50d79406dfcd8c7">regina::NClosedPrimeMinSearcher</a>, <a class="el" href="classregina_1_1NCompactSearcher.html#a92c0e8398a0a1ece7408254f2bf75a60">regina::NCompactSearcher</a>, and <a class="el" href="classregina_1_1NEulerSearcher.html#a7bda1b180433944a8433ef49dab08b93">regina::NEulerSearcher</a>.</p>

</div>
</div>
<a class="anchor" id="aaf7dbf42bf4e74028009acbdd7cc2c98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of simplices under consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a class="anchor" id="a03494fffaeb8c00bb44c7b224b10fd2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing. </p>
<p>Each matched pair of facets and their associated permutations will be realised as two simplex facets in the triangulation glued together with the corresponding gluing permutation. Each unmatched facet will be realised as a boundary facet in the triangulation.</p>
<p>It is the responsibility of the caller of this routine to delete this triangulation once it is no longer required.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created triangulation modelled by this structure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad8e1d796fc14435bda8efbac2b33861d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html#a29c1d0f565e50aa76cfca68714347533">NFacePairing::IsoList</a>* regina::NGluingPermSearcher::autos_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The set of isomorphisms that define equivalence of gluing permutation sets. </p>
<p>Generally this is the set of all automorphisms of the underlying face pairing. </p>

</div>
</div>
<a class="anchor" id="a5c31c8d63273120ba78fabd59d1b9592"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::autosNew</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)? </p>

</div>
</div>
<a class="anchor" id="a16039d81d15978a663240ae1786e83b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::NGluingPermSearcher::dataTag_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A character used to identify this class when reading and writing tagged data in text format. </p>

</div>
</div>
<a class="anchor" id="ac196b3dbc150dea2572b000c189cd3fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::finiteOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to finite triangulations? </p>

</div>
</div>
<a class="anchor" id="a4df279bd42b9f49e8527774aabf3f6f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::inputError_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has an error occurred during construction from an input stream? </p>

</div>
</div>
<a class="anchor" id="a2318c6a68fd1c8f8f8c75bdb32d7d3de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#ga5d7efda7dff99a8a422a75e1bc2ca5d6">NTetFace</a>* regina::NGluingPermSearcher::order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes the order in which gluing permutations are assigned to faces. </p>
<p>Specifically, this order is order[0], order[1], ..., order[orderSize-1].</p>
<p>Note that each element of this array corresponds to a single edge of the underlying face pairing graph, which in turn represents a tetrahedron face and its image under the given face pairing.</p>
<p>The specific tetrahedron face stored in this array for each edge of the underlying face pairing graph will be the smaller of the two identified tetrahedron faces (unless otherwise specified for a particular edge type; see <a class="el" href="classregina_1_1NClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">NClosedPrimeMinSearcher</a> for examples). </p>

</div>
</div>
<a class="anchor" id="a24d5c90d38ffc1d63212f21e79fb710b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NGluingPermSearcher::orderElt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks which element of order[] we are currently examining at this stage of the search. </p>

</div>
</div>
<a class="anchor" id="a875ddbcdf6e391c09e811886003e3566"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NGluingPermSearcher::orderSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array. </p>

</div>
</div>
<a class="anchor" id="afcecf9deb5b145b1a0ba78ada59c42a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::orientableOnly_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are we only searching for gluing permutations that correspond to orientable triangulations? </p>

</div>
</div>
<a class="anchor" id="a7624c6d0d928fecde27b515ee7ff792a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* regina::NGluingPermSearcher::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the orientation of each tetrahedron in the underlying triangulation. </p>
<p>Orientation is positive/negative, or 0 if unknown. Note that in some algorithms the orientation is simply +/-1, and in some algorithms the orientation counts forwards or backwards from 0 according to how many times the orientation has been set or verified. </p>

</div>
</div>
<a class="anchor" id="ae860718c9bfd69ee9580ed59fa1011d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::pairing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The facet pairing that this permutation set complements. </p>
<p>This is guaranteed to be the minimal representative of its facet pairing isomorphism class. </p>

</div>
</div>
<a class="anchor" id="ae099e06f91c89942ff8bb69071a5b067"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1NGenericGluingPerms.html">regina::NGenericGluingPerms</a>&lt; dim &gt;::permIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index into array NPerm&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner. </p>
<p>Note that this is not a gluing permutation as such but rather a permutation of 0,...,<em>dim-1</em> only (see the routines gluingToIndex() and indexToGluing() for conversions). If a permutation has not yet been selected (e.g., if this permutation set is still under construction) then this index is -1. </p>

</div>
</div>
<a class="anchor" id="af94c5ed7eca9105ca5c0e9305a612f0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NGluingPermSearcher::started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search. </p>

</div>
</div>
<a class="anchor" id="acd6ec032a1dbfde1b376ad64e9ae3191"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__census.html#gac5925ac4ae59f01c975987cd90e827dd">UseGluingPerms</a> regina::NGluingPermSearcher::use_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to call each time a gluing permutation set is found during the search. </p>

</div>
</div>
<a class="anchor" id="a9e9416290ea2bd8dda6067550f4e2c09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* regina::NGluingPermSearcher::useArgs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine. </p>

</div>
</div>
<a class="anchor" id="a33937a8b2d37b296c028fd23fc80d55b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::NGluingPermSearcher::whichPurge_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are there any types of triangulation that we may optionally avoid constructing? This should be a bitwise OR of constants from the PurgeFlags enumeration. </p>
<p>See the constructor documentation for further details on this search parameter. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="ngluingpermsearcher_8h.html">ngluingpermsearcher.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
