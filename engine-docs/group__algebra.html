<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Algebraic Structures</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Algebraic Structures</div>  </div>
</div><!--header-->
<div class="contents">

<p>Various algebraic structures.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html">regina::AbelianGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a finitely generated abelian group.  <a href="classregina_1_1AbelianGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1GroupExpressionTerm.html">regina::GroupExpressionTerm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a power of a generator in a group presentation.  <a href="structregina_1_1GroupExpressionTerm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html">regina::GroupExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an expression involving generators from a group presentation or a free group.  <a href="classregina_1_1GroupExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupPresentation.html">regina::GroupPresentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a finite presentation of a group.  <a href="classregina_1_1GroupPresentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomGroupPresentation.html">regina::HomGroupPresentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a homomorphism between groups which are described via finite presentations.  <a href="classregina_1_1HomGroupPresentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedAbelianGroup.html">regina::MarkedAbelianGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a finitely generated abelian group given by a chain complex.  <a href="classregina_1_1MarkedAbelianGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">regina::HomMarkedAbelianGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a homomorphism of finitely generated abelian groups.  <a href="classregina_1_1HomMarkedAbelianGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLAbelianGroupReader.html">regina::XMLAbelianGroupReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads a single abelian group.  <a href="classregina_1_1XMLAbelianGroupReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLGroupPresentationReader.html">regina::XMLGroupPresentationReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads a single group presentation.  <a href="classregina_1_1XMLGroupPresentationReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga662fd6697ca03b1b0e4f6173f4c729af"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga662fd6697ca03b1b0e4f6173f4c729af">regina::NAbelianGroup</a></td></tr>
<tr class="memdesc:ga662fd6697ca03b1b0e4f6173f4c729af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__algebra.html#ga662fd6697ca03b1b0e4f6173f4c729af">More...</a><br /></td></tr>
<tr class="separator:ga662fd6697ca03b1b0e4f6173f4c729af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdca61a051e0a5d53c4afcd54ee8587"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7fdca61a051e0a5d53c4afcd54ee8587">regina::NGroupExpressionTerm</a></td></tr>
<tr class="memdesc:ga7fdca61a051e0a5d53c4afcd54ee8587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__algebra.html#ga7fdca61a051e0a5d53c4afcd54ee8587">More...</a><br /></td></tr>
<tr class="separator:ga7fdca61a051e0a5d53c4afcd54ee8587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d4ba66291ab83c46aa1937ca2e013a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga15d4ba66291ab83c46aa1937ca2e013a">regina::NGroupExpression</a></td></tr>
<tr class="memdesc:ga15d4ba66291ab83c46aa1937ca2e013a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__algebra.html#ga15d4ba66291ab83c46aa1937ca2e013a">More...</a><br /></td></tr>
<tr class="separator:ga15d4ba66291ab83c46aa1937ca2e013a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb7e3c50225946da320c9ea879915461"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafb7e3c50225946da320c9ea879915461">regina::NGroupPresentation</a></td></tr>
<tr class="memdesc:gafb7e3c50225946da320c9ea879915461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__algebra.html#gafb7e3c50225946da320c9ea879915461">More...</a><br /></td></tr>
<tr class="separator:gafb7e3c50225946da320c9ea879915461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64199b6ed14045690701c547d40405bf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga64199b6ed14045690701c547d40405bf">regina::NHomGroupPresentation</a></td></tr>
<tr class="memdesc:ga64199b6ed14045690701c547d40405bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__algebra.html#ga64199b6ed14045690701c547d40405bf">More...</a><br /></td></tr>
<tr class="separator:ga64199b6ed14045690701c547d40405bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d169eec300ce18756c423cc712f41b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga40d169eec300ce18756c423cc712f41b">regina::NMarkedAbelianGroup</a></td></tr>
<tr class="memdesc:ga40d169eec300ce18756c423cc712f41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__algebra.html#ga40d169eec300ce18756c423cc712f41b">More...</a><br /></td></tr>
<tr class="separator:ga40d169eec300ce18756c423cc712f41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17ec63facf1abd66b3836639a9442991"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga17ec63facf1abd66b3836639a9442991">regina::NHomMarkedAbelianGroup</a></td></tr>
<tr class="memdesc:ga17ec63facf1abd66b3836639a9442991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__algebra.html#ga17ec63facf1abd66b3836639a9442991">More...</a><br /></td></tr>
<tr class="separator:ga17ec63facf1abd66b3836639a9442991"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad5bf25488fbf05a2f0ad0d7c3b63be59">regina::AbelianGroup::AbelianGroup</a> ()</td></tr>
<tr class="memdesc:gad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial group.  <a href="group__algebra.html#gad5bf25488fbf05a2f0ad0d7c3b63be59">More...</a><br /></td></tr>
<tr class="separator:gad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa09553f6ad8761b079032f00318378"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga6aa09553f6ad8761b079032f00318378">regina::AbelianGroup::AbelianGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga6aa09553f6ad8761b079032f00318378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group.  <a href="group__algebra.html#ga6aa09553f6ad8761b079032f00318378">More...</a><br /></td></tr>
<tr class="separator:ga6aa09553f6ad8761b079032f00318378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712bec823deba982b0712adabc6d4d23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga712bec823deba982b0712adabc6d4d23">regina::AbelianGroup::AbelianGroup</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;M, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;N)</td></tr>
<tr class="memdesc:ga712bec823deba982b0712adabc6d4d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex.  <a href="group__algebra.html#ga712bec823deba982b0712adabc6d4d23">More...</a><br /></td></tr>
<tr class="separator:ga712bec823deba982b0712adabc6d4d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bfaa1a1a6aa834ffaa0883e37416bd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2bfaa1a1a6aa834ffaa0883e37416bd6">regina::AbelianGroup::AbelianGroup</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;M, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;N, const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;p)</td></tr>
<tr class="memdesc:ga2bfaa1a1a6aa834ffaa0883e37416bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients.  <a href="group__algebra.html#ga2bfaa1a1a6aa834ffaa0883e37416bd6">More...</a><br /></td></tr>
<tr class="separator:ga2bfaa1a1a6aa834ffaa0883e37416bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaffd523df4ffbe34d6d38adacd4b6e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaaffd523df4ffbe34d6d38adacd4b6e7d">regina::AbelianGroup::addRank</a> (int extraRank=1)</td></tr>
<tr class="memdesc:gaaffd523df4ffbe34d6d38adacd4b6e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the rank of the group by the given integer.  <a href="group__algebra.html#gaaffd523df4ffbe34d6d38adacd4b6e7d">More...</a><br /></td></tr>
<tr class="separator:gaaffd523df4ffbe34d6d38adacd4b6e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9de8c90029f068306126465da9f7296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa9de8c90029f068306126465da9f7296">regina::AbelianGroup::addTorsionElement</a> (const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;<a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>, unsigned mult=1)</td></tr>
<tr class="memdesc:gaa9de8c90029f068306126465da9f7296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given torsion element to the group.  <a href="group__algebra.html#gaa9de8c90029f068306126465da9f7296">More...</a><br /></td></tr>
<tr class="separator:gaa9de8c90029f068306126465da9f7296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae926d3d6b0dce31e40c27eb475057077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae926d3d6b0dce31e40c27eb475057077">regina::AbelianGroup::addTorsionElement</a> (unsigned long <a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>, unsigned mult=1)</td></tr>
<tr class="memdesc:gae926d3d6b0dce31e40c27eb475057077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given torsion element to the group.  <a href="group__algebra.html#gae926d3d6b0dce31e40c27eb475057077">More...</a><br /></td></tr>
<tr class="separator:gae926d3d6b0dce31e40c27eb475057077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70f9f394fc848b2483e5ac93ad6e7cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga70f9f394fc848b2483e5ac93ad6e7cef">regina::AbelianGroup::addTorsionElements</a> (const std::multiset&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;torsion)</td></tr>
<tr class="memdesc:ga70f9f394fc848b2483e5ac93ad6e7cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given set of torsion elements to this group.  <a href="group__algebra.html#ga70f9f394fc848b2483e5ac93ad6e7cef">More...</a><br /></td></tr>
<tr class="separator:ga70f9f394fc848b2483e5ac93ad6e7cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e49620574efadb724e8fd07449d5e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga06e49620574efadb724e8fd07449d5e8">regina::AbelianGroup::addGroup</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;presentation)</td></tr>
<tr class="memdesc:ga06e49620574efadb724e8fd07449d5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the abelian group defined by the given presentation to this group.  <a href="group__algebra.html#ga06e49620574efadb724e8fd07449d5e8">More...</a><br /></td></tr>
<tr class="separator:ga06e49620574efadb724e8fd07449d5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f258af0b04c62e2de0f61df3d710509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3f258af0b04c62e2de0f61df3d710509">regina::AbelianGroup::addGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;group)</td></tr>
<tr class="memdesc:ga3f258af0b04c62e2de0f61df3d710509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given abelian group to this group.  <a href="group__algebra.html#ga3f258af0b04c62e2de0f61df3d710509">More...</a><br /></td></tr>
<tr class="separator:ga3f258af0b04c62e2de0f61df3d710509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada506c15842e993b6fdc651b0122d3af"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gada506c15842e993b6fdc651b0122d3af">regina::AbelianGroup::rank</a> () const</td></tr>
<tr class="memdesc:gada506c15842e993b6fdc651b0122d3af"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group.  <a href="group__algebra.html#gada506c15842e993b6fdc651b0122d3af">More...</a><br /></td></tr>
<tr class="separator:gada506c15842e993b6fdc651b0122d3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b15418d1e879e91983cbbd13dcbb1e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga72b15418d1e879e91983cbbd13dcbb1e">regina::AbelianGroup::torsionRank</a> (const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;<a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>) const</td></tr>
<tr class="memdesc:ga72b15418d1e879e91983cbbd13dcbb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="group__algebra.html#ga72b15418d1e879e91983cbbd13dcbb1e">More...</a><br /></td></tr>
<tr class="separator:ga72b15418d1e879e91983cbbd13dcbb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3777b5ec94d450465db9327c7ea774e7"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3777b5ec94d450465db9327c7ea774e7">regina::AbelianGroup::torsionRank</a> (unsigned long <a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>) const</td></tr>
<tr class="memdesc:ga3777b5ec94d450465db9327c7ea774e7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="group__algebra.html#ga3777b5ec94d450465db9327c7ea774e7">More...</a><br /></td></tr>
<tr class="separator:ga3777b5ec94d450465db9327c7ea774e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb7bc0b871554e7302ba01b17470fe0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3eb7bc0b871554e7302ba01b17470fe0">regina::AbelianGroup::countInvariantFactors</a> () const</td></tr>
<tr class="memdesc:ga3eb7bc0b871554e7302ba01b17470fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group.  <a href="group__algebra.html#ga3eb7bc0b871554e7302ba01b17470fe0">More...</a><br /></td></tr>
<tr class="separator:ga3eb7bc0b871554e7302ba01b17470fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e9b0ee0a3ba3323fddec44ca8a87dbb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga6e9b0ee0a3ba3323fddec44ca8a87dbb">regina::AbelianGroup::invariantFactor</a> (size_t index) const</td></tr>
<tr class="memdesc:ga6e9b0ee0a3ba3323fddec44ca8a87dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group.  <a href="group__algebra.html#ga6e9b0ee0a3ba3323fddec44ca8a87dbb">More...</a><br /></td></tr>
<tr class="separator:ga6e9b0ee0a3ba3323fddec44ca8a87dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65860d714f70889df0fec507a7658f8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga65860d714f70889df0fec507a7658f8f">regina::AbelianGroup::isTrivial</a> () const</td></tr>
<tr class="memdesc:ga65860d714f70889df0fec507a7658f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the trivial (zero) group.  <a href="group__algebra.html#ga65860d714f70889df0fec507a7658f8f">More...</a><br /></td></tr>
<tr class="separator:ga65860d714f70889df0fec507a7658f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga919a9f896922a25d7c9b6e32a877471f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga919a9f896922a25d7c9b6e32a877471f">regina::AbelianGroup::isZ</a> () const</td></tr>
<tr class="memdesc:ga919a9f896922a25d7c9b6e32a877471f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the infinite cyclic group (Z).  <a href="group__algebra.html#ga919a9f896922a25d7c9b6e32a877471f">More...</a><br /></td></tr>
<tr class="separator:ga919a9f896922a25d7c9b6e32a877471f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd8d4c1dd13f30df21855b26e4d1198"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga1dd8d4c1dd13f30df21855b26e4d1198">regina::AbelianGroup::isFree</a> (unsigned r) const</td></tr>
<tr class="memdesc:ga1dd8d4c1dd13f30df21855b26e4d1198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the free abelian group of the given rank.  <a href="group__algebra.html#ga1dd8d4c1dd13f30df21855b26e4d1198">More...</a><br /></td></tr>
<tr class="separator:ga1dd8d4c1dd13f30df21855b26e4d1198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae75846527dae06863f9b924622ccfe8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae75846527dae06863f9b924622ccfe8b">regina::AbelianGroup::isZn</a> (unsigned long n) const</td></tr>
<tr class="memdesc:gae75846527dae06863f9b924622ccfe8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the non-trivial cyclic group on the given number of elements.  <a href="group__algebra.html#gae75846527dae06863f9b924622ccfe8b">More...</a><br /></td></tr>
<tr class="separator:gae75846527dae06863f9b924622ccfe8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ed4b87463c30c91f16059b8587522b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga87ed4b87463c30c91f16059b8587522b">regina::AbelianGroup::operator==</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:ga87ed4b87463c30c91f16059b8587522b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group are isomorphic.  <a href="group__algebra.html#ga87ed4b87463c30c91f16059b8587522b">More...</a><br /></td></tr>
<tr class="separator:ga87ed4b87463c30c91f16059b8587522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654c5cee9a97206990fcc36ff62906b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga654c5cee9a97206990fcc36ff62906b1">regina::AbelianGroup::operator!=</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:ga654c5cee9a97206990fcc36ff62906b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group are non-isomorphic.  <a href="group__algebra.html#ga654c5cee9a97206990fcc36ff62906b1">More...</a><br /></td></tr>
<tr class="separator:ga654c5cee9a97206990fcc36ff62906b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a4395eba4812e1b94c78c03fce56b64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga0a4395eba4812e1b94c78c03fce56b64">regina::AbelianGroup::operator=</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga0a4395eba4812e1b94c78c03fce56b64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a clone of the given group.  <a href="group__algebra.html#ga0a4395eba4812e1b94c78c03fce56b64">More...</a><br /></td></tr>
<tr class="separator:ga0a4395eba4812e1b94c78c03fce56b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd184409a580597ac709e7875355be74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafd184409a580597ac709e7875355be74">regina::AbelianGroup::writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gafd184409a580597ac709e7875355be74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this abelian group.  <a href="group__algebra.html#gafd184409a580597ac709e7875355be74">More...</a><br /></td></tr>
<tr class="separator:gafd184409a580597ac709e7875355be74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga655d3a9de8d18a136f5ca578b6cfa7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga655d3a9de8d18a136f5ca578b6cfa7b9">regina::AbelianGroup::writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="group__engine.html#gae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a>=false) const</td></tr>
<tr class="memdesc:ga655d3a9de8d18a136f5ca578b6cfa7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__algebra.html#ga655d3a9de8d18a136f5ca578b6cfa7b9">More...</a><br /></td></tr>
<tr class="separator:ga655d3a9de8d18a136f5ca578b6cfa7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7edb441bb51e6d540c3f803662b0cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac7edb441bb51e6d540c3f803662b0cab">regina::AbelianGroup::replaceTorsion</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;matrix)</td></tr>
<tr class="memdesc:gac7edb441bb51e6d540c3f803662b0cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the torsion elements of this group with those in the abelian group represented by the given Smith normal form presentation matrix.  <a href="group__algebra.html#gac7edb441bb51e6d540c3f803662b0cab">More...</a><br /></td></tr>
<tr class="separator:gac7edb441bb51e6d540c3f803662b0cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ac61c7392b0e70f7f70a38e2405b61c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3ac61c7392b0e70f7f70a38e2405b61c">regina::GroupExpressionTerm::GroupExpressionTerm</a> ()</td></tr>
<tr class="memdesc:ga3ac61c7392b0e70f7f70a38e2405b61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised term.  <a href="group__algebra.html#ga3ac61c7392b0e70f7f70a38e2405b61c">More...</a><br /></td></tr>
<tr class="separator:ga3ac61c7392b0e70f7f70a38e2405b61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb163426eabcec172dea7e49fe537f81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gacb163426eabcec172dea7e49fe537f81">regina::GroupExpressionTerm::GroupExpressionTerm</a> (unsigned long newGen, long newExp)</td></tr>
<tr class="memdesc:gacb163426eabcec172dea7e49fe537f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new term initialised to the given value.  <a href="group__algebra.html#gacb163426eabcec172dea7e49fe537f81">More...</a><br /></td></tr>
<tr class="separator:gacb163426eabcec172dea7e49fe537f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0dc710a480e83bcf44467c729095866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac0dc710a480e83bcf44467c729095866">regina::GroupExpressionTerm::GroupExpressionTerm</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gac0dc710a480e83bcf44467c729095866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new term initialised to the given value.  <a href="group__algebra.html#gac0dc710a480e83bcf44467c729095866">More...</a><br /></td></tr>
<tr class="separator:gac0dc710a480e83bcf44467c729095866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27838261a91a54ad923f43641df49011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga27838261a91a54ad923f43641df49011">regina::GroupExpressionTerm::operator=</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga27838261a91a54ad923f43641df49011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this term identical to the given term.  <a href="group__algebra.html#ga27838261a91a54ad923f43641df49011">More...</a><br /></td></tr>
<tr class="separator:ga27838261a91a54ad923f43641df49011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fd28691c9501bab70a1304149a46340"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga4fd28691c9501bab70a1304149a46340">regina::GroupExpressionTerm::operator==</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;other) const</td></tr>
<tr class="memdesc:ga4fd28691c9501bab70a1304149a46340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given term contain identical data.  <a href="group__algebra.html#ga4fd28691c9501bab70a1304149a46340">More...</a><br /></td></tr>
<tr class="separator:ga4fd28691c9501bab70a1304149a46340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad992666ed443843d2884901a803ac461"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad992666ed443843d2884901a803ac461">regina::GroupExpressionTerm::operator!=</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;other) const</td></tr>
<tr class="memdesc:gad992666ed443843d2884901a803ac461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given term do not contain identical data.  <a href="group__algebra.html#gad992666ed443843d2884901a803ac461">More...</a><br /></td></tr>
<tr class="separator:gad992666ed443843d2884901a803ac461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd215c1f0bac8eb3768ffd4e2962da42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafd215c1f0bac8eb3768ffd4e2962da42">regina::GroupExpressionTerm::operator&lt;</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;other) const</td></tr>
<tr class="memdesc:gafd215c1f0bac8eb3768ffd4e2962da42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imposes an ordering on terms.  <a href="group__algebra.html#gafd215c1f0bac8eb3768ffd4e2962da42">More...</a><br /></td></tr>
<tr class="separator:gafd215c1f0bac8eb3768ffd4e2962da42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa425a2e30651c963c641dd096fc50886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa425a2e30651c963c641dd096fc50886">regina::GroupExpressionTerm::inverse</a> () const</td></tr>
<tr class="memdesc:gaa425a2e30651c963c641dd096fc50886"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the inverse of this term.  <a href="group__algebra.html#gaa425a2e30651c963c641dd096fc50886">More...</a><br /></td></tr>
<tr class="separator:gaa425a2e30651c963c641dd096fc50886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34893fcea2e39ced4522b8a779d4b3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa34893fcea2e39ced4522b8a779d4b3c">regina::GroupExpressionTerm::operator+=</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;other)</td></tr>
<tr class="memdesc:gaa34893fcea2e39ced4522b8a779d4b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to merge this term with the given term.  <a href="group__algebra.html#gaa34893fcea2e39ced4522b8a779d4b3c">More...</a><br /></td></tr>
<tr class="separator:gaa34893fcea2e39ced4522b8a779d4b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa109e29599c8ff6f92fd2aadc017fd42"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa109e29599c8ff6f92fd2aadc017fd42">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;term)</td></tr>
<tr class="memdesc:gaa109e29599c8ff6f92fd2aadc017fd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given term to the given output stream.  <a href="group__algebra.html#gaa109e29599c8ff6f92fd2aadc017fd42">More...</a><br /></td></tr>
<tr class="separator:gaa109e29599c8ff6f92fd2aadc017fd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc1d5b73995d9fb27c1b73edaac73c08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gacc1d5b73995d9fb27c1b73edaac73c08">regina::GroupExpression::GroupExpression</a> ()</td></tr>
<tr class="memdesc:gacc1d5b73995d9fb27c1b73edaac73c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The terms that make up this expression.  <a href="group__algebra.html#gacc1d5b73995d9fb27c1b73edaac73c08">More...</a><br /></td></tr>
<tr class="separator:gacc1d5b73995d9fb27c1b73edaac73c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f2c9cfc082f39e382a38b72d72a0677"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2f2c9cfc082f39e382a38b72d72a0677">regina::GroupExpression::GroupExpression</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga2f2c9cfc082f39e382a38b72d72a0677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression that is a clone of the given expression.  <a href="group__algebra.html#ga2f2c9cfc082f39e382a38b72d72a0677">More...</a><br /></td></tr>
<tr class="separator:ga2f2c9cfc082f39e382a38b72d72a0677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfbc34d75a9cb38218f25c8ed5582ccf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gadfbc34d75a9cb38218f25c8ed5582ccf">regina::GroupExpression::GroupExpression</a> (const std::string &amp;input, bool *valid=nullptr)</td></tr>
<tr class="memdesc:gadfbc34d75a9cb38218f25c8ed5582ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to interpret the given input string as a word in a group.  <a href="group__algebra.html#gadfbc34d75a9cb38218f25c8ed5582ccf">More...</a><br /></td></tr>
<tr class="separator:gadfbc34d75a9cb38218f25c8ed5582ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb42e4226df8081fd18a9f64a3f6bb6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gabb42e4226df8081fd18a9f64a3f6bb6f">regina::GroupExpression::operator=</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gabb42e4226df8081fd18a9f64a3f6bb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this expression a clone of the given expression.  <a href="group__algebra.html#gabb42e4226df8081fd18a9f64a3f6bb6f">More...</a><br /></td></tr>
<tr class="separator:gabb42e4226df8081fd18a9f64a3f6bb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff2ca294cd89c65857d242215a72a650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaff2ca294cd89c65857d242215a72a650">regina::GroupExpression::operator==</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;comp) const</td></tr>
<tr class="memdesc:gaff2ca294cd89c65857d242215a72a650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="group__algebra.html#gaff2ca294cd89c65857d242215a72a650">More...</a><br /></td></tr>
<tr class="separator:gaff2ca294cd89c65857d242215a72a650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0402158ae2680818b04bb815e3ed7eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga0402158ae2680818b04bb815e3ed7eb9">regina::GroupExpression::operator!=</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;comp) const</td></tr>
<tr class="memdesc:ga0402158ae2680818b04bb815e3ed7eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="group__algebra.html#ga0402158ae2680818b04bb815e3ed7eb9">More...</a><br /></td></tr>
<tr class="separator:ga0402158ae2680818b04bb815e3ed7eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7107330382d76de56540ef1e5ec986e"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gab7107330382d76de56540ef1e5ec986e">regina::GroupExpression::terms</a> ()</td></tr>
<tr class="memdesc:gab7107330382d76de56540ef1e5ec986e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the list of terms in this expression.  <a href="group__algebra.html#gab7107330382d76de56540ef1e5ec986e">More...</a><br /></td></tr>
<tr class="separator:gab7107330382d76de56540ef1e5ec986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961eb0fc634f28142e23abe582fe977a"><td class="memItemLeft" align="right" valign="top">const std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga961eb0fc634f28142e23abe582fe977a">regina::GroupExpression::terms</a> () const</td></tr>
<tr class="memdesc:ga961eb0fc634f28142e23abe582fe977a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the list of terms in this expression.  <a href="group__algebra.html#ga961eb0fc634f28142e23abe582fe977a">More...</a><br /></td></tr>
<tr class="separator:ga961eb0fc634f28142e23abe582fe977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aeebe99241025551efccdbc0640417f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2aeebe99241025551efccdbc0640417f">regina::GroupExpression::countTerms</a> () const</td></tr>
<tr class="memdesc:ga2aeebe99241025551efccdbc0640417f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of terms in this expression.  <a href="group__algebra.html#ga2aeebe99241025551efccdbc0640417f">More...</a><br /></td></tr>
<tr class="separator:ga2aeebe99241025551efccdbc0640417f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c683c8a7391ae8ad801b2c48e6ae3f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga4c683c8a7391ae8ad801b2c48e6ae3f6">regina::GroupExpression::wordLength</a> () const</td></tr>
<tr class="memdesc:ga4c683c8a7391ae8ad801b2c48e6ae3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the length of the word, i.e.  <a href="group__algebra.html#ga4c683c8a7391ae8ad801b2c48e6ae3f6">More...</a><br /></td></tr>
<tr class="separator:ga4c683c8a7391ae8ad801b2c48e6ae3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab76ba3c8c7120f4b99787bd78068d39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaab76ba3c8c7120f4b99787bd78068d39">regina::GroupExpression::isTrivial</a> () const</td></tr>
<tr class="memdesc:gaab76ba3c8c7120f4b99787bd78068d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this is the trivial (unit) word.  <a href="group__algebra.html#gaab76ba3c8c7120f4b99787bd78068d39">More...</a><br /></td></tr>
<tr class="separator:gaab76ba3c8c7120f4b99787bd78068d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4e343e87b3c1b157a97292651e1d25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaad4e343e87b3c1b157a97292651e1d25">regina::GroupExpression::erase</a> ()</td></tr>
<tr class="memdesc:gaad4e343e87b3c1b157a97292651e1d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all terms from this this word.  <a href="group__algebra.html#gaad4e343e87b3c1b157a97292651e1d25">More...</a><br /></td></tr>
<tr class="separator:gaad4e343e87b3c1b157a97292651e1d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5eaab7ecde7ceff9428853e17106fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae5eaab7ecde7ceff9428853e17106fe9">regina::GroupExpression::term</a> (size_t index)</td></tr>
<tr class="memdesc:gae5eaab7ecde7ceff9428853e17106fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the term at the given index in this expression.  <a href="group__algebra.html#gae5eaab7ecde7ceff9428853e17106fe9">More...</a><br /></td></tr>
<tr class="separator:gae5eaab7ecde7ceff9428853e17106fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0b885e1054074186d17ce7adc8a7db8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae0b885e1054074186d17ce7adc8a7db8">regina::GroupExpression::term</a> (size_t index) const</td></tr>
<tr class="memdesc:gae0b885e1054074186d17ce7adc8a7db8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the term at the given index in this expression.  <a href="group__algebra.html#gae0b885e1054074186d17ce7adc8a7db8">More...</a><br /></td></tr>
<tr class="separator:gae0b885e1054074186d17ce7adc8a7db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5851d978d13f5844ccbf2a6bc7de001"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa5851d978d13f5844ccbf2a6bc7de001">regina::GroupExpression::generator</a> (size_t index) const</td></tr>
<tr class="memdesc:gaa5851d978d13f5844ccbf2a6bc7de001"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the generator corresonding to the term at the given index in this expression.  <a href="group__algebra.html#gaa5851d978d13f5844ccbf2a6bc7de001">More...</a><br /></td></tr>
<tr class="separator:gaa5851d978d13f5844ccbf2a6bc7de001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff0207f2d1602d0e1a7752b9bb2b0183"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaff0207f2d1602d0e1a7752b9bb2b0183">regina::GroupExpression::exponent</a> (size_t index) const</td></tr>
<tr class="memdesc:gaff0207f2d1602d0e1a7752b9bb2b0183"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the exponent corresonding to the term at the given index in this expression.  <a href="group__algebra.html#gaff0207f2d1602d0e1a7752b9bb2b0183">More...</a><br /></td></tr>
<tr class="separator:gaff0207f2d1602d0e1a7752b9bb2b0183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a2753d395ab5cb3089cb09ec637d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga29a2753d395ab5cb3089cb09ec637d86">regina::GroupExpression::addTermFirst</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;<a class="el" href="group__algebra.html#gae5eaab7ecde7ceff9428853e17106fe9">term</a>)</td></tr>
<tr class="memdesc:ga29a2753d395ab5cb3089cb09ec637d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the beginning of this expression.  <a href="group__algebra.html#ga29a2753d395ab5cb3089cb09ec637d86">More...</a><br /></td></tr>
<tr class="separator:ga29a2753d395ab5cb3089cb09ec637d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe441455a1744f9b5a02cc0fa20bfcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gadfe441455a1744f9b5a02cc0fa20bfcf">regina::GroupExpression::addTermFirst</a> (unsigned long <a class="el" href="group__algebra.html#gaa5851d978d13f5844ccbf2a6bc7de001">generator</a>, long <a class="el" href="group__algebra.html#gaff0207f2d1602d0e1a7752b9bb2b0183">exponent</a>)</td></tr>
<tr class="memdesc:gadfe441455a1744f9b5a02cc0fa20bfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the beginning of this expression.  <a href="group__algebra.html#gadfe441455a1744f9b5a02cc0fa20bfcf">More...</a><br /></td></tr>
<tr class="separator:gadfe441455a1744f9b5a02cc0fa20bfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga372453b28e949d4ddacd682fb655cbda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga372453b28e949d4ddacd682fb655cbda">regina::GroupExpression::addTermLast</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;<a class="el" href="group__algebra.html#gae5eaab7ecde7ceff9428853e17106fe9">term</a>)</td></tr>
<tr class="memdesc:ga372453b28e949d4ddacd682fb655cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the end of this expression.  <a href="group__algebra.html#ga372453b28e949d4ddacd682fb655cbda">More...</a><br /></td></tr>
<tr class="separator:ga372453b28e949d4ddacd682fb655cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga539c39976a30b6836a750ffb57fd4d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga539c39976a30b6836a750ffb57fd4d90">regina::GroupExpression::addTermLast</a> (unsigned long <a class="el" href="group__algebra.html#gaa5851d978d13f5844ccbf2a6bc7de001">generator</a>, long <a class="el" href="group__algebra.html#gaff0207f2d1602d0e1a7752b9bb2b0183">exponent</a>)</td></tr>
<tr class="memdesc:ga539c39976a30b6836a750ffb57fd4d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the end of this expression.  <a href="group__algebra.html#ga539c39976a30b6836a750ffb57fd4d90">More...</a><br /></td></tr>
<tr class="separator:ga539c39976a30b6836a750ffb57fd4d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9d2537788e2b9ca4019a9ed62bf695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gade9d2537788e2b9ca4019a9ed62bf695">regina::GroupExpression::addTermsFirst</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;word)</td></tr>
<tr class="memdesc:gade9d2537788e2b9ca4019a9ed62bf695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the left by the given word.  <a href="group__algebra.html#gade9d2537788e2b9ca4019a9ed62bf695">More...</a><br /></td></tr>
<tr class="separator:gade9d2537788e2b9ca4019a9ed62bf695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8411bb87da43d3b5e4d2d7573b1600a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa8411bb87da43d3b5e4d2d7573b1600a">regina::GroupExpression::addTermsLast</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;word)</td></tr>
<tr class="memdesc:gaa8411bb87da43d3b5e4d2d7573b1600a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the right by the given word.  <a href="group__algebra.html#gaa8411bb87da43d3b5e4d2d7573b1600a">More...</a><br /></td></tr>
<tr class="separator:gaa8411bb87da43d3b5e4d2d7573b1600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe1e06fa7de1208569484895d832274a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafe1e06fa7de1208569484895d832274a">regina::GroupExpression::addStringFirst</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:gafe1e06fa7de1208569484895d832274a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the left by the word respresented by the given string.  <a href="group__algebra.html#gafe1e06fa7de1208569484895d832274a">More...</a><br /></td></tr>
<tr class="separator:gafe1e06fa7de1208569484895d832274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe11d45edbdfe2ed3915a2fd2203560d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafe11d45edbdfe2ed3915a2fd2203560d">regina::GroupExpression::addStringLast</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:gafe11d45edbdfe2ed3915a2fd2203560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the right by the word respresented by the given string.  <a href="group__algebra.html#gafe11d45edbdfe2ed3915a2fd2203560d">More...</a><br /></td></tr>
<tr class="separator:gafe11d45edbdfe2ed3915a2fd2203560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga688406ed1ec6e9f3dfd4f31a220729c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga688406ed1ec6e9f3dfd4f31a220729c4">regina::GroupExpression::cycleRight</a> ()</td></tr>
<tr class="memdesc:ga688406ed1ec6e9f3dfd4f31a220729c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles this word by moving the leftmost term around to the rightmost.  <a href="group__algebra.html#ga688406ed1ec6e9f3dfd4f31a220729c4">More...</a><br /></td></tr>
<tr class="separator:ga688406ed1ec6e9f3dfd4f31a220729c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30471b33e30035e299ebfae316519d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga30471b33e30035e299ebfae316519d0c">regina::GroupExpression::cycleLeft</a> ()</td></tr>
<tr class="memdesc:ga30471b33e30035e299ebfae316519d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles this word by moving the rightmost term around to the leftmost.  <a href="group__algebra.html#ga30471b33e30035e299ebfae316519d0c">More...</a><br /></td></tr>
<tr class="separator:ga30471b33e30035e299ebfae316519d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0bdc4dd3b1a5d1abe1e086b0a91b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafc0bdc4dd3b1a5d1abe1e086b0a91b39">regina::GroupExpression::inverse</a> () const</td></tr>
<tr class="memdesc:gafc0bdc4dd3b1a5d1abe1e086b0a91b39"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is the inverse of this expression.  <a href="group__algebra.html#gafc0bdc4dd3b1a5d1abe1e086b0a91b39">More...</a><br /></td></tr>
<tr class="separator:gafc0bdc4dd3b1a5d1abe1e086b0a91b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e65aaa150201d3df9fd6199d136d63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7e65aaa150201d3df9fd6199d136d63e">regina::GroupExpression::invert</a> ()</td></tr>
<tr class="memdesc:ga7e65aaa150201d3df9fd6199d136d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts this expression.  <a href="group__algebra.html#ga7e65aaa150201d3df9fd6199d136d63e">More...</a><br /></td></tr>
<tr class="separator:ga7e65aaa150201d3df9fd6199d136d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9413bf389924cf7188e034d66d2580ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga9413bf389924cf7188e034d66d2580ca">regina::GroupExpression::power</a> (long <a class="el" href="group__algebra.html#gaff0207f2d1602d0e1a7752b9bb2b0183">exponent</a>) const</td></tr>
<tr class="memdesc:ga9413bf389924cf7188e034d66d2580ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is this expression raised to the given power.  <a href="group__algebra.html#ga9413bf389924cf7188e034d66d2580ca">More...</a><br /></td></tr>
<tr class="separator:ga9413bf389924cf7188e034d66d2580ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae77e1f2423da57b6bd93984762691bf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae77e1f2423da57b6bd93984762691bf2">regina::GroupExpression::simplify</a> (bool cyclic=false)</td></tr>
<tr class="memdesc:gae77e1f2423da57b6bd93984762691bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies this expression.  <a href="group__algebra.html#gae77e1f2423da57b6bd93984762691bf2">More...</a><br /></td></tr>
<tr class="separator:gae77e1f2423da57b6bd93984762691bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc5f90b79dc0a50956c1737ac350c0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5dc5f90b79dc0a50956c1737ac350c0b">regina::GroupExpression::substitute</a> (unsigned long <a class="el" href="group__algebra.html#gaa5851d978d13f5844ccbf2a6bc7de001">generator</a>, const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;expansion, bool cyclic=false)</td></tr>
<tr class="memdesc:ga5dc5f90b79dc0a50956c1737ac350c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces every occurrence of the given generator with the given substite expression.  <a href="group__algebra.html#ga5dc5f90b79dc0a50956c1737ac350c0b">More...</a><br /></td></tr>
<tr class="separator:ga5dc5f90b79dc0a50956c1737ac350c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d02f0fa24e3d333ce3bcfb4e6acee1a"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::map&lt; unsigned long, <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga1d02f0fa24e3d333ce3bcfb4e6acee1a">regina::GroupExpression::relabellingsThisToOther</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;other, bool cyclic=false) const</td></tr>
<tr class="memdesc:ga1d02f0fa24e3d333ce3bcfb4e6acee1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not one can relabel the generators in this word to obtain the given other word.  <a href="group__algebra.html#ga1d02f0fa24e3d333ce3bcfb4e6acee1a">More...</a><br /></td></tr>
<tr class="separator:ga1d02f0fa24e3d333ce3bcfb4e6acee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b0fedf30a85fc54ede2e37c5deb088"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa8b0fedf30a85fc54ede2e37c5deb088">regina::GroupExpression::writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaa8b0fedf30a85fc54ede2e37c5deb088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this expression.  <a href="group__algebra.html#gaa8b0fedf30a85fc54ede2e37c5deb088">More...</a><br /></td></tr>
<tr class="separator:gaa8b0fedf30a85fc54ede2e37c5deb088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad42f3dcd7375c149457822529f3efa8b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad42f3dcd7375c149457822529f3efa8b">regina::GroupExpression::toTeX</a> () const</td></tr>
<tr class="memdesc:gad42f3dcd7375c149457822529f3efa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this expression.  <a href="group__algebra.html#gad42f3dcd7375c149457822529f3efa8b">More...</a><br /></td></tr>
<tr class="separator:gad42f3dcd7375c149457822529f3efa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5288d1ece14ec07413a046ac62245b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5288d1ece14ec07413a046ac62245b1f">regina::GroupExpression::writeTeX</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga5288d1ece14ec07413a046ac62245b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a TeX represesentation of this expression to the given output stream.  <a href="group__algebra.html#ga5288d1ece14ec07413a046ac62245b1f">More...</a><br /></td></tr>
<tr class="separator:ga5288d1ece14ec07413a046ac62245b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4485c48e5523b43d4753cf3262c45e52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga4485c48e5523b43d4753cf3262c45e52">regina::GroupExpression::writeText</a> (std::ostream &amp;out, bool shortword=false, bool <a class="el" href="group__engine.html#gae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a>=false) const</td></tr>
<tr class="memdesc:ga4485c48e5523b43d4753cf3262c45e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a text representation of this expression to the given output stream, using either numbered generators or alphabetic generators.  <a href="group__algebra.html#ga4485c48e5523b43d4753cf3262c45e52">More...</a><br /></td></tr>
<tr class="separator:ga4485c48e5523b43d4753cf3262c45e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24620bfbae6fe30c5036a0308ee7e52c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga24620bfbae6fe30c5036a0308ee7e52c">regina::GroupExpression::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga24620bfbae6fe30c5036a0308ee7e52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__algebra.html#ga24620bfbae6fe30c5036a0308ee7e52c">More...</a><br /></td></tr>
<tr class="separator:ga24620bfbae6fe30c5036a0308ee7e52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ffeca6d3c8d43baafeeba6fc0d303b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga35ffeca6d3c8d43baafeeba6fc0d303b">regina::GroupPresentation::GroupPresentation</a> ()</td></tr>
<tr class="memdesc:ga35ffeca6d3c8d43baafeeba6fc0d303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new presentation with no generators and no relations.  <a href="group__algebra.html#ga35ffeca6d3c8d43baafeeba6fc0d303b">More...</a><br /></td></tr>
<tr class="separator:ga35ffeca6d3c8d43baafeeba6fc0d303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa106507aa970573666c0d9b8085cfe5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa106507aa970573666c0d9b8085cfe5e">regina::GroupPresentation::GroupPresentation</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gaa106507aa970573666c0d9b8085cfe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group presentation.  <a href="group__algebra.html#gaa106507aa970573666c0d9b8085cfe5e">More...</a><br /></td></tr>
<tr class="separator:gaa106507aa970573666c0d9b8085cfe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e5de7fb4b495c779c61c8580f2723a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf0e5de7fb4b495c779c61c8580f2723a">regina::GroupPresentation::GroupPresentation</a> (unsigned long nGens, const std::vector&lt; std::string &gt; &amp;rels)</td></tr>
<tr class="memdesc:gaf0e5de7fb4b495c779c61c8580f2723a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that allows you to directly pass an arbitrary number of relators in string format.  <a href="group__algebra.html#gaf0e5de7fb4b495c779c61c8580f2723a">More...</a><br /></td></tr>
<tr class="separator:gaf0e5de7fb4b495c779c61c8580f2723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3629e95ac978c4c136e23b60b830b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5d3629e95ac978c4c136e23b60b830b1">regina::GroupPresentation::~GroupPresentation</a> ()</td></tr>
<tr class="memdesc:ga5d3629e95ac978c4c136e23b60b830b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the group presentation.  <a href="group__algebra.html#ga5d3629e95ac978c4c136e23b60b830b1">More...</a><br /></td></tr>
<tr class="separator:ga5d3629e95ac978c4c136e23b60b830b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b7dc666fcc3020fb1307a3f322b5ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga88b7dc666fcc3020fb1307a3f322b5ba">regina::GroupPresentation::operator=</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga88b7dc666fcc3020fb1307a3f322b5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="group__algebra.html#ga88b7dc666fcc3020fb1307a3f322b5ba">More...</a><br /></td></tr>
<tr class="separator:ga88b7dc666fcc3020fb1307a3f322b5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc7827368f5d5c46b125c526720eb7b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaefc7827368f5d5c46b125c526720eb7b">regina::GroupPresentation::addGenerator</a> (unsigned long numToAdd=1)</td></tr>
<tr class="memdesc:gaefc7827368f5d5c46b125c526720eb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one or more generators to the group presentation.  <a href="group__algebra.html#gaefc7827368f5d5c46b125c526720eb7b">More...</a><br /></td></tr>
<tr class="separator:gaefc7827368f5d5c46b125c526720eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e31202d42ccdaa2dc7bc362e47df86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga87e31202d42ccdaa2dc7bc362e47df86">regina::GroupPresentation::addRelation</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> *rel)</td></tr>
<tr class="memdesc:ga87e31202d42ccdaa2dc7bc362e47df86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given relation to the group presentation.  <a href="group__algebra.html#ga87e31202d42ccdaa2dc7bc362e47df86">More...</a><br /></td></tr>
<tr class="separator:ga87e31202d42ccdaa2dc7bc362e47df86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610ea6821977d1a2f6709627316e7649"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga610ea6821977d1a2f6709627316e7649">regina::GroupPresentation::countGenerators</a> () const</td></tr>
<tr class="memdesc:ga610ea6821977d1a2f6709627316e7649"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators in this group presentation.  <a href="group__algebra.html#ga610ea6821977d1a2f6709627316e7649">More...</a><br /></td></tr>
<tr class="separator:ga610ea6821977d1a2f6709627316e7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ffa647790e42c8d984168db32197d22"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2ffa647790e42c8d984168db32197d22">regina::GroupPresentation::countRelations</a> () const</td></tr>
<tr class="memdesc:ga2ffa647790e42c8d984168db32197d22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of relations in this group presentation.  <a href="group__algebra.html#ga2ffa647790e42c8d984168db32197d22">More...</a><br /></td></tr>
<tr class="separator:ga2ffa647790e42c8d984168db32197d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b394968e63b1a679b318400537c926"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae5b394968e63b1a679b318400537c926">regina::GroupPresentation::relation</a> (size_t index) const</td></tr>
<tr class="memdesc:gae5b394968e63b1a679b318400537c926"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the relation at the given index in this group presentation.  <a href="group__algebra.html#gae5b394968e63b1a679b318400537c926">More...</a><br /></td></tr>
<tr class="separator:gae5b394968e63b1a679b318400537c926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46e579e06a36b35db8e8dce18ded41a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga46e579e06a36b35db8e8dce18ded41a5">regina::GroupPresentation::isValid</a> () const</td></tr>
<tr class="memdesc:ga46e579e06a36b35db8e8dce18ded41a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether all of the relations for the group are indeed words in the generators.  <a href="group__algebra.html#ga46e579e06a36b35db8e8dce18ded41a5">More...</a><br /></td></tr>
<tr class="separator:ga46e579e06a36b35db8e8dce18ded41a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee43de413fbbd1dd88bd645d3fac340f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaee43de413fbbd1dd88bd645d3fac340f">regina::GroupPresentation::intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:gaee43de413fbbd1dd88bd645d3fac340f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation as intelligently as possible without further input.  <a href="group__algebra.html#gaee43de413fbbd1dd88bd645d3fac340f">More...</a><br /></td></tr>
<tr class="separator:gaee43de413fbbd1dd88bd645d3fac340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacffb20abcd98421db215b1141108fb7d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gacffb20abcd98421db215b1141108fb7d">regina::GroupPresentation::intelligentSimplifyDetail</a> ()</td></tr>
<tr class="memdesc:gacffb20abcd98421db215b1141108fb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation as intelligently as possible without further input.  <a href="group__algebra.html#gacffb20abcd98421db215b1141108fb7d">More...</a><br /></td></tr>
<tr class="separator:gacffb20abcd98421db215b1141108fb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea435013f581c63967ddae8e9af94de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gacea435013f581c63967ddae8e9af94de">regina::GroupPresentation::smallCancellation</a> ()</td></tr>
<tr class="memdesc:gacea435013f581c63967ddae8e9af94de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation using only small cancellation theory.  <a href="group__algebra.html#gacea435013f581c63967ddae8e9af94de">More...</a><br /></td></tr>
<tr class="separator:gacea435013f581c63967ddae8e9af94de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5e18bdc3cc36fee22e8b3fd3a6d7572"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf5e18bdc3cc36fee22e8b3fd3a6d7572">regina::GroupPresentation::smallCancellationDetail</a> ()</td></tr>
<tr class="memdesc:gaf5e18bdc3cc36fee22e8b3fd3a6d7572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the group presentation using small cancellation theory.  <a href="group__algebra.html#gaf5e18bdc3cc36fee22e8b3fd3a6d7572">More...</a><br /></td></tr>
<tr class="separator:gaf5e18bdc3cc36fee22e8b3fd3a6d7572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf21b58e5745a140d2fb50c2643e9d052"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf21b58e5745a140d2fb50c2643e9d052">regina::GroupPresentation::simplifyWord</a> (<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;input) const</td></tr>
<tr class="memdesc:gaf21b58e5745a140d2fb50c2643e9d052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses small cancellation theory to reduce the input word, using the current presentation of the group.  <a href="group__algebra.html#gaf21b58e5745a140d2fb50c2643e9d052">More...</a><br /></td></tr>
<tr class="separator:gaf21b58e5745a140d2fb50c2643e9d052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa7653e9f59d3f194e4b560d7f84f6e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaaa7653e9f59d3f194e4b560d7f84f6e6">regina::GroupPresentation::proliferateRelators</a> (unsigned long depth=1)</td></tr>
<tr class="memdesc:gaaa7653e9f59d3f194e4b560d7f84f6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to help escape local wells when simplifying presentations, which may be useful when small cancellation theory can't find the simplest relators.  <a href="group__algebra.html#gaaa7653e9f59d3f194e4b560d7f84f6e6">More...</a><br /></td></tr>
<tr class="separator:gaaa7653e9f59d3f194e4b560d7f84f6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd5465442f764dcca7c9f83683144ff"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga6dd5465442f764dcca7c9f83683144ff">regina::GroupPresentation::recogniseGroup</a> (bool moreUtf8=false) const</td></tr>
<tr class="memdesc:ga6dd5465442f764dcca7c9f83683144ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to recognise the group corresponding to this presentation.  <a href="group__algebra.html#ga6dd5465442f764dcca7c9f83683144ff">More...</a><br /></td></tr>
<tr class="separator:ga6dd5465442f764dcca7c9f83683144ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0a688500a505588004520eff2807545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa0a688500a505588004520eff2807545">regina::GroupPresentation::writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaa0a688500a505588004520eff2807545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this group presentation.  <a href="group__algebra.html#gaa0a688500a505588004520eff2807545">More...</a><br /></td></tr>
<tr class="separator:gaa0a688500a505588004520eff2807545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c9ee67ee75ee1d9539d235a5cd8f101"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5c9ee67ee75ee1d9539d235a5cd8f101">regina::GroupPresentation::relatorLength</a> () const</td></tr>
<tr class="memdesc:ga5c9ee67ee75ee1d9539d235a5cd8f101"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sum of the word lengths of the relators.  <a href="group__algebra.html#ga5c9ee67ee75ee1d9539d235a5cd8f101">More...</a><br /></td></tr>
<tr class="separator:ga5c9ee67ee75ee1d9539d235a5cd8f101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4021da14012efb7a5fbe770662060259"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga4021da14012efb7a5fbe770662060259">regina::GroupPresentation::abelianisation</a> () const</td></tr>
<tr class="memdesc:ga4021da14012efb7a5fbe770662060259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the abelianisation of this group.  <a href="group__algebra.html#ga4021da14012efb7a5fbe770662060259">More...</a><br /></td></tr>
<tr class="separator:ga4021da14012efb7a5fbe770662060259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8939724e818da45670621a8d431b90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaee8939724e818da45670621a8d431b90">regina::GroupPresentation::markedAbelianisation</a> () const</td></tr>
<tr class="memdesc:gaee8939724e818da45670621a8d431b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the abelianisation of this group.  <a href="group__algebra.html#gaee8939724e818da45670621a8d431b90">More...</a><br /></td></tr>
<tr class="separator:gaee8939724e818da45670621a8d431b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f4798b7eca1cb22d8b5c3414d5f256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga23f4798b7eca1cb22d8b5c3414d5f256">regina::GroupPresentation::identifyAbelian</a> () const</td></tr>
<tr class="memdesc:ga23f4798b7eca1cb22d8b5c3414d5f256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to determine if the group is abelian.  <a href="group__algebra.html#ga23f4798b7eca1cb22d8b5c3414d5f256">More...</a><br /></td></tr>
<tr class="separator:ga23f4798b7eca1cb22d8b5c3414d5f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81c7a84245d4d123ca2b5d144c9cb21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf81c7a84245d4d123ca2b5d144c9cb21">regina::GroupPresentation::nielsenTransposition</a> (unsigned long i, unsigned long j)</td></tr>
<tr class="memdesc:gaf81c7a84245d4d123ca2b5d144c9cb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the generators in the presentation indexed by <em>i</em> and <em>j</em> respectively, and recomputes the appropriate presentation.  <a href="group__algebra.html#gaf81c7a84245d4d123ca2b5d144c9cb21">More...</a><br /></td></tr>
<tr class="separator:gaf81c7a84245d4d123ca2b5d144c9cb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6af4e4996b9c37bfe2bece59ccb6483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac6af4e4996b9c37bfe2bece59ccb6483">regina::GroupPresentation::nielsenInvert</a> (unsigned long i)</td></tr>
<tr class="memdesc:gac6af4e4996b9c37bfe2bece59ccb6483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a generator in a presentation by its inverse, and recomputes the appropriate presentation.  <a href="group__algebra.html#gac6af4e4996b9c37bfe2bece59ccb6483">More...</a><br /></td></tr>
<tr class="separator:gac6af4e4996b9c37bfe2bece59ccb6483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87e91e72bd03e053343c769fb6ef307"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac87e91e72bd03e053343c769fb6ef307">regina::GroupPresentation::nielsenCombine</a> (unsigned long i, unsigned long j, long k, bool rightMult=true)</td></tr>
<tr class="memdesc:gac87e91e72bd03e053343c769fb6ef307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a generator <code>gi</code> by either <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code> in the presentation.  <a href="group__algebra.html#gac87e91e72bd03e053343c769fb6ef307">More...</a><br /></td></tr>
<tr class="separator:gac87e91e72bd03e053343c769fb6ef307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7f596f55ec44803ed094cc71ec3420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7e7f596f55ec44803ed094cc71ec3420">regina::GroupPresentation::intelligentNielsen</a> ()</td></tr>
<tr class="memdesc:ga7e7f596f55ec44803ed094cc71ec3420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for Nielsen moves that will simplify the presentation.  <a href="group__algebra.html#ga7e7f596f55ec44803ed094cc71ec3420">More...</a><br /></td></tr>
<tr class="separator:ga7e7f596f55ec44803ed094cc71ec3420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b6505e3621220ef4bda814c1c37a4a5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga1b6505e3621220ef4bda814c1c37a4a5">regina::GroupPresentation::intelligentNielsenDetail</a> ()</td></tr>
<tr class="memdesc:ga1b6505e3621220ef4bda814c1c37a4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for Nielsen moves that will simplify the presentation.  <a href="group__algebra.html#ga1b6505e3621220ef4bda814c1c37a4a5">More...</a><br /></td></tr>
<tr class="separator:ga1b6505e3621220ef4bda814c1c37a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6428c2ece188536f87fe7ca5cb7d49d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf6428c2ece188536f87fe7ca5cb7d49d">regina::GroupPresentation::homologicalAlignment</a> ()</td></tr>
<tr class="memdesc:gaf6428c2ece188536f87fe7ca5cb7d49d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible).  <a href="group__algebra.html#gaf6428c2ece188536f87fe7ca5cb7d49d">More...</a><br /></td></tr>
<tr class="separator:gaf6428c2ece188536f87fe7ca5cb7d49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6072043f595d328349c365e9d6f37fd3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga6072043f595d328349c365e9d6f37fd3">regina::GroupPresentation::homologicalAlignmentDetail</a> ()</td></tr>
<tr class="memdesc:ga6072043f595d328349c365e9d6f37fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible).  <a href="group__algebra.html#ga6072043f595d328349c365e9d6f37fd3">More...</a><br /></td></tr>
<tr class="separator:ga6072043f595d328349c365e9d6f37fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0507961c7e28fee174bdb08d4d0e8364"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga0507961c7e28fee174bdb08d4d0e8364">regina::GroupPresentation::prettyRewriting</a> ()</td></tr>
<tr class="memdesc:ga0507961c7e28fee174bdb08d4d0e8364"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entirely cosmetic re-writing of the presentation, which is fast and superficial.  <a href="group__algebra.html#ga0507961c7e28fee174bdb08d4d0e8364">More...</a><br /></td></tr>
<tr class="separator:ga0507961c7e28fee174bdb08d4d0e8364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33c241cd3b0f6bd18e64217cbcd56ae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gab33c241cd3b0f6bd18e64217cbcd56ae">regina::GroupPresentation::prettyRewritingDetail</a> ()</td></tr>
<tr class="memdesc:gab33c241cd3b0f6bd18e64217cbcd56ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entirely cosmetic re-writing of the presentation, which is fast and superficial.  <a href="group__algebra.html#gab33c241cd3b0f6bd18e64217cbcd56ae">More...</a><br /></td></tr>
<tr class="separator:gab33c241cd3b0f6bd18e64217cbcd56ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57f9afdee9e1c46fa06e802a2c8e652"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa57f9afdee9e1c46fa06e802a2c8e652">regina::GroupPresentation::identifySimplyIsomorphicTo</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;other) const</td></tr>
<tr class="memdesc:gaa57f9afdee9e1c46fa06e802a2c8e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to prove that this and the given group presentation are <em>simply isomorphic</em>.  <a href="group__algebra.html#gaa57f9afdee9e1c46fa06e802a2c8e652">More...</a><br /></td></tr>
<tr class="separator:gaa57f9afdee9e1c46fa06e802a2c8e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7b92796d5d1bf3a5dba2641a98fcfe"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafa7b92796d5d1bf3a5dba2641a98fcfe">regina::GroupPresentation::toTeX</a> () const</td></tr>
<tr class="memdesc:gafa7b92796d5d1bf3a5dba2641a98fcfe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this group presentation.  <a href="group__algebra.html#gafa7b92796d5d1bf3a5dba2641a98fcfe">More...</a><br /></td></tr>
<tr class="separator:gafa7b92796d5d1bf3a5dba2641a98fcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c373720fc59d7973d53f53e3126a409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7c373720fc59d7973d53f53e3126a409">regina::GroupPresentation::writeTeX</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga7c373720fc59d7973d53f53e3126a409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a TeX represesentation of this group presentation to the given output stream.  <a href="group__algebra.html#ga7c373720fc59d7973d53f53e3126a409">More...</a><br /></td></tr>
<tr class="separator:ga7c373720fc59d7973d53f53e3126a409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c930c1a8cdb5e53c2a01747dca8c1e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga8c930c1a8cdb5e53c2a01747dca8c1e5">regina::GroupPresentation::compact</a> () const</td></tr>
<tr class="memdesc:ga8c930c1a8cdb5e53c2a01747dca8c1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a compact one-line representation of this group presentation, including details of all generators and relations.  <a href="group__algebra.html#ga8c930c1a8cdb5e53c2a01747dca8c1e5">More...</a><br /></td></tr>
<tr class="separator:ga8c930c1a8cdb5e53c2a01747dca8c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9848a7d3303be02671e18c57d28afec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf9848a7d3303be02671e18c57d28afec">regina::GroupPresentation::writeTextCompact</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaf9848a7d3303be02671e18c57d28afec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a compact represesentation of this group to the given output stream.  <a href="group__algebra.html#gaf9848a7d3303be02671e18c57d28afec">More...</a><br /></td></tr>
<tr class="separator:gaf9848a7d3303be02671e18c57d28afec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64ef64c265916b3fdc7e0c513d2b458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac64ef64c265916b3fdc7e0c513d2b458">regina::GroupPresentation::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gac64ef64c265916b3fdc7e0c513d2b458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__algebra.html#gac64ef64c265916b3fdc7e0c513d2b458">More...</a><br /></td></tr>
<tr class="separator:gac64ef64c265916b3fdc7e0c513d2b458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fa6a40ae529c19a16fdba8f66d6768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga37fa6a40ae529c19a16fdba8f66d6768">regina::GroupPresentation::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga37fa6a40ae529c19a16fdba8f66d6768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__algebra.html#ga37fa6a40ae529c19a16fdba8f66d6768">More...</a><br /></td></tr>
<tr class="separator:ga37fa6a40ae529c19a16fdba8f66d6768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69bac586bbdb9e0469363e104436c911"><td class="memItemLeft" align="right" valign="top">FinitelyPresentedGroup&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga69bac586bbdb9e0469363e104436c911">regina::GroupPresentation::sage</a> () const</td></tr>
<tr class="memdesc:ga69bac586bbdb9e0469363e104436c911"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Sage-only routine that returns a copy of this group presentation in a format native to Sage.  <a href="group__algebra.html#ga69bac586bbdb9e0469363e104436c911">More...</a><br /></td></tr>
<tr class="separator:ga69bac586bbdb9e0469363e104436c911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a7082e7d192b1f14a4717ebec946e18"><td class="memItemLeft" align="right" valign="top"><a id="ga0a7082e7d192b1f14a4717ebec946e18"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GroupPresentation::NWordSubstitutionData::operator&lt;</b> (const NWordSubstitutionData &amp;other) const</td></tr>
<tr class="separator:ga0a7082e7d192b1f14a4717ebec946e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b77bd677052bd3260488132ba16f005"><td class="memItemLeft" align="right" valign="top"><a id="ga6b77bd677052bd3260488132ba16f005"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>regina::GroupPresentation::NWordSubstitutionData::writeTextShort</b> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ga6b77bd677052bd3260488132ba16f005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b076c4c6bae31bd4efa6562a1ead073"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga9b076c4c6bae31bd4efa6562a1ead073">regina::HomGroupPresentation::HomGroupPresentation</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;<a class="el" href="group__algebra.html#ga7f7f2527f5247f549e2f96bae2f2682b">domain</a>, const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;<a class="el" href="group__algebra.html#ga187d58d673d8acefae2931604f161a78">range</a>, const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;map)</td></tr>
<tr class="memdesc:ga9b076c4c6bae31bd4efa6562a1ead073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new homomorphism from the given data.  <a href="group__algebra.html#ga9b076c4c6bae31bd4efa6562a1ead073">More...</a><br /></td></tr>
<tr class="separator:ga9b076c4c6bae31bd4efa6562a1ead073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7bc5b3895007ae0351d49fd1788ca53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad7bc5b3895007ae0351d49fd1788ca53">regina::HomGroupPresentation::HomGroupPresentation</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;<a class="el" href="group__algebra.html#ga7f7f2527f5247f549e2f96bae2f2682b">domain</a>, const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;<a class="el" href="group__algebra.html#ga187d58d673d8acefae2931604f161a78">range</a>, const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;map, const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;inv)</td></tr>
<tr class="memdesc:gad7bc5b3895007ae0351d49fd1788ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a declared isomorphism from the given data.  <a href="group__algebra.html#gad7bc5b3895007ae0351d49fd1788ca53">More...</a><br /></td></tr>
<tr class="separator:gad7bc5b3895007ae0351d49fd1788ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3799566faa70c9e628dc75953553b8a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3799566faa70c9e628dc75953553b8a2">regina::HomGroupPresentation::HomGroupPresentation</a> (const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;groupForIdentity)</td></tr>
<tr class="memdesc:ga3799566faa70c9e628dc75953553b8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new identity homomorphism for the given group.  <a href="group__algebra.html#ga3799566faa70c9e628dc75953553b8a2">More...</a><br /></td></tr>
<tr class="separator:ga3799566faa70c9e628dc75953553b8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aea71e6385c36ebd19a74db79bdef86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga0aea71e6385c36ebd19a74db79bdef86">regina::HomGroupPresentation::HomGroupPresentation</a> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga0aea71e6385c36ebd19a74db79bdef86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group presentation.  <a href="group__algebra.html#ga0aea71e6385c36ebd19a74db79bdef86">More...</a><br /></td></tr>
<tr class="separator:ga0aea71e6385c36ebd19a74db79bdef86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3898f6193634c768c9ab9276d95618"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5b3898f6193634c768c9ab9276d95618">regina::HomGroupPresentation::~HomGroupPresentation</a> ()</td></tr>
<tr class="memdesc:ga5b3898f6193634c768c9ab9276d95618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the group homomorphism.  <a href="group__algebra.html#ga5b3898f6193634c768c9ab9276d95618">More...</a><br /></td></tr>
<tr class="separator:ga5b3898f6193634c768c9ab9276d95618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7f2527f5247f549e2f96bae2f2682b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7f7f2527f5247f549e2f96bae2f2682b">regina::HomGroupPresentation::domain</a> () const</td></tr>
<tr class="memdesc:ga7f7f2527f5247f549e2f96bae2f2682b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The domain of the map.  <a href="group__algebra.html#ga7f7f2527f5247f549e2f96bae2f2682b">More...</a><br /></td></tr>
<tr class="separator:ga7f7f2527f5247f549e2f96bae2f2682b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187d58d673d8acefae2931604f161a78"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga187d58d673d8acefae2931604f161a78">regina::HomGroupPresentation::range</a> () const</td></tr>
<tr class="memdesc:ga187d58d673d8acefae2931604f161a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The range of the map.  <a href="group__algebra.html#ga187d58d673d8acefae2931604f161a78">More...</a><br /></td></tr>
<tr class="separator:ga187d58d673d8acefae2931604f161a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf222ad0e798429548eb15ed5ceccd909"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf222ad0e798429548eb15ed5ceccd909">regina::HomGroupPresentation::knowsInverse</a> () const</td></tr>
<tr class="memdesc:gaf222ad0e798429548eb15ed5ceccd909"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a declared isomorphism.  <a href="group__algebra.html#gaf222ad0e798429548eb15ed5ceccd909">More...</a><br /></td></tr>
<tr class="separator:gaf222ad0e798429548eb15ed5ceccd909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97d1a45f27160a284918d2b1ab0162e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gab97d1a45f27160a284918d2b1ab0162e">regina::HomGroupPresentation::evaluate</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;arg) const</td></tr>
<tr class="memdesc:gab97d1a45f27160a284918d2b1ab0162e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the homomorphism at an element of the domain.  <a href="group__algebra.html#gab97d1a45f27160a284918d2b1ab0162e">More...</a><br /></td></tr>
<tr class="separator:gab97d1a45f27160a284918d2b1ab0162e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea6512988efb34a5c0d4785d5ae24bd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaea6512988efb34a5c0d4785d5ae24bd6">regina::HomGroupPresentation::evaluate</a> (unsigned long i) const</td></tr>
<tr class="memdesc:gaea6512988efb34a5c0d4785d5ae24bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the homomorphism at a generator of the domain.  <a href="group__algebra.html#gaea6512988efb34a5c0d4785d5ae24bd6">More...</a><br /></td></tr>
<tr class="separator:gaea6512988efb34a5c0d4785d5ae24bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfc9413a22527d5fea70b46085df4e84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gadfc9413a22527d5fea70b46085df4e84">regina::HomGroupPresentation::invEvaluate</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;arg) const</td></tr>
<tr class="memdesc:gadfc9413a22527d5fea70b46085df4e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the isomorphisms's inverse at an element of the range.  <a href="group__algebra.html#gadfc9413a22527d5fea70b46085df4e84">More...</a><br /></td></tr>
<tr class="separator:gadfc9413a22527d5fea70b46085df4e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37003838777aedbe54e9cf372aa2fbd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga37003838777aedbe54e9cf372aa2fbd9">regina::HomGroupPresentation::invEvaluate</a> (unsigned long i) const</td></tr>
<tr class="memdesc:ga37003838777aedbe54e9cf372aa2fbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the isomorphism at a generator of the range.  <a href="group__algebra.html#ga37003838777aedbe54e9cf372aa2fbd9">More...</a><br /></td></tr>
<tr class="separator:ga37003838777aedbe54e9cf372aa2fbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac51beafb7f570b78db3a9328313a81af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac51beafb7f570b78db3a9328313a81af">regina::HomGroupPresentation::intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:gac51beafb7f570b78db3a9328313a81af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simultaneously simplifies:  <a href="group__algebra.html#gac51beafb7f570b78db3a9328313a81af">More...</a><br /></td></tr>
<tr class="separator:gac51beafb7f570b78db3a9328313a81af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb66be2c97c5c03a5ce61ea37f447dc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gadb66be2c97c5c03a5ce61ea37f447dc0">regina::HomGroupPresentation::intelligentNielsen</a> ()</td></tr>
<tr class="memdesc:gadb66be2c97c5c03a5ce61ea37f447dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the domain and range using only Nielsen moves, keeping track of the resulting map in the progress.  <a href="group__algebra.html#gadb66be2c97c5c03a5ce61ea37f447dc0">More...</a><br /></td></tr>
<tr class="separator:gadb66be2c97c5c03a5ce61ea37f447dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a2112399e2d6b1b7a49368730920b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga29a2112399e2d6b1b7a49368730920b0">regina::HomGroupPresentation::smallCancellation</a> ()</td></tr>
<tr class="memdesc:ga29a2112399e2d6b1b7a49368730920b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies the domain and range using only small cancellation theory.  <a href="group__algebra.html#ga29a2112399e2d6b1b7a49368730920b0">More...</a><br /></td></tr>
<tr class="separator:ga29a2112399e2d6b1b7a49368730920b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528e30f6bae521207e5c9315af07fba6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga528e30f6bae521207e5c9315af07fba6">regina::HomGroupPresentation::composeWith</a> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;input) const</td></tr>
<tr class="memdesc:ga528e30f6bae521207e5c9315af07fba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes this homomorphism with the given input homomorphism.  <a href="group__algebra.html#ga528e30f6bae521207e5c9315af07fba6">More...</a><br /></td></tr>
<tr class="separator:ga528e30f6bae521207e5c9315af07fba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga746c24ac004ad8a426c072f0b7c17891"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga746c24ac004ad8a426c072f0b7c17891">regina::HomGroupPresentation::invert</a> ()</td></tr>
<tr class="memdesc:ga746c24ac004ad8a426c072f0b7c17891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the homomorphism.  <a href="group__algebra.html#ga746c24ac004ad8a426c072f0b7c17891">More...</a><br /></td></tr>
<tr class="separator:ga746c24ac004ad8a426c072f0b7c17891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542d03cd5ebf7bd5d589fe5ef5ae2e48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga542d03cd5ebf7bd5d589fe5ef5ae2e48">regina::HomGroupPresentation::verify</a> () const</td></tr>
<tr class="memdesc:ga542d03cd5ebf7bd5d589fe5ef5ae2e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies the map is a valid homomorphism.  <a href="group__algebra.html#ga542d03cd5ebf7bd5d589fe5ef5ae2e48">More...</a><br /></td></tr>
<tr class="separator:ga542d03cd5ebf7bd5d589fe5ef5ae2e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21c8442bd57b8974495b657d3e675683"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga21c8442bd57b8974495b657d3e675683">regina::HomGroupPresentation::verifyIsomorphism</a> () const</td></tr>
<tr class="memdesc:ga21c8442bd57b8974495b657d3e675683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to verify that a declared isomorphism is, indeed, an isomorphism.  <a href="group__algebra.html#ga21c8442bd57b8974495b657d3e675683">More...</a><br /></td></tr>
<tr class="separator:ga21c8442bd57b8974495b657d3e675683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79eaff158b800e7e2f7ed3dfc1358368"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga79eaff158b800e7e2f7ed3dfc1358368">regina::HomGroupPresentation::markedAbelianisation</a> () const</td></tr>
<tr class="memdesc:ga79eaff158b800e7e2f7ed3dfc1358368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the induced map on the abelianizations of the domain and range.  <a href="group__algebra.html#ga79eaff158b800e7e2f7ed3dfc1358368">More...</a><br /></td></tr>
<tr class="separator:ga79eaff158b800e7e2f7ed3dfc1358368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga507262602c062ad0190e0c22af7390f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga507262602c062ad0190e0c22af7390f7">regina::HomGroupPresentation::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga507262602c062ad0190e0c22af7390f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__algebra.html#ga507262602c062ad0190e0c22af7390f7">More...</a><br /></td></tr>
<tr class="separator:ga507262602c062ad0190e0c22af7390f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b1eda088e5ec8331c924d284cfcc359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2b1eda088e5ec8331c924d284cfcc359">regina::HomGroupPresentation::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga2b1eda088e5ec8331c924d284cfcc359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__algebra.html#ga2b1eda088e5ec8331c924d284cfcc359">More...</a><br /></td></tr>
<tr class="separator:ga2b1eda088e5ec8331c924d284cfcc359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab910195bd009c5a8aa6dae67fe79a73c"><td class="memItemLeft" align="right" valign="top"><a id="gab910195bd009c5a8aa6dae67fe79a73c"></a>
<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::HomGroupPresentation::operator=</b> (const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;)=delete</td></tr>
<tr class="separator:gab910195bd009c5a8aa6dae67fe79a73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ffa5d54abe1ead15dc3cf8db0e7426"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf2ffa5d54abe1ead15dc3cf8db0e7426">regina::MarkedAbelianGroup::MarkedAbelianGroup</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="group__algebra.html#ga746b854c7cfea2e4c5852a72565058b4">M</a>, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="group__algebra.html#ga48c5e7997650a39ab835814a0ed5cc61">N</a>)</td></tr>
<tr class="memdesc:gaf2ffa5d54abe1ead15dc3cf8db0e7426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a marked abelian group from a chain complex.  <a href="group__algebra.html#gaf2ffa5d54abe1ead15dc3cf8db0e7426">More...</a><br /></td></tr>
<tr class="separator:gaf2ffa5d54abe1ead15dc3cf8db0e7426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada0ac7d4799e5082c5454caef301a60d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gada0ac7d4799e5082c5454caef301a60d">regina::MarkedAbelianGroup::MarkedAbelianGroup</a> (const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="group__algebra.html#ga746b854c7cfea2e4c5852a72565058b4">M</a>, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;<a class="el" href="group__algebra.html#ga48c5e7997650a39ab835814a0ed5cc61">N</a>, const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;pcoeff)</td></tr>
<tr class="memdesc:gada0ac7d4799e5082c5454caef301a60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a marked abelian group from a chain complex with coefficients in Z_p.  <a href="group__algebra.html#gada0ac7d4799e5082c5454caef301a60d">More...</a><br /></td></tr>
<tr class="separator:gada0ac7d4799e5082c5454caef301a60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac293e56e8222e2e5ff7a75fb5d6a8b36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac293e56e8222e2e5ff7a75fb5d6a8b36">regina::MarkedAbelianGroup::MarkedAbelianGroup</a> (unsigned long rk, const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;p)</td></tr>
<tr class="memdesc:gac293e56e8222e2e5ff7a75fb5d6a8b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a free Z_p-module of a given rank using the direct sum of the standard chain complex <code>0 --&gt; Z &ndash;p--&gt; Z --&gt; 0</code>.  <a href="group__algebra.html#gac293e56e8222e2e5ff7a75fb5d6a8b36">More...</a><br /></td></tr>
<tr class="separator:gac293e56e8222e2e5ff7a75fb5d6a8b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41084d6f839ceb295e3aaadf022c8c4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga41084d6f839ceb295e3aaadf022c8c4e">regina::MarkedAbelianGroup::MarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga41084d6f839ceb295e3aaadf022c8c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group.  <a href="group__algebra.html#ga41084d6f839ceb295e3aaadf022c8c4e">More...</a><br /></td></tr>
<tr class="separator:ga41084d6f839ceb295e3aaadf022c8c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga466303b009840a96e49874e0f139854d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga466303b009840a96e49874e0f139854d">regina::MarkedAbelianGroup::isChainComplex</a> () const</td></tr>
<tr class="memdesc:ga466303b009840a96e49874e0f139854d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the defining maps for this group actually give a chain complex.  <a href="group__algebra.html#ga466303b009840a96e49874e0f139854d">More...</a><br /></td></tr>
<tr class="separator:ga466303b009840a96e49874e0f139854d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga000ce1a1c59819c497cd964486be934f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga000ce1a1c59819c497cd964486be934f">regina::MarkedAbelianGroup::rank</a> () const</td></tr>
<tr class="memdesc:ga000ce1a1c59819c497cd964486be934f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group.  <a href="group__algebra.html#ga000ce1a1c59819c497cd964486be934f">More...</a><br /></td></tr>
<tr class="separator:ga000ce1a1c59819c497cd964486be934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f15cbf9347b95351868181735e7dbd"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga99f15cbf9347b95351868181735e7dbd">regina::MarkedAbelianGroup::torsionRank</a> (const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;<a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>) const</td></tr>
<tr class="memdesc:ga99f15cbf9347b95351868181735e7dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="group__algebra.html#ga99f15cbf9347b95351868181735e7dbd">More...</a><br /></td></tr>
<tr class="separator:ga99f15cbf9347b95351868181735e7dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dca8084edda8307373869fd840fe586"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2dca8084edda8307373869fd840fe586">regina::MarkedAbelianGroup::torsionRank</a> (unsigned long <a class="el" href="namespaceregina.html#a1c497b92a8fbf559760f2436cb6bfe15">degree</a>) const</td></tr>
<tr class="memdesc:ga2dca8084edda8307373869fd840fe586"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="group__algebra.html#ga2dca8084edda8307373869fd840fe586">More...</a><br /></td></tr>
<tr class="separator:ga2dca8084edda8307373869fd840fe586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25dc94bfeb64347d3d88ed3505334d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa25dc94bfeb64347d3d88ed3505334d5">regina::MarkedAbelianGroup::countInvariantFactors</a> () const</td></tr>
<tr class="memdesc:gaa25dc94bfeb64347d3d88ed3505334d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group.  <a href="group__algebra.html#gaa25dc94bfeb64347d3d88ed3505334d5">More...</a><br /></td></tr>
<tr class="separator:gaa25dc94bfeb64347d3d88ed3505334d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5e8b466766eb274146277ac9bd98a55"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gab5e8b466766eb274146277ac9bd98a55">regina::MarkedAbelianGroup::minNumberOfGenerators</a> () const</td></tr>
<tr class="memdesc:gab5e8b466766eb274146277ac9bd98a55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the minimum number of generators for the group.  <a href="group__algebra.html#gab5e8b466766eb274146277ac9bd98a55">More...</a><br /></td></tr>
<tr class="separator:gab5e8b466766eb274146277ac9bd98a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga1646cf2d9cb4bc31b0b0df1f1f4289a4">regina::MarkedAbelianGroup::invariantFactor</a> (size_t index) const</td></tr>
<tr class="memdesc:ga1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group.  <a href="group__algebra.html#ga1646cf2d9cb4bc31b0b0df1f1f4289a4">More...</a><br /></td></tr>
<tr class="separator:ga1646cf2d9cb4bc31b0b0df1f1f4289a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2511bd16caaaeb926df617a731c965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga1b2511bd16caaaeb926df617a731c965">regina::MarkedAbelianGroup::isTrivial</a> () const</td></tr>
<tr class="memdesc:ga1b2511bd16caaaeb926df617a731c965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the trivial (zero) group.  <a href="group__algebra.html#ga1b2511bd16caaaeb926df617a731c965">More...</a><br /></td></tr>
<tr class="separator:ga1b2511bd16caaaeb926df617a731c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c65d588478bdbfc871d9d8e94d690ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7c65d588478bdbfc871d9d8e94d690ff">regina::MarkedAbelianGroup::isZ</a> () const</td></tr>
<tr class="memdesc:ga7c65d588478bdbfc871d9d8e94d690ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the infinite cyclic group (Z).  <a href="group__algebra.html#ga7c65d588478bdbfc871d9d8e94d690ff">More...</a><br /></td></tr>
<tr class="separator:ga7c65d588478bdbfc871d9d8e94d690ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad04a54db050fca088bad38c7b5b9c980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad04a54db050fca088bad38c7b5b9c980">regina::MarkedAbelianGroup::isIsomorphicTo</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:gad04a54db050fca088bad38c7b5b9c980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group are isomorphic.  <a href="group__algebra.html#gad04a54db050fca088bad38c7b5b9c980">More...</a><br /></td></tr>
<tr class="separator:gad04a54db050fca088bad38c7b5b9c980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c17b81d8ed166a87d1f57d0864d61e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7c17b81d8ed166a87d1f57d0864d61e7">regina::MarkedAbelianGroup::equalTo</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:ga7c17b81d8ed166a87d1f57d0864d61e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the two MarkedAbelianGroups are identical, which means they have exactly the same presentation matrices.  <a href="group__algebra.html#ga7c17b81d8ed166a87d1f57d0864d61e7">More...</a><br /></td></tr>
<tr class="separator:ga7c17b81d8ed166a87d1f57d0864d61e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db2c8ef127dba9ee3717e8660a7da43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga7db2c8ef127dba9ee3717e8660a7da43">regina::MarkedAbelianGroup::writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="group__engine.html#gae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a>=false) const</td></tr>
<tr class="memdesc:ga7db2c8ef127dba9ee3717e8660a7da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>.  <a href="group__algebra.html#ga7db2c8ef127dba9ee3717e8660a7da43">More...</a><br /></td></tr>
<tr class="separator:ga7db2c8ef127dba9ee3717e8660a7da43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e2133542af695b8b850b6281ee6feb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf0e2133542af695b8b850b6281ee6feb">regina::MarkedAbelianGroup::freeRep</a> (unsigned long index) const</td></tr>
<tr class="memdesc:gaf0e2133542af695b8b850b6281ee6feb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested free generator in the original chain complex defining the group.  <a href="group__algebra.html#gaf0e2133542af695b8b850b6281ee6feb">More...</a><br /></td></tr>
<tr class="separator:gaf0e2133542af695b8b850b6281ee6feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cdebf3efcd47ef18d96369b243794b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2cdebf3efcd47ef18d96369b243794b9">regina::MarkedAbelianGroup::torsionRep</a> (unsigned long index) const</td></tr>
<tr class="memdesc:ga2cdebf3efcd47ef18d96369b243794b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested generator of the torsion subgroup but represented in the original chain complex defining the group.  <a href="group__algebra.html#ga2cdebf3efcd47ef18d96369b243794b9">More...</a><br /></td></tr>
<tr class="separator:ga2cdebf3efcd47ef18d96369b243794b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77834f35e4900eed8e928688ce898f2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga77834f35e4900eed8e928688ce898f2a">regina::MarkedAbelianGroup::ccRep</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;SNFRep) const</td></tr>
<tr class="memdesc:ga77834f35e4900eed8e928688ce898f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of freeRep and torsionRep, this routine takes a vector which represents an element in the group in the SNF coordinates and returns a corresponding vector in the original chain complex.  <a href="group__algebra.html#ga77834f35e4900eed8e928688ce898f2a">More...</a><br /></td></tr>
<tr class="separator:ga77834f35e4900eed8e928688ce898f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebf137dca4e97dfa1ef9f703f2787008"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaebf137dca4e97dfa1ef9f703f2787008">regina::MarkedAbelianGroup::ccRep</a> (unsigned long SNFRep) const</td></tr>
<tr class="memdesc:gaebf137dca4e97dfa1ef9f703f2787008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as ccRep(const std::vector&lt;Integer&gt;&amp;), but we assume you only want the chain complex representation of a standard basis vector from SNF coordinates.  <a href="group__algebra.html#gaebf137dca4e97dfa1ef9f703f2787008">More...</a><br /></td></tr>
<tr class="separator:gaebf137dca4e97dfa1ef9f703f2787008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63e1b742025e5d366ee982cbf618ec8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae63e1b742025e5d366ee982cbf618ec8">regina::MarkedAbelianGroup::cycleProjection</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;ccelt) const</td></tr>
<tr class="memdesc:gae63e1b742025e5d366ee982cbf618ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an element of the chain complex to the subspace of cycles.  <a href="group__algebra.html#gae63e1b742025e5d366ee982cbf618ec8">More...</a><br /></td></tr>
<tr class="separator:gae63e1b742025e5d366ee982cbf618ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b08ed9f51b87f8390c5f38996b82e38"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga1b08ed9f51b87f8390c5f38996b82e38">regina::MarkedAbelianGroup::cycleProjection</a> (unsigned long ccindx) const</td></tr>
<tr class="memdesc:ga1b08ed9f51b87f8390c5f38996b82e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects an element of the chain complex to the subspace of cycles.  <a href="group__algebra.html#ga1b08ed9f51b87f8390c5f38996b82e38">More...</a><br /></td></tr>
<tr class="separator:ga1b08ed9f51b87f8390c5f38996b82e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6df135646b8e56fa438477a849f4c9bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga6df135646b8e56fa438477a849f4c9bc">regina::MarkedAbelianGroup::isCycle</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:ga6df135646b8e56fa438477a849f4c9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector, determines if it represents a cycle in the chain complex.  <a href="group__algebra.html#ga6df135646b8e56fa438477a849f4c9bc">More...</a><br /></td></tr>
<tr class="separator:ga6df135646b8e56fa438477a849f4c9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8c72fcfbf384f9c72742f7fc024f70"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gabf8c72fcfbf384f9c72742f7fc024f70">regina::MarkedAbelianGroup::boundaryMap</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;CCrep) const</td></tr>
<tr class="memdesc:gabf8c72fcfbf384f9c72742f7fc024f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differential of the given vector in the chain complex whose kernel is the cycles.  <a href="group__algebra.html#gabf8c72fcfbf384f9c72742f7fc024f70">More...</a><br /></td></tr>
<tr class="separator:gabf8c72fcfbf384f9c72742f7fc024f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8266305f2c94b9f7c7880715eba189e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaa8266305f2c94b9f7c7880715eba189e">regina::MarkedAbelianGroup::isBoundary</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:gaa8266305f2c94b9f7c7880715eba189e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector, determines if it represents a boundary in the chain complex.  <a href="group__algebra.html#gaa8266305f2c94b9f7c7880715eba189e">More...</a><br /></td></tr>
<tr class="separator:gaa8266305f2c94b9f7c7880715eba189e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94ea2ed41e910b2c52a6d5736283caa3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga94ea2ed41e910b2c52a6d5736283caa3">regina::MarkedAbelianGroup::writeAsBoundary</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:ga94ea2ed41e910b2c52a6d5736283caa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the given vector as a boundary in the chain complex (if the vector is indeed a boundary at all).  <a href="group__algebra.html#ga94ea2ed41e910b2c52a6d5736283caa3">More...</a><br /></td></tr>
<tr class="separator:ga94ea2ed41e910b2c52a6d5736283caa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f90140da9a0ab47482cb68a29078432"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga6f90140da9a0ab47482cb68a29078432">regina::MarkedAbelianGroup::rankCC</a> () const</td></tr>
<tr class="memdesc:ga6f90140da9a0ab47482cb68a29078432"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the chain complex supporting the homology computation.  <a href="group__algebra.html#ga6f90140da9a0ab47482cb68a29078432">More...</a><br /></td></tr>
<tr class="separator:ga6f90140da9a0ab47482cb68a29078432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0563fc60015d3690c89776aaf94c956b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga0563fc60015d3690c89776aaf94c956b">regina::MarkedAbelianGroup::snfRep</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;v) const</td></tr>
<tr class="memdesc:ga0563fc60015d3690c89776aaf94c956b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expresses the given vector as a combination of free and torsion generators.  <a href="group__algebra.html#ga0563fc60015d3690c89776aaf94c956b">More...</a><br /></td></tr>
<tr class="separator:ga0563fc60015d3690c89776aaf94c956b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac714d64e8dca4bc06cce32c3ed26b8db"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gac714d64e8dca4bc06cce32c3ed26b8db">regina::MarkedAbelianGroup::minNumberCycleGens</a> () const</td></tr>
<tr class="memdesc:gac714d64e8dca4bc06cce32c3ed26b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators of ker(M), where M is one of the defining matrices of the chain complex.  <a href="group__algebra.html#gac714d64e8dca4bc06cce32c3ed26b8db">More...</a><br /></td></tr>
<tr class="separator:gac714d64e8dca4bc06cce32c3ed26b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38ec35918dfa4fb844982feac3fff28"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf38ec35918dfa4fb844982feac3fff28">regina::MarkedAbelianGroup::cycleGen</a> (unsigned long i) const</td></tr>
<tr class="memdesc:gaf38ec35918dfa4fb844982feac3fff28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>i</em>th generator of the cycles, i.e., the kernel of M in the chain complex.  <a href="group__algebra.html#gaf38ec35918dfa4fb844982feac3fff28">More...</a><br /></td></tr>
<tr class="separator:gaf38ec35918dfa4fb844982feac3fff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga746b854c7cfea2e4c5852a72565058b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga746b854c7cfea2e4c5852a72565058b4">regina::MarkedAbelianGroup::M</a> () const</td></tr>
<tr class="memdesc:ga746b854c7cfea2e4c5852a72565058b4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;right&rsquo; matrix used in defining the chain complex.  <a href="group__algebra.html#ga746b854c7cfea2e4c5852a72565058b4">More...</a><br /></td></tr>
<tr class="separator:ga746b854c7cfea2e4c5852a72565058b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c5e7997650a39ab835814a0ed5cc61"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga48c5e7997650a39ab835814a0ed5cc61">regina::MarkedAbelianGroup::N</a> () const</td></tr>
<tr class="memdesc:ga48c5e7997650a39ab835814a0ed5cc61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;left&rsquo; matrix used in defining the chain complex.  <a href="group__algebra.html#ga48c5e7997650a39ab835814a0ed5cc61">More...</a><br /></td></tr>
<tr class="separator:ga48c5e7997650a39ab835814a0ed5cc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1d6947da29e7eb4e2765f268da6d64"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gabd1d6947da29e7eb4e2765f268da6d64">regina::MarkedAbelianGroup::coefficients</a> () const</td></tr>
<tr class="memdesc:gabd1d6947da29e7eb4e2765f268da6d64"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coefficients used for the computation of homology.  <a href="group__algebra.html#gabd1d6947da29e7eb4e2765f268da6d64">More...</a><br /></td></tr>
<tr class="separator:gabd1d6947da29e7eb4e2765f268da6d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964cf786ad3ed296a325f03f6d8bf51c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga964cf786ad3ed296a325f03f6d8bf51c">regina::MarkedAbelianGroup::torsionSubgroup</a> () const</td></tr>
<tr class="memdesc:ga964cf786ad3ed296a325f03f6d8bf51c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> representing the torsion subgroup of this group.  <a href="group__algebra.html#ga964cf786ad3ed296a325f03f6d8bf51c">More...</a><br /></td></tr>
<tr class="separator:ga964cf786ad3ed296a325f03f6d8bf51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9882af6b8ec2757932ac1c49833633"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaaa9882af6b8ec2757932ac1c49833633">regina::MarkedAbelianGroup::torsionInclusion</a> () const</td></tr>
<tr class="memdesc:gaaa9882af6b8ec2757932ac1c49833633"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the inclusion of the torsion subgroup into this group.  <a href="group__algebra.html#gaaa9882af6b8ec2757932ac1c49833633">More...</a><br /></td></tr>
<tr class="separator:gaaa9882af6b8ec2757932ac1c49833633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74474b48927e2ff60bb026f5f4fa4eec"><td class="memItemLeft" align="right" valign="top"><a id="ga74474b48927e2ff60bb026f5f4fa4eec"></a>
<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::MarkedAbelianGroup::operator=</b> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;)=delete</td></tr>
<tr class="separator:ga74474b48927e2ff60bb026f5f4fa4eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2226807b3a0d0d3ddf9f0acc0a3a5029"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2226807b3a0d0d3ddf9f0acc0a3a5029">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;dom, const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;ran, const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;mat)</td></tr>
<tr class="memdesc:ga2226807b3a0d0d3ddf9f0acc0a3a5029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a homomorphism from two marked abelian groups and a matrix that indicates where the generators are sent.  <a href="group__algebra.html#ga2226807b3a0d0d3ddf9f0acc0a3a5029">More...</a><br /></td></tr>
<tr class="separator:ga2226807b3a0d0d3ddf9f0acc0a3a5029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbde369a4fe315e50c0a8c4a9d327912"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gadbde369a4fe315e50c0a8c4a9d327912">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;h)</td></tr>
<tr class="memdesc:gadbde369a4fe315e50c0a8c4a9d327912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="group__algebra.html#gadbde369a4fe315e50c0a8c4a9d327912">More...</a><br /></td></tr>
<tr class="separator:gadbde369a4fe315e50c0a8c4a9d327912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f0882d4131e137378cf2885f49ae431"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2f0882d4131e137378cf2885f49ae431">regina::HomMarkedAbelianGroup::~HomMarkedAbelianGroup</a> ()</td></tr>
<tr class="memdesc:ga2f0882d4131e137378cf2885f49ae431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="group__algebra.html#ga2f0882d4131e137378cf2885f49ae431">More...</a><br /></td></tr>
<tr class="separator:ga2f0882d4131e137378cf2885f49ae431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d30febe413482babd2ab43d01f6950"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad3d30febe413482babd2ab43d01f6950">regina::HomMarkedAbelianGroup::isChainMap</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;other) const</td></tr>
<tr class="memdesc:gad3d30febe413482babd2ab43d01f6950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given homomorphism together form a chain map.  <a href="group__algebra.html#gad3d30febe413482babd2ab43d01f6950">More...</a><br /></td></tr>
<tr class="separator:gad3d30febe413482babd2ab43d01f6950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada5bd0951ee72da6cd1ce3f3df090389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gada5bd0951ee72da6cd1ce3f3df090389">regina::HomMarkedAbelianGroup::isCycleMap</a> () const</td></tr>
<tr class="memdesc:gada5bd0951ee72da6cd1ce3f3df090389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this at least a cycle map? If not, pretty much any further computations you try with this class will be give you nothing more than carefully-crafted garbage.  <a href="group__algebra.html#gada5bd0951ee72da6cd1ce3f3df090389">More...</a><br /></td></tr>
<tr class="separator:gada5bd0951ee72da6cd1ce3f3df090389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97881fce1ecb435c23f9aac5ee2d5f15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga97881fce1ecb435c23f9aac5ee2d5f15">regina::HomMarkedAbelianGroup::isEpic</a> () const</td></tr>
<tr class="memdesc:ga97881fce1ecb435c23f9aac5ee2d5f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an epic homomorphism?  <a href="group__algebra.html#ga97881fce1ecb435c23f9aac5ee2d5f15">More...</a><br /></td></tr>
<tr class="separator:ga97881fce1ecb435c23f9aac5ee2d5f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ed7cbfa00a9a9ca3a63cd9e046cfda"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad4ed7cbfa00a9a9ca3a63cd9e046cfda">regina::HomMarkedAbelianGroup::isMonic</a> () const</td></tr>
<tr class="memdesc:gad4ed7cbfa00a9a9ca3a63cd9e046cfda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this a monic homomorphism?  <a href="group__algebra.html#gad4ed7cbfa00a9a9ca3a63cd9e046cfda">More...</a><br /></td></tr>
<tr class="separator:gad4ed7cbfa00a9a9ca3a63cd9e046cfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8303e2ed95989253fb385a8e2207d4f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga8303e2ed95989253fb385a8e2207d4f6">regina::HomMarkedAbelianGroup::isIsomorphism</a> () const</td></tr>
<tr class="memdesc:ga8303e2ed95989253fb385a8e2207d4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this an isomorphism?  <a href="group__algebra.html#ga8303e2ed95989253fb385a8e2207d4f6">More...</a><br /></td></tr>
<tr class="separator:ga8303e2ed95989253fb385a8e2207d4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65f49b1eb7f9cdf8319addb2346d6cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad65f49b1eb7f9cdf8319addb2346d6cf">regina::HomMarkedAbelianGroup::isZero</a> () const</td></tr>
<tr class="memdesc:gad65f49b1eb7f9cdf8319addb2346d6cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the zero map?  <a href="group__algebra.html#gad65f49b1eb7f9cdf8319addb2346d6cf">More...</a><br /></td></tr>
<tr class="separator:gad65f49b1eb7f9cdf8319addb2346d6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fd7a747825f74d559cb7d4201f3d304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3fd7a747825f74d559cb7d4201f3d304">regina::HomMarkedAbelianGroup::isIdentity</a> () const</td></tr>
<tr class="memdesc:ga3fd7a747825f74d559cb7d4201f3d304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this the identity automorphism?  <a href="group__algebra.html#ga3fd7a747825f74d559cb7d4201f3d304">More...</a><br /></td></tr>
<tr class="separator:ga3fd7a747825f74d559cb7d4201f3d304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9471bec920757e90e466e76b43599e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga9471bec920757e90e466e76b43599e0b">regina::HomMarkedAbelianGroup::kernel</a> () const</td></tr>
<tr class="memdesc:ga9471bec920757e90e466e76b43599e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the kernel of this homomorphism.  <a href="group__algebra.html#ga9471bec920757e90e466e76b43599e0b">More...</a><br /></td></tr>
<tr class="separator:ga9471bec920757e90e466e76b43599e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e353de0ec88b8424c111ba97b10d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae2e353de0ec88b8424c111ba97b10d27">regina::HomMarkedAbelianGroup::cokernel</a> () const</td></tr>
<tr class="memdesc:gae2e353de0ec88b8424c111ba97b10d27"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the cokernel of this homomorphism.  <a href="group__algebra.html#gae2e353de0ec88b8424c111ba97b10d27">More...</a><br /></td></tr>
<tr class="separator:gae2e353de0ec88b8424c111ba97b10d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4ffc683e473505b5e11c6e82bfb8b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga6c88de0d46fb43fb08bf788c82243ccc">REGINA_INLINE_REQUIRED</a> const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaca4ffc683e473505b5e11c6e82bfb8b9">regina::HomMarkedAbelianGroup::image</a> () const</td></tr>
<tr class="memdesc:gaca4ffc683e473505b5e11c6e82bfb8b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this homomorphism.  <a href="group__algebra.html#gaca4ffc683e473505b5e11c6e82bfb8b9">More...</a><br /></td></tr>
<tr class="separator:gaca4ffc683e473505b5e11c6e82bfb8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2779b4feadb621b496a2ec8e6f8eadc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2779b4feadb621b496a2ec8e6f8eadc4">regina::HomMarkedAbelianGroup::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga2779b4feadb621b496a2ec8e6f8eadc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Short text representation.  <a href="group__algebra.html#ga2779b4feadb621b496a2ec8e6f8eadc4">More...</a><br /></td></tr>
<tr class="separator:ga2779b4feadb621b496a2ec8e6f8eadc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd028394928cbaba6ce8cfe28c96f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaafd028394928cbaba6ce8cfe28c96f97">regina::HomMarkedAbelianGroup::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaafd028394928cbaba6ce8cfe28c96f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more detailed text representation of the homomorphism.  <a href="group__algebra.html#gaafd028394928cbaba6ce8cfe28c96f97">More...</a><br /></td></tr>
<tr class="separator:gaafd028394928cbaba6ce8cfe28c96f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6ad98271d7a7e95931ead6e727309c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5b6ad98271d7a7e95931ead6e727309c">regina::HomMarkedAbelianGroup::domain</a> () const</td></tr>
<tr class="memdesc:ga5b6ad98271d7a7e95931ead6e727309c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the domain of this homomorphism.  <a href="group__algebra.html#ga5b6ad98271d7a7e95931ead6e727309c">More...</a><br /></td></tr>
<tr class="separator:ga5b6ad98271d7a7e95931ead6e727309c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6785735056383f2f66b9e44c1c3e6ef3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga6785735056383f2f66b9e44c1c3e6ef3">regina::HomMarkedAbelianGroup::range</a> () const</td></tr>
<tr class="memdesc:ga6785735056383f2f66b9e44c1c3e6ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the range of this homomorphism.  <a href="group__algebra.html#ga6785735056383f2f66b9e44c1c3e6ef3">More...</a><br /></td></tr>
<tr class="separator:ga6785735056383f2f66b9e44c1c3e6ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81d1d62efe5d42f9914693969e3e4b6f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga81d1d62efe5d42f9914693969e3e4b6f">regina::HomMarkedAbelianGroup::definingMatrix</a> () const</td></tr>
<tr class="memdesc:ga81d1d62efe5d42f9914693969e3e4b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the defining matrix for the homomorphism.  <a href="group__algebra.html#ga81d1d62efe5d42f9914693969e3e4b6f">More...</a><br /></td></tr>
<tr class="separator:ga81d1d62efe5d42f9914693969e3e4b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106dcb279e4294694478447f2dc06639"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga106dcb279e4294694478447f2dc06639">regina::HomMarkedAbelianGroup::reducedMatrix</a> () const</td></tr>
<tr class="memdesc:ga106dcb279e4294694478447f2dc06639"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the internal reduced matrix representing the homomorphism.  <a href="group__algebra.html#ga106dcb279e4294694478447f2dc06639">More...</a><br /></td></tr>
<tr class="separator:ga106dcb279e4294694478447f2dc06639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b903afa2ba14ee0d159ecd36199ce9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga09b903afa2ba14ee0d159ecd36199ce9">regina::HomMarkedAbelianGroup::evalCC</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:ga09b903afa2ba14ee0d159ecd36199ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the image of a vector under this homomorphism, using the original chain complexes' coordinates.  <a href="group__algebra.html#ga09b903afa2ba14ee0d159ecd36199ce9">More...</a><br /></td></tr>
<tr class="separator:ga09b903afa2ba14ee0d159ecd36199ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895179b6078be8be5420ac3c41f41d91"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga895179b6078be8be5420ac3c41f41d91">regina::HomMarkedAbelianGroup::evalSNF</a> (const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;input) const</td></tr>
<tr class="memdesc:ga895179b6078be8be5420ac3c41f41d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the image of a vector under this homomorphism, using the Smith normal form coordinates.  <a href="group__algebra.html#ga895179b6078be8be5420ac3c41f41d91">More...</a><br /></td></tr>
<tr class="separator:ga895179b6078be8be5420ac3c41f41d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3cc3f63fa92d4ee7e2aca0eeb6584b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5d3cc3f63fa92d4ee7e2aca0eeb6584b">regina::HomMarkedAbelianGroup::inverseHom</a> () const</td></tr>
<tr class="memdesc:ga5d3cc3f63fa92d4ee7e2aca0eeb6584b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the inverse to a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>.  <a href="group__algebra.html#ga5d3cc3f63fa92d4ee7e2aca0eeb6584b">More...</a><br /></td></tr>
<tr class="separator:ga5d3cc3f63fa92d4ee7e2aca0eeb6584b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4205a684b4e381bf13239008f39244ef"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga4205a684b4e381bf13239008f39244ef">regina::HomMarkedAbelianGroup::operator*</a> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;X) const</td></tr>
<tr class="memdesc:ga4205a684b4e381bf13239008f39244ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the composition of two homomorphisms.  <a href="group__algebra.html#ga4205a684b4e381bf13239008f39244ef">More...</a><br /></td></tr>
<tr class="separator:ga4205a684b4e381bf13239008f39244ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafddf033b724ebbab1c972ccd765192a6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gafddf033b724ebbab1c972ccd765192a6">regina::HomMarkedAbelianGroup::torsionSubgroup</a> () const</td></tr>
<tr class="memdesc:gafddf033b724ebbab1c972ccd765192a6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the induced map on the torsion subgroups.  <a href="group__algebra.html#gafddf033b724ebbab1c972ccd765192a6">More...</a><br /></td></tr>
<tr class="separator:gafddf033b724ebbab1c972ccd765192a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae703e8484eebdc75098446d2a90ef9a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae703e8484eebdc75098446d2a90ef9a2">regina::HomMarkedAbelianGroup::writeReducedMatrix</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gae703e8484eebdc75098446d2a90ef9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human-readable version of the reduced matrix to the given output stream.  <a href="group__algebra.html#gae703e8484eebdc75098446d2a90ef9a2">More...</a><br /></td></tr>
<tr class="separator:gae703e8484eebdc75098446d2a90ef9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f52ad800e0b721bcb9d53b4a86bea3d"><td class="memItemLeft" align="right" valign="top"><a id="ga1f52ad800e0b721bcb9d53b4a86bea3d"></a>
<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::HomMarkedAbelianGroup::operator=</b> (const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;)=delete</td></tr>
<tr class="separator:ga1f52ad800e0b721bcb9d53b4a86bea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga320c068af5e2f1b6d602e6eb28cfab60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga320c068af5e2f1b6d602e6eb28cfab60">regina::XMLAbelianGroupReader::XMLAbelianGroupReader</a> ()</td></tr>
<tr class="memdesc:ga320c068af5e2f1b6d602e6eb28cfab60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new abelian group reader.  <a href="group__algebra.html#ga320c068af5e2f1b6d602e6eb28cfab60">More...</a><br /></td></tr>
<tr class="separator:ga320c068af5e2f1b6d602e6eb28cfab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fe47d46e60bf4c37150ded43073084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga37fe47d46e60bf4c37150ded43073084">regina::XMLAbelianGroupReader::group</a> ()</td></tr>
<tr class="memdesc:ga37fe47d46e60bf4c37150ded43073084"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated abelian group that has been read by this element reader.  <a href="group__algebra.html#ga37fe47d46e60bf4c37150ded43073084">More...</a><br /></td></tr>
<tr class="separator:ga37fe47d46e60bf4c37150ded43073084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e9dbf20d9a0d919388b0fe1d61b6c0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3e9dbf20d9a0d919388b0fe1d61b6c0f">regina::XMLAbelianGroupReader::startElement</a> (const std::string &amp;tagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;tagProps, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *parentReader) override</td></tr>
<tr class="memdesc:ga3e9dbf20d9a0d919388b0fe1d61b6c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__algebra.html#ga3e9dbf20d9a0d919388b0fe1d61b6c0f">More...</a><br /></td></tr>
<tr class="separator:ga3e9dbf20d9a0d919388b0fe1d61b6c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a5b4836d67b669d25e7602043d35ff4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2a5b4836d67b669d25e7602043d35ff4">regina::XMLAbelianGroupReader::initialChars</a> (const std::string &amp;chars) override</td></tr>
<tr class="memdesc:ga2a5b4836d67b669d25e7602043d35ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__algebra.html#ga2a5b4836d67b669d25e7602043d35ff4">More...</a><br /></td></tr>
<tr class="separator:ga2a5b4836d67b669d25e7602043d35ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b3ce81d51565ad8725ecd3bf6a1ed7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga15b3ce81d51565ad8725ecd3bf6a1ed7">regina::XMLGroupPresentationReader::XMLGroupPresentationReader</a> ()</td></tr>
<tr class="memdesc:ga15b3ce81d51565ad8725ecd3bf6a1ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new group presentation reader.  <a href="group__algebra.html#ga15b3ce81d51565ad8725ecd3bf6a1ed7">More...</a><br /></td></tr>
<tr class="separator:ga15b3ce81d51565ad8725ecd3bf6a1ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78da5667ebb1527d778d0f84a04b7574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga78da5667ebb1527d778d0f84a04b7574">regina::XMLGroupPresentationReader::group</a> ()</td></tr>
<tr class="memdesc:ga78da5667ebb1527d778d0f84a04b7574"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated group presentation that has been read by this element reader.  <a href="group__algebra.html#ga78da5667ebb1527d778d0f84a04b7574">More...</a><br /></td></tr>
<tr class="separator:ga78da5667ebb1527d778d0f84a04b7574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcadcdfb766850fb41e1b5d03326e0b9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gabcadcdfb766850fb41e1b5d03326e0b9">regina::XMLGroupPresentationReader::startElement</a> (const std::string &amp;tagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;tagProps, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *parentReader) override</td></tr>
<tr class="memdesc:gabcadcdfb766850fb41e1b5d03326e0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__algebra.html#gabcadcdfb766850fb41e1b5d03326e0b9">More...</a><br /></td></tr>
<tr class="separator:gabcadcdfb766850fb41e1b5d03326e0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90354f52dfa7a5b3e8cc9603bc298ff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf90354f52dfa7a5b3e8cc9603bc298ff">regina::XMLGroupPresentationReader::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:gaf90354f52dfa7a5b3e8cc9603bc298ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__algebra.html#gaf90354f52dfa7a5b3e8cc9603bc298ff">More...</a><br /></td></tr>
<tr class="separator:gaf90354f52dfa7a5b3e8cc9603bc298ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf033c93a7017458c5e941bd0a508ad33"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf033c93a7017458c5e941bd0a508ad33">regina::XMLGroupPresentationReader::endSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:gaf033c93a7017458c5e941bd0a508ad33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing has finished for a subelement of this XML element.  <a href="group__algebra.html#gaf033c93a7017458c5e941bd0a508ad33">More...</a><br /></td></tr>
<tr class="separator:gaf033c93a7017458c5e941bd0a508ad33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga9bb4166ec40c17c6a042f6d0609ed4db"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga9bb4166ec40c17c6a042f6d0609ed4db">regina::AbelianGroup::rank_</a></td></tr>
<tr class="memdesc:ga9bb4166ec40c17c6a042f6d0609ed4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of the group (the number of Z components).  <a href="group__algebra.html#ga9bb4166ec40c17c6a042f6d0609ed4db">More...</a><br /></td></tr>
<tr class="separator:ga9bb4166ec40c17c6a042f6d0609ed4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3697f3d8592b06715c111a3ab6e1096c"><td class="memItemLeft" align="right" valign="top">std::multiset&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga3697f3d8592b06715c111a3ab6e1096c">regina::AbelianGroup::invariantFactors</a></td></tr>
<tr class="memdesc:ga3697f3d8592b06715c111a3ab6e1096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.  <a href="group__algebra.html#ga3697f3d8592b06715c111a3ab6e1096c">More...</a><br /></td></tr>
<tr class="separator:ga3697f3d8592b06715c111a3ab6e1096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58329571e0653f3818ed12b05f3e41f5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga58329571e0653f3818ed12b05f3e41f5">regina::GroupExpressionTerm::generator</a></td></tr>
<tr class="memdesc:ga58329571e0653f3818ed12b05f3e41f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number that identifies the generator in this term.  <a href="group__algebra.html#ga58329571e0653f3818ed12b05f3e41f5">More...</a><br /></td></tr>
<tr class="separator:ga58329571e0653f3818ed12b05f3e41f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c56664a7a957fd6742bfd2940c473b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gae5c56664a7a957fd6742bfd2940c473b">regina::GroupExpressionTerm::exponent</a></td></tr>
<tr class="memdesc:gae5c56664a7a957fd6742bfd2940c473b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exponent to which the generator is raised.  <a href="group__algebra.html#gae5c56664a7a957fd6742bfd2940c473b">More...</a><br /></td></tr>
<tr class="separator:gae5c56664a7a957fd6742bfd2940c473b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a626a41861ed1142ddb117a2e1b578"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga27a626a41861ed1142ddb117a2e1b578">regina::GroupPresentation::nGenerators</a></td></tr>
<tr class="memdesc:ga27a626a41861ed1142ddb117a2e1b578"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of generators.  <a href="group__algebra.html#ga27a626a41861ed1142ddb117a2e1b578">More...</a><br /></td></tr>
<tr class="separator:ga27a626a41861ed1142ddb117a2e1b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d903e49f27734aec45a59117c0e9bc1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga2d903e49f27734aec45a59117c0e9bc1">regina::GroupPresentation::relations</a></td></tr>
<tr class="memdesc:ga2d903e49f27734aec45a59117c0e9bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The relations between the generators.  <a href="group__algebra.html#ga2d903e49f27734aec45a59117c0e9bc1">More...</a><br /></td></tr>
<tr class="separator:ga2d903e49f27734aec45a59117c0e9bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e48e08f2f475bcd5d443cb200a214b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gaf3e48e08f2f475bcd5d443cb200a214b">regina::GroupPresentation::NWordSubstitutionData::start_sub_at</a></td></tr>
<tr class="memdesc:gaf3e48e08f2f475bcd5d443cb200a214b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where in A do we start?  <a href="group__algebra.html#gaf3e48e08f2f475bcd5d443cb200a214b">More...</a><br /></td></tr>
<tr class="separator:gaf3e48e08f2f475bcd5d443cb200a214b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e0c2232d89cf63b96db716c4277cd8f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga5e0c2232d89cf63b96db716c4277cd8f">regina::GroupPresentation::NWordSubstitutionData::start_from</a></td></tr>
<tr class="memdesc:ga5e0c2232d89cf63b96db716c4277cd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where in B do we start?  <a href="group__algebra.html#ga5e0c2232d89cf63b96db716c4277cd8f">More...</a><br /></td></tr>
<tr class="separator:ga5e0c2232d89cf63b96db716c4277cd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada543feeb78f2ab1b2e85a3aa4558877"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gada543feeb78f2ab1b2e85a3aa4558877">regina::GroupPresentation::NWordSubstitutionData::sub_length</a></td></tr>
<tr class="memdesc:gada543feeb78f2ab1b2e85a3aa4558877"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of letters from B to use.  <a href="group__algebra.html#gada543feeb78f2ab1b2e85a3aa4558877">More...</a><br /></td></tr>
<tr class="separator:gada543feeb78f2ab1b2e85a3aa4558877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839bbeb4a4de73984b48b5ba8f4cccab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#ga839bbeb4a4de73984b48b5ba8f4cccab">regina::GroupPresentation::NWordSubstitutionData::invertB</a></td></tr>
<tr class="memdesc:ga839bbeb4a4de73984b48b5ba8f4cccab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert B before making the substitution?  <a href="group__algebra.html#ga839bbeb4a4de73984b48b5ba8f4cccab">More...</a><br /></td></tr>
<tr class="separator:ga839bbeb4a4de73984b48b5ba8f4cccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33039c3161ba88d5abb24f4d5f020e4"><td class="memItemLeft" align="right" valign="top">long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__algebra.html#gad33039c3161ba88d5abb24f4d5f020e4">regina::GroupPresentation::NWordSubstitutionData::score</a></td></tr>
<tr class="memdesc:gad33039c3161ba88d5abb24f4d5f020e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The score, i.e., the decrease in the word letter count provided this substitution is made.  <a href="group__algebra.html#gad33039c3161ba88d5abb24f4d5f020e4">More...</a><br /></td></tr>
<tr class="separator:gad33039c3161ba88d5abb24f4d5f020e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gaffec81b08826210c7ee5fa33e4de25e2"><td class="memItemLeft" align="right" valign="top"><a id="gaffec81b08826210c7ee5fa33e4de25e2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::MarkedAbelianGroup::HomMarkedAbelianGroup</b></td></tr>
<tr class="separator:gaffec81b08826210c7ee5fa33e4de25e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Various algebraic structures. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga662fd6697ca03b1b0e4f6173f4c729af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga662fd6697ca03b1b0e4f6173f4c729af">&#9670;&nbsp;</a></span>NAbelianGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> <a class="el" href="group__algebra.html#ga662fd6697ca03b1b0e4f6173f4c729af">regina::NAbelianGroup</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>The class NAbelianGroup has now been renamed to <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a>. </dd></dl>

</div>
</div>
<a id="ga15d4ba66291ab83c46aa1937ca2e013a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15d4ba66291ab83c46aa1937ca2e013a">&#9670;&nbsp;</a></span>NGroupExpression</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> <a class="el" href="group__algebra.html#ga15d4ba66291ab83c46aa1937ca2e013a">regina::NGroupExpression</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>The struct NGroupExpression has now been renamed to <a class="el" href="classregina_1_1GroupExpression.html" title="Represents an expression involving generators from a group presentation or a free group.">GroupExpression</a>. </dd></dl>

</div>
</div>
<a id="ga7fdca61a051e0a5d53c4afcd54ee8587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fdca61a051e0a5d53c4afcd54ee8587">&#9670;&nbsp;</a></span>NGroupExpressionTerm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> <a class="el" href="group__algebra.html#ga7fdca61a051e0a5d53c4afcd54ee8587">regina::NGroupExpressionTerm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>The struct NGroupExpressionTerm has now been renamed to <a class="el" href="structregina_1_1GroupExpressionTerm.html" title="Represents a power of a generator in a group presentation.">GroupExpressionTerm</a>. </dd></dl>

</div>
</div>
<a id="gafb7e3c50225946da320c9ea879915461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb7e3c50225946da320c9ea879915461">&#9670;&nbsp;</a></span>NGroupPresentation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> <a class="el" href="group__algebra.html#gafb7e3c50225946da320c9ea879915461">regina::NGroupPresentation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>The struct NGroupPresentation has now been renamed to <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a>. </dd></dl>

</div>
</div>
<a id="ga64199b6ed14045690701c547d40405bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64199b6ed14045690701c547d40405bf">&#9670;&nbsp;</a></span>NHomGroupPresentation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> <a class="el" href="group__algebra.html#ga64199b6ed14045690701c547d40405bf">regina::NHomGroupPresentation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>The class NHomGroupPresentation has now been renamed to <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a>. </dd></dl>

</div>
</div>
<a id="ga17ec63facf1abd66b3836639a9442991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17ec63facf1abd66b3836639a9442991">&#9670;&nbsp;</a></span>NHomMarkedAbelianGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> <a class="el" href="group__algebra.html#ga17ec63facf1abd66b3836639a9442991">regina::NHomMarkedAbelianGroup</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>The class NHomMarkedAbelianGroup has now been renamed to <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>. </dd></dl>

</div>
</div>
<a id="ga40d169eec300ce18756c423cc712f41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40d169eec300ce18756c423cc712f41b">&#9670;&nbsp;</a></span>NMarkedAbelianGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> <a class="el" href="group__algebra.html#ga40d169eec300ce18756c423cc712f41b">regina::NMarkedAbelianGroup</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>The class NMarkedAbelianGroup has now been renamed to <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad5bf25488fbf05a2f0ad0d7c3b63be59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5bf25488fbf05a2f0ad0d7c3b63be59">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new trivial group. </p>

</div>
</div>
<a id="ga6aa09553f6ad8761b079032f00318378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa09553f6ad8761b079032f00318378">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the group to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga712bec823deba982b0712adabc6d4d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga712bec823deba982b0712adabc6d4d23">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex. </p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a id="ga2bfaa1a1a6aa834ffaa0883e37416bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bfaa1a1a6aa834ffaa0883e37416bd6">&#9670;&nbsp;</a></span>AbelianGroup() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients. </p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
    <tr><td class="paramname">p</td><td>the modulus, which may be any Integer. Zero is interpreted as a request for integer coefficents, which will give the same result as the <a class="el" href="group__algebra.html#ga712bec823deba982b0712adabc6d4d23" title="Creates an abelian group as the homology of a chain complex.">AbelianGroup(const MatrixInt&amp;, const MatrixInt&amp;)</a> constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a id="ga4021da14012efb7a5fbe770662060259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4021da14012efb7a5fbe770662060259">&#9670;&nbsp;</a></span>abelianisation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&gt; regina::GroupPresentation::abelianisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the abelianisation of this group. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated abelianisation of this group. </dd></dl>

</div>
</div>
<a id="gaefc7827368f5d5c46b125c526720eb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefc7827368f5d5c46b125c526720eb7b">&#9670;&nbsp;</a></span>addGenerator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::addGenerator </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>numToAdd</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds one or more generators to the group presentation. </p>
<p>If the new presentation has <em>g</em> generators, the new generators will be numbered <em>g</em>-1, <em>g</em>-2 and so on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numToAdd</td><td>the number of generators to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of generators in the new presentation. </dd></dl>

</div>
</div>
<a id="ga3f258af0b04c62e2de0f61df3d710509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f258af0b04c62e2de0f61df3d710509">&#9670;&nbsp;</a></span>addGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given abelian group to this group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to add to this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06e49620574efadb724e8fd07449d5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06e49620574efadb724e8fd07449d5e8">&#9670;&nbsp;</a></span>addGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>presentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the abelian group defined by the given presentation to this group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">presentation</td><td>a presentation matrix for the group to be added to this group, where each column represents a generator and each row a relation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaffd523df4ffbe34d6d38adacd4b6e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaffd523df4ffbe34d6d38adacd4b6e7d">&#9670;&nbsp;</a></span>addRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addRank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extraRank</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the rank of the group by the given integer. </p>
<p>This integer may be positive, negative or zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The current rank plus the given integer is non-negative. In other words, if we are subtracting rank then we are not trying to subtract more rank than the group actually has.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraRank</td><td>the extra rank to add; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87e31202d42ccdaa2dc7bc362e47df86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e31202d42ccdaa2dc7bc362e47df86">&#9670;&nbsp;</a></span>addRelation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::addRelation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> *&#160;</td>
          <td class="paramname"><em>rel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given relation to the group presentation. </p>
<p>The relation must be of the form <code>expression = 1</code>.</p>
<p>This presentation will take ownership of the given expression, may change it and will be responsible for its deallocation.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine does not check whether or not your relation is a word only in the generators of this group. In other words, it does not stop you from using generators beyond the <a class="el" href="group__algebra.html#ga610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a> bound.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>In Python, this routine clones its argument instead of claiming ownership of it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rel</td><td>the expression that the relation sets to 1; for instance, if the relation is <code>g1^2 g2 = 1</code> then this parameter should be the expression <code>g1^2 g2</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe1e06fa7de1208569484895d832274a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe1e06fa7de1208569484895d832274a">&#9670;&nbsp;</a></span>addStringFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::addStringFirst </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the left by the word respresented by the given string. </p>
<p>See the string-based constructor <a class="el" href="group__algebra.html#gadfbc34d75a9cb38218f25c8ed5582ccf" title="Attempts to interpret the given input string as a word in a group.">GroupExpression(const std::string&amp;, bool*)</a> for further information on how this string should be formatted.</p>
<p>If the given string cannot be interpreted as a word in a group, then this expression will be left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a string representation of the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given string could interpreted (and therefore the multiplication was completed successfully), or <code>false</code> if the given string could not be interpreted (in which case this expression will be left untouched). </dd></dl>

</div>
</div>
<a id="gafe11d45edbdfe2ed3915a2fd2203560d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe11d45edbdfe2ed3915a2fd2203560d">&#9670;&nbsp;</a></span>addStringLast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::addStringLast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the right by the word respresented by the given string. </p>
<p>See the string-based constructor <a class="el" href="group__algebra.html#gadfbc34d75a9cb38218f25c8ed5582ccf" title="Attempts to interpret the given input string as a word in a group.">GroupExpression(const std::string&amp;, bool*)</a> for further information on how this string should be formatted.</p>
<p>If the given string cannot be interpreted as a word in a group, then this expression will be left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a string representation of the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given string could interpreted (and therefore the multiplication was completed successfully), or <code>false</code> if the given string could not be interpreted (in which case this expression will be left untouched). </dd></dl>

</div>
</div>
<a id="ga29a2753d395ab5cb3089cb09ec637d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29a2753d395ab5cb3089cb09ec637d86">&#9670;&nbsp;</a></span>addTermFirst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the beginning of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfe441455a1744f9b5a02cc0fa20bfcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfe441455a1744f9b5a02cc0fa20bfcf">&#9670;&nbsp;</a></span>addTermFirst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermFirst </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the beginning of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the number of the generator corresponding to the new term. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent to which the given generator is raised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga372453b28e949d4ddacd682fb655cbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga372453b28e949d4ddacd682fb655cbda">&#9670;&nbsp;</a></span>addTermLast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermLast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the end of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga539c39976a30b6836a750ffb57fd4d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga539c39976a30b6836a750ffb57fd4d90">&#9670;&nbsp;</a></span>addTermLast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermLast </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the end of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the number of the generator corresponding to the new term. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent to which the given generator is raised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade9d2537788e2b9ca4019a9ed62bf695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9d2537788e2b9ca4019a9ed62bf695">&#9670;&nbsp;</a></span>addTermsFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermsFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the left by the given word. </p>
<p>This expression will be modified directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8411bb87da43d3b5e4d2d7573b1600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8411bb87da43d3b5e4d2d7573b1600a">&#9670;&nbsp;</a></span>addTermsLast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermsLast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the right by the given word. </p>
<p>This expression will be modified directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9de8c90029f068306126465da9f7296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9de8c90029f068306126465da9f7296">&#9670;&nbsp;</a></span>addTorsionElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mult</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given torsion element to the group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial. If many different torsion elements are to be added, consider using <a class="el" href="group__algebra.html#ga70f9f394fc848b2483e5ac93ad6e7cef" title="Adds the given set of torsion elements to this group.">addTorsionElements()</a> instead so the invariant factors need only be calculated once.</p>
<p>In this routine we add a specified number of copies of Z_<em>d</em>, where <em>d</em> is some given degree.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2 and the given multiplicity is at least 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td><em>d</em>, where we are adding copies of <em>Z_d</em> to the torsion. </td></tr>
    <tr><td class="paramname">mult</td><td>the multiplicity <em>m</em>, where we are adding precisely <em>m</em> copies of <em>Z_d</em>; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae926d3d6b0dce31e40c27eb475057077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae926d3d6b0dce31e40c27eb475057077">&#9670;&nbsp;</a></span>addTorsionElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElement </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mult</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given torsion element to the group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial. If many different torsion elements are to be added, consider using <a class="el" href="group__algebra.html#ga70f9f394fc848b2483e5ac93ad6e7cef" title="Adds the given set of torsion elements to this group.">addTorsionElements()</a> instead so the invariant factors need only be calculated once.</p>
<p>In this routine we add a specified number of copies of Z_<em>d</em>, where <em>d</em> is some given degree.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2 and the given multiplicity is at least 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td><em>d</em>, where we are adding copies of <em>Z_d</em> to the torsion. </td></tr>
    <tr><td class="paramname">mult</td><td>the multiplicity <em>m</em>, where we are adding precisely <em>m</em> copies of <em>Z_d</em>; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70f9f394fc848b2483e5ac93ad6e7cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70f9f394fc848b2483e5ac93ad6e7cef">&#9670;&nbsp;</a></span>addTorsionElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElements </td>
          <td>(</td>
          <td class="paramtype">const std::multiset&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>torsion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given set of torsion elements to this group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<p>The torsion elements to add are described by a list of integers <em>k1</em>,...,<em>km</em>, where we are adding Z_<em>k1</em>,...,Z_<em>km</em>. Unlike invariant factors, the <em>ki</em> are not required to divide each other.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each integer in the given list is strictly greater than 1.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine takes a python list as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">torsion</td><td>a list containing the torsion elements to add, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf8c72fcfbf384f9c72742f7fc024f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf8c72fcfbf384f9c72742f7fc024f70">&#9670;&nbsp;</a></span>boundaryMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::boundaryMap </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>CCrep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the differential of the given vector in the chain complex whose kernel is the cycles. </p>
<p>In other words, this routine returns <code>M*CCrep</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CCrep</td><td>a vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the differential, expressed as a vector of length M.rows(). </dd></dl>

</div>
</div>
<a id="ga77834f35e4900eed8e928688ce898f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77834f35e4900eed8e928688ce898f2a">&#9670;&nbsp;</a></span>ccRep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::ccRep </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>SNFRep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of freeRep and torsionRep, this routine takes a vector which represents an element in the group in the SNF coordinates and returns a corresponding vector in the original chain complex. </p>
<p>This routine is the inverse to <a class="el" href="group__algebra.html#ga0563fc60015d3690c89776aaf94c956b" title="Expresses the given vector as a combination of free and torsion generators.">snfRep()</a> described below.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SNFRep</td><td>a vector of size the number of generators of the group, i.e., it must be valid in the SNF coordinates. If not, an empty vector is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex; see the class notes for details. </dd></dl>

</div>
</div>
<a id="gaebf137dca4e97dfa1ef9f703f2787008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebf137dca4e97dfa1ef9f703f2787008">&#9670;&nbsp;</a></span>ccRep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::ccRep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>SNFRep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as ccRep(const std::vector&lt;Integer&gt;&amp;), but we assume you only want the chain complex representation of a standard basis vector from SNF coordinates. </p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">SNFRep</td><td>specifies which standard basis vector from SNF coordinates; this must be between 0 and <a class="el" href="group__algebra.html#gab5e8b466766eb274146277ac9bd98a55" title="Returns the minimum number of generators for the group.">minNumberOfGenerators()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex; see the class notes for details. </dd></dl>

</div>
</div>
<a id="gabd1d6947da29e7eb4e2765f268da6d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd1d6947da29e7eb4e2765f268da6d64">&#9670;&nbsp;</a></span>coefficients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp; regina::MarkedAbelianGroup::coefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coefficients used for the computation of homology. </p>
<p>That is, this routine returns the integer <em>p</em> where we use coefficients in Z_p. If we use coefficients in the integers Z, then this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the coefficients used in the homology calculation. </dd></dl>

</div>
</div>
<a id="gae2e353de0ec88b8424c111ba97b10d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e353de0ec88b8424c111ba97b10d27">&#9670;&nbsp;</a></span>cokernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::cokernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the cokernel of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the cokernel of the homomorphism, as a marked abelian group. </dd></dl>

</div>
</div>
<a id="ga8c930c1a8cdb5e53c2a01747dca8c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c930c1a8cdb5e53c2a01747dca8c1e5">&#9670;&nbsp;</a></span>compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupPresentation::compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a compact one-line representation of this group presentation, including details of all generators and relations. </p>
<p>See <a class="el" href="group__algebra.html#gaf9848a7d3303be02671e18c57d28afec" title="Writes a compact represesentation of this group to the given output stream.">writeTextCompact()</a> for details on how this is formed.</p>
<dl class="section return"><dt>Returns</dt><dd>a compact representation of this group presentation. </dd></dl>

</div>
</div>
<a id="ga528e30f6bae521207e5c9315af07fba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga528e30f6bae521207e5c9315af07fba6">&#9670;&nbsp;</a></span>composeWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&gt; regina::HomGroupPresentation::composeWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes this homomorphism with the given input homomorphism. </p>
<p>Evaluating the composition on some group element <em>x</em> is the same as evaluating <code>this(input(x))</code>. In other words, in this composition, <em>input</em> is evaluated first and then the output of that is evaluated by this homomorphism.</p>
<p>If both of the given homomorphisms are declared isomorphisms, then the return value will be a declared isomoprhism also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>the range of <em>input</em> must be the same as the domain of this homomorphism.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the homomorphism to compose with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the composition of both homomorphisms. </dd></dl>

</div>
</div>
<a id="ga610ea6821977d1a2f6709627316e7649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga610ea6821977d1a2f6709627316e7649">&#9670;&nbsp;</a></span>countGenerators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::countGenerators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators in this group presentation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of generators. </dd></dl>

</div>
</div>
<a id="ga3eb7bc0b871554e7302ba01b17470fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb7bc0b871554e7302ba01b17470fe0">&#9670;&nbsp;</a></span>countInvariantFactors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::countInvariantFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of invariant factors. </dd></dl>

</div>
</div>
<a id="gaa25dc94bfeb64347d3d88ed3505334d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25dc94bfeb64347d3d88ed3505334d5">&#9670;&nbsp;</a></span>countInvariantFactors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedAbelianGroup::countInvariantFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group. </p>
<p>This is the minimal number of torsion generators. See the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of invariant factors. </dd></dl>

</div>
</div>
<a id="ga2ffa647790e42c8d984168db32197d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ffa647790e42c8d984168db32197d22">&#9670;&nbsp;</a></span>countRelations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupPresentation::countRelations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of relations in this group presentation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of relations. </dd></dl>

</div>
</div>
<a id="ga2aeebe99241025551efccdbc0640417f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aeebe99241025551efccdbc0640417f">&#9670;&nbsp;</a></span>countTerms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupExpression::countTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of terms in this expression. </p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> contains three terms. See also <a class="el" href="group__algebra.html#ga4c683c8a7391ae8ad801b2c48e6ae3f6" title="Returns the length of the word, i.e.">wordLength()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms. </dd></dl>

</div>
</div>
<a id="gaf38ec35918dfa4fb844982feac3fff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf38ec35918dfa4fb844982feac3fff28">&#9670;&nbsp;</a></span>cycleGen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::cycleGen </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>i</em>th generator of the cycles, i.e., the kernel of M in the chain complex. </p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, as it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>between 0 and minNumCycleGens()-1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding generator in chain complex coordinates. </dd></dl>

</div>
</div>
<a id="ga30471b33e30035e299ebfae316519d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30471b33e30035e299ebfae316519d0c">&#9670;&nbsp;</a></span>cycleLeft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::cycleLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycles this word by moving the rightmost term around to the leftmost. </p>
<p>All other terms shift one step to the right.</p>
<p>If the word is of the form <code>g_i1^j1 g_i2^j2 ... g_in^jn</code>, this converts it into the word <code>g_in^jn g_i1^j1 g_i1^j1 ... g_in-1^jn-1</code>. </p>

</div>
</div>
<a id="gae63e1b742025e5d366ee982cbf618ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae63e1b742025e5d366ee982cbf618ec8">&#9670;&nbsp;</a></span>cycleProjection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::cycleProjection </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ccelt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an element of the chain complex to the subspace of cycles. </p>
<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an empty vector if the input element does not have dimensions of the chain complex.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccelt</td><td>a vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a corresponding vector, also in the chain complex coordinates. </dd></dl>

</div>
</div>
<a id="ga1b08ed9f51b87f8390c5f38996b82e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b08ed9f51b87f8390c5f38996b82e38">&#9670;&nbsp;</a></span>cycleProjection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::cycleProjection </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ccindx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects an element of the chain complex to the subspace of cycles. </p>
<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an empty vector if the input index is out of bounds.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ccindx</td><td>the index of the standard basis vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting projection, in the chain complex coordinates. </dd></dl>

</div>
</div>
<a id="ga688406ed1ec6e9f3dfd4f31a220729c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga688406ed1ec6e9f3dfd4f31a220729c4">&#9670;&nbsp;</a></span>cycleRight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::cycleRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycles this word by moving the leftmost term around to the rightmost. </p>
<p>All other terms shift one step to the left.</p>
<p>If the word is of the form <code>g_i1^j1 g_i2^j2 ... g_in^jn</code>, this converts it into the word <code>g_i2^j2 ... g_in^jn g_i1^j1</code>. </p>

</div>
</div>
<a id="ga81d1d62efe5d42f9914693969e3e4b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81d1d62efe5d42f9914693969e3e4b6f">&#9670;&nbsp;</a></span>definingMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::HomMarkedAbelianGroup::definingMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the defining matrix for the homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the matrix that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a id="ga7f7f2527f5247f549e2f96bae2f2682b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7f2527f5247f549e2f96bae2f2682b">&#9670;&nbsp;</a></span>domain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; regina::HomGroupPresentation::domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The domain of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the domain. </dd></dl>

</div>
</div>
<a id="ga5b6ad98271d7a7e95931ead6e727309c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b6ad98271d7a7e95931ead6e727309c">&#9670;&nbsp;</a></span>domain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the domain of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the domain that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a id="gaf033c93a7017458c5e941bd0a508ad33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf033c93a7017458c5e941bd0a508ad33">&#9670;&nbsp;</a></span>endSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLGroupPresentationReader::endSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing has finished for a subelement of this XML element. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__algebra.html#gaf90354f52dfa7a5b3e8cc9603bc298ff" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga6957484c2540429d42866348285f0cf7">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga7c17b81d8ed166a87d1f57d0864d61e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c17b81d8ed166a87d1f57d0864d61e7">&#9670;&nbsp;</a></span>equalTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::equalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not the two MarkedAbelianGroups are identical, which means they have exactly the same presentation matrices. </p>
<p>This is useful for determining if two HomMarkedAbelianGroups are composable. See <a class="el" href="group__algebra.html#gad04a54db050fca088bad38c7b5b9c980" title="Determines whether this and the given abelian group are isomorphic.">isIsomorphicTo()</a> if all you care about is the isomorphism relation among groups defined by presentation matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups have identical chain-complex definitions. </dd></dl>

</div>
</div>
<a id="gaad4e343e87b3c1b157a97292651e1d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad4e343e87b3c1b157a97292651e1d25">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::erase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all terms from this this word. </p>
<p>This effectively turns this word into the identity element. </p>

</div>
</div>
<a id="ga09b903afa2ba14ee0d159ecd36199ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b903afa2ba14ee0d159ecd36199ce9">&#9670;&nbsp;</a></span>evalCC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::HomMarkedAbelianGroup::evalCC </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the image of a vector under this homomorphism, using the original chain complexes' coordinates. </p>
<p>This involves multiplication by the defining matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in the domain chain complex's coordinates, of length <a class="el" href="group__algebra.html#ga5b6ad98271d7a7e95931ead6e727309c" title="Returns the domain of this homomorphism.">domain()</a>.M().columns(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this vector in the range chain complex's coordinates, of length <a class="el" href="group__algebra.html#ga6785735056383f2f66b9e44c1c3e6ef3" title="Returns the range of this homomorphism.">range()</a>.M().columns(). </dd></dl>

</div>
</div>
<a id="ga895179b6078be8be5420ac3c41f41d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga895179b6078be8be5420ac3c41f41d91">&#9670;&nbsp;</a></span>evalSNF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::HomMarkedAbelianGroup::evalSNF </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the image of a vector under this homomorphism, using the Smith normal form coordinates. </p>
<p>This is just multiplication by the reduced matrix, returning the empty vector if the input vector has the wrong dimensions.</p>
<dl class="section warning"><dt>Warning</dt><dd>Smith normal form coordinates are sensitive to the implementation of the Smith Normal Form, i.e., they are not canonical.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in the domain SNF coordinates, of length <a class="el" href="group__algebra.html#ga5b6ad98271d7a7e95931ead6e727309c" title="Returns the domain of this homomorphism.">domain()</a>.minNumberOfGenerators(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this vector in the range chain complex's coordinates, of length <a class="el" href="group__algebra.html#ga6785735056383f2f66b9e44c1c3e6ef3" title="Returns the range of this homomorphism.">range()</a>.minNumberOfGenerators(). </dd></dl>

</div>
</div>
<a id="gab97d1a45f27160a284918d2b1ab0162e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97d1a45f27160a284918d2b1ab0162e">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the homomorphism at an element of the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>an element of the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this element in the range. </dd></dl>

</div>
</div>
<a id="gaea6512988efb34a5c0d4785d5ae24bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea6512988efb34a5c0d4785d5ae24bd6">&#9670;&nbsp;</a></span>evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::evaluate </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the homomorphism at a generator of the domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of a generator in the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of the <em>i</em>th generator in the range. </dd></dl>

</div>
</div>
<a id="gaff0207f2d1602d0e1a7752b9bb2b0183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff0207f2d1602d0e1a7752b9bb2b0183">&#9670;&nbsp;</a></span>exponent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::GroupExpression::exponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the exponent corresonding to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="group__algebra.html#ga2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested exponent. </dd></dl>

</div>
</div>
<a id="gaf0e2133542af695b8b850b6281ee6feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e2133542af695b8b850b6281ee6feb">&#9670;&nbsp;</a></span>freeRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::freeRep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested free generator in the original chain complex defining the group. </p>
<p>As described in the class overview, this marked abelian group is defined by matrices <em>M</em> and <em>N</em> where M*N = 0. If <em>M</em> is an <em>m</em> by <em>l</em> matrix and <em>N</em> is an <em>l</em> by <em>n</em> matrix, then this routine returns the (<em>index</em>)th free generator of ker(M)/img(N) in <em>Z^l</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which free generator to look up; this must be between 0 and <a class="el" href="group__algebra.html#ga000ce1a1c59819c497cd964486be934f" title="Returns the rank of the group.">rank()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinates of the free generator in the nullspace of <em>M</em>; this vector will have length M.columns() (or equivalently, N.rows()). If this generator does not exist, you will receive an empty vector. </dd></dl>

</div>
</div>
<a id="gaa5851d978d13f5844ccbf2a6bc7de001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5851d978d13f5844ccbf2a6bc7de001">&#9670;&nbsp;</a></span>generator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupExpression::generator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the generator corresonding to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="group__algebra.html#ga2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the requested generator. </dd></dl>

</div>
</div>
<a id="ga37fe47d46e60bf4c37150ded43073084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fe47d46e60bf4c37150ded43073084">&#9670;&nbsp;</a></span>group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> * regina::XMLAbelianGroupReader::group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated abelian group that has been read by this element reader. </p>
<dl class="section return"><dt>Returns</dt><dd>the group that has been read, or 0 if an error occurred. </dd></dl>

</div>
</div>
<a id="ga78da5667ebb1527d778d0f84a04b7574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78da5667ebb1527d778d0f84a04b7574">&#9670;&nbsp;</a></span>group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> * regina::XMLGroupPresentationReader::group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated group presentation that has been read by this element reader. </p>
<dl class="section return"><dt>Returns</dt><dd>the group that has been read, or 0 if an error occurred. </dd></dl>

</div>
</div>
<a id="gacc1d5b73995d9fb27c1b73edaac73c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc1d5b73995d9fb27c1b73edaac73c08">&#9670;&nbsp;</a></span>GroupExpression() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The terms that make up this expression. </p>
<p>Creates a new expression with no terms. </p>

</div>
</div>
<a id="ga2f2c9cfc082f39e382a38b72d72a0677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f2c9cfc082f39e382a38b72d72a0677">&#9670;&nbsp;</a></span>GroupExpression() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new expression that is a clone of the given expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the expression to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadfbc34d75a9cb38218f25c8ed5582ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfbc34d75a9cb38218f25c8ed5582ccf">&#9670;&nbsp;</a></span>GroupExpression() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to interpret the given input string as a word in a group. </p>
<p>Regina can recognise strings in the following four basic forms:</p>
<ul>
<li><code>a^7b^-2</code> </li>
<li><code>aaaaaaaBB</code> </li>
<li><code>a^7B^2</code> </li>
<li><code>g0^7g1^-2</code> </li>
</ul>
<p>The string may contain whitespace, which will simply be ignored.</p>
<p>The argument <em>valid</em> may be <code>null</code>, but if it is non-null then the boolean it points to will be used for error reporting. This routine sets valid to <code>true</code> if the string was successfully interpreted, or <code>false</code> if the algorithm failed to interpret the string.</p>
<p>Regardless of whether <em>valid</em> is <code>null</code>, if the string could not be interpreted then this expression will be initialised to the trivial word.</p>
<dl class="section user"><dt>Python</dt><dd>The second argument <em>valid</em> is not present, and will be assumed to be <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input string that is to be interpreted. </td></tr>
    <tr><td class="paramname">valid</td><td>used for error reporting as described above, or <code>null</code> if no error reporting is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ac61c7392b0e70f7f70a38e2405b61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ac61c7392b0e70f7f70a38e2405b61c">&#9670;&nbsp;</a></span>GroupExpressionTerm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpressionTerm::GroupExpressionTerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised term. </p>

</div>
</div>
<a id="gac0dc710a480e83bcf44467c729095866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0dc710a480e83bcf44467c729095866">&#9670;&nbsp;</a></span>GroupExpressionTerm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpressionTerm::GroupExpressionTerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new term initialised to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>a term whose data will be copied to the new term. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb163426eabcec172dea7e49fe537f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb163426eabcec172dea7e49fe537f81">&#9670;&nbsp;</a></span>GroupExpressionTerm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpressionTerm::GroupExpressionTerm </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newGen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newExp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new term initialised to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newGen</td><td>the number that identifies the generator in the new term. </td></tr>
    <tr><td class="paramname">newExp</td><td>the exponent to which this generator is raised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35ffeca6d3c8d43baafeeba6fc0d303b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35ffeca6d3c8d43baafeeba6fc0d303b">&#9670;&nbsp;</a></span>GroupPresentation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new presentation with no generators and no relations. </p>

</div>
</div>
<a id="gaa106507aa970573666c0d9b8085cfe5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa106507aa970573666c0d9b8085cfe5e">&#9670;&nbsp;</a></span>GroupPresentation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of the given group presentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the presentation to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0e5de7fb4b495c779c61c8580f2723a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0e5de7fb4b495c779c61c8580f2723a">&#9670;&nbsp;</a></span>GroupPresentation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::GroupPresentation </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nGens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor that allows you to directly pass an arbitrary number of relators in string format. </p>
<p>The first argument <em>nGens</em> is the number of generators one wants the group to have. The second argument <em>rels</em> is a vector of strings, where each string gives a single relator. See the <a class="el" href="group__algebra.html#gadfbc34d75a9cb38218f25c8ed5582ccf" title="Attempts to interpret the given input string as a word in a group.">GroupExpression::GroupExpression(const std::string&amp;, bool*)</a> constructor notes for information on what format these strings can take.</p>
<p>If any of the given strings could not be interpreted as words, this routine will insert the trivial (unit) word in its place.</p>
<p>If you are compiling Regina against C++11, you can use the C++11 initializer_list construction to construct an <a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a> directly using syntax of the form <code><a class="el" href="classregina_1_1GroupPresentation.html" title="Represents a finite presentation of a group.">GroupPresentation</a>(nGens, { "rel1", "rel2", ... })</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nGens</td><td>the number of generators. </td></tr>
    <tr><td class="paramname">rels</td><td>a vector of relations each given in string form, as outlined above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b076c4c6bae31bd4efa6562a1ead073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b076c4c6bae31bd4efa6562a1ead073">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new homomorphism from the given data. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>the domain of the homomorphism. </td></tr>
    <tr><td class="paramname">range</td><td>the range of the homomorphism. </td></tr>
    <tr><td class="paramname">map</td><td>a vector of length <em>g</em>, where <em>g</em> is the number of generators of the domain, and where this homomorphism sends the <em>i</em>th generator of the domain to the element <code>map[i]</code> of the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gad7bc5b3895007ae0351d49fd1788ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7bc5b3895007ae0351d49fd1788ca53">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a declared isomorphism from the given data. </p>
<p>Here you must provide both a map from the domain to range, and the inverse map from the range to domain.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The argument <em>inv</em> is indeed the inverse of <em>map</em>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>the domain of the homomorphism. </td></tr>
    <tr><td class="paramname">range</td><td>the range of the homomorphism. </td></tr>
    <tr><td class="paramname">map</td><td>a vector of length <em>g</em>, where <em>g</em> is the number of generators of the domain, and where this homomorphism sends the <em>i</em>th generator of the domain to the element <code>map[i]</code> of the range. </td></tr>
    <tr><td class="paramname">inv</td><td>a vector of length <em>k</em> where <em>k</em> is the number of generators of the range, and where the inverse homomorphism sends the <em>i</em>th generator of the range to the element <code>inv[i]</code> of the domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3799566faa70c9e628dc75953553b8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3799566faa70c9e628dc75953553b8a2">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>groupForIdentity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new identity homomorphism for the given group. </p>
<p>This will be a declared isomorphism (see the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupForIdentity</td><td>both the range and domain of the new identity homomorphism. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0aea71e6385c36ebd19a74db79bdef86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aea71e6385c36ebd19a74db79bdef86">&#9670;&nbsp;</a></span>HomGroupPresentation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::HomGroupPresentation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group presentation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the presentation to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbde369a4fe315e50c0a8c4a9d327912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbde369a4fe315e50c0a8c4a9d327912">&#9670;&nbsp;</a></span>HomMarkedAbelianGroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>the homomorphism to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2226807b3a0d0d3ddf9f0acc0a3a5029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2226807b3a0d0d3ddf9f0acc0a3a5029">&#9670;&nbsp;</a></span>HomMarkedAbelianGroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>dom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>ran</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a homomorphism from two marked abelian groups and a matrix that indicates where the generators are sent. </p>
<p>The roles of the two groups and the matrix are described in detail in the <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> class overview.</p>
<p>The matrix must be given in the chain-complex coordinates. Specifically, if the domain was defined via the chain complex <code>Z^a &ndash;N1--&gt; Z^b &ndash;M1--&gt; Z^c</code> and the range was defined via <code>Z^d &ndash;N2--&gt; Z^e &ndash;M2--&gt; Z^f</code>, then <em>mat</em> is an e-by-b matrix that describes a homomorphism from Z^b to Z^e.</p>
<p>In order for this to make sense as a homomorphism of the groups represented by the domain and range respectively, one requires img(mat*N1) to be a subset of img(N2). Similarly, ker(M1) must be sent into ker(M2). These facts are not checked, but are assumed as preconditions of this constructor.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The matrix <em>mat</em> has the required dimensions e-by-b, gives img(mat*N1) as a subset of img(N2), and sends ker(M1) into ker(M2), as explained in the detailed notes above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dom</td><td>the domain group. </td></tr>
    <tr><td class="paramname">ran</td><td>the range group. </td></tr>
    <tr><td class="paramname">mat</td><td>the matrix that describes the homomorphism from <em>dom</em> to <em>ran</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf6428c2ece188536f87fe7ca5cb7d49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6428c2ece188536f87fe7ca5cb7d49d">&#9670;&nbsp;</a></span>homologicalAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::homologicalAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible). </p>
<p>Consider this a <em>homological-alignment</em> of the presentation.</p>
<p>See <a class="el" href="group__algebra.html#ga6072043f595d328349c365e9d6f37fd3" title="Rewrites the presentation so that generators of the group map to generators of the abelianisation,...">homologicalAlignmentDetail()</a> for further details on what this routine does.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if presentation was changed, or <code>false</code> if the presentation was already homologically aligned. See <a class="el" href="group__algebra.html#ga6072043f595d328349c365e9d6f37fd3" title="Rewrites the presentation so that generators of the group map to generators of the abelianisation,...">homologicalAlignmentDetail()</a> if you wish to get the isomorphism. </dd></dl>

</div>
</div>
<a id="ga6072043f595d328349c365e9d6f37fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6072043f595d328349c365e9d6f37fd3">&#9670;&nbsp;</a></span>homologicalAlignmentDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&gt; regina::GroupPresentation::homologicalAlignmentDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the presentation so that generators of the group map to generators of the abelianisation, with any left-over generators mapping to zero (if possible). </p>
<p>Consider this a <em>homological-alignment</em> of the presentation.</p>
<p>If the abelianisation of this group has rank <em>N</em> and <em>M</em> invariant factors <code>d0 | d2 | ... | d(M-1)</code>, this routine applies Nielsen moves to the presentation to ensure that under the <a class="el" href="group__algebra.html#gaee8939724e818da45670621a8d431b90" title="Computes the abelianisation of this group.">markedAbelianisation()</a> routine, generators 0 through <em>M-1</em> are mapped to generators of the relevant <code>Z_di</code> group. Similarly, generators <em>M</em> through <em>M</em>+<em>N</em>-1 are mapped to +/-1 in the appropriate factor. All further generators will be mapped to zero.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism giving the reduction map from the old presentation to the new, or a null pointer if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="ga23f4798b7eca1cb22d8b5c3414d5f256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f4798b7eca1cb22d8b5c3414d5f256">&#9670;&nbsp;</a></span>identifyAbelian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::identifyAbelian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to determine if the group is abelian. </p>
<p>A return value of <code>true</code> indicates that this routine successfully certified that the group is abelian. A return value of <code>false</code> indicates an inconclusive result: either the group is non-abelian, or the group is abelian but this routine could not prove so.</p>
<p>If the group is abelian, then markedAbelianization() is the easiest way to see precisely which abelian group it is, and how the generators sit in that group.</p>
<p>You will have better results from this algorithm if the presentation has been simplified, since this algorithm uses small cancellation theory in an attempt to reduce the commutators of all pairs of generators.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you have not adequately simplified this presentation this routine will most likely return <code>false</code>. Consider running intelligentSimplify, possibly in concert with <a class="el" href="group__algebra.html#gaaa7653e9f59d3f194e4b560d7f84f6e6" title="A routine to help escape local wells when simplifying presentations, which may be useful when small c...">proliferateRelators()</a>, in order to discover adequately many commutators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the group is shown to be abelian, or <code>false</code> if the result is inconclusive. </dd></dl>

</div>
</div>
<a id="gaa57f9afdee9e1c46fa06e802a2c8e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa57f9afdee9e1c46fa06e802a2c8e652">&#9670;&nbsp;</a></span>identifySimplyIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::identifySimplyIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to prove that this and the given group presentation are <em>simply isomorphic</em>. </p>
<p>A <em>simple isomorphism</em> is an isomorphism where each generator <em>g<sub>i</sub></em> of this presentation is sent to some generator <em>g<sub>j</sub></em><sup>+/-1</sup> of the other presentation. Moreover, at present this routine only looks for maps where both presentations have the same number of generators, and where distinct generators <em>g<sub>i</sub></em> of this presentation correspond to distinct generators <em>g<sub>j</sub></em> of the other presentation (possibly with inversion, as noted above).</p>
<p>If this routine returns <code>true</code>, it means that the two presentations are indeed simply isomorphic.</p>
<p>If this routine returns <code>false</code>, it could mean one of many things:</p>
<ul>
<li>The groups are not isomorphic;</li>
<li>The groups are isomorphic, but not simply isomorphic;</li>
<li>The groups are simply isomorphic but this routine could not prove it, due to difficulties with the word problem.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group presentation to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this routine could certify that the two group presentations are simply isomorphic, or <code>false</code> if it could not. </dd></dl>

</div>
</div>
<a id="gaca4ffc683e473505b5e11c6e82bfb8b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4ffc683e473505b5e11c6e82bfb8b9">&#9670;&nbsp;</a></span>image()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the image of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the image of the homomorphism, as a marked abelian group. </dd></dl>

</div>
</div>
<a id="ga2a5b4836d67b669d25e7602043d35ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a5b4836d67b669d25e7602043d35ff4">&#9670;&nbsp;</a></span>initialChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLAbelianGroupReader::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga7e7f596f55ec44803ed094cc71ec3420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e7f596f55ec44803ed094cc71ec3420">&#9670;&nbsp;</a></span>intelligentNielsen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::intelligentNielsen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for Nielsen moves that will simplify the presentation. </p>
<p>Performs one of the most-effective moves, if it can find any.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if it performed a Nielsen move. You can call <a class="el" href="group__algebra.html#ga7e7f596f55ec44803ed094cc71ec3420" title="Looks for Nielsen moves that will simplify the presentation.">intelligentNielsen()</a> to get the isomorphism. </dd></dl>

</div>
</div>
<a id="gadb66be2c97c5c03a5ce61ea37f447dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb66be2c97c5c03a5ce61ea37f447dc0">&#9670;&nbsp;</a></span>intelligentNielsen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::intelligentNielsen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the domain and range using only Nielsen moves, keeping track of the resulting map in the progress. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if either presentation was changed. </dd></dl>

</div>
</div>
<a id="ga1b6505e3621220ef4bda814c1c37a4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b6505e3621220ef4bda814c1c37a4a5">&#9670;&nbsp;</a></span>intelligentNielsenDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&gt; regina::GroupPresentation::intelligentNielsenDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for Nielsen moves that will simplify the presentation. </p>
<p>Performs one of the most-effective moves, if it can find any.</p>
<p>If this routine does return a homomorphism (because some move was performed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the map from the original presentation to the new presentation, or a null pointer if no move was performed. </dd></dl>

</div>
</div>
<a id="gaee43de413fbbd1dd88bd645d3fac340f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee43de413fbbd1dd88bd645d3fac340f">&#9670;&nbsp;</a></span>intelligentSimplify() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation as intelligently as possible without further input. </p>
<p>See <a class="el" href="group__algebra.html#gacffb20abcd98421db215b1141108fb7d" title="Attempts to simplify the group presentation as intelligently as possible without further input.">intelligentSimplifyDetail()</a> for further details on how the simplification is done.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the group presentation was changed. You can call <a class="el" href="group__algebra.html#gacffb20abcd98421db215b1141108fb7d" title="Attempts to simplify the group presentation as intelligently as possible without further input.">intelligentSimplifyDetail()</a> to get the isomorphism. </dd></dl>

</div>
</div>
<a id="gac51beafb7f570b78db3a9328313a81af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac51beafb7f570b78db3a9328313a81af">&#9670;&nbsp;</a></span>intelligentSimplify() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simultaneously simplifies: </p>
<ul>
<li>the presentation of the domain;</li>
<li>the presentation of the range;</li>
<li>the description of the map.</li>
</ul>
<p>Uses the underlying <a class="el" href="group__algebra.html#gaee43de413fbbd1dd88bd645d3fac340f" title="Attempts to simplify the group presentation as intelligently as possible without further input.">GroupPresentation::intelligentSimplify()</a>. See that routine for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the presentations or map have changed. </dd></dl>

</div>
</div>
<a id="gacffb20abcd98421db215b1141108fb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacffb20abcd98421db215b1141108fb7d">&#9670;&nbsp;</a></span>intelligentSimplifyDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&gt; regina::GroupPresentation::intelligentSimplifyDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation as intelligently as possible without further input. </p>
<p>The current simplification method uses a combination of small cancellation theory and Nielsen moves.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the reduction map from the original presentation to the new presentation, or a null pointer if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="ga6e9b0ee0a3ba3323fddec44ca8a87dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e9b0ee0a3ba3323fddec44ca8a87dbb">&#9670;&nbsp;</a></span>invariantFactor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&amp; regina::AbelianGroup::invariantFactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<p>If the invariant factors are <em>d0</em>|<em>d1</em>|...|<em>dn</em>, this routine will return <em>di</em> where <em>i</em> is the value of parameter <em>index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the invariant factor to return; this must be between 0 and <a class="el" href="group__algebra.html#ga3eb7bc0b871554e7302ba01b17470fe0" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested invariant factor. </dd></dl>

</div>
</div>
<a id="ga1646cf2d9cb4bc31b0b0df1f1f4289a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1646cf2d9cb4bc31b0b0df1f1f4289a4">&#9670;&nbsp;</a></span>invariantFactor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp; regina::MarkedAbelianGroup::invariantFactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> class notes for further details.</p>
<p>If the invariant factors are <em>d0</em>|<em>d1</em>|...|<em>dn</em>, this routine will return <em>di</em> where <em>i</em> is the value of parameter <em>index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the invariant factor to return; this must be between 0 and <a class="el" href="group__algebra.html#gaa25dc94bfeb64347d3d88ed3505334d5" title="Returns the number of invariant factors that describe the torsion elements of this group.">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested invariant factor. </dd></dl>

</div>
</div>
<a id="gaa425a2e30651c963c641dd096fc50886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa425a2e30651c963c641dd096fc50886">&#9670;&nbsp;</a></span>inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> regina::GroupExpressionTerm::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the inverse of this term. </p>
<p>The inverse has the same generator but a negated exponent.</p>
<p>Note that this term will remain unchanged.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse of this term. </dd></dl>

</div>
</div>
<a id="gafc0bdc4dd3b1a5d1abe1e086b0a91b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc0bdc4dd3b1a5d1abe1e086b0a91b39">&#9670;&nbsp;</a></span>inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>* regina::GroupExpression::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is the inverse of this expression. </p>
<p>The terms will be reversed and the exponents negated.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse of this expression. </dd></dl>

</div>
</div>
<a id="ga5d3cc3f63fa92d4ee7e2aca0eeb6584b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3cc3f63fa92d4ee7e2aca0eeb6584b">&#9670;&nbsp;</a></span>inverseHom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::HomMarkedAbelianGroup::inverseHom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the inverse to a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>. </p>
<p>If this homomorphism is not invertible, this routine returns the zero homomorphism.</p>
<p>If you are computing with mod-p coefficients, this routine will further require that this invertible map preserves the UCT splitting of the group, i.e., it gives an isomorphism of the tensor product parts and the TOR parts. At present this suffices since we're only using this to construct maps between homology groups in different coordinate systems.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse homomorphism, or the zero homomorphism if this is not invertible. </dd></dl>

</div>
</div>
<a id="ga7e65aaa150201d3df9fd6199d136d63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e65aaa150201d3df9fd6199d136d63e">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts this expression. </p>
<p>Does not allocate or deallocate anything. </p>

</div>
</div>
<a id="ga746c24ac004ad8a426c072f0b7c17891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga746c24ac004ad8a426c072f0b7c17891">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts the homomorphism. </p>
<p>This is only possible if the homomorphism is in fact a declared isomorphism (which means that the inverse map is already stored internally). See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for further details on declared isomorphisms.</p>
<p>If this is not a declared isomorphism then this routine will do nothing and simply return <code>false</code>.</p>
<p>This operation is (very) fast constant time.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the inversion operation was successful (i.e., if this is a declared isomorphism). </dd></dl>

</div>
</div>
<a id="gadfc9413a22527d5fea70b46085df4e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfc9413a22527d5fea70b46085df4e84">&#9670;&nbsp;</a></span>invEvaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::invEvaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the isomorphisms's inverse at an element of the range. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This homomorphism is in fact a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>an element of the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this element in the domain. </dd></dl>

</div>
</div>
<a id="ga37003838777aedbe54e9cf372aa2fbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37003838777aedbe54e9cf372aa2fbd9">&#9670;&nbsp;</a></span>invEvaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> regina::HomGroupPresentation::invEvaluate </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate the isomorphism at a generator of the range. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This homomorphism is in fact a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the index of a generator in the range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of this generator in the domain. </dd></dl>

</div>
</div>
<a id="gaa8266305f2c94b9f7c7880715eba189e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8266305f2c94b9f7c7880715eba189e">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isBoundary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector, determines if it represents a boundary in the chain complex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a vector whose length is M.columns(), where <em>M</em> is one of the matrices that defines the chain complex (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given vector represents a boundary. </dd></dl>

</div>
</div>
<a id="ga466303b009840a96e49874e0f139854d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga466303b009840a96e49874e0f139854d">&#9670;&nbsp;</a></span>isChainComplex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isChainComplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not the defining maps for this group actually give a chain complex. </p>
<p>This is helpful for debugging.</p>
<p>Specifically, this routine returns <code>true</code> if and only if M*N = 0 where M and N are the definining matrices.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if M*N = 0. </dd></dl>

</div>
</div>
<a id="gad3d30febe413482babd2ab43d01f6950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3d30febe413482babd2ab43d01f6950">&#9670;&nbsp;</a></span>isChainMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isChainMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given homomorphism together form a chain map. </p>
<p>Given two HomMarkedAbelianGroups, you have two diagrams: </p><pre>
Z^a --N1--&gt; Z^b --M1--&gt; Z^c   Z^g --N3--&gt; Z^h --M3--&gt; Z^i
                  ^                             ^
                  |this.matrix                  |other.matrix
Z^d --N2--&gt; Z^e --M2--&gt; Z^f   Z^j --N4--&gt; Z^k --M4--&gt; Z^l
</pre><p> If c=g and f=j and M1=N3 and M2=N4, you can ask if these maps commute, i.e., whether you have a map of chain complexes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other homomorphism to analyse in conjunction with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if c=g, M1=N3, f=j, M2=N4, and the diagram commutes. </dd></dl>

</div>
</div>
<a id="ga6df135646b8e56fa438477a849f4c9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6df135646b8e56fa438477a849f4c9bc">&#9670;&nbsp;</a></span>isCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isCycle </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vector, determines if it represents a cycle in the chain complex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>an input vector in chain complex coordinates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given vector represents a cycle. </dd></dl>

</div>
</div>
<a id="gada5bd0951ee72da6cd1ce3f3df090389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada5bd0951ee72da6cd1ce3f3df090389">&#9670;&nbsp;</a></span>isCycleMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isCycleMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this at least a cycle map? If not, pretty much any further computations you try with this class will be give you nothing more than carefully-crafted garbage. </p>
<p>Technically, this routine only checks that cycles are sent to cycles, since it only has access to three of the four maps you need to verify you have a cycle map.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a chain map. </dd></dl>

</div>
</div>
<a id="ga97881fce1ecb435c23f9aac5ee2d5f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97881fce1ecb435c23f9aac5ee2d5f15">&#9670;&nbsp;</a></span>isEpic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isEpic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this an epic homomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is epic. </dd></dl>

</div>
</div>
<a id="ga1dd8d4c1dd13f30df21855b26e4d1198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dd8d4c1dd13f30df21855b26e4d1198">&#9670;&nbsp;</a></span>isFree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isFree </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the free abelian group of the given rank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>the rank of the free abelian group that we are testing for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the free abelian group of rank <em>r</em>. </dd></dl>

</div>
</div>
<a id="ga3fd7a747825f74d559cb7d4201f3d304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fd7a747825f74d559cb7d4201f3d304">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this the identity automorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the domain and range are defined via the same chain complexes and the induced map on homology is the identity. </dd></dl>

</div>
</div>
<a id="gad04a54db050fca088bad38c7b5b9c980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad04a54db050fca088bad38c7b5b9c980">&#9670;&nbsp;</a></span>isIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group are isomorphic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups are isomorphic. </dd></dl>

</div>
</div>
<a id="ga8303e2ed95989253fb385a8e2207d4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8303e2ed95989253fb385a8e2207d4f6">&#9670;&nbsp;</a></span>isIsomorphism()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isIsomorphism </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this an isomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is an isomorphism. </dd></dl>

</div>
</div>
<a id="gad4ed7cbfa00a9a9ca3a63cd9e046cfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4ed7cbfa00a9a9ca3a63cd9e046cfda">&#9670;&nbsp;</a></span>isMonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isMonic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this a monic homomorphism? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is monic. </dd></dl>

</div>
</div>
<a id="ga65860d714f70889df0fec507a7658f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65860d714f70889df0fec507a7658f8f">&#9670;&nbsp;</a></span>isTrivial() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the trivial (zero) group. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial group. </dd></dl>

</div>
</div>
<a id="gaab76ba3c8c7120f4b99787bd78068d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab76ba3c8c7120f4b99787bd78068d39">&#9670;&nbsp;</a></span>isTrivial() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this is the trivial (unit) word. </p>
<p>No attempt is made to remove redundant terms (so the word <code>g g^-1</code> will be treated as non-trivial).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial word. </dd></dl>

</div>
</div>
<a id="ga1b2511bd16caaaeb926df617a731c965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b2511bd16caaaeb926df617a731c965">&#9670;&nbsp;</a></span>isTrivial() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the trivial (zero) group. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial group. </dd></dl>

</div>
</div>
<a id="ga46e579e06a36b35db8e8dce18ded41a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46e579e06a36b35db8e8dce18ded41a5">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether all of the relations for the group are indeed words in the generators. </p>
<p>This routine returns <code>false</code> if at least one relator uses an out-of-bound generator, and <code>true</code> otherwise.</p>
<p>This routine is intended only for sanity checking: you should never have an invalid group presentation in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all of the relations are words in the generators. </dd></dl>

</div>
</div>
<a id="ga919a9f896922a25d7c9b6e32a877471f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga919a9f896922a25d7c9b6e32a877471f">&#9670;&nbsp;</a></span>isZ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the infinite cyclic group (Z). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the infinite cyclic group. </dd></dl>

</div>
</div>
<a id="ga7c65d588478bdbfc871d9d8e94d690ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c65d588478bdbfc871d9d8e94d690ff">&#9670;&nbsp;</a></span>isZ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::MarkedAbelianGroup::isZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the infinite cyclic group (Z). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the infinite cyclic group. </dd></dl>

</div>
</div>
<a id="gad65f49b1eb7f9cdf8319addb2346d6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65f49b1eb7f9cdf8319addb2346d6cf">&#9670;&nbsp;</a></span>isZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomMarkedAbelianGroup::isZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this the zero map? </p>
<dl class="section return"><dt>Returns</dt><dd>true if this homomorphism is the zero map. </dd></dl>

</div>
</div>
<a id="gae75846527dae06863f9b924622ccfe8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae75846527dae06863f9b924622ccfe8b">&#9670;&nbsp;</a></span>isZn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZn </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the non-trivial cyclic group on the given number of elements. </p>
<p>As a special case, if <em>n</em> = 0 then this routine will test for the infinite cyclic group (i.e., it will behave the same as <a class="el" href="group__algebra.html#ga919a9f896922a25d7c9b6e32a877471f" title="Determines whether this is the infinite cyclic group (Z).">isZ()</a>). If <em>n</em> = 1, then this routine will test for the trivial group (i.e., it will behave the same as <a class="el" href="group__algebra.html#ga65860d714f70889df0fec507a7658f8f" title="Determines whether this is the trivial (zero) group.">isTrivial()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of elements of the cyclic group in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the cyclic group Z_n. </dd></dl>

</div>
</div>
<a id="ga9471bec920757e90e466e76b43599e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9471bec920757e90e466e76b43599e0b">&#9670;&nbsp;</a></span>kernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::kernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the kernel of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the kernel of the homomorphism, as a marked abelian group. </dd></dl>

</div>
</div>
<a id="gaf222ad0e798429548eb15ed5ceccd909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf222ad0e798429548eb15ed5ceccd909">&#9670;&nbsp;</a></span>knowsInverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::knowsInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a declared isomorphism. </p>
<p>A <em>declared isomorphism</em> is a isomorphism for which the user has explicitly provided the inverse map. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a declared isomorphism, i.e, the inverse map was explicitly provided. </dd></dl>

</div>
</div>
<a id="ga746b854c7cfea2e4c5852a72565058b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga746b854c7cfea2e4c5852a72565058b4">&#9670;&nbsp;</a></span>M()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::MarkedAbelianGroup::M </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;right&rsquo; matrix used in defining the chain complex. </p>
<p>Our group was defined as the kernel of <em>M</em> mod the image of <em>N</em>. This is the matrix <em>M</em>.</p>
<p>This is a copy of the matrix <em>M</em> that was originally passed to the class constructor. See the class overview for further details on matrices <em>M</em> and <em>N</em> and their roles in defining the chain complex.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the defining matrix M. </dd></dl>

</div>
</div>
<a id="ga41084d6f839ceb295e3aaadf022c8c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41084d6f839ceb295e3aaadf022c8c4e">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the group to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2ffa5d54abe1ead15dc3cf8db0e7426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ffa5d54abe1ead15dc3cf8db0e7426">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a marked abelian group from a chain complex. </p>
<p>This constructor assumes you're interested in homology with integer coefficents of the chain complex. Creates a marked abelian group given by the quotient of the kernel of <em>M</em> modulo the image of <em>N</em>.</p>
<p>See the class notes for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada0ac7d4799e5082c5454caef301a60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada0ac7d4799e5082c5454caef301a60d">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>pcoeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a marked abelian group from a chain complex with coefficients in Z_p. </p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the &lsquo;right&rsquo; matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the &lsquo;left&rsquo; matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
    <tr><td class="paramname">pcoeff</td><td>specifies the coefficient ring, Z_pcoeff. We require <em>pcoeff</em> &gt;= 0. If you know beforehand that <em>pcoeff=0</em>, it's more efficient to use the previous constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac293e56e8222e2e5ff7a75fb5d6a8b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac293e56e8222e2e5ff7a75fb5d6a8b36">&#9670;&nbsp;</a></span>MarkedAbelianGroup() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::MarkedAbelianGroup::MarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>rk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a free Z_p-module of a given rank using the direct sum of the standard chain complex <code>0 --&gt; Z &ndash;p--&gt; Z --&gt; 0</code>. </p>
<p>So this group is isomorphic to <code>n Z_p</code>. Moreover, if constructed using the previous constructor, <em>M</em> would be zero and <em>N</em> would be diagonal and square with <em>p</em> down the diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rk</td><td>the rank of the group as a Z_p-module. That is, if the group is <code>n Z_p</code>, then <em>rk</em> should be <em>n</em>. </td></tr>
    <tr><td class="paramname">p</td><td>describes the type of ring that we use to talk about the "free" module. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee8939724e818da45670621a8d431b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8939724e818da45670621a8d431b90">&#9670;&nbsp;</a></span>markedAbelianisation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&gt; regina::GroupPresentation::markedAbelianisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the abelianisation of this group. </p>
<p>The coordinates in the chain complex correspond to the generators and relators for this group.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated abelianisation of this group. </dd></dl>

</div>
</div>
<a id="ga79eaff158b800e7e2f7ed3dfc1358368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79eaff158b800e7e2f7ed3dfc1358368">&#9670;&nbsp;</a></span>markedAbelianisation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &gt; regina::HomGroupPresentation::markedAbelianisation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the induced map on the abelianizations of the domain and range. </p>
<dl class="section return"><dt>Returns</dt><dd>the induced map on the abelianizations. </dd></dl>

</div>
</div>
<a id="gac714d64e8dca4bc06cce32c3ed26b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac714d64e8dca4bc06cce32c3ed26b8db">&#9670;&nbsp;</a></span>minNumberCycleGens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::minNumberCycleGens </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of generators of ker(M), where M is one of the defining matrices of the chain complex. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of generators of ker(M). </dd></dl>

</div>
</div>
<a id="gab5e8b466766eb274146277ac9bd98a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5e8b466766eb274146277ac9bd98a55">&#9670;&nbsp;</a></span>minNumberOfGenerators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::minNumberOfGenerators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the minimum number of generators for the group. </p>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of generators. </dd></dl>

</div>
</div>
<a id="ga48c5e7997650a39ab835814a0ed5cc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c5e7997650a39ab835814a0ed5cc61">&#9670;&nbsp;</a></span>N()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::MarkedAbelianGroup::N </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the &lsquo;left&rsquo; matrix used in defining the chain complex. </p>
<p>Our group was defined as the kernel of <em>M</em> mod the image of <em>N</em>. This is the matrix <em>N</em>.</p>
<p>This is a copy of the matrix <em>N</em> that was originally passed to the class constructor. See the class overview for further details on matrices <em>M</em> and <em>N</em> and their roles in defining the chain complex.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the defining matrix N. </dd></dl>

</div>
</div>
<a id="gac87e91e72bd03e053343c769fb6ef307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac87e91e72bd03e053343c769fb6ef307">&#9670;&nbsp;</a></span>nielsenCombine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::nielsenCombine </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rightMult</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a generator <code>gi</code> by either <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code> in the presentation. </p>
<p>It it is the third type of Nielsen move one can apply to a presentation.</p>
<p>This means that, if the new generator <code>Gi</code> is the old <code>(gi)(gj)^k</code> or <code>(gj)^k(gi)</code>, then we can construct the new presentation from the old by replacing occurrences of <code>Gi</code> by <code>(Gi)(gj)^(-k)</code> or <code>(gj)^(-k)(Gi)</code> respectively.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>i</em> and <em>j</em> are strictly less than <a class="el" href="group__algebra.html#ga610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the generator to replace. </td></tr>
    <tr><td class="paramname">j</td><td>indicates the generator to combine with <code>gi</code>. </td></tr>
    <tr><td class="paramname">k</td><td>indicates the power to which we raise <code>gj</code> when performing the replacement; this may be positive or negative (or zero, but this will have no effect). </td></tr>
    <tr><td class="paramname">rightMult</td><td><code>true</code> if we should replace <code>gi</code> by <code>(gi)(gj)^k</code>, or <code>false</code> if we should replace <code>gi</code> by <code>(gj)^k(gi)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a id="gac6af4e4996b9c37bfe2bece59ccb6483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6af4e4996b9c37bfe2bece59ccb6483">&#9670;&nbsp;</a></span>nielsenInvert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::nielsenInvert </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a generator in a presentation by its inverse, and recomputes the appropriate presentation. </p>
<p>This is the second generator type of the automorphism group of a free group.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>i</em> is strictly less than <a class="el" href="group__algebra.html#ga610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the generator to invert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the Nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a id="gaf81c7a84245d4d123ca2b5d144c9cb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81c7a84245d4d123ca2b5d144c9cb21">&#9670;&nbsp;</a></span>nielsenTransposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::nielsenTransposition </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the generators in the presentation indexed by <em>i</em> and <em>j</em> respectively, and recomputes the appropriate presentation. </p>
<p>It is one of the standard Nielsen moves, which is the first of three generator types of the automorphism group of a free group.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>i</em> and <em>j</em> are strictly less than <a class="el" href="group__algebra.html#ga610ea6821977d1a2f6709627316e7649" title="Returns the number of generators in this group presentation.">countGenerators()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>indicates the first of the two generators to switch. </td></tr>
    <tr><td class="paramname">j</td><td>indicates the second of the two generators to switch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the Nielsen automorphism had an effect on at least one relation. </dd></dl>

</div>
</div>
<a id="ga654c5cee9a97206990fcc36ff62906b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga654c5cee9a97206990fcc36ff62906b1">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group are non-isomorphic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups are non-isomorphic. </dd></dl>

</div>
</div>
<a id="ga0402158ae2680818b04bb815e3ed7eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0402158ae2680818b04bb815e3ed7eb9">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Checks to see whether or not these two words represent different literal strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the expression to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given string literal are not identical. </dd></dl>

</div>
</div>
<a id="gad992666ed443843d2884901a803ac461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad992666ed443843d2884901a803ac461">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpressionTerm::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given term do not contain identical data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the term with which this term will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given term do not have both the same generator and exponent. </dd></dl>

</div>
</div>
<a id="ga4205a684b4e381bf13239008f39244ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4205a684b4e381bf13239008f39244ef">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::HomMarkedAbelianGroup::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the composition of two homomorphisms. </p>
<dl class="section pre"><dt>Precondition</dt><dd>the homomorphisms must be composable, meaning that the range of X must have the same presentation matrices as the domain of this homomorphism.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the homomorphism to compose this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created composite homomorphism. </dd></dl>

</div>
</div>
<a id="gaa34893fcea2e39ced4522b8a779d4b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa34893fcea2e39ced4522b8a779d4b3c">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpressionTerm::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to merge this term with the given term. </p>
<p>If both terms have the same generator, the two exponents will be added and stored in this term. If the generators are different, this routine will do nothing.</p>
<p>Note that this term might be changed but the given term will remain unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the term to merge with this term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two terms were merged into this term, or <code>false</code> if the two terms have different generators. </dd></dl>

</div>
</div>
<a id="gafd215c1f0bac8eb3768ffd4e2962da42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd215c1f0bac8eb3768ffd4e2962da42">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpressionTerm::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Imposes an ordering on terms. </p>
<p>Terms are ordered lexigraphically as (generator, exponent) pairs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the term to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if this term is lexicographically smaller than <em>other</em>. </dd></dl>

</div>
</div>
<a id="gaa109e29599c8ff6f92fd2aadc017fd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa109e29599c8ff6f92fd2aadc017fd42">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given term to the given output stream. </p>
<p>The term will be written in the format <code>g3^-7</code>, where in this example the term represents generator number 3 raised to the -7th power.</p>
<p>If the term has exponent 0 or 1, the output format will be appropriately simplified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">term</td><td>the term to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="ga0a4395eba4812e1b94c78c03fce56b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a4395eba4812e1b94c78c03fce56b64">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&amp; regina::AbelianGroup::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a clone of the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the group to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb42e4226df8081fd18a9f64a3f6bb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb42e4226df8081fd18a9f64a3f6bb6f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>&amp; regina::GroupExpression::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this expression a clone of the given expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the expression to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this expression. </dd></dl>

</div>
</div>
<a id="ga27838261a91a54ad923f43641df49011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27838261a91a54ad923f43641df49011">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a>&amp; regina::GroupExpressionTerm::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this term identical to the given term. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the term whose data will be copied to this term. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this term. </dd></dl>

</div>
</div>
<a id="ga88b7dc666fcc3020fb1307a3f322b5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b7dc666fcc3020fb1307a3f322b5ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&amp; regina::GroupPresentation::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the group presentation that this will become a copy of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this group presentation. </dd></dl>

</div>
</div>
<a id="ga87ed4b87463c30c91f16059b8587522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ed4b87463c30c91f16059b8587522b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group are isomorphic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups are isomorphic. </dd></dl>

</div>
</div>
<a id="gaff2ca294cd89c65857d242215a72a650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff2ca294cd89c65857d242215a72a650">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Checks to see whether or not these two words represent the same literal string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the expression to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given string literal are identical. </dd></dl>

</div>
</div>
<a id="ga4fd28691c9501bab70a1304149a46340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fd28691c9501bab70a1304149a46340">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpressionTerm::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given term contain identical data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the term with which this term will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given term have both the same generator and exponent. </dd></dl>

</div>
</div>
<a id="ga9413bf389924cf7188e034d66d2580ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9413bf389924cf7188e034d66d2580ca">&#9670;&nbsp;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>* regina::GroupExpression::power </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is this expression raised to the given power. </p>
<p>Note that the given exponent may be positive, zero or negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exponent</td><td>the power to which this expression should be raised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this expression raised to the given power. </dd></dl>

</div>
</div>
<a id="ga0507961c7e28fee174bdb08d4d0e8364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0507961c7e28fee174bdb08d4d0e8364">&#9670;&nbsp;</a></span>prettyRewriting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::prettyRewriting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entirely cosmetic re-writing of the presentation, which is fast and superficial. </p>
<p>See <a class="el" href="group__algebra.html#gab33c241cd3b0f6bd18e64217cbcd56ae" title="An entirely cosmetic re-writing of the presentation, which is fast and superficial.">prettyRewritingDetail()</a> for further details on what this routine does.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the choice of generators for the group has changed. You can call <a class="el" href="group__algebra.html#gab33c241cd3b0f6bd18e64217cbcd56ae" title="An entirely cosmetic re-writing of the presentation, which is fast and superficial.">prettyRewritingDetail()</a> to get the the isomorphism. </dd></dl>

</div>
</div>
<a id="gab33c241cd3b0f6bd18e64217cbcd56ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab33c241cd3b0f6bd18e64217cbcd56ae">&#9670;&nbsp;</a></span>prettyRewritingDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&gt; regina::GroupPresentation::prettyRewritingDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entirely cosmetic re-writing of the presentation, which is fast and superficial. </p>
<ol type="1">
<li>If there are any length 1 relators, those generators are deleted, and the remaining relators simplified.</li>
<li>It sorts the relators by number of generator indices that appear, followed by relator numbers (lexico) followed by relator length.</li>
<li>inverts relators if net sign of the generators is negative.</li>
<li>Given each generator, it looks for the smallest word where that generator appears with non-zero weight. If negative weight, it inverts that generator.</li>
<li>It cyclically permutes relators to start with smallest gen.</li>
</ol>
<p>If this routine does return a homomorphism (because the choice of generators was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>As a final step, make elementary simplifications to aid in seeing standard relators like commutators.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the map from the original presentation to the new presentation, or a null pointer if the choice of generators did not change. </dd></dl>

</div>
</div>
<a id="gaaa7653e9f59d3f194e4b560d7f84f6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa7653e9f59d3f194e4b560d7f84f6e6">&#9670;&nbsp;</a></span>proliferateRelators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::proliferateRelators </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine to help escape local wells when simplifying presentations, which may be useful when small cancellation theory can't find the simplest relators. </p>
<p>Given a presentation &lt;g_i | r_i&gt;, this routine appends consequences of the relators {r_i} to the presentation that are of the form ab, where both a and b are cyclic permutations of relators from the collection {r_i}.</p>
<p>Passing depth=1 means it will only form products of two relators. Depth=2 means products of three, etc. Depth=4 is typically the last depth before the exponential growth of the operation grows out of hand. It also conveniently trivializes all the complicated trivial group presentations that we've come across so far.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this routine with depth n before having called it at depth n-1 first. Depth=0 is invalid, and depth=1 should be your first call to this routine. This routine gobbles up an exponential amount of memory (exponential in your presentation size times n). So do be careful when using it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>controls the depth of the proliferation, as described above; this must be strictly positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga187d58d673d8acefae2931604f161a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga187d58d673d8acefae2931604f161a78">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; regina::HomGroupPresentation::range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The range of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the range. </dd></dl>

</div>
</div>
<a id="ga6785735056383f2f66b9e44c1c3e6ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6785735056383f2f66b9e44c1c3e6ef3">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a> &amp; regina::HomMarkedAbelianGroup::range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the range of this homomorphism. </p>
<dl class="section return"><dt>Returns</dt><dd>the range that was used to define the homomorphism. </dd></dl>

</div>
</div>
<a id="gada506c15842e993b6fdc651b0122d3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada506c15842e993b6fdc651b0122d3af">&#9670;&nbsp;</a></span>rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group. </p>
<p>This is the number of included copies of <em>Z</em>.</p>
<p>Equivalently, the rank is the maximum number of linearly independent elements, and it indicates the size of the largest free abelian subgroup. The rank effectively ignores all torsion elements.</p>
<dl class="section warning"><dt>Warning</dt><dd>SnapPy users should be aware that SnapPy defines rank differently. Specifically, SnapPy's <a class="el" href="group__algebra.html#gada506c15842e993b6fdc651b0122d3af" title="Returns the rank of the group.">AbelianGroup.rank()</a> computation includes torsion factors also.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of included copies of <em>Z</em>. </dd></dl>

</div>
</div>
<a id="ga000ce1a1c59819c497cd964486be934f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga000ce1a1c59819c497cd964486be934f">&#9670;&nbsp;</a></span>rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group. </p>
<p>This is the number of included copies of <em>Z</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the group. </dd></dl>

</div>
</div>
<a id="ga6f90140da9a0ab47482cb68a29078432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f90140da9a0ab47482cb68a29078432">&#9670;&nbsp;</a></span>rankCC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::rankCC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the chain complex supporting the homology computation. </p>
<p>In the description of this class, this is also given by M.columns() and N.rows() from the constructor that takes as input two matrices, M and N.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the chain complex. </dd></dl>

</div>
</div>
<a id="ga6dd5465442f764dcca7c9f83683144ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dd5465442f764dcca7c9f83683144ff">&#9670;&nbsp;</a></span>recogniseGroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupPresentation::recogniseGroup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>moreUtf8</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to recognise the group corresponding to this presentation. </p>
<p>This routine is much more likely to be successful if you have already called <a class="el" href="group__algebra.html#gaee43de413fbbd1dd88bd645d3fac340f" title="Attempts to simplify the group presentation as intelligently as possible without further input.">intelligentSimplify()</a>.</p>
<p>Currently, the groups this routine recognises include: the trivial group, abelian groups, free groups, extensions over the integers, and free products of any group the algorithm can recognise (inductively).</p>
<p>The string returned from this routine may use some unicode characters, which will be encoding using UTF-8. If <em>moreUtf8</em> is passed as <code>false</code> then unicode will be used sparingly; if <em>moreUtf8</em> is <code>true</code> then unicode will be use more liberally, resulting in strings that look nicer but require more complex fonts to be available on the user's machine.</p>
<p>Examples of the format of the returned string are:</p>
<ul>
<li><code>0</code> for the trivial group;</li>
<li><code>Z_n</code> for cyclic groups with <em>n</em> &gt; 1;</li>
<li><code>Free(n)</code> for free groups with <em>n</em> &gt; 1 generators - see <a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">AbelianGroup::str()</a> for how abelian groups are presented;</li>
<li><code>FreeProduct(G1, G2, ... , Gk)</code> for free products, where one replaces <em>G1</em> through <em>Gk</em> by text strings representing the free summands;</li>
<li><p class="startli"><code>Z~G w/ monodromy H</code> for extensions over Z, where <em>G</em> is a description of the kernel of the homomorphism to the integers, and <em>H</em> is a text string representing the monodromy - see <a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">HomMarkedAbelianGroup.str()</a> for details on how these are presented.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><em>Feature (long-term):</em> Make this recognition more effective.</dd></dl>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a simple string representation of the group if it is recognised, or an empty string if the group is not recognised. </dd></dl>

</div>
</div>
<a id="ga106dcb279e4294694478447f2dc06639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga106dcb279e4294694478447f2dc06639">&#9670;&nbsp;</a></span>reducedMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp; regina::HomMarkedAbelianGroup::reducedMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the internal reduced matrix representing the homomorphism. </p>
<p>This is where the rows/columns of the matrix represent first the free generators, then the torsion summands in the order of the invariant factors: </p><pre class="fragment">        Z^d + Z_{d0} + ... + Z_{dk}
</pre><p> where:</p>
<ul>
<li><em>d</em> is the number of free generators, as returned by rank();</li>
<li><em>d1</em>, ..., <em>dk</em> are the invariant factors that describe the torsion elements of the group, where 1 &lt; <em>d1</em> | <em>d2</em> | ... | <em>dk</em>.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a copy of the internal representation of the homomorphism. </dd></dl>

</div>
</div>
<a id="ga1d02f0fa24e3d333ce3bcfb4e6acee1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d02f0fa24e3d333ce3bcfb4e6acee1a">&#9670;&nbsp;</a></span>relabellingsThisToOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::map&lt; unsigned long, <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &gt; regina::GroupExpression::relabellingsThisToOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cyclic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not one can relabel the generators in this word to obtain the given other word. </p>
<p>If so, returns a non-empty list of all such relabellings. If not, returns an empty list.</p>
<p>Relabellings are partially-defined permutations on the generator set, also allowing for possible inversions if cyclic is <code>true</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Change this to use less heavyweight types and less deep copying.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>cyclic</em> is <code>true</code>, then both this word and <em>other</em> have been cyclically reduced.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the word to compare against this. </td></tr>
    <tr><td class="paramname">cyclic</td><td>if <code>false</code> we get a list of exact relabellings from this word to <em>other</em>. If <code>true</code>, it can be up to cyclic permutation and inversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of permutations, implemented as maps from generator indices of this word to generator indices of <em>other</em>. </dd></dl>

</div>
</div>
<a id="gae5b394968e63b1a679b318400537c926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b394968e63b1a679b318400537c926">&#9670;&nbsp;</a></span>relation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp; regina::GroupPresentation::relation </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the relation at the given index in this group presentation. </p>
<p>The relation will be of the form <code>expresson = 1</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired relation; this must be between 0 and <a class="el" href="group__algebra.html#ga2ffa647790e42c8d984168db32197d22" title="Returns the number of relations in this group presentation.">countRelations()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expression that the requested relation sets to 1; for instance, if the relation is <code>g1^2 g2 = 1</code> then this will be the expression <code>g1^2 g2</code>. </dd></dl>

</div>
</div>
<a id="ga5c9ee67ee75ee1d9539d235a5cd8f101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c9ee67ee75ee1d9539d235a5cd8f101">&#9670;&nbsp;</a></span>relatorLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupPresentation::relatorLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sum of the word lengths of the relators. </p>
<p>Word lengths are computing using <a class="el" href="group__algebra.html#ga4c683c8a7391ae8ad801b2c48e6ae3f6" title="Returns the length of the word, i.e.">GroupExpression::wordLength()</a>. Used as a coarse measure of the complexity of the presentation.</p>
<dl class="section return"><dt>Returns</dt><dd>the sum of word lengths. </dd></dl>

</div>
</div>
<a id="gac7edb441bb51e6d540c3f803662b0cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7edb441bb51e6d540c3f803662b0cab">&#9670;&nbsp;</a></span>replaceTorsion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::replaceTorsion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the torsion elements of this group with those in the abelian group represented by the given Smith normal form presentation matrix. </p>
<p>Any zero columns in the matrix will also be added to the rank as additional copies of Z. Note that preexisting torsion elements will be deleted, but preexisting rank will not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix is in Smith normal form, with the diagonal consisting of a series of positive, non-decreasing integers followed by zeroes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>a matrix containing the Smith normal form presentation matrix for the new torsion elements, where each column represents a generator and each row a relation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga69bac586bbdb9e0469363e104436c911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69bac586bbdb9e0469363e104436c911">&#9670;&nbsp;</a></span>sage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FinitelyPresentedGroup regina::GroupPresentation::sage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Sage-only routine that returns a copy of this group presentation in a format native to Sage. </p>
<dl class="section user"><dt>C++</dt><dd>Not present. </dd></dl>
<dl class="section user"><dt>Python</dt><dd>Only present when run within Sage.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this group as a mathematical object native to Sage. </dd></dl>

</div>
</div>
<a id="gae77e1f2423da57b6bd93984762691bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae77e1f2423da57b6bd93984762691bf2">&#9670;&nbsp;</a></span>simplify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::simplify </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cyclic</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies this expression. </p>
<p>Adjacent powers of the same generator will be combined, and terms with an exponent of zero will be removed. Note that it is <em>not</em> assumed that the underlying group is abelian.</p>
<p>You may declare that the expression is cyclic, in which case it is assumed that terms may be moved from the back to the front and vice versa. Thus expression <code>g1 g2 g1 g2 g1</code> simplifies to <code>g1^2 g2 g1 g2</code> if it is cyclic, but does not simplify at all if it is not cyclic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cyclic</td><td><code>true</code> if and only if the expression may be assumed to be cyclic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this expression was changed. </dd></dl>

</div>
</div>
<a id="gaf21b58e5745a140d2fb50c2643e9d052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf21b58e5745a140d2fb50c2643e9d052">&#9670;&nbsp;</a></span>simplifyWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::simplifyWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses small cancellation theory to reduce the input word, using the current presentation of the group. </p>
<p>The input word will be modified directly.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is only as good as the relator table for the group. You might want to consider running <a class="el" href="group__algebra.html#gaee43de413fbbd1dd88bd645d3fac340f" title="Attempts to simplify the group presentation as intelligently as possible without further input.">intelligentSimplify()</a>, possibly in concert with <a class="el" href="group__algebra.html#gaaa7653e9f59d3f194e4b560d7f84f6e6" title="A routine to help escape local wells when simplifying presentations, which may be useful when small c...">proliferateRelators()</a>, before using this routine for any significant tasks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>is the word you would like to simplify. This must be a word in the generators of this group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the input word was modified. </dd></dl>

</div>
</div>
<a id="gacea435013f581c63967ddae8e9af94de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacea435013f581c63967ddae8e9af94de">&#9670;&nbsp;</a></span>smallCancellation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::smallCancellation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation using only small cancellation theory. </p>
<p>See <a class="el" href="group__algebra.html#gaf5e18bdc3cc36fee22e8b3fd3a6d7572" title="Attempts to simplify the group presentation using small cancellation theory.">smallCancellationDetail()</a> for further details on how the simplification is done.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the group presentation was changed. You can call <a class="el" href="group__algebra.html#gaf5e18bdc3cc36fee22e8b3fd3a6d7572" title="Attempts to simplify the group presentation using small cancellation theory.">smallCancellationDetail()</a> to get the isomorphism. </dd></dl>

</div>
</div>
<a id="ga29a2112399e2d6b1b7a49368730920b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29a2112399e2d6b1b7a49368730920b0">&#9670;&nbsp;</a></span>smallCancellation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::smallCancellation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies the domain and range using only small cancellation theory. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if either presentation was changed. </dd></dl>

</div>
</div>
<a id="gaf5e18bdc3cc36fee22e8b3fd3a6d7572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5e18bdc3cc36fee22e8b3fd3a6d7572">&#9670;&nbsp;</a></span>smallCancellationDetail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomGroupPresentation.html">HomGroupPresentation</a>&gt; regina::GroupPresentation::smallCancellationDetail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the group presentation using small cancellation theory. </p>
<p>The simplification method is based on the Dehn algorithm for hyperbolic groups, i.e. small cancellation theory. This means we look to see if part of one relator can be used to simplify others. If so, make the substitution and simplify. We continue until no more presentation-shortening substitutions are available. We follow that by killing any available generators using words where generators appear a single time.</p>
<p>If this routine does return a homomorphism (because the presentation was changed), then this homomorphsm will in fact be a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> This routine could use some small tweaks - recognition of utility of some score==0 moves, such as commutators, for example.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated homomorphism describing the reduction map from the original presentation to the new presentation, or a null pointer if this presentation was not changed. </dd></dl>

</div>
</div>
<a id="ga0563fc60015d3690c89776aaf94c956b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0563fc60015d3690c89776aaf94c956b">&#9670;&nbsp;</a></span>snfRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::snfRep </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expresses the given vector as a combination of free and torsion generators. </p>
<p>This answer is coordinate dependant, meaning the answer may change depending on how the Smith Normal Form is computed.</p>
<p>Recall that this marked abelian was defined by matrices <em>M</em> and <em>N</em> with M*N=0; suppose that <em>M</em> is an <em>m</em> by <em>l</em> matrix and <em>N</em> is an <em>l</em> by <em>n</em> matrix. This abelian group is then the quotient ker(M)/img(N) in <em>Z^l</em>.</p>
<p>When it is constructed, this group is computed to be isomorphic to some Z_{d0} + ... + Z_{dk} + Z^d, where:</p>
<ul>
<li><em>d</em> is the number of free generators, as returned by <a class="el" href="group__algebra.html#ga000ce1a1c59819c497cd964486be934f" title="Returns the rank of the group.">rank()</a>;</li>
<li><em>d1</em>, ..., <em>dk</em> are the invariant factors that describe the torsion elements of the group, where 1 &lt; <em>d1</em> | <em>d2</em> | ... | <em>dk</em>.</li>
</ul>
<p>This routine takes a single argument <em>v</em>, which must be a vector in <em>Z^l</em>.</p>
<p>If <em>v</em> belongs to ker(M), this routine describes how it projects onto the group ker(M)/img(N). Specifically, it returns a vector of length <em>d</em> + <em>k</em>, where:</p>
<ul>
<li>The first <em>k</em> elements describe the projection of <em>v</em> to the torsion component Z_{d1} + ... + Z_{dk}. These elements are returned as non-negative integers modulo <em>d1</em>, ..., <em>dk</em> respectively.</li>
<li>The remaining <em>d</em> elements describe the projection of <em>v</em> to the free component <em>Z^d</em>.</li>
</ul>
<p>In other words, suppose <em>v</em> belongs to ker(M) and snfRep(v) returns the vector (<em>b1</em>, ..., <em>bk</em>, <em>a1</em>, ..., <em>ad</em>). Suppose furthermore that the free generators returned by freeRep(0..(d-1)) are <em>f1</em>, ..., <em>fd</em> respectively, and that the torsion generators returned by torsionRep(0..(k-1)) are <em>t1</em>, ..., <em>tk</em> respectively. Then <em>v</em> = <em>b1.t1</em> + ... + <em>bk.tk</em> + <em>a1.f1</em> + ... + <em>ad.fd</em> modulo img(N).</p>
<p>If <em>v</em> does not belong to ker(M), this routine simply returns the empty vector.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, as it depends on the choice of Smith normal form.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classregina_1_1Vector.html" title="An optimised vector class of elements from a given ring T.">Vector</a> <em>v</em> has length M.columns(), or equivalently N.rows().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector of length M.columns(). M.columns() is also <a class="el" href="group__algebra.html#ga6f90140da9a0ab47482cb68a29078432" title="Returns the rank of the chain complex supporting the homology computation.">rankCC()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector that describes <em>v</em> in the standard Z_{d1} + ... + Z_{dk} + Z^d form, or the empty vector if <em>v</em> is not in the kernel of <em>M</em>. k+d is equal to <a class="el" href="group__algebra.html#gab5e8b466766eb274146277ac9bd98a55" title="Returns the minimum number of generators for the group.">minNumberOfGenerators()</a>. </dd></dl>

</div>
</div>
<a id="ga3e9dbf20d9a0d919388b0fe1d61b6c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e9dbf20d9a0d919388b0fe1d61b6c0f">&#9670;&nbsp;</a></span>startElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLAbelianGroupReader::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gabcadcdfb766850fb41e1b5d03326e0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcadcdfb766850fb41e1b5d03326e0b9">&#9670;&nbsp;</a></span>startElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLGroupPresentationReader::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__algebra.html#gaf90354f52dfa7a5b3e8cc9603bc298ff" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gaf90354f52dfa7a5b3e8cc9603bc298ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf90354f52dfa7a5b3e8cc9603bc298ff">&#9670;&nbsp;</a></span>startSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLGroupPresentationReader::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga5dc5f90b79dc0a50956c1737ac350c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dc5f90b79dc0a50956c1737ac350c0b">&#9670;&nbsp;</a></span>substitute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::substitute </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cyclic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces every occurrence of the given generator with the given substite expression. </p>
<p>If the given generator was found, the expression will be simplified once the substitution is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the generator to be replaced. </td></tr>
    <tr><td class="paramname">expansion</td><td>the substitute expression that will replace every occurrence of the given generator. </td></tr>
    <tr><td class="paramname">cyclic</td><td><code>true</code> if and only if the expression may be assumed to be cyclic; see <a class="el" href="group__algebra.html#gae77e1f2423da57b6bd93984762691bf2" title="Simplifies this expression.">simplify()</a> for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if any substitutions were made. </dd></dl>

</div>
</div>
<a id="gae5eaab7ecde7ceff9428853e17106fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5eaab7ecde7ceff9428853e17106fe9">&#9670;&nbsp;</a></span>term() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a>&amp; regina::GroupExpression::term </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="group__algebra.html#ga2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested term. </dd></dl>

</div>
</div>
<a id="gae0b885e1054074186d17ce7adc8a7db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0b885e1054074186d17ce7adc8a7db8">&#9670;&nbsp;</a></span>term() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a>&amp; regina::GroupExpression::term </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present; only the non-const version of this routine is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="group__algebra.html#ga2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested term. </dd></dl>

</div>
</div>
<a id="gab7107330382d76de56540ef1e5ec986e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7107330382d76de56540ef1e5ec986e">&#9670;&nbsp;</a></span>terms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp; regina::GroupExpression::terms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the list of terms in this expression. </p>
<p>These are the actual terms stored internally; any modifications made to this list will show up in the expression itself.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> has list consisting of three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; only the const version of this routine is available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of terms. </dd></dl>

</div>
</div>
<a id="ga961eb0fc634f28142e23abe582fe977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga961eb0fc634f28142e23abe582fe977a">&#9670;&nbsp;</a></span>terms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp; regina::GroupExpression::terms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the list of terms in this expression. </p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> has list consisting of three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list of copied <a class="el" href="structregina_1_1GroupExpressionTerm.html" title="Represents a power of a generator in a group presentation.">GroupExpressionTerm</a> objects. In particular, modifying this list or the terms within it will not modify the group expression from which they came.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of terms. </dd></dl>

</div>
</div>
<a id="gaaa9882af6b8ec2757932ac1c49833633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa9882af6b8ec2757932ac1c49833633">&#9670;&nbsp;</a></span>torsionInclusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::MarkedAbelianGroup::torsionInclusion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the inclusion of the torsion subgroup into this group. </p>

</div>
</div>
<a id="ga72b15418d1e879e91983cbbd13dcbb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72b15418d1e879e91983cbbd13dcbb1e">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="ga99f15cbf9347b95351868181735e7dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99f15cbf9347b95351868181735e7dbd">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="ga3777b5ec94d450465db9327c7ea774e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3777b5ec94d450465db9327c7ea774e7">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="ga2dca8084edda8307373869fd840fe586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dca8084edda8307373869fd840fe586">&#9670;&nbsp;</a></span>torsionRank() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::MarkedAbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a id="ga2cdebf3efcd47ef18d96369b243794b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cdebf3efcd47ef18d96369b243794b9">&#9670;&nbsp;</a></span>torsionRep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::torsionRep </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested generator of the torsion subgroup but represented in the original chain complex defining the group. </p>
<p>As described in the class overview, this marked abelian group is defined by matrices <em>M</em> and <em>N</em> where M*N = 0. If <em>M</em> is an <em>m</em> by <em>l</em> matrix and <em>N</em> is an <em>l</em> by <em>n</em> matrix, then this routine returns the (<em>index</em>)th torsion generator of ker(M)/img(N) in <em>Z^l</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which generator in the torsion subgroup; this must be at least 0 and strictly less than the number of non-trivial invariant factors. If not, you receive an empty vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinates of the generator in the nullspace of <em>M</em>; this vector will have length M.columns() (or equivalently, N.rows()). </dd></dl>

</div>
</div>
<a id="ga964cf786ad3ed296a325f03f6d8bf51c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964cf786ad3ed296a325f03f6d8bf51c">&#9670;&nbsp;</a></span>torsionSubgroup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1MarkedAbelianGroup.html">MarkedAbelianGroup</a>&gt; regina::MarkedAbelianGroup::torsionSubgroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> representing the torsion subgroup of this group. </p>

</div>
</div>
<a id="gafddf033b724ebbab1c972ccd765192a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafddf033b724ebbab1c972ccd765192a6">&#9670;&nbsp;</a></span>torsionSubgroup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1HomMarkedAbelianGroup.html">HomMarkedAbelianGroup</a>&gt; regina::HomMarkedAbelianGroup::torsionSubgroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a> representing the induced map on the torsion subgroups. </p>

</div>
</div>
<a id="gad42f3dcd7375c149457822529f3efa8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad42f3dcd7375c149457822529f3efa8b">&#9670;&nbsp;</a></span>toTeX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupExpression::toTeX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this expression. </p>
<p>See <a class="el" href="group__algebra.html#ga5288d1ece14ec07413a046ac62245b1f" title="Writes a TeX represesentation of this expression to the given output stream.">writeTeX()</a> for details on how this is formed.</p>
<dl class="section return"><dt>Returns</dt><dd>a TeX representation of this expression. </dd></dl>

</div>
</div>
<a id="gafa7b92796d5d1bf3a5dba2641a98fcfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa7b92796d5d1bf3a5dba2641a98fcfe">&#9670;&nbsp;</a></span>toTeX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupPresentation::toTeX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this group presentation. </p>
<p>See <a class="el" href="group__algebra.html#ga7c373720fc59d7973d53f53e3126a409" title="Writes a TeX represesentation of this group presentation to the given output stream.">writeTeX()</a> for details on how this is formed.</p>
<dl class="section return"><dt>Returns</dt><dd>a TeX representation of this group presentation. </dd></dl>

</div>
</div>
<a id="ga542d03cd5ebf7bd5d589fe5ef5ae2e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga542d03cd5ebf7bd5d589fe5ef5ae2e48">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies the map is a valid homomorphism. </p>
<p>Specifically, this routine runs through all the relators in the domain, evaluates the homomorphism on the relators and checks that they simplify to 1 in the range.</p>
<p>This routine does not guarantee a conclusive result (since the word problem is, in general, undecidable). If this routine returns <code>true</code> then this proves that the homomorphism is indeed valid. If this routine returns <code>false</code>, then the result is inconclusive (i.e., it might still be valid but Regina was not able to prove this).</p>
<p>This routine is intended for sanity checking only: any homomorphism that you construct in Regina should always be valid in this sense.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if Regina is able to verify that this is a homomorphism, or <code>false</code> if the result is inconclusive. </dd></dl>

</div>
</div>
<a id="ga21c8442bd57b8974495b657d3e675683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21c8442bd57b8974495b657d3e675683">&#9670;&nbsp;</a></span>verifyIsomorphism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::HomGroupPresentation::verifyIsomorphism </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to verify that a declared isomorphism is, indeed, an isomorphism. </p>
<p>This routine works by attempting to verify that <code>f^-1(f(x))x^-1</code> simplifes to 1 for all generators <em>x</em> in the domain, and likewise for the range.</p>
<p>This routine does not guarantee a conclusive result. If this routine returns <code>true</code> then this proves that this is indeed an isomorphism. If this routine returns <code>false</code> then the result is inconclusive (i.e., it might still be an isomorphism but Regina was not able to prove this).</p>
<p>You probably only want to run this on good presentations for small cancellation theory - an automorphism of a poorly-presented group likely will not be noticed.</p>
<p>This routine is intended for sanity checking only: any homomorphism that you construct as a declared isomorphism should always be an isomorphism.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This homomorphism is in fact a declared isomorphism. See the <a class="el" href="classregina_1_1HomGroupPresentation.html" title="Represents a homomorphism between groups which are described via finite presentations.">HomGroupPresentation</a> class notes for details on what this means.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it is verified that this is an isomorphism, or <code>false</code> if the result is inconclusive. </dd></dl>

</div>
</div>
<a id="ga4c683c8a7391ae8ad801b2c48e6ae3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c683c8a7391ae8ad801b2c48e6ae3f6">&#9670;&nbsp;</a></span>wordLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupExpression::wordLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the length of the word, i.e. </p>
<p>the number of letters with exponent +1 or -1 for which this word is expressable as a product.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> is a word of length four. See also <a class="el" href="group__algebra.html#ga2aeebe99241025551efccdbc0640417f" title="Returns the number of terms in this expression.">countTerms()</a>.</p>
<p>No attempt is made to remove redundant terms (so the word <code>g g^-1</code> will count as length two).</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the word. </dd></dl>

</div>
</div>
<a id="ga94ea2ed41e910b2c52a6d5736283caa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94ea2ed41e910b2c52a6d5736283caa3">&#9670;&nbsp;</a></span>writeAsBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::MarkedAbelianGroup::writeAsBoundary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expresses the given vector as a boundary in the chain complex (if the vector is indeed a boundary at all). </p>
<p>This routine uses chain complex coordinates for both the input and the return value.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you're using mod-p coefficients and if your element projects to a non-trivial element of TOR, then Nv != input as elements of TOR aren't in the image of N. In this case, input-Nv represents the projection to TOR.</dd>
<dd>
The return value may change from version to version of Regina, since it depends on the choice of Smith normal form.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a length zero vector if the input is not a boundary; otherwise a vector <em>v</em> such that <code>Nv=input</code>. </dd></dl>

</div>
</div>
<a id="gae703e8484eebdc75098446d2a90ef9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae703e8484eebdc75098446d2a90ef9a2">&#9670;&nbsp;</a></span>writeReducedMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeReducedMatrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a human-readable version of the reduced matrix to the given output stream. </p>
<p>This is a description of the homomorphism in some specific coordinates at present only meant to be internal to <a class="el" href="classregina_1_1HomMarkedAbelianGroup.html" title="Represents a homomorphism of finitely generated abelian groups.">HomMarkedAbelianGroup</a>. At present, these coordinates have the torsion factors of the group appearing first, followed by the free factors.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is missing; instead this is assumed to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5288d1ece14ec07413a046ac62245b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5288d1ece14ec07413a046ac62245b1f">&#9670;&nbsp;</a></span>writeTeX() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeTeX </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a TeX represesentation of this expression to the given output stream. </p>
<p>The text representation will be of the form <code>g_2^4 g_{13}^{-5} g_4</code>.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c373720fc59d7973d53f53e3126a409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c373720fc59d7973d53f53e3126a409">&#9670;&nbsp;</a></span>writeTeX() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTeX </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a TeX represesentation of this group presentation to the given output stream. </p>
<p>The output will be of the form &lt; generators | relators &gt;. There will be no final newline.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4485c48e5523b43d4753cf3262c45e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4485c48e5523b43d4753cf3262c45e52">&#9670;&nbsp;</a></span>writeText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeText </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortword</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a text representation of this expression to the given output stream, using either numbered generators or alphabetic generators. </p>
<p>The text representation will be of the form <code>g2^4 g13^-5 g4</code>. If the <em>shortword</em> flag is <code>true</code>, it will assume your word is in an alphabet of no more than 26 letters, and will write the word using lower-case ASCII, i.e., <code>c^4 n^-5 e</code>. If the <em>utf8</em> flag is <code>true</code>, all exponents will be written using superscript characters encoded in UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>shortword</em> is <code>true</code>, the number of generators in the corresponding group must be 26 or fewer.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">shortword</td><td>indicates whether to use numbered or alphabetic generators, as described above. </td></tr>
    <tr><td class="paramname">utf8</td><td><code>true</code> if exponents should be written using unicode superscript characters, or <code>false</code> if they should be written using a caret (^) symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9848a7d3303be02671e18c57d28afec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9848a7d3303be02671e18c57d28afec">&#9670;&nbsp;</a></span>writeTextCompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTextCompact </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a compact represesentation of this group to the given output stream. </p>
<p>The output will be of the form &lt; generators | relators &gt;. The full relations will be included, and the entire output will be written on a single line. There will be no final newline.</p>
<dl class="section user"><dt>Python</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37fa6a40ae529c19a16fdba8f66d6768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fa6a40ae529c19a16fdba8f66d6768">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b1eda088e5ec8331c924d284cfcc359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b1eda088e5ec8331c924d284cfcc359">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomGroupPresentation::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaafd028394928cbaba6ce8cfe28c96f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafd028394928cbaba6ce8cfe28c96f97">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A more detailed text representation of the homomorphism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24620bfbae6fe30c5036a0308ee7e52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24620bfbae6fe30c5036a0308ee7e52c">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>The text representation will be of the form <code>g2^4 g13^-5 g4</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac64ef64c265916b3fdc7e0c513d2b458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac64ef64c265916b3fdc7e0c513d2b458">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga507262602c062ad0190e0c22af7390f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga507262602c062ad0190e0c22af7390f7">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomGroupPresentation::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2779b4feadb621b496a2ec8e6f8eadc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2779b4feadb621b496a2ec8e6f8eadc4">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::HomMarkedAbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Short text representation. </p>
<p>This will state some basic properties of the homomorphism, such as:</p>
<ul>
<li>whether the map is the identity;</li>
<li>whether the map is an isomorphism;</li>
<li>whether the map is monic or epic;</li>
<li>if it is not monic, describes the kernel;</li>
<li>if it is not epic, describes the co-kernel;</li>
<li>if it is neither monic nor epic, describes the image.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga655d3a9de8d18a136f5ca578b6cfa7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga655d3a9de8d18a136f5ca578b6cfa7b9">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>. The torsion elements will be written in terms of the invariant factors of the group, as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td>if <code>true</code>, then richer unicode characters will be used to make the output more pleasant to read. In particular, the output will use subscript digits and the blackboard bold Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7db2c8ef127dba9ee3717e8660a7da43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db2c8ef127dba9ee3717e8660a7da43">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::MarkedAbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>. </p>
<p>The torsion elements will be written in terms of the invariant factors of the group, as described in the <a class="el" href="classregina_1_1MarkedAbelianGroup.html" title="Represents a finitely generated abelian group given by a chain complex.">MarkedAbelianGroup</a> notes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the stream to write to. </td></tr>
    <tr><td class="paramname">utf8</td><td>if <code>true</code>, then richer unicode characters will be used to make the output more pleasant to read. In particular, the output will use subscript digits and the blackboard bold Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd184409a580597ac709e7875355be74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd184409a580597ac709e7875355be74">&#9670;&nbsp;</a></span>writeXMLData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this abelian group. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8b0fedf30a85fc54ede2e37c5deb088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b0fedf30a85fc54ede2e37c5deb088">&#9670;&nbsp;</a></span>writeXMLData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this expression. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0a688500a505588004520eff2807545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0a688500a505588004520eff2807545">&#9670;&nbsp;</a></span>writeXMLData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupPresentation::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this group presentation. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga320c068af5e2f1b6d602e6eb28cfab60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga320c068af5e2f1b6d602e6eb28cfab60">&#9670;&nbsp;</a></span>XMLAbelianGroupReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLAbelianGroupReader::XMLAbelianGroupReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new abelian group reader. </p>

</div>
</div>
<a id="ga15b3ce81d51565ad8725ecd3bf6a1ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b3ce81d51565ad8725ecd3bf6a1ed7">&#9670;&nbsp;</a></span>XMLGroupPresentationReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLGroupPresentationReader::XMLGroupPresentationReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new group presentation reader. </p>

</div>
</div>
<a id="ga5d3629e95ac978c4c136e23b60b830b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3629e95ac978c4c136e23b60b830b1">&#9670;&nbsp;</a></span>~GroupPresentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupPresentation::~GroupPresentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the group presentation. </p>
<p>All relations that are stored will be deallocated. </p>

</div>
</div>
<a id="ga5b3898f6193634c768c9ab9276d95618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b3898f6193634c768c9ab9276d95618">&#9670;&nbsp;</a></span>~HomGroupPresentation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomGroupPresentation::~HomGroupPresentation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the group homomorphism. </p>

</div>
</div>
<a id="ga2f0882d4131e137378cf2885f49ae431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f0882d4131e137378cf2885f49ae431">&#9670;&nbsp;</a></span>~HomMarkedAbelianGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::HomMarkedAbelianGroup::~HomMarkedAbelianGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae5c56664a7a957fd6742bfd2940c473b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c56664a7a957fd6742bfd2940c473b">&#9670;&nbsp;</a></span>exponent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::GroupExpressionTerm::exponent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The exponent to which the generator is raised. </p>

</div>
</div>
<a id="ga58329571e0653f3818ed12b05f3e41f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58329571e0653f3818ed12b05f3e41f5">&#9670;&nbsp;</a></span>generator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupExpressionTerm::generator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number that identifies the generator in this term. </p>

</div>
</div>
<a id="ga3697f3d8592b06715c111a3ab6e1096c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3697f3d8592b06715c111a3ab6e1096c">&#9670;&nbsp;</a></span>invariantFactors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::multiset&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::AbelianGroup::invariantFactors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes. </p>

</div>
</div>
<a id="ga839bbeb4a4de73984b48b5ba8f4cccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga839bbeb4a4de73984b48b5ba8f4cccab">&#9670;&nbsp;</a></span>invertB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupPresentation::NWordSubstitutionData::invertB</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert B before making the substitution? </p>

</div>
</div>
<a id="ga27a626a41861ed1142ddb117a2e1b578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a626a41861ed1142ddb117a2e1b578">&#9670;&nbsp;</a></span>nGenerators</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::nGenerators</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of generators. </p>

</div>
</div>
<a id="ga9bb4166ec40c17c6a042f6d0609ed4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bb4166ec40c17c6a042f6d0609ed4db">&#9670;&nbsp;</a></span>rank_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::rank_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rank of the group (the number of Z components). </p>

</div>
</div>
<a id="ga2d903e49f27734aec45a59117c0e9bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d903e49f27734aec45a59117c0e9bc1">&#9670;&nbsp;</a></span>relations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>*&gt; regina::GroupPresentation::relations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The relations between the generators. </p>

</div>
</div>
<a id="gad33039c3161ba88d5abb24f4d5f020e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad33039c3161ba88d5abb24f4d5f020e4">&#9670;&nbsp;</a></span>score</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long int regina::GroupPresentation::NWordSubstitutionData::score</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The score, i.e., the decrease in the word letter count provided this substitution is made. </p>

</div>
</div>
<a id="ga5e0c2232d89cf63b96db716c4277cd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e0c2232d89cf63b96db716c4277cd8f">&#9670;&nbsp;</a></span>start_from</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::NWordSubstitutionData::start_from</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Where in B do we start? </p>

</div>
</div>
<a id="gaf3e48e08f2f475bcd5d443cb200a214b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3e48e08f2f475bcd5d443cb200a214b">&#9670;&nbsp;</a></span>start_sub_at</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::NWordSubstitutionData::start_sub_at</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Where in A do we start? </p>

</div>
</div>
<a id="gada543feeb78f2ab1b2e85a3aa4558877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada543feeb78f2ab1b2e85a3aa4558877">&#9670;&nbsp;</a></span>sub_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupPresentation::NWordSubstitutionData::sub_length</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of letters from B to use. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
