<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::AngleStructures Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1AngleStructures-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::AngleStructures Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__angle.html">Angle Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A packet representing a collection of angle structures on a triangulation.  
 <a href="classregina_1_1AngleStructures.html#details">More...</a></p>

<p><code>#include &lt;angle/anglestructures.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::AngleStructures:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1AngleStructures.png" usemap="#regina::AngleStructures_map" alt=""/>
  <map id="regina::AngleStructures_map" name="regina::AngleStructures_map">
<area href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon." alt="regina::Packet" shape="rect" coords="111,56,323,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Packet &gt;" shape="rect" coords="0,0,212,24"/>
<area href="classregina_1_1SafePointeeBase.html" alt="regina::SafePointeeBase&lt; Packet &gt;" shape="rect" coords="222,0,434,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1AngleStructures_1_1StructureInserter.html">StructureInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output iterator used to insert angle structures into an <a class="el" href="classregina_1_1AngleStructures.html" title="A packet representing a collection of angle structures on a triangulation.">AngleStructures</a> list.  <a href="structregina_1_1AngleStructures_1_1StructureInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td></tr>
<tr class="memdesc:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object being pointed to.  <a href="#a2e4bacf91fc79a12ae3a02f4339ed034">More...</a><br /></td></tr>
<tr class="separator:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae365bea588f1787b1ffee38fc6d70dc6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ae365bea588f1787b1ffee38fc6d70dc6">~AngleStructures</a> ()</td></tr>
<tr class="memdesc:ae365bea588f1787b1ffee38fc6d70dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this list and all the angle structures within.  <a href="#ae365bea588f1787b1ffee38fc6d70dc6">More...</a><br /></td></tr>
<tr class="separator:ae365bea588f1787b1ffee38fc6d70dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2d244430aeec23a20f060e2c876866"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a4f2d244430aeec23a20f060e2c876866">triangulation</a> () const</td></tr>
<tr class="memdesc:a4f2d244430aeec23a20f060e2c876866"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation on which these angle structures lie.  <a href="#a4f2d244430aeec23a20f060e2c876866">More...</a><br /></td></tr>
<tr class="separator:a4f2d244430aeec23a20f060e2c876866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315d5492ed03fc096678261e6583d6c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a315d5492ed03fc096678261e6583d6c6">isTautOnly</a> () const</td></tr>
<tr class="memdesc:a315d5492ed03fc096678261e6583d6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was produced by enumerating taut angle structures only.  <a href="#a315d5492ed03fc096678261e6583d6c6">More...</a><br /></td></tr>
<tr class="separator:a315d5492ed03fc096678261e6583d6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bfa1531d425a1c33b920d8f83586b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a25bfa1531d425a1c33b920d8f83586b3">size</a> () const</td></tr>
<tr class="memdesc:a25bfa1531d425a1c33b920d8f83586b3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of angle structures stored in this list.  <a href="#a25bfa1531d425a1c33b920d8f83586b3">More...</a><br /></td></tr>
<tr class="separator:a25bfa1531d425a1c33b920d8f83586b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f333def3b5ffc6dec4f9ccbd00c8466"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a5f333def3b5ffc6dec4f9ccbd00c8466">structure</a> (size_t index) const</td></tr>
<tr class="memdesc:a5f333def3b5ffc6dec4f9ccbd00c8466"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the angle structure at the requested index in this list.  <a href="#a5f333def3b5ffc6dec4f9ccbd00c8466">More...</a><br /></td></tr>
<tr class="separator:a5f333def3b5ffc6dec4f9ccbd00c8466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c8446f4a8bbbb387104397bfde140d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ac4c8446f4a8bbbb387104397bfde140d">spansStrict</a> () const</td></tr>
<tr class="memdesc:ac4c8446f4a8bbbb387104397bfde140d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any convex combination of the angle structures in this list is a strict angle structure.  <a href="#ac4c8446f4a8bbbb387104397bfde140d">More...</a><br /></td></tr>
<tr class="separator:ac4c8446f4a8bbbb387104397bfde140d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f5a2614871da2375a68cdaca5fefa8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ae0f5a2614871da2375a68cdaca5fefa8">spansTaut</a> () const</td></tr>
<tr class="memdesc:ae0f5a2614871da2375a68cdaca5fefa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether any angle structure in this list is a taut structure.  <a href="#ae0f5a2614871da2375a68cdaca5fefa8">More...</a><br /></td></tr>
<tr class="separator:ae0f5a2614871da2375a68cdaca5fefa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125b651b08f8aa07d79f450a6f29ff7d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a125b651b08f8aa07d79f450a6f29ff7d">writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a125b651b08f8aa07d79f450a6f29ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a125b651b08f8aa07d79f450a6f29ff7d">More...</a><br /></td></tr>
<tr class="separator:a125b651b08f8aa07d79f450a6f29ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c0c8c9b7bb190f32e48573b4299de4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a12c0c8c9b7bb190f32e48573b4299de4">writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a12c0c8c9b7bb190f32e48573b4299de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a12c0c8c9b7bb190f32e48573b4299de4">More...</a><br /></td></tr>
<tr class="separator:a12c0c8c9b7bb190f32e48573b4299de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5ac676fbceae4514b483fb661a11c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a7c5ac676fbceae4514b483fb661a11c9">dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:a7c5ac676fbceae4514b483fb661a11c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="#a7c5ac676fbceae4514b483fb661a11c9">More...</a><br /></td></tr>
<tr class="separator:a7c5ac676fbceae4514b483fb661a11c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">hasOwner</a> () const</td></tr>
<tr class="memdesc:gac85ba39c124eda4ce631b653d6bb0a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object.  <a href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">More...</a><br /></td></tr>
<tr class="separator:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa724448326c5e5b0ba727fe6ce6d1233"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#aa724448326c5e5b0ba727fe6ce6d1233">hasSafePtr</a> () const</td></tr>
<tr class="memdesc:aa724448326c5e5b0ba727fe6ce6d1233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there one or more SafePtr currently pointing to this object?  <a href="#aa724448326c5e5b0ba727fe6ce6d1233">More...</a><br /></td></tr>
<tr class="separator:aa724448326c5e5b0ba727fe6ce6d1233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Identification</div></td></tr>
<tr class="memitem:ga11e183185ea0a33e67e2574fc93c7469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a> () const =0</td></tr>
<tr class="memdesc:ga11e183185ea0a33e67e2574fc93c7469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet.  <a href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">More...</a><br /></td></tr>
<tr class="separator:ga11e183185ea0a33e67e2574fc93c7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787a09ec531988778fcfb0bc87effdd4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">typeName</a> () const =0</td></tr>
<tr class="memdesc:ga787a09ec531988778fcfb0bc87effdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet.  <a href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">More...</a><br /></td></tr>
<tr class="separator:ga787a09ec531988778fcfb0bc87effdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a> () const</td></tr>
<tr class="memdesc:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">More...</a><br /></td></tr>
<tr class="separator:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfaee615502b79cbeef31628a1186dc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">humanLabel</a> () const</td></tr>
<tr class="memdesc:gadfaee615502b79cbeef31628a1186dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">More...</a><br /></td></tr>
<tr class="separator:gadfaee615502b79cbeef31628a1186dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">adornedLabel</a> (const std::string &amp;adornment) const</td></tr>
<tr class="memdesc:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string.  <a href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">More...</a><br /></td></tr>
<tr class="separator:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd869991cbf664891629f21a5432b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfd869991cbf664891629f21a5432b02">setLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:gadfd869991cbf664891629f21a5432b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="group__packet.html#gadfd869991cbf664891629f21a5432b02">More...</a><br /></td></tr>
<tr class="separator:gadfd869991cbf664891629f21a5432b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f5775c175a56d06da14444b391ed3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">fullName</a> () const</td></tr>
<tr class="memdesc:ga29f5775c175a56d06da14444b391ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet.  <a href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">More...</a><br /></td></tr>
<tr class="separator:ga29f5775c175a56d06da14444b391ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tags</div></td></tr>
<tr class="memitem:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:gaf4315a8b8ebcf47e781c204927f8845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">More...</a><br /></td></tr>
<tr class="separator:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4404beade84983a4f1c051cd64035ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">hasTags</a> () const</td></tr>
<tr class="memdesc:ga4404beade84983a4f1c051cd64035ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">More...</a><br /></td></tr>
<tr class="separator:ga4404beade84983a4f1c051cd64035ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">More...</a><br /></td></tr>
<tr class="separator:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">More...</a><br /></td></tr>
<tr class="separator:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">removeAllTags</a> ()</td></tr>
<tr class="memdesc:gaee2405989e058dbfddf7ae445d47ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">More...</a><br /></td></tr>
<tr class="separator:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d41356ff086d078b04f34919aac26d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">tags</a> () const</td></tr>
<tr class="memdesc:ga06d41356ff086d078b04f34919aac26d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">More...</a><br /></td></tr>
<tr class="separator:ga06d41356ff086d078b04f34919aac26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event Handling</div></td></tr>
<tr class="memitem:gaa504cfa813a3190c00337743915ffef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">listen</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gaa504cfa813a3190c00337743915ffef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">More...</a><br /></td></tr>
<tr class="separator:gaa504cfa813a3190c00337743915ffef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">isListening</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">More...</a><br /></td></tr>
<tr class="separator:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71b40cd2416de174bba61db2ec92f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">unlisten</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gae71b40cd2416de174bba61db2ec92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">More...</a><br /></td></tr>
<tr class="separator:gae71b40cd2416de174bba61db2ec92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Queries</div></td></tr>
<tr class="memitem:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a> () const</td></tr>
<tr class="memdesc:gab80d6d7bc86d4600980f0c9555bb6237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">More...</a><br /></td></tr>
<tr class="separator:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">firstChild</a> () const</td></tr>
<tr class="memdesc:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">More...</a><br /></td></tr>
<tr class="separator:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">lastChild</a> () const</td></tr>
<tr class="memdesc:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">More...</a><br /></td></tr>
<tr class="separator:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">nextSibling</a> () const</td></tr>
<tr class="memdesc:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">More...</a><br /></td></tr>
<tr class="separator:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84decda10642eccee55a109e70e10076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga84decda10642eccee55a109e70e10076">prevSibling</a> () const</td></tr>
<tr class="memdesc:ga84decda10642eccee55a109e70e10076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="group__packet.html#ga84decda10642eccee55a109e70e10076">More...</a><br /></td></tr>
<tr class="separator:ga84decda10642eccee55a109e70e10076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">root</a> () const</td></tr>
<tr class="memdesc:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">More...</a><br /></td></tr>
<tr class="separator:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">levelsDownTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">More...</a><br /></td></tr>
<tr class="separator:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">levelsUpTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *ancestor) const</td></tr>
<tr class="memdesc:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">More...</a><br /></td></tr>
<tr class="separator:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">isGrandparentOf</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">More...</a><br /></td></tr>
<tr class="separator:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">countChildren</a> () const</td></tr>
<tr class="memdesc:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet.  <a href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">More...</a><br /></td></tr>
<tr class="separator:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">countDescendants</a> () const</td></tr>
<tr class="memdesc:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of strict descendants of this packet.  <a href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">More...</a><br /></td></tr>
<tr class="separator:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2519c2dac8e039b7acd5df8373c608d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">totalTreeSize</a> () const</td></tr>
<tr class="memdesc:gae2519c2dac8e039b7acd5df8373c608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">More...</a><br /></td></tr>
<tr class="separator:gae2519c2dac8e039b7acd5df8373c608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Manipulation</div></td></tr>
<tr class="memitem:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">insertChildFirst</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gac389781f5c53a7d3aac3206d51ecfd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">More...</a><br /></td></tr>
<tr class="separator:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">insertChildLast</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gad3d02be74192f03b372a4195c9e5bc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">More...</a><br /></td></tr>
<tr class="separator:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9556e8405ca88517ccd5549471fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">insertChildAfter</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newChild, <a class="el" href="classregina_1_1Packet.html">Packet</a> *prevChild)</td></tr>
<tr class="memdesc:gad7f9556e8405ca88517ccd5549471fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">More...</a><br /></td></tr>
<tr class="separator:gad7f9556e8405ca88517ccd5549471fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">makeOrphan</a> ()</td></tr>
<tr class="memdesc:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree.  <a href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">More...</a><br /></td></tr>
<tr class="separator:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">reparent</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent, bool first=false)</td></tr>
<tr class="memdesc:ga219920e1523d3edf2982da0a3ba1a33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">More...</a><br /></td></tr>
<tr class="separator:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">transferChildren</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent)</td></tr>
<tr class="memdesc:ga27ce736503ede9e8c57fb5d169e6414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">More...</a><br /></td></tr>
<tr class="separator:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765186c1742fe402922433b77e5f439a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga765186c1742fe402922433b77e5f439a">swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:ga765186c1742fe402922433b77e5f439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="group__packet.html#ga765186c1742fe402922433b77e5f439a">More...</a><br /></td></tr>
<tr class="separator:ga765186c1742fe402922433b77e5f439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">More...</a><br /></td></tr>
<tr class="separator:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adc13b6143cf994779796077aed731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga59adc13b6143cf994779796077aed731">moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:ga59adc13b6143cf994779796077aed731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="group__packet.html#ga59adc13b6143cf994779796077aed731">More...</a><br /></td></tr>
<tr class="separator:ga59adc13b6143cf994779796077aed731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d7730c57940444bf7d3085459449e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">moveToFirst</a> ()</td></tr>
<tr class="memdesc:gab4d7730c57940444bf7d3085459449e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">More...</a><br /></td></tr>
<tr class="separator:gab4d7730c57940444bf7d3085459449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">moveToLast</a> ()</td></tr>
<tr class="memdesc:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">More...</a><br /></td></tr>
<tr class="separator:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91bc951714dc60db12810affb266b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">sortChildren</a> ()</td></tr>
<tr class="memdesc:gaf91bc951714dc60db12810affb266b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">More...</a><br /></td></tr>
<tr class="separator:gaf91bc951714dc60db12810affb266b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Searching and Iterating</div></td></tr>
<tr class="memitem:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a> ()</td></tr>
<tr class="memdesc:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">More...</a><br /></td></tr>
<tr class="separator:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941baf3f572331538ec82154fd3dc997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a> ()</td></tr>
<tr class="memdesc:ga941baf3f572331538ec82154fd3dc997"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">More...</a><br /></td></tr>
<tr class="separator:ga941baf3f572331538ec82154fd3dc997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">descendants</a> () const</td></tr>
<tr class="memdesc:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through all strict descendants of this packet in the packet tree.  <a href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">More...</a><br /></td></tr>
<tr class="separator:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17dd27f603463f226e64ccb65211060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">children</a> () const</td></tr>
<tr class="memdesc:gaf17dd27f603463f226e64ccb65211060"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through the immediate children of this packet.  <a href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">More...</a><br /></td></tr>
<tr class="separator:gaf17dd27f603463f226e64ccb65211060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">nextTreePacket</a> ()</td></tr>
<tr class="memdesc:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">More...</a><br /></td></tr>
<tr class="separator:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">nextTreePacket</a> () const</td></tr>
<tr class="memdesc:gaeaff341860febcb3daadd1b9b4216c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">More...</a><br /></td></tr>
<tr class="separator:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">More...</a><br /></td></tr>
<tr class="separator:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74345507fd3326dc1b22a284b90da5d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga74345507fd3326dc1b22a284b90da5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">More...</a><br /></td></tr>
<tr class="separator:ga74345507fd3326dc1b22a284b90da5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e196f0f1c415b457df17f96d5b6518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga12e196f0f1c415b457df17f96d5b6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">More...</a><br /></td></tr>
<tr class="separator:ga12e196f0f1c415b457df17f96d5b6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">More...</a><br /></td></tr>
<tr class="separator:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">More...</a><br /></td></tr>
<tr class="separator:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7855ea352221d498d1ca38a34d85af5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>) const</td></tr>
<tr class="memdesc:gac7855ea352221d498d1ca38a34d85af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">More...</a><br /></td></tr>
<tr class="separator:gac7855ea352221d498d1ca38a34d85af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Dependencies</div></td></tr>
<tr class="memitem:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">isPacketEditable</a> () const</td></tr>
<tr class="memdesc:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children.  <a href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">More...</a><br /></td></tr>
<tr class="separator:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloning</div></td></tr>
<tr class="memitem:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">clone</a> (bool cloneDescendants=false, bool <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>=true) const</td></tr>
<tr class="memdesc:ga73c411ef1237a06ad6b634d3db67f17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">More...</a><br /></td></tr>
<tr class="separator:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File I/O</div></td></tr>
<tr class="memitem:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">save</a> (const char *filename, bool compressed=true) const</td></tr>
<tr class="memdesc:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">More...</a><br /></td></tr>
<tr class="separator:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">save</a> (std::ostream &amp;s, bool compressed=true) const</td></tr>
<tr class="memdesc:ga898ec49e8d39c46cd965ad506493f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">More...</a><br /></td></tr>
<tr class="separator:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">writeXMLFile</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga0bf681a968d890cd848f1277ea22ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">More...</a><br /></td></tr>
<tr class="separator:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">internalID</a> () const</td></tr>
<tr class="memdesc:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">More...</a><br /></td></tr>
<tr class="separator:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9c339156d162a54d6a66c949dda62a3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a9c339156d162a54d6a66c949dda62a3c">enumerate</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *owner, bool tautOnly=false, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=0)</td></tr>
<tr class="memdesc:a9c339156d162a54d6a66c949dda62a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates all angle structures on the given triangulation.  <a href="#a9c339156d162a54d6a66c949dda62a3c">More...</a><br /></td></tr>
<tr class="separator:a9c339156d162a54d6a66c949dda62a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4cd806b356e57973456e5350c98fb6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#abe4cd806b356e57973456e5350c98fb6">enumerateTautDD</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *owner)</td></tr>
<tr class="memdesc:abe4cd806b356e57973456e5350c98fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slower, alternative method to enumerate all taut angle structures on the given triangulation.  <a href="#abe4cd806b356e57973456e5350c98fb6">More...</a><br /></td></tr>
<tr class="separator:abe4cd806b356e57973456e5350c98fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8b726b927d8e08928736527d41e9b4"><td class="memItemLeft" align="right" valign="top"><a id="a2c8b726b927d8e08928736527d41e9b4"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:a2c8b726b927d8e08928736527d41e9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">safeDelete</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either destroys or orphans the given packet, according to whether it has safe pointers that currently reference it.  <a href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">More...</a><br /></td></tr>
<tr class="separator:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a17d596ce2f45572f0ed2d03c8d807e97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a17d596ce2f45572f0ed2d03c8d807e97">AngleStructures</a> (bool tautOnly)</td></tr>
<tr class="memdesc:a17d596ce2f45572f0ed2d03c8d807e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new empty angle structure list.  <a href="#a17d596ce2f45572f0ed2d03c8d807e97">More...</a><br /></td></tr>
<tr class="separator:a17d596ce2f45572f0ed2d03c8d807e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045880691b243edd429661aa1d0fc859"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#a045880691b243edd429661aa1d0fc859">internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:a045880691b243edd429661aa1d0fc859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="#a045880691b243edd429661aa1d0fc859">More...</a><br /></td></tr>
<tr class="separator:a045880691b243edd429661aa1d0fc859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe639ef03c5af712afaae0b602dab37f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#afe639ef03c5af712afaae0b602dab37f">writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:afe639ef03c5af712afaae0b602dab37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="#afe639ef03c5af712afaae0b602dab37f">More...</a><br /></td></tr>
<tr class="separator:afe639ef03c5af712afaae0b602dab37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb315298423dc92a072462d9d9b6a110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#abb315298423dc92a072462d9d9b6a110">calculateSpanStrict</a> () const</td></tr>
<tr class="memdesc:abb315298423dc92a072462d9d9b6a110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate whether the convex span of this list includes a strict angle structure.  <a href="#abb315298423dc92a072462d9d9b6a110">More...</a><br /></td></tr>
<tr class="separator:abb315298423dc92a072462d9d9b6a110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34f5f7ee0c4397353cf4edb4791ecd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AngleStructures.html#ad34f5f7ee0c4397353cf4edb4791ecd1">calculateSpanTaut</a> () const</td></tr>
<tr class="memdesc:ad34f5f7ee0c4397353cf4edb4791ecd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate whether the convex span of this list includes a taut structure.  <a href="#ad34f5f7ee0c4397353cf4edb4791ecd1">More...</a><br /></td></tr>
<tr class="separator:ad34f5f7ee0c4397353cf4edb4791ecd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">writeXMLPacketTree</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the subtree with this packet as matriarch.  <a href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">More...</a><br /></td></tr>
<tr class="separator:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7d43cee2f6d4a3a3ee51964ad7e3e7f4"><td class="memItemLeft" align="right" valign="top"><a id="a7d43cee2f6d4a3a3ee51964ad7e3e7f4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLAngleStructuresReader</b></td></tr>
<tr class="separator:a7d43cee2f6d4a3a3ee51964ad7e3e7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A packet representing a collection of angle structures on a triangulation. </p>
<p>Such a packet must always be a child packet of the triangulation on which the angle structures lie. If this triangulation changes, the information contained in this packet will become invalid.</p>
<p>Angle structure lists should be created using the routine <a class="el" href="classregina_1_1AngleStructures.html#a9c339156d162a54d6a66c949dda62a3c" title="Enumerates all angle structures on the given triangulation.">enumerate()</a>, which is new as of Regina 3.95. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e4bacf91fc79a12ae3a02f4339ed034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4bacf91fc79a12ae3a02f4339ed034">&#9670;&nbsp;</a></span>SafePointeeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>  <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a>  &gt;::<a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of object being pointed to. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae365bea588f1787b1ffee38fc6d70dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae365bea588f1787b1ffee38fc6d70dc6">&#9670;&nbsp;</a></span>~AngleStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::~AngleStructures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this list and all the angle structures within. </p>

</div>
</div>
<a id="a17d596ce2f45572f0ed2d03c8d807e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d596ce2f45572f0ed2d03c8d807e97">&#9670;&nbsp;</a></span>AngleStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AngleStructures::AngleStructures </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tautOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new empty angle structure list. </p>
<p>All properties are marked as unknown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tautOnly</td><td><code>true</code> if only taut structures are to be enuemrated (when the time comes for enumeration to be performed), or <code>false</code> if we should enumerate all vertices of the angle structure solution space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abb315298423dc92a072462d9d9b6a110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb315298423dc92a072462d9d9b6a110">&#9670;&nbsp;</a></span>calculateSpanStrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::calculateSpanStrict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate whether the convex span of this list includes a strict angle structure. </p>

</div>
</div>
<a id="ad34f5f7ee0c4397353cf4edb4791ecd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34f5f7ee0c4397353cf4edb4791ecd1">&#9670;&nbsp;</a></span>calculateSpanTaut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AngleStructures::calculateSpanTaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate whether the convex span of this list includes a taut structure. </p>

</div>
</div>
<a id="a7c5ac676fbceae4514b483fb661a11c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5ac676fbceae4514b483fb661a11c9">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a9c339156d162a54d6a66c949dda62a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c339156d162a54d6a66c949dda62a3c">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>* regina::AngleStructures::enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tautOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerates all angle structures on the given triangulation. </p>
<p>A list containing all vertices of the angle structure solution space will be returned.</p>
<p>The option is offered to find only taut structures (which are considerably faster to enumerate) instead of enumerating all vertex angle structures. See the <em>tautOnly</em> argument below.</p>
<p>The angle structure list that is created will be inserted as the last child of the given triangulation. This triangulation <b>must</b> remain the parent of this angle structure list, and must not change while this angle structure list remains in existence.</p>
<p>If a progress tracker is passed, the angle structure enumeration will take place in a new thread and this routine will return immediately. If the user cancels the operation from another thread, then the angle structure list will <em>not</em> be inserted into the packet tree (but the caller of this routine will still need to delete it). Regarding progress tracking, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p>If no progress tracker is passed, the enumeration will run in the current thread and this routine will return only when the enumeration is complete. Note that this enumeration can be extremely slow for larger triangulations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the triangulation for which the vertex angle structures will be enumerated. </td></tr>
    <tr><td class="paramname">tautOnly</td><td><code>true</code> if only taut structures are to be enuemrated, or <code>false</code> if we should enumerate all vertices of the angle structure solution space; this defaults to <code>false</code>. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or 0 if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created angle structure list. Note that if a progress tracker is passed then this list may not be completely filled when this routine returns. If a progress tracker is passed and a new thread could not be started, this routine returns 0 (and no angle structure list is created). </dd></dl>

</div>
</div>
<a id="abe4cd806b356e57973456e5350c98fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4cd806b356e57973456e5350c98fb6">&#9670;&nbsp;</a></span>enumerateTautDD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1AngleStructures.html">AngleStructures</a>* regina::AngleStructures::enumerateTautDD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A slower, alternative method to enumerate all taut angle structures on the given triangulation. </p>
<p>A list containing all taut angle structures will be returned.</p>
<p>The algorithm used by this routine is based on the double description method. The algorithm used by <a class="el" href="classregina_1_1AngleStructures.html#a9c339156d162a54d6a66c949dda62a3c" title="Enumerates all angle structures on the given triangulation.">enumerate()</a> (the preferred method) is instead based on linear programming, and is typically <em>much</em> faster than this routine for larger triangulations.</p>
<p>The angle structure list that is created will be inserted as the last child of the given triangulation. This triangulation <b>must</b> remain the parent of this angle structure list, and must not change while this angle structure list remains in existence.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is slow, and users will not want to call it unless they have some specialised need.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the triangulation for which the taut angle structures will be enumerated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created angle structure list. </dd></dl>

</div>
</div>
<a id="aa724448326c5e5b0ba727fe6ce6d1233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa724448326c5e5b0ba727fe6ce6d1233">&#9670;&nbsp;</a></span>hasSafePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a>  &gt;::hasSafePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is there one or more <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> currently pointing to this object? </p>

</div>
</div>
<a id="a045880691b243edd429661aa1d0fc859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045880691b243edd429661aa1d0fc859">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::AngleStructures::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="a315d5492ed03fc096678261e6583d6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d5492ed03fc096678261e6583d6c6">&#9670;&nbsp;</a></span>isTautOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::isTautOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was produced by enumerating taut angle structures only. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was produced by enumerating taut angle structures only, or <code>false</code> if the enumeration procedure allowed for any angle structures. </dd></dl>

</div>
</div>
<a id="a25bfa1531d425a1c33b920d8f83586b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bfa1531d425a1c33b920d8f83586b3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AngleStructures::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of angle structures stored in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of angle structures. </dd></dl>

</div>
</div>
<a id="ac4c8446f4a8bbbb387104397bfde140d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c8446f4a8bbbb387104397bfde140d">&#9670;&nbsp;</a></span>spansStrict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::spansStrict </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any convex combination of the angle structures in this list is a strict angle structure. </p>
<p>See <a class="el" href="classregina_1_1AngleStructure.html#aea6b3db616a85e5557a62996499b5994" title="Determines whether this is a strict angle structure.">AngleStructure::isStrict()</a> for details on strict angle structures.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a strict angle structure can be produced. </dd></dl>

</div>
</div>
<a id="ae0f5a2614871da2375a68cdaca5fefa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f5a2614871da2375a68cdaca5fefa8">&#9670;&nbsp;</a></span>spansTaut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AngleStructures::spansTaut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether any angle structure in this list is a taut structure. </p>
<p>Because taut structures always appear as vertices of the angle structure solution space, this routine is equivalent to testing whether any convex combination of the angle structures in this list is a taut structure.</p>
<p>See <a class="el" href="classregina_1_1AngleStructure.html#a41850883aa5d36f82a0ef708bd1e26ef" title="Determines whether this is a taut angle structure.">AngleStructure::isTaut()</a> for details on taut structures.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a taut structure can be produced. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python</dt><dd>In addition to <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a5f333def3b5ffc6dec4f9ccbd00c8466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f333def3b5ffc6dec4f9ccbd00c8466">&#9670;&nbsp;</a></span>structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AngleStructure.html">AngleStructure</a> * regina::AngleStructures::structure </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the angle structure at the requested index in this list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested angle structure in this list; this must be between 0 and <a class="el" href="classregina_1_1AngleStructures.html#a25bfa1531d425a1c33b920d8f83586b3" title="Returns the number of angle structures stored in this list.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the angle structure at the requested index. </dd></dl>

</div>
</div>
<a id="a4f2d244430aeec23a20f060e2c876866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2d244430aeec23a20f060e2c876866">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::AngleStructures::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation on which these angle structures lie. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding triangulation. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a12c0c8c9b7bb190f32e48573b4299de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c0c8c9b7bb190f32e48573b4299de4">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::AngleStructures::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="a125b651b08f8aa07d79f450a6f29ff7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125b651b08f8aa07d79f450a6f29ff7d">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::AngleStructures::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="afe639ef03c5af712afaae0b602dab37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe639ef03c5af712afaae0b602dab37f">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::AngleStructures::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>angle/<a class="el" href="anglestructures_8h.html">anglestructures.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
