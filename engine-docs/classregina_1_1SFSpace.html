<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::SFSpace Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1SFSpace.html">SFSpace</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1SFSpace-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::SFSpace Class Reference<div class="ingroups"><a class="el" href="group__manifold.html">Standard 3-Manifolds</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a general Seifert fibred space, which may be orientable or non-orientable.  
 <a href="classregina_1_1SFSpace.html#details">More...</a></p>

<p><code>#include &lt;manifold/sfs.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::SFSpace:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1SFSpace.png" usemap="#regina::SFSpace_map" alt=""/>
  <map id="regina::SFSpace_map" name="regina::SFSpace_map">
<area href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold." alt="regina::Manifold" shape="rect" coords="87,56,251,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Manifold &gt;" shape="rect" coords="0,0,164,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ca6dbe82be7c2f77c480e5ad720f451"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451">classType</a> { <br/>
&#160;&#160;<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451aee6551a605ca5c2257265ae389a8ad49">o1</a> = 101, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a5d35a6be3a142c543fec1e3e53d362a6">o2</a> = 102, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a20296b965f715f5c8d705ba59e39c408">n1</a> = 201, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a2ff57c6837334c6b20769ca49b0db5c1">n2</a> = 202, 
<br/>
&#160;&#160;<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451aac79eded7f2f568c7f1f8bc461c99c40">n3</a> = 203, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a0407c4c93466e1b07016a53b14674384">n4</a> = 204, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a1654d3e2dace8737bec604781355ecfc">bo1</a> = 301, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a663bb34f4339e3041e80cfb67be260e1">bo2</a> = 302, 
<br/>
&#160;&#160;<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a58c4517e4b1116a250580b8d72c1acd0">bn1</a> = 401, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a5f6b58c0ede57bcfdaced07f2e9415e4">bn2</a> = 402, 
<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451a4e6ff4256bd817e0cf2f0bb0c61a97e9">bn3</a> = 403
<br/>
 }</td></tr>
<tr class="memdesc:a8ca6dbe82be7c2f77c480e5ad720f451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code>, <code>n4</code> for base orbifolds without boundaries, plus five classes <code>bo1</code>, <code>b02</code>, <code>bn1</code>, <code>bn2</code>, <code>bn3</code> for base orbifolds with boundaries.  <a href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451">More...</a><br/></td></tr>
<tr class="separator:a8ca6dbe82be7c2f77c480e5ad720f451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a577f3044abc53a580a0bf8e7c2c072d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a577f3044abc53a580a0bf8e7c2c072d0">SFSpace</a> ()</td></tr>
<tr class="memdesc:a577f3044abc53a580a0bf8e7c2c072d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space with base orbifold the 2-sphere and no exceptional fibres.  <a href="#a577f3044abc53a580a0bf8e7c2c072d0">More...</a><br/></td></tr>
<tr class="separator:a577f3044abc53a580a0bf8e7c2c072d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fad6e2b785d4a98f21cdfba570992f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a9fad6e2b785d4a98f21cdfba570992f7">SFSpace</a> (<a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451">classType</a> useClass, unsigned long genus, unsigned long <a class="el" href="classregina_1_1SFSpace.html#ab54dda9d07b66c035f01e4a1e55a3c41">punctures</a>=0, unsigned long puncturesTwisted=0, unsigned long <a class="el" href="classregina_1_1SFSpace.html#aa2605817b36df44cc52bb08c5a4a6ef9">reflectors</a>=0, unsigned long reflectorsTwisted=0)</td></tr>
<tr class="memdesc:a9fad6e2b785d4a98f21cdfba570992f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space of the given class with the given base orbifold and no exceptional fibres.  <a href="#a9fad6e2b785d4a98f21cdfba570992f7">More...</a><br/></td></tr>
<tr class="separator:a9fad6e2b785d4a98f21cdfba570992f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8f297d09fd4dec0bf321fd97b618e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a2c8f297d09fd4dec0bf321fd97b618e5">SFSpace</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a2c8f297d09fd4dec0bf321fd97b618e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Seifert fibred space that is a clone of the given space.  <a href="#a2c8f297d09fd4dec0bf321fd97b618e5">More...</a><br/></td></tr>
<tr class="separator:a2c8f297d09fd4dec0bf321fd97b618e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc6b7476178bdec9fd20d809c6f3fa2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a7dc6b7476178bdec9fd20d809c6f3fa2">~SFSpace</a> ()</td></tr>
<tr class="memdesc:a7dc6b7476178bdec9fd20d809c6f3fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this Seifert fibred space.  <a href="#a7dc6b7476178bdec9fd20d809c6f3fa2">More...</a><br/></td></tr>
<tr class="separator:a7dc6b7476178bdec9fd20d809c6f3fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f450fd4f6f3022e04bba6338b3122c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a8f450fd4f6f3022e04bba6338b3122c6">operator=</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a8f450fd4f6f3022e04bba6338b3122c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies this Seifert fibred space to be a clone of the given space.  <a href="#a8f450fd4f6f3022e04bba6338b3122c6">More...</a><br/></td></tr>
<tr class="separator:a8f450fd4f6f3022e04bba6338b3122c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d9de8721fa3c4d11a1bdb27ded9112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451">classType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#af6d9de8721fa3c4d11a1bdb27ded9112">baseClass</a> () const </td></tr>
<tr class="memdesc:af6d9de8721fa3c4d11a1bdb27ded9112"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which of the eleven predefined classes this space belongs to.  <a href="#af6d9de8721fa3c4d11a1bdb27ded9112">More...</a><br/></td></tr>
<tr class="separator:af6d9de8721fa3c4d11a1bdb27ded9112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0819bae105bba1bf15a17db1a6adce8d"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a0819bae105bba1bf15a17db1a6adce8d">baseGenus</a> () const </td></tr>
<tr class="memdesc:a0819bae105bba1bf15a17db1a6adce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the genus of the base orbifold.  <a href="#a0819bae105bba1bf15a17db1a6adce8d">More...</a><br/></td></tr>
<tr class="separator:a0819bae105bba1bf15a17db1a6adce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9b60a3b4f6689247ee107124d9b5d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a3f9b60a3b4f6689247ee107124d9b5d5">baseOrientable</a> () const </td></tr>
<tr class="memdesc:a3f9b60a3b4f6689247ee107124d9b5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not the base surface is orientable.  <a href="#a3f9b60a3b4f6689247ee107124d9b5d5">More...</a><br/></td></tr>
<tr class="separator:a3f9b60a3b4f6689247ee107124d9b5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216b158dd60788f8a67cdc264d9b4915"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a216b158dd60788f8a67cdc264d9b4915">fibreReversing</a> () const </td></tr>
<tr class="memdesc:a216b158dd60788f8a67cdc264d9b4915"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this space contains any fibre-reversing paths.  <a href="#a216b158dd60788f8a67cdc264d9b4915">More...</a><br/></td></tr>
<tr class="separator:a216b158dd60788f8a67cdc264d9b4915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0340f7f57b3cef1646f51b221d3002"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aad0340f7f57b3cef1646f51b221d3002">fibreNegating</a> () const </td></tr>
<tr class="memdesc:aad0340f7f57b3cef1646f51b221d3002"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not we can negate an exceptional fibre by passing it around the interior of the base orbifold.  <a href="#aad0340f7f57b3cef1646f51b221d3002">More...</a><br/></td></tr>
<tr class="separator:aad0340f7f57b3cef1646f51b221d3002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54dda9d07b66c035f01e4a1e55a3c41"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ab54dda9d07b66c035f01e4a1e55a3c41">punctures</a> () const </td></tr>
<tr class="memdesc:ab54dda9d07b66c035f01e4a1e55a3c41"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of punctures in the base orbifold.  <a href="#ab54dda9d07b66c035f01e4a1e55a3c41">More...</a><br/></td></tr>
<tr class="separator:ab54dda9d07b66c035f01e4a1e55a3c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad15db0e0e3acd699ac823d5a4c9ef3"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a6ad15db0e0e3acd699ac823d5a4c9ef3">punctures</a> (bool twisted) const </td></tr>
<tr class="memdesc:a6ad15db0e0e3acd699ac823d5a4c9ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of punctures of the given type in the base orbifold.  <a href="#a6ad15db0e0e3acd699ac823d5a4c9ef3">More...</a><br/></td></tr>
<tr class="separator:a6ad15db0e0e3acd699ac823d5a4c9ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2605817b36df44cc52bb08c5a4a6ef9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aa2605817b36df44cc52bb08c5a4a6ef9">reflectors</a> () const </td></tr>
<tr class="memdesc:aa2605817b36df44cc52bb08c5a4a6ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of reflector boundary components of the base orbifold.  <a href="#aa2605817b36df44cc52bb08c5a4a6ef9">More...</a><br/></td></tr>
<tr class="separator:aa2605817b36df44cc52bb08c5a4a6ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d274c83fa1e9f64e61ab345a13c059"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ad5d274c83fa1e9f64e61ab345a13c059">reflectors</a> (bool twisted) const </td></tr>
<tr class="memdesc:ad5d274c83fa1e9f64e61ab345a13c059"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of reflector boundary components of the given type in the base orbifold.  <a href="#ad5d274c83fa1e9f64e61ab345a13c059">More...</a><br/></td></tr>
<tr class="separator:ad5d274c83fa1e9f64e61ab345a13c059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60b05358790c5dfce67cd155a9320f6"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ab60b05358790c5dfce67cd155a9320f6">fibreCount</a> () const </td></tr>
<tr class="memdesc:ab60b05358790c5dfce67cd155a9320f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of exceptional fibres in this Seifert fibred space.  <a href="#ab60b05358790c5dfce67cd155a9320f6">More...</a><br/></td></tr>
<tr class="separator:ab60b05358790c5dfce67cd155a9320f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8844e068c18f5960e28279588ce73007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a8844e068c18f5960e28279588ce73007">fibre</a> (unsigned long which) const </td></tr>
<tr class="memdesc:a8844e068c18f5960e28279588ce73007"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested exceptional fibre.  <a href="#a8844e068c18f5960e28279588ce73007">More...</a><br/></td></tr>
<tr class="separator:a8844e068c18f5960e28279588ce73007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1f2b59dcae38aae0978722f5fb70f7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a0b1f2b59dcae38aae0978722f5fb70f7">obstruction</a> () const </td></tr>
<tr class="memdesc:a0b1f2b59dcae38aae0978722f5fb70f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the obstruction constant <em>b</em> for this Seifert fibred space.  <a href="#a0b1f2b59dcae38aae0978722f5fb70f7">More...</a><br/></td></tr>
<tr class="separator:a0b1f2b59dcae38aae0978722f5fb70f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6811f7faaddfc8024244ad326a8b2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#adb6811f7faaddfc8024244ad326a8b2f">addHandle</a> (bool <a class="el" href="classregina_1_1SFSpace.html#a216b158dd60788f8a67cdc264d9b4915">fibreReversing</a>=false)</td></tr>
<tr class="memdesc:adb6811f7faaddfc8024244ad326a8b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new handle into the base orbifold.  <a href="#adb6811f7faaddfc8024244ad326a8b2f">More...</a><br/></td></tr>
<tr class="separator:adb6811f7faaddfc8024244ad326a8b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd42f80225f7c7e0c2af0933baeb338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a9dd42f80225f7c7e0c2af0933baeb338">addCrosscap</a> (bool <a class="el" href="classregina_1_1SFSpace.html#a216b158dd60788f8a67cdc264d9b4915">fibreReversing</a>=false)</td></tr>
<tr class="memdesc:a9dd42f80225f7c7e0c2af0933baeb338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new crosscap into the base orbifold.  <a href="#a9dd42f80225f7c7e0c2af0933baeb338">More...</a><br/></td></tr>
<tr class="separator:a9dd42f80225f7c7e0c2af0933baeb338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b831e36639d0182ce5fc4f89b9a218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a77b831e36639d0182ce5fc4f89b9a218">addPuncture</a> (bool twisted=false, unsigned long nPunctures=1)</td></tr>
<tr class="memdesc:a77b831e36639d0182ce5fc4f89b9a218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts one or more new punctures into the base orbifold.  <a href="#a77b831e36639d0182ce5fc4f89b9a218">More...</a><br/></td></tr>
<tr class="separator:a77b831e36639d0182ce5fc4f89b9a218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaef6a5a9f7187c315817b222e6cf28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#affaef6a5a9f7187c315817b222e6cf28">addReflector</a> (bool twisted=false, unsigned long nReflectors=1)</td></tr>
<tr class="memdesc:affaef6a5a9f7187c315817b222e6cf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one or more new reflector boundary components to the base orbifold.  <a href="#affaef6a5a9f7187c315817b222e6cf28">More...</a><br/></td></tr>
<tr class="separator:affaef6a5a9f7187c315817b222e6cf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cabfe8efaeb3c370e74abf2f50a09be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a9cabfe8efaeb3c370e74abf2f50a09be">insertFibre</a> (const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;<a class="el" href="classregina_1_1SFSpace.html#a8844e068c18f5960e28279588ce73007">fibre</a>)</td></tr>
<tr class="memdesc:a9cabfe8efaeb3c370e74abf2f50a09be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given fibre to this Seifert fibred space.  <a href="#a9cabfe8efaeb3c370e74abf2f50a09be">More...</a><br/></td></tr>
<tr class="separator:a9cabfe8efaeb3c370e74abf2f50a09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35622fc87c75f221bff99ce9ad5db238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a35622fc87c75f221bff99ce9ad5db238">insertFibre</a> (long alpha, long beta)</td></tr>
<tr class="memdesc:a35622fc87c75f221bff99ce9ad5db238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given fibre to this Seifert fibred space.  <a href="#a35622fc87c75f221bff99ce9ad5db238">More...</a><br/></td></tr>
<tr class="separator:a35622fc87c75f221bff99ce9ad5db238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e0759c61a8b7d8816ca10bbee42a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a070e0759c61a8b7d8816ca10bbee42a8">reflect</a> ()</td></tr>
<tr class="memdesc:a070e0759c61a8b7d8816ca10bbee42a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces this space with its mirror image.  <a href="#a070e0759c61a8b7d8816ca10bbee42a8">More...</a><br/></td></tr>
<tr class="separator:a070e0759c61a8b7d8816ca10bbee42a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699dd395b4b242cd4d6157b705f65123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a699dd395b4b242cd4d6157b705f65123">complementAllFibres</a> ()</td></tr>
<tr class="memdesc:a699dd395b4b242cd4d6157b705f65123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces each exceptional fibre of the form (<em>alpha</em>, <em>beta</em>) with a fibre of the form (<em>alpha</em>, <em>alpha</em> - <em>beta</em>).  <a href="#a699dd395b4b242cd4d6157b705f65123">More...</a><br/></td></tr>
<tr class="separator:a699dd395b4b242cd4d6157b705f65123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28f4b1aeac0b2105233f4293509c492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ab28f4b1aeac0b2105233f4293509c492">reduce</a> (bool mayReflect=true)</td></tr>
<tr class="memdesc:ab28f4b1aeac0b2105233f4293509c492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the parameters of this Seifert fibred space to a simpler form if possible, without changing the underlying fibration.  <a href="#ab28f4b1aeac0b2105233f4293509c492">More...</a><br/></td></tr>
<tr class="separator:ab28f4b1aeac0b2105233f4293509c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66857a5ee5da45a49ff992efc3d08f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1LensSpace.html">LensSpace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a66857a5ee5da45a49ff992efc3d08f5f">isLensSpace</a> () const </td></tr>
<tr class="memdesc:a66857a5ee5da45a49ff992efc3d08f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this Seifert fibred space is a Lens space.  <a href="#a66857a5ee5da45a49ff992efc3d08f5f">More...</a><br/></td></tr>
<tr class="separator:a66857a5ee5da45a49ff992efc3d08f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade660dec9aa0160b1698fc1febfdcaaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ade660dec9aa0160b1698fc1febfdcaaa">operator==</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const </td></tr>
<tr class="memdesc:ade660dec9aa0160b1698fc1febfdcaaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure contain precisely the same representations of precisely the same Seifert fibred spaces.  <a href="#ade660dec9aa0160b1698fc1febfdcaaa">More...</a><br/></td></tr>
<tr class="separator:ade660dec9aa0160b1698fc1febfdcaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab762c648927d9f11a575a54cab53ae74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#ab762c648927d9f11a575a54cab53ae74">operator!=</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const </td></tr>
<tr class="memdesc:ab762c648927d9f11a575a54cab53ae74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given structure do not contain precisely the same representations of precisely the same Seifert fibred spaces.  <a href="#ab762c648927d9f11a575a54cab53ae74">More...</a><br/></td></tr>
<tr class="separator:ab762c648927d9f11a575a54cab53ae74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa231bd15b73f58932e235e517564e032"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aa231bd15b73f58932e235e517564e032">operator&lt;</a> (const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;compare) const </td></tr>
<tr class="memdesc:aa231bd15b73f58932e235e517564e032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space.  <a href="#aa231bd15b73f58932e235e517564e032">More...</a><br/></td></tr>
<tr class="separator:aa231bd15b73f58932e235e517564e032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d5b7b50b8f677e98dced29221ee02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a92d5b7b50b8f677e98dced29221ee02b">construct</a> () const </td></tr>
<tr class="memdesc:a92d5b7b50b8f677e98dced29221ee02b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented.  <a href="#a92d5b7b50b8f677e98dced29221ee02b">More...</a><br/></td></tr>
<tr class="separator:a92d5b7b50b8f677e98dced29221ee02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee67d06a663a807cf98e47bc31596fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#aee67d06a663a807cf98e47bc31596fee">homology</a> () const </td></tr>
<tr class="memdesc:aee67d06a663a807cf98e47bc31596fee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="#aee67d06a663a807cf98e47bc31596fee">More...</a><br/></td></tr>
<tr class="separator:aee67d06a663a807cf98e47bc31596fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6928ca0b6c1b3181f68b5ca6d2eb9cce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a6928ca0b6c1b3181f68b5ca6d2eb9cce">isHyperbolic</a> () const </td></tr>
<tr class="memdesc:a6928ca0b6c1b3181f68b5ca6d2eb9cce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold.  <a href="#a6928ca0b6c1b3181f68b5ca6d2eb9cce">More...</a><br/></td></tr>
<tr class="separator:a6928ca0b6c1b3181f68b5ca6d2eb9cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965642fb379850e57502bf608c68ea5a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a965642fb379850e57502bf608c68ea5a">writeName</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a965642fb379850e57502bf608c68ea5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold as a human-readable string to the given output stream.  <a href="#a965642fb379850e57502bf608c68ea5a">More...</a><br/></td></tr>
<tr class="separator:a965642fb379850e57502bf608c68ea5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3e04f98faff83c3e40aac90fe6f8e3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a1d3e04f98faff83c3e40aac90fe6f8e3">writeTeXName</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a1d3e04f98faff83c3e40aac90fe6f8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the common name of this 3-manifold in TeX format to the given output stream.  <a href="#a1d3e04f98faff83c3e40aac90fe6f8e3">More...</a><br/></td></tr>
<tr class="separator:a1d3e04f98faff83c3e40aac90fe6f8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d51606fa9d2823f3f1d43bb587c0dfa"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SFSpace.html#a3d51606fa9d2823f3f1d43bb587c0dfa">writeStructure</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a3d51606fa9d2823f3f1d43bb587c0dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream.  <a href="#a3d51606fa9d2823f3f1d43bb587c0dfa">More...</a><br/></td></tr>
<tr class="separator:a3d51606fa9d2823f3f1d43bb587c0dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a461f3cc37f3838004879a99b2909c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a80a461f3cc37f3838004879a99b2909c">name</a> () const </td></tr>
<tr class="memdesc:a80a461f3cc37f3838004879a99b2909c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold as a human-readable string.  <a href="#a80a461f3cc37f3838004879a99b2909c">More...</a><br/></td></tr>
<tr class="separator:a80a461f3cc37f3838004879a99b2909c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fe1dfb92384caf6e6fceb40c56f1c3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#ac6fe1dfb92384caf6e6fceb40c56f1c3">TeXName</a> () const </td></tr>
<tr class="memdesc:ac6fe1dfb92384caf6e6fceb40c56f1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold in TeX format.  <a href="#ac6fe1dfb92384caf6e6fceb40c56f1c3">More...</a><br/></td></tr>
<tr class="separator:ac6fe1dfb92384caf6e6fceb40c56f1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d92ed8193a7a903735e5c7918391720"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a5d92ed8193a7a903735e5c7918391720">structure</a> () const </td></tr>
<tr class="memdesc:a5d92ed8193a7a903735e5c7918391720"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the structure of this 3-manifold that might not be evident from its common name.  <a href="#a5d92ed8193a7a903735e5c7918391720">More...</a><br/></td></tr>
<tr class="separator:a5d92ed8193a7a903735e5c7918391720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0d65481b78c982e313d11ace3913e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a8a0d65481b78c982e313d11ace3913e1">homologyH1</a> () const </td></tr>
<tr class="memdesc:a8a0d65481b78c982e313d11ace3913e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented.  <a href="#a8a0d65481b78c982e313d11ace3913e1">More...</a><br/></td></tr>
<tr class="separator:a8a0d65481b78c982e313d11ace3913e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1951cbfdfcfab303eb99ad5a290c74f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a1951cbfdfcfab303eb99ad5a290c74f2">operator&lt;</a> (const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;compare) const </td></tr>
<tr class="memdesc:a1951cbfdfcfab303eb99ad5a290c74f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines in a fairly ad-hoc fashion whether this representation of this 3-manifold is "smaller" than the given representation of the given 3-manifold.  <a href="#a1951cbfdfcfab303eb99ad5a290c74f2">More...</a><br/></td></tr>
<tr class="separator:a1951cbfdfcfab303eb99ad5a290c74f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f686b6319f41fcb86951f0efa63279f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a7f686b6319f41fcb86951f0efa63279f">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a7f686b6319f41fcb86951f0efa63279f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a7f686b6319f41fcb86951f0efa63279f">More...</a><br/></td></tr>
<tr class="separator:a7f686b6319f41fcb86951f0efa63279f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ccdb452aa029228e0b9e496d29a9144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Manifold.html#a7ccdb452aa029228e0b9e496d29a9144">writeTextLong</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a7ccdb452aa029228e0b9e496d29a9144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a7ccdb452aa029228e0b9e496d29a9144">More...</a><br/></td></tr>
<tr class="separator:a7ccdb452aa029228e0b9e496d29a9144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a general Seifert fibred space, which may be orientable or non-orientable. </p>
<p>Punctures and reflector boundaries in the base orbifold are supported.</p>
<p>A Seifert fibred space whose base orbifold has no punctures or reflector boundaries can be placed into one of the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code> and <code>n4</code>, as detailed on page 88 of "Seifert Manifolds", Peter Orlik, Springer-Verlag, 1972. These classes describe whether this base surface is orientable, as well as how many of its generators give fibre-reversing paths in the 3-manifold.</p>
<p>In the case where the base orbifold has punctures and/or reflector boundaries, we use the five simplified classes <code>bo1</code>, <code>bo2</code>, <code>bn1</code>, <code>bn2</code> and <code>bn3</code>. These classes are not standard terminology (i.e., they have been created explicitly for Regina), and generally they do not provide enough information to uniquely identify the 3-manifold. They do however identify whether or not the base orbifold is orientable, and whether or not it contains any fibre-reversing paths.</p>
<p>When describing punctures and reflector boundaries, a <em>twisted</em> boundary is one that gives a fibre-reversing path, and an <em>untwisted</em> boundary is one around which the direction of fibres is preserved.</p>
<p>Exceptional fibres are sorted first by <em>alpha</em> (the index) and then by <em>beta</em>. The obstruction constant <em>b</em> is stored separately, though in output routines such as <a class="el" href="classregina_1_1Manifold.html#a80a461f3cc37f3838004879a99b2909c" title="Returns the common name of this 3-manifold as a human-readable string.">name()</a> and <a class="el" href="classregina_1_1Manifold.html#a5d92ed8193a7a903735e5c7918391720" title="Returns details of the structure of this 3-manifold that might not be evident from its common name...">structure()</a> it is merged in with the exceptional fibres. Specifically, it is merged in with the <em>beta</em> of the final exceptional fibre (replacing it with <code>beta + b.alpha</code>), or if there are no exceptional fibres then it is presented as a single (1,b) fibre.</p>
<p>The <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a> routines <a class="el" href="classregina_1_1SFSpace.html#aee67d06a663a807cf98e47bc31596fee" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homology()</a> and <a class="el" href="classregina_1_1SFSpace.html#a92d5b7b50b8f677e98dced29221ee02b" title="Returns a triangulation of this 3-manifold, if such a construction has been implemented.">construct()</a> are only implemented in some cases. The <a class="el" href="classregina_1_1SFSpace.html#aee67d06a663a807cf98e47bc31596fee" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homology()</a> routine is implemented if and only if the base orbifold has no punctures. The <a class="el" href="classregina_1_1SFSpace.html#a92d5b7b50b8f677e98dced29221ee02b" title="Returns a triangulation of this 3-manifold, if such a construction has been implemented.">construct()</a> routine is implemented only for lens spaces and Seifert fibred spaces over the 2-sphere without punctures or reflector boundaries.</p>
<dl class="section warning"><dt>Warning</dt><dd>In Regina 4.2.1 and earlier, this class was named NSFS. As of Regina 4.3, this class was renamed due to significant changes of behaviour (it became more general, and also now keeps the obstruction parameter <em>b</em> separate). Code that was written to work with the old NSFS class should be looked at closely before being adapted to the new <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class (i.e., it may require more than just substituting class names).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd><p class="startdd"><em>Feature (long-term):</em> Implement recognition of more common names. </p>
<p class="enddd"><em>Feature (long-term):</em> Implement triangulation construction and homology calculation for more Seifert fibred spaces. </p>
</dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451">regina::SFSpace::classType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code>, <code>n4</code> for base orbifolds without boundaries, plus five classes <code>bo1</code>, <code>b02</code>, <code>bn1</code>, <code>bn2</code>, <code>bn3</code> for base orbifolds with boundaries. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451aee6551a605ca5c2257265ae389a8ad49"></a>o1</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold is orientable with no punctures or reflector boundaries, and that none of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a5d35a6be3a142c543fec1e3e53d362a6"></a>o2</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold is orientable with no punctures or reflector boundaries, and that all of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a20296b965f715f5c8d705ba59e39c408"></a>n1</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, and that none of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a2ff57c6837334c6b20769ca49b0db5c1"></a>n2</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, and that all of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451aac79eded7f2f568c7f1f8bc461c99c40"></a>n3</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, that it has non-orientable genus at least two, and that precisely one of its generators gives a fibre-reversing path. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a0407c4c93466e1b07016a53b14674384"></a>n4</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold is non-orientable with no punctures or reflector boundaries, that it has non-orientable genus at least three, and that precisely two of its generators give fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a1654d3e2dace8737bec604781355ecfc"></a>bo1</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is orientable, and that it contains no fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a663bb34f4339e3041e80cfb67be260e1"></a>bo2</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is orientable, and that it contains at least one fibre-reversing path. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a58c4517e4b1116a250580b8d72c1acd0"></a>bn1</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, and that it contains no fibre-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a5f6b58c0ede57bcfdaced07f2e9415e4"></a>bn2</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, and that its fibre-reversing paths correspond precisely to its orientation-reversing paths. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a8ca6dbe82be7c2f77c480e5ad720f451a4e6ff4256bd817e0cf2f0bb0c61a97e9"></a>bn3</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the base orbifold contains punctures and/or reflector boundaries, that it is non-orientable, that it contains at least one fibre-reversing path, and that its fibre-reversing paths do not correspond precisely to its orientation-reversing paths. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a577f3044abc53a580a0bf8e7c2c072d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space with base orbifold the 2-sphere and no exceptional fibres. </p>

</div>
</div>
<a class="anchor" id="a9fad6e2b785d4a98f21cdfba570992f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451">SFSpace::classType</a>&#160;</td>
          <td class="paramname"><em>useClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>genus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>punctures</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>puncturesTwisted</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>reflectors</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>reflectorsTwisted</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space of the given class with the given base orbifold and no exceptional fibres. </p>
<dl class="section pre"><dt>Precondition</dt><dd>If there are no punctures or reflector boundary components, then <em>useClass</em> is one of the six classes <code>o1</code>, <code>o2</code>, <code>n1</code>, <code>n2</code>, <code>n3</code> or <code>n4</code>. Likewise, if there are punctures and/or reflector boundary components, then <em>useClass</em> is one of the five classes <code>bo1</code>, <code>bo2</code>, <code>bn1</code>, <code>bn2</code> or <code>bn3</code>. </dd>
<dd>
If there are any twisted punctures or reflector boundary components, then <em>useClass</em> is either <code>bo2</code> or <code>bn3</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">useClass</td><td>indicates whether the base orbifold is closed and/or orientable, and gives information about fibre-reversing paths in the 3-manifold. See the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes and the classType enumeration notes for details. </td></tr>
    <tr><td class="paramname">genus</td><td>the genus of the base orbifold (the number of tori or projective planes that it contains). Note that for non-orientable base surfaces, this is the non-orientable genus. </td></tr>
    <tr><td class="paramname">punctures</td><td>the number of untwisted ordinary boundary components of the base orbifold. Here "ordinary" means that the puncture gives rise to a real 3-manifold boundary (i.e., this is not a reflector boundary of the base orbifold). </td></tr>
    <tr><td class="paramname">puncturesTwisted</td><td>the number of twisted ordinary boundary components of the base orbifold. Here "ordinary" means that the puncture gives rise to a real 3-manifold boundary (i.e., this is not a reflector boundary of the base orbifold). </td></tr>
    <tr><td class="paramname">reflectors</td><td>the number of untwisted reflector boundary components of the base orbifold. These are in addition to the ordinary boundary components described by <em>punctures</em>. </td></tr>
    <tr><td class="paramname">reflectorsTwisted</td><td>the number of twisted reflector boundary components of the base orbifold. These are in addition to the ordinary boundary components described by <em>puncturesTwisted</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c8f297d09fd4dec0bf321fd97b618e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::SFSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new Seifert fibred space that is a clone of the given space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the Seifert fibred space to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dc6b7476178bdec9fd20d809c6f3fa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SFSpace::~SFSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this Seifert fibred space. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9dd42f80225f7c7e0c2af0933baeb338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addCrosscap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fibreReversing</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new crosscap into the base orbifold. </p>
<p>This makes the base orbifold non-orientable, and increases its non-orientable genus by one. It is equivalent to removing a disc from the base orbifold and replacing it with a Mobius band.</p>
<p>Note that this operation may alter which of the classes described by classType this space belongs to.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibreReversing</td><td><code>true</code> if the generator of the new crosscap should give a fibre-reversing curve in the overall 3-manifold, or <code>false</code> (the default) if it should preserve the directions of the fibres. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb6811f7faaddfc8024244ad326a8b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addHandle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fibreReversing</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new handle into the base orbifold. </p>
<p>This increases the orientable genus of the base orbifold by one, or the non-orientable genus by two. It is equivalent to removing a disc from the base orbifold and replacing it with a punctured torus.</p>
<p>Note that this operation may alter which of the classes described by classType this space belongs to.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibreReversing</td><td><code>true</code> if one or both generators of the new handle should give fibre-reversing curves in the overall 3-manifold, or <code>false</code> (the default) if both generators should preserve the directions of the fibres. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77b831e36639d0182ce5fc4f89b9a218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addPuncture </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nPunctures</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts one or more new punctures into the base orbifold. </p>
<p>The punctures may be twisted or untwisted.</p>
<p>Each puncture insertion is equivalent to removing a disc from the base orbifold. In the untwisted case this results in a new torus boundary for the 3-manifold, and in the twisted case it results in a new Klein bottle boundary.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new punctures should be twisted (i.e., their boundaries should be fibre-reversing), or <code>false</code> if the new punctures should be untwisted. </td></tr>
    <tr><td class="paramname">nPunctures</td><td>the number of new punctures to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="affaef6a5a9f7187c315817b222e6cf28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::addReflector </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>nReflectors</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one or more new reflector boundary components to the base orbifold. </p>
<p>The new reflector boundaries may be twisted or untwisted.</p>
<p>Each addition of a reflector boundary component is equivalent to removing a disc from the base orbifold and replacing it with an annulus with one reflector boundary.</p>
<p>In the untwisted case, it has the effect of removing a trivially fibred solid torus from the overall 3-manifold and replacing it with an appropriately fibred twisted I-bundle over the torus.</p>
<p>The exceptional fibres and the obstruction constant <em>b</em> are not modified by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if the new reflector boundaries should be twisted (i.e., the boundaries should be fibre-reversing), or <code>false</code> if the new reflector boundaries should be untwisted. </td></tr>
    <tr><td class="paramname">nReflectors</td><td>the number of new reflector boundaries to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6d9de8721fa3c4d11a1bdb27ded9112"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SFSpace.html#a8ca6dbe82be7c2f77c480e5ad720f451">SFSpace::classType</a> regina::SFSpace::baseClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which of the eleven predefined classes this space belongs to. </p>
<p>The specific class indicates whether the base orbifold has punctures and/or reflector boundaries, whether the base orbifold is orientable, and gives information on fibre-reversing paths.</p>
<p>The class can be (indirectly) modified by calling <a class="el" href="classregina_1_1SFSpace.html#adb6811f7faaddfc8024244ad326a8b2f" title="Inserts a new handle into the base orbifold.">addHandle()</a>, <a class="el" href="classregina_1_1SFSpace.html#a9dd42f80225f7c7e0c2af0933baeb338" title="Inserts a new crosscap into the base orbifold.">addCrosscap()</a>, <a class="el" href="classregina_1_1SFSpace.html#a77b831e36639d0182ce5fc4f89b9a218" title="Inserts one or more new punctures into the base orbifold.">addPuncture()</a> or <a class="el" href="classregina_1_1SFSpace.html#affaef6a5a9f7187c315817b222e6cf28" title="Adds one or more new reflector boundary components to the base orbifold.">addReflector()</a>.</p>
<p>For more information on the eleven predefined classes, see the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes or the classType enumeration notes.</p>
<dl class="section return"><dt>Returns</dt><dd>the particular class to which this space belongs. </dd></dl>

</div>
</div>
<a class="anchor" id="a0819bae105bba1bf15a17db1a6adce8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::baseGenus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the genus of the base orbifold. </p>
<p>All punctures and reflector boundaries in the base orbifold are ignored (i.e., they are treated as though they had been replaced with ordinary filled discs).</p>
<p>The genus is the number of tori or projective planes that the base surface is formed from. In particular, if the base surface is non-orientable then this is the non-orientable genus.</p>
<dl class="section return"><dt>Returns</dt><dd>the genus of the base orbifold. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f9b60a3b4f6689247ee107124d9b5d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::baseOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not the base surface is orientable. </p>
<p>Reflector boundary components of the base orbifold are not considered here.</p>
<p>The orientability of the base surface can be (indirectly) modified by calling <a class="el" href="classregina_1_1SFSpace.html#a9dd42f80225f7c7e0c2af0933baeb338" title="Inserts a new crosscap into the base orbifold.">addCrosscap()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the base surface is orientable. </dd></dl>

</div>
</div>
<a class="anchor" id="a699dd395b4b242cd4d6157b705f65123"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::complementAllFibres </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces each exceptional fibre of the form (<em>alpha</em>, <em>beta</em>) with a fibre of the form (<em>alpha</em>, <em>alpha</em> - <em>beta</em>). </p>
<p>The obstruction constant <em>b</em> is not touched. </p>

</div>
</div>
<a class="anchor" id="a92d5b7b50b8f677e98dced29221ee02b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::SFSpace::construct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of this 3-manifold, if such a construction has been implemented. </p>
<p>If no construction routine has yet been implemented for this 3-manifold (for instance, if this 3-manifold is a Seifert fibred space with sufficiently many exceptional fibres) then this routine will return 0.</p>
<p>The details of which 3-manifolds have construction routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this 3-manifold, or 0 if the appropriate construction routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1Manifold.html#a98be6808ba14b0da4fda2979a48162d1">regina::Manifold</a>.</p>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8844e068c18f5960e28279588ce73007"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> regina::SFSpace::fibre </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested exceptional fibre. </p>
<p>Fibres are stored in sorted order by <em>alpha</em> (the index) and then by <em>beta</em>. See the <a class="el" href="classregina_1_1SFSpace.html" title="Represents a general Seifert fibred space, which may be orientable or non-orientable.">SFSpace</a> class notes for details.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine takes linear time (specifically, linear in the argument <em>which</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>determines which fibre to return; this must be between 0 and getFibreCount()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested fibre. </dd></dl>

</div>
</div>
<a class="anchor" id="ab60b05358790c5dfce67cd155a9320f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::fibreCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of exceptional fibres in this Seifert fibred space. </p>
<p>Note that the obstruction parameter <em>b</em> is not included in this count. That is, any (1,k) fibres are ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of exceptional fibres. </dd></dl>

</div>
</div>
<a class="anchor" id="aad0340f7f57b3cef1646f51b221d3002"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::fibreNegating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not we can negate an exceptional fibre by passing it around the interior of the base orbifold. </p>
<p>That is, this routine determines whether a (<em>p</em>, <em>q</em>) exceptional fibre can become a (<em>p</em>, -<em>q</em>) exceptional fibre simply by sliding it around.</p>
<p>This is possible if either</p>
<ul>
<li>the base orbifold has an orientation-reversing loop that does not reverse fibres in the 3-manifold, or</li>
<li>the base orbifold has an orientation-preserving loop that does reverse fibres in the 3-manifold.</li>
</ul>
<p>Note that reflector boundary components, whilst making the overall 3-manifold non-orientable, have no bearing on the outcome of this routine.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only an exceptional fibre can be reflected as described above. </dd></dl>

</div>
</div>
<a class="anchor" id="a216b158dd60788f8a67cdc264d9b4915"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::fibreReversing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this space contains any fibre-reversing paths. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if a fibre-reversing path exists. </dd></dl>

</div>
</div>
<a class="anchor" id="aee67d06a663a807cf98e47bc31596fee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>* regina::SFSpace::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="classregina_1_1Manifold.html#a8a0d65481b78c982e313d11ace3913e1" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1Manifold.html#a7416ad3572fd30afc49402a7f11b8285">regina::Manifold</a>.</p>

</div>
</div>
<a class="anchor" id="a8a0d65481b78c982e313d11ace3913e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> * regina::Manifold::homologyH1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this 3-manifold, if such a routine has been implemented. </p>
<p>If the calculation of homology has not yet been implemented for this 3-manifold then this routine will return 0.</p>
<p>The details of which 3-manifolds have homology calculation routines can be found in the notes for the corresponding subclasses of <a class="el" href="classregina_1_1Manifold.html" title="Represents a particular 3-manifold.">Manifold</a>. The default implemention of this routine returns 0.</p>
<p>The homology group will be newly allocated and must be destroyed by the caller of this routine.</p>
<p>This routine can also be accessed via the alias <a class="el" href="classregina_1_1Manifold.html#a7416ad3572fd30afc49402a7f11b8285" title="Returns the first homology group of this 3-manifold, if such a routine has been implemented.">homology()</a> (a name that is less specific, but a little easier to type).</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group of this 3-manifold, or 0 if the appropriate calculation routine has not yet been implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="a9cabfe8efaeb3c370e74abf2f50a09be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::insertFibre </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1SFSFibre.html">SFSFibre</a> &amp;&#160;</td>
          <td class="paramname"><em>fibre</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given fibre to this Seifert fibred space. </p>
<p>This may be an exceptional fibre (<em>alpha</em> &gt; 1) or it may be a regular fibre (<em>alpha</em> = 1). If it is a regular fibre, the obstruction constant <em>b</em> will be adjusted according to the value of <em>beta</em>.</p>
<p>Note that there is no restriction on the range of the second parameter <em>beta</em>. If it is out of the usual range 0 &lt;= <em>beta</em> &lt; <em>alpha</em>, it will be pulled back into this range and the excess will be pushed into the obstruction constant <em>b</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fibre</td><td>the fibre to insert. The first parameter of this fibre (i.e., its index) must be strictly positive, and the two parameters of this fibre must be coprime. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35622fc87c75f221bff99ce9ad5db238"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::insertFibre </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given fibre to this Seifert fibred space. </p>
<p>This may be an exceptional fibre (<em>alpha</em> &gt; 1) or it may be a regular fibre (<em>alpha</em> = 1). If it is a regular fibre, the obstruction constant <em>b</em> will be adjusted according to the value of <em>beta</em>.</p>
<p>Note that there is no restriction on the range of the second parameter <em>beta</em>. If it is out of the usual range 0 &lt;= <em>beta</em> &lt; <em>alpha</em>, it will be pulled back into this range and the excess will be pushed into the obstruction constant <em>b</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alpha</td><td>the first parameter (i.e., the index) of the fibre to insert; this must be strictly positive. </td></tr>
    <tr><td class="paramname">beta</td><td>the second parameter of the fibre to insert; this must have no common factors with the first parameter <em>alpha</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6928ca0b6c1b3181f68b5ca6d2eb9cce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::isHyperbolic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this is a finite-volume hyperbolic manifold. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is a finite-volume hyperbolic manifold, or <code>false</code> if not. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Manifold.html#a8ae723ffbf9ca421caeac7e990765f5a">regina::Manifold</a>.</p>

</div>
</div>
<a class="anchor" id="a66857a5ee5da45a49ff992efc3d08f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LensSpace.html">LensSpace</a>* regina::SFSpace::isLensSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this Seifert fibred space is a Lens space. </p>
<p>If this is a Lens space, the <a class="el" href="classregina_1_1LensSpace.html" title="Represents a general lens space.">LensSpace</a> returned will be newly created and it will be up to the caller of this routine to destroy it.</p>
<dl class="section return"><dt>Returns</dt><dd>a structure containing the details of this Lens space, or <code>null</code> if this is not a Lens space. </dd></dl>

</div>
</div>
<a class="anchor" id="a80a461f3cc37f3838004879a99b2909c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold as a human-readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>the common name of this 3-manifold. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b1f2b59dcae38aae0978722f5fb70f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::SFSpace::obstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the obstruction constant <em>b</em> for this Seifert fibred space. </p>
<p>The obstruction constant corresponds to the insertion of an additional (1,<em>b</em>) fibre. It can be modified by calling <a class="el" href="classregina_1_1SFSpace.html#a9cabfe8efaeb3c370e74abf2f50a09be" title="Adds the given fibre to this Seifert fibred space.">insertFibre()</a> with a value of <em>alpha</em> = 1. It will also be modified whenever <a class="el" href="classregina_1_1SFSpace.html#a9cabfe8efaeb3c370e74abf2f50a09be" title="Adds the given fibre to this Seifert fibred space.">insertFibre()</a> is called with <em>beta</em> out of range (<em>beta</em> &lt; 0 or <em>beta</em> &gt;= <em>alpha</em>), since each exceptional fibre must be stored in standard form (0 &lt;= <em>beta</em> &lt; <em>alpha</em>).</p>
<dl class="section return"><dt>Returns</dt><dd>the obstruction constant <em>b</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab762c648927d9f11a575a54cab53ae74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given structure do not contain precisely the same representations of precisely the same Seifert fibred spaces. </p>
<p>Note that this routine examines the particular representation of the Seifert fibred space. Different Seifert parameters that give the same 3-manifold will be regarded as different by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given Seifert fibred space representations are different. </dd></dl>

</div>
</div>
<a class="anchor" id="a1951cbfdfcfab303eb99ad5a290c74f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Manifold::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Manifold.html">Manifold</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this 3-manifold is "smaller" than the given representation of the given 3-manifold. </p>
<p>The ordering imposed on 3-manifolds is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<p>The ordering also depends on the particular representation of the 3-manifold that is used. As an example, different representations of the same Seifert fibred space might well be ordered differently.</p>
<p>All that this routine really offers is a well-defined way of ordering 3-manifold representations.</p>
<dl class="section warning"><dt>Warning</dt><dd>Currently this routine is only implemented in full for closed 3-manifolds. For most classes of bounded 3-manifolds, this routine simply compares the strings returned by <a class="el" href="classregina_1_1Manifold.html#a80a461f3cc37f3838004879a99b2909c" title="Returns the common name of this 3-manifold as a human-readable string.">name()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the 3-manifold representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given 3-manifold representation. </dd></dl>

</div>
</div>
<a class="anchor" id="aa231bd15b73f58932e235e517564e032"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines in a fairly ad-hoc fashion whether this representation of this space is "smaller" than the given representation of the given space. </p>
<p>The ordering imposed on Seifert fibred space representations is purely aesthetic on the part of the author, and is subject to change in future versions of Regina. It also depends upon the particular representation, so that different representations of the same space may be ordered differently.</p>
<p>All that this routine really offers is a well-defined way of ordering Seifert fibred space representations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is "smaller" than the given Seifert fibred space representation. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f450fd4f6f3022e04bba6338b3122c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies this Seifert fibred space to be a clone of the given space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the Seifert fibred space to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade660dec9aa0160b1698fc1febfdcaaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SFSpace::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SFSpace.html">SFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given structure contain precisely the same representations of precisely the same Seifert fibred spaces. </p>
<p>Note that this routine examines the particular representation of the Seifert fibred space. Different Seifert parameters that give the same 3-manifold will be regarded as not equal by this routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the representation with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given Seifert fibred space representations are identical. </dd></dl>

</div>
</div>
<a class="anchor" id="ab54dda9d07b66c035f01e4a1e55a3c41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::punctures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of punctures in the base orbifold. </p>
<p>In other words, this routine returns the total number of real torus or Klein bottle boundary components in the overall 3-manifold.</p>
<p>Note that reflector boundaries on the base orbifold are <em>not</em> counted here; only the ordinary boundary components that give rise to real 3-manifold boundaries are included.</p>
<p>Both untwisted and twisted punctures (giving rise to torus and Klein bottle boundaries respectively in the 3-manifold) are counted by this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of punctures. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ad15db0e0e3acd699ac823d5a4c9ef3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::punctures </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of punctures of the given type in the base orbifold. </p>
<p>In other words, this routine returns the number of real boundary components of the given type in the overall 3-manifold.</p>
<p>This routine either counts only twisted punctures (which give rise to Klein bottle boundaries), or only untwisted punctures (which give rise to torus boundaries).</p>
<p>Either way, reflector boundaries on the base orbifold are <em>not</em> counted here; only ordinary boundary components that give rise to real 3-manifold boundaries are considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if only twisted punctures should be counted (those that give fibre-reversing paths and Klein bottle boundaries), or <code>false</code> if only untwisted punctures should be counted (those that are fibre-preserving and give torus boundaries). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of punctures of the given type. </dd></dl>

</div>
</div>
<a class="anchor" id="ab28f4b1aeac0b2105233f4293509c492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::reduce </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mayReflect</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reduces the parameters of this Seifert fibred space to a simpler form if possible, without changing the underlying fibration. </p>
<p>In some cases the parameters of the Seifert fibred space may be simplified by taking a mirror image of the entire 3-manifold. The argument <em>mayReflect</em> signifies whether this is allowed.</p>
<p>This routine will not change the curves made by the fibres and the base orbifold on any boundary components (i.e., boundaries caused by punctures in the base orbifold).</p>
<dl class="section warning"><dt>Warning</dt><dd>If <em>mayReflect</em> is <code>true</code> then the entire 3-manifold might be replaced with its mirror image, in which case any subsequent modifications (such as inserting additional fibres or altering the base orbifold) may give unexpected results.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mayReflect</td><td><code>true</code> if we are allowed to take a mirror image of the entire 3-manifold, or <code>false</code> if we are not. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a070e0759c61a8b7d8816ca10bbee42a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SFSpace::reflect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces this space with its mirror image. </p>
<p>Specifically, all exceptional fibres and the obstruction constant <em>b</em> will be negated. Note that the obstruction constant will generally undergo further change as the exceptional fibres are standardised into the usual 0 &lt;= <em>beta</em> &lt; <em>alpha</em> form.</p>
<p>This routine will not change the curves made by the fibres and the base orbifold on any boundary components (i.e., boundaries caused by punctures in the base orbifold), with the exception that each base curve will be reflected.</p>
<dl class="section warning"><dt>Warning</dt><dd>The space is <em>not</em> reduced after reflecting. It may be that the space can be further simplified (especially in the case of non-orientable manifolds). </dd></dl>

</div>
</div>
<a class="anchor" id="aa2605817b36df44cc52bb08c5a4a6ef9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::reflectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of reflector boundary components of the base orbifold. </p>
<p>This includes both twisted and untwisted reflector boundaries.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of reflector boundary components. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5d274c83fa1e9f64e61ab345a13c059"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::SFSpace::reflectors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>twisted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of reflector boundary components of the given type in the base orbifold. </p>
<p>This either counts only twisted reflector boundaries, or only untwisted reflector boundaries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">twisted</td><td><code>true</code> if only twisted reflector boundaries should be counted (those that give fibre-reversing paths), or <code>false</code> if only untwisted reflector boundaries should be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of reflector boundaries of the given type. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d92ed8193a7a903735e5c7918391720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::structure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the structure of this 3-manifold that might not be evident from its common name. </p>
<p>For instance, for an orbit space S^3/G this routine might return the full Seifert structure.</p>
<p>This routine may return the empty string if no additional details are deemed necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>a string describing additional structural details. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6fe1dfb92384caf6e6fceb40c56f1c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Manifold::TeXName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the common name of this 3-manifold in TeX format. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the common name of this 3-manifold in TeX format. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Manifold.html">Manifold</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a965642fb379850e57502bf608c68ea5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold as a human-readable string to the given output stream. </p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Manifold.html#a8a0411f3eb6409674e448dfe4a6b682f">regina::Manifold</a>.</p>

</div>
</div>
<a class="anchor" id="a3d51606fa9d2823f3f1d43bb587c0dfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeStructure </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes details of the structure of this 3-manifold that might not be evident from its common name to the given output stream. </p>
<p>For instance, for an orbit space S^3/G this routine might write the full Seifert structure.</p>
<p>This routine may write nothing if no additional details are deemed necessary. The default implementation of this routine behaves in this way.</p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1Manifold.html#acaa0ea6b89be84220e30a9c87072a1fe">regina::Manifold</a>.</p>

</div>
</div>
<a class="anchor" id="a1d3e04f98faff83c3e40aac90fe6f8e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::SFSpace::writeTeXName </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the common name of this 3-manifold in TeX format to the given output stream. </p>
<p>No leading or trailing dollar signs will be included.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed as of Regina 4.3; in earlier versions, leading and trailing dollar signs were provided.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; instead standard output will always be used. Moreover, this routine returns <code>None</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Manifold.html#a48689f189a77113323a55eb8029e3c61">regina::Manifold</a>.</p>

</div>
</div>
<a class="anchor" id="a7ccdb452aa029228e0b9e496d29a9144"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Manifold::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>Subclasses must not override this routine. They should override <a class="el" href="classregina_1_1Manifold.html#a8a0411f3eb6409674e448dfe4a6b682f" title="Writes the common name of this 3-manifold as a human-readable string to the given output stream...">writeName()</a> and <a class="el" href="classregina_1_1Manifold.html#acaa0ea6b89be84220e30a9c87072a1fe" title="Writes details of the structure of this 3-manifold that might not be evident from its common name to ...">writeStructure()</a> instead.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f686b6319f41fcb86951f0efa63279f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Manifold::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>Subclasses must not override this routine. They should override <a class="el" href="classregina_1_1Manifold.html#a8a0411f3eb6409674e448dfe4a6b682f" title="Writes the common name of this 3-manifold as a human-readable string to the given output stream...">writeName()</a> instead.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>manifold/<a class="el" href="sfs_8h.html">sfs.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
