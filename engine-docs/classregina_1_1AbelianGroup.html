<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::AbelianGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1AbelianGroup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::AbelianGroup Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a finitely generated abelian group.  
 <a href="classregina_1_1AbelianGroup.html#details">More...</a></p>

<p><code>#include &lt;algebra/abeliangroup.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::AbelianGroup:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1AbelianGroup.png" usemap="#regina::AbelianGroup_map" alt=""/>
  <map id="regina::AbelianGroup_map" name="regina::AbelianGroup_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; AbelianGroup, true &gt;" shape="rect" coords="0,56,272,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; AbelianGroup, supportsUtf8 &gt;" shape="rect" coords="0,0,272,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ad5bf25488fbf05a2f0ad0d7c3b63be59">AbelianGroup</a> ()</td></tr>
<tr class="memdesc:ad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new trivial group.  <a href="#ad5bf25488fbf05a2f0ad0d7c3b63be59">More...</a><br/></td></tr>
<tr class="separator:ad5bf25488fbf05a2f0ad0d7c3b63be59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada30347a8df5f918ed4fb4a4ac2f20a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ada30347a8df5f918ed4fb4a4ac2f20a6">AbelianGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ada30347a8df5f918ed4fb4a4ac2f20a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given group.  <a href="#ada30347a8df5f918ed4fb4a4ac2f20a6">More...</a><br/></td></tr>
<tr class="separator:ada30347a8df5f918ed4fb4a4ac2f20a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712bec823deba982b0712adabc6d4d23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a712bec823deba982b0712adabc6d4d23">AbelianGroup</a> (const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;M, const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;N)</td></tr>
<tr class="memdesc:a712bec823deba982b0712adabc6d4d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex.  <a href="#a712bec823deba982b0712adabc6d4d23">More...</a><br/></td></tr>
<tr class="separator:a712bec823deba982b0712adabc6d4d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfaa1a1a6aa834ffaa0883e37416bd6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a2bfaa1a1a6aa834ffaa0883e37416bd6">AbelianGroup</a> (const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;M, const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;N, const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;p)</td></tr>
<tr class="memdesc:a2bfaa1a1a6aa834ffaa0883e37416bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients.  <a href="#a2bfaa1a1a6aa834ffaa0883e37416bd6">More...</a><br/></td></tr>
<tr class="separator:a2bfaa1a1a6aa834ffaa0883e37416bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffd523df4ffbe34d6d38adacd4b6e7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aaffd523df4ffbe34d6d38adacd4b6e7d">addRank</a> (int extraRank=1)</td></tr>
<tr class="memdesc:aaffd523df4ffbe34d6d38adacd4b6e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the rank of the group by the given integer.  <a href="#aaffd523df4ffbe34d6d38adacd4b6e7d">More...</a><br/></td></tr>
<tr class="separator:aaffd523df4ffbe34d6d38adacd4b6e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9de8c90029f068306126465da9f7296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aa9de8c90029f068306126465da9f7296">addTorsionElement</a> (const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;degree, unsigned mult=1)</td></tr>
<tr class="memdesc:aa9de8c90029f068306126465da9f7296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given torsion element to the group.  <a href="#aa9de8c90029f068306126465da9f7296">More...</a><br/></td></tr>
<tr class="separator:aa9de8c90029f068306126465da9f7296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae926d3d6b0dce31e40c27eb475057077"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ae926d3d6b0dce31e40c27eb475057077">addTorsionElement</a> (unsigned long degree, unsigned mult=1)</td></tr>
<tr class="memdesc:ae926d3d6b0dce31e40c27eb475057077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given torsion element to the group.  <a href="#ae926d3d6b0dce31e40c27eb475057077">More...</a><br/></td></tr>
<tr class="separator:ae926d3d6b0dce31e40c27eb475057077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9f394fc848b2483e5ac93ad6e7cef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a70f9f394fc848b2483e5ac93ad6e7cef">addTorsionElements</a> (const std::multiset&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;torsion)</td></tr>
<tr class="memdesc:a70f9f394fc848b2483e5ac93ad6e7cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given set of torsion elements to this group.  <a href="#a70f9f394fc848b2483e5ac93ad6e7cef">More...</a><br/></td></tr>
<tr class="separator:a70f9f394fc848b2483e5ac93ad6e7cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e49620574efadb724e8fd07449d5e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a06e49620574efadb724e8fd07449d5e8">addGroup</a> (const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;presentation)</td></tr>
<tr class="memdesc:a06e49620574efadb724e8fd07449d5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the abelian group defined by the given presentation to this group.  <a href="#a06e49620574efadb724e8fd07449d5e8">More...</a><br/></td></tr>
<tr class="separator:a06e49620574efadb724e8fd07449d5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f258af0b04c62e2de0f61df3d710509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a3f258af0b04c62e2de0f61df3d710509">addGroup</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;group)</td></tr>
<tr class="memdesc:a3f258af0b04c62e2de0f61df3d710509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given abelian group to this group.  <a href="#a3f258af0b04c62e2de0f61df3d710509">More...</a><br/></td></tr>
<tr class="separator:a3f258af0b04c62e2de0f61df3d710509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350de40913409c4a12efa1ece1033097"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a350de40913409c4a12efa1ece1033097">rank</a> () const </td></tr>
<tr class="memdesc:a350de40913409c4a12efa1ece1033097"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group.  <a href="#a350de40913409c4a12efa1ece1033097">More...</a><br/></td></tr>
<tr class="separator:a350de40913409c4a12efa1ece1033097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03685446114b8e94498f314c3fe1458"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ad03685446114b8e94498f314c3fe1458">torsionRank</a> (const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;degree) const </td></tr>
<tr class="memdesc:ad03685446114b8e94498f314c3fe1458"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="#ad03685446114b8e94498f314c3fe1458">More...</a><br/></td></tr>
<tr class="separator:ad03685446114b8e94498f314c3fe1458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba8a24f4ed513f5ac1ea973d3341828"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a3ba8a24f4ed513f5ac1ea973d3341828">torsionRank</a> (unsigned long degree) const </td></tr>
<tr class="memdesc:a3ba8a24f4ed513f5ac1ea973d3341828"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree.  <a href="#a3ba8a24f4ed513f5ac1ea973d3341828">More...</a><br/></td></tr>
<tr class="separator:a3ba8a24f4ed513f5ac1ea973d3341828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907b487293d4f00db3aeebecd59aede0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a907b487293d4f00db3aeebecd59aede0">countInvariantFactors</a> () const </td></tr>
<tr class="memdesc:a907b487293d4f00db3aeebecd59aede0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group.  <a href="#a907b487293d4f00db3aeebecd59aede0">More...</a><br/></td></tr>
<tr class="separator:a907b487293d4f00db3aeebecd59aede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a2337fdd4c4f512bdb63057968c05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a4f5a2337fdd4c4f512bdb63057968c05">invariantFactor</a> (size_t index) const </td></tr>
<tr class="memdesc:a4f5a2337fdd4c4f512bdb63057968c05"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group.  <a href="#a4f5a2337fdd4c4f512bdb63057968c05">More...</a><br/></td></tr>
<tr class="separator:a4f5a2337fdd4c4f512bdb63057968c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a9a2aa3459af16c673737681b4cbc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#af9a9a2aa3459af16c673737681b4cbc7">isTrivial</a> () const </td></tr>
<tr class="memdesc:af9a9a2aa3459af16c673737681b4cbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the trivial (zero) group.  <a href="#af9a9a2aa3459af16c673737681b4cbc7">More...</a><br/></td></tr>
<tr class="separator:af9a9a2aa3459af16c673737681b4cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4deabd53997c113adafa4c140ba4561"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#aa4deabd53997c113adafa4c140ba4561">isZ</a> () const </td></tr>
<tr class="memdesc:aa4deabd53997c113adafa4c140ba4561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the infinite cyclic group (Z).  <a href="#aa4deabd53997c113adafa4c140ba4561">More...</a><br/></td></tr>
<tr class="separator:aa4deabd53997c113adafa4c140ba4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca4c8fa3ce986f39444ffc888429381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#acca4c8fa3ce986f39444ffc888429381">isZn</a> (unsigned long n) const </td></tr>
<tr class="memdesc:acca4c8fa3ce986f39444ffc888429381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is the non-trivial cyclic group on the given number of elements.  <a href="#acca4c8fa3ce986f39444ffc888429381">More...</a><br/></td></tr>
<tr class="separator:acca4c8fa3ce986f39444ffc888429381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce77f2b358c31a666d0afcefe9a2e66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a6ce77f2b358c31a666d0afcefe9a2e66">operator==</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const </td></tr>
<tr class="memdesc:a6ce77f2b358c31a666d0afcefe9a2e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group are isomorphic.  <a href="#a6ce77f2b358c31a666d0afcefe9a2e66">More...</a><br/></td></tr>
<tr class="separator:a6ce77f2b358c31a666d0afcefe9a2e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf769ea285f6f665c43e63673f4d093"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a2bf769ea285f6f665c43e63673f4d093">operator!=</a> (const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;other) const </td></tr>
<tr class="memdesc:a2bf769ea285f6f665c43e63673f4d093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given abelian group are non-isomorphic.  <a href="#a2bf769ea285f6f665c43e63673f4d093">More...</a><br/></td></tr>
<tr class="separator:a2bf769ea285f6f665c43e63673f4d093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39205739f100116e5fcc9a6abe01d15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ab39205739f100116e5fcc9a6abe01d15">writeXMLData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ab39205739f100116e5fcc9a6abe01d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this abelian group.  <a href="#ab39205739f100116e5fcc9a6abe01d15">More...</a><br/></td></tr>
<tr class="separator:ab39205739f100116e5fcc9a6abe01d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b00e945510c041d22ced48c1598d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a46b00e945510c041d22ced48c1598d0d">writeTextShort</a> (std::ostream &amp;out, bool <a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a>=false) const </td></tr>
<tr class="memdesc:a46b00e945510c041d22ced48c1598d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a46b00e945510c041d22ced48c1598d0d">More...</a><br/></td></tr>
<tr class="separator:a46b00e945510c041d22ced48c1598d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#afb6c9df60a4ebe89115cd80eb683cf58">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afb6c9df60a4ebe89115cd80eb683cf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="#afb6c9df60a4ebe89115cd80eb683cf58">More...</a><br/></td></tr>
<tr class="separator:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac7edb441bb51e6d540c3f803662b0cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#ac7edb441bb51e6d540c3f803662b0cab">replaceTorsion</a> (const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;matrix)</td></tr>
<tr class="memdesc:ac7edb441bb51e6d540c3f803662b0cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the torsion elements of this group with those in the abelian group represented by the given Smith normal form presentation matrix.  <a href="#ac7edb441bb51e6d540c3f803662b0cab">More...</a><br/></td></tr>
<tr class="separator:ac7edb441bb51e6d540c3f803662b0cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9bb4166ec40c17c6a042f6d0609ed4db"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a9bb4166ec40c17c6a042f6d0609ed4db">rank_</a></td></tr>
<tr class="memdesc:a9bb4166ec40c17c6a042f6d0609ed4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rank of the group (the number of Z components).  <a href="#a9bb4166ec40c17c6a042f6d0609ed4db">More...</a><br/></td></tr>
<tr class="separator:a9bb4166ec40c17c6a042f6d0609ed4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3697f3d8592b06715c111a3ab6e1096c"><td class="memItemLeft" align="right" valign="top">std::multiset&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1AbelianGroup.html#a3697f3d8592b06715c111a3ab6e1096c">invariantFactors</a></td></tr>
<tr class="memdesc:a3697f3d8592b06715c111a3ab6e1096c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.  <a href="#a3697f3d8592b06715c111a3ab6e1096c">More...</a><br/></td></tr>
<tr class="separator:a3697f3d8592b06715c111a3ab6e1096c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a finitely generated abelian group. </p>
<p>The torsion elements of the group are stored in terms of their invariant factors. For instance, Z_2+Z_3 will appear as Z_6, and Z_2+Z_2+Z_3 will appear as Z_2+Z_6.</p>
<p>In general the factors will appear as Z_<em>d0</em>+...+Z_<em>dn</em>, where the invariant factors <em>di</em> are all greater than 1 and satisfy <em>d0</em>|<em>d1</em>|...|<em>dn</em>. Note that this representation is unique.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><em>Optimise (long-term):</em> Look at using sparse matrices for storage of SNF and the like. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad5bf25488fbf05a2f0ad0d7c3b63be59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new trivial group. </p>

</div>
</div>
<a class="anchor" id="ada30347a8df5f918ed4fb4a4ac2f20a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the group to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a712bec823deba982b0712adabc6d4d23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex. </p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the `right' matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the `left' matrix in the chain complex; that is, the matrix that one takes the image of when computing homology.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<a class="anchor" id="a2bfaa1a1a6aa834ffaa0883e37416bd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::AbelianGroup::AbelianGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an abelian group as the homology of a chain complex, using mod-<em>p</em> coefficients. </p>
<dl class="section pre"><dt>Precondition</dt><dd>M.columns() = N.rows(). </dd>
<dd>
The product M*N = 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>the `right' matrix in the chain complex; that is, the matrix that one takes the kernel of when computing homology. </td></tr>
    <tr><td class="paramname">N</td><td>the `left' matrix in the chain complex; that is, the matrix that one takes the image of when computing homology. </td></tr>
    <tr><td class="paramname">p</td><td>the modulus, which may be any Integer. Zero is interpreted as a request for integer coefficents, which will give the same result as the <a class="el" href="classregina_1_1AbelianGroup.html#a712bec823deba982b0712adabc6d4d23" title="Creates an abelian group as the homology of a chain complex.">AbelianGroup(const MatrixInt&amp;, const MatrixInt&amp;)</a> constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Ryan Budney </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a06e49620574efadb724e8fd07449d5e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>presentation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the abelian group defined by the given presentation to this group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">presentation</td><td>a presentation matrix for the group to be added to this group, where each column represents a generator and each row a relation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f258af0b04c62e2de0f61df3d710509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given abelian group to this group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to add to this one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaffd523df4ffbe34d6d38adacd4b6e7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addRank </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extraRank</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the rank of the group by the given integer. </p>
<p>This integer may be positive, negative or zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The current rank plus the given integer is non-negative. In other words, if we are subtracting rank then we are not trying to subtract more rank than the group actually has.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraRank</td><td>the extra rank to add; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9de8c90029f068306126465da9f7296"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mult</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given torsion element to the group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial. If many different torsion elements are to be added, consider using <a class="el" href="classregina_1_1AbelianGroup.html#a70f9f394fc848b2483e5ac93ad6e7cef" title="Adds the given set of torsion elements to this group.">addTorsionElements()</a> instead so the invariant factors need only be calculated once.</p>
<p>In this routine we add a specified number of copies of Z_<em>d</em>, where <em>d</em> is some given degree.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2 and the given multiplicity is at least 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td><em>d</em>, where we are adding copies of <em>Z_d</em> to the torsion. </td></tr>
    <tr><td class="paramname">mult</td><td>the multiplicity <em>m</em>, where we are adding precisely <em>m</em> copies of <em>Z_d</em>; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae926d3d6b0dce31e40c27eb475057077"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElement </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mult</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given torsion element to the group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial. If many different torsion elements are to be added, consider using <a class="el" href="classregina_1_1AbelianGroup.html#a70f9f394fc848b2483e5ac93ad6e7cef" title="Adds the given set of torsion elements to this group.">addTorsionElements()</a> instead so the invariant factors need only be calculated once.</p>
<p>In this routine we add a specified number of copies of Z_<em>d</em>, where <em>d</em> is some given degree.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2 and the given multiplicity is at least 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td><em>d</em>, where we are adding copies of <em>Z_d</em> to the torsion. </td></tr>
    <tr><td class="paramname">mult</td><td>the multiplicity <em>m</em>, where we are adding precisely <em>m</em> copies of <em>Z_d</em>; this defaults to 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70f9f394fc848b2483e5ac93ad6e7cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::addTorsionElements </td>
          <td>(</td>
          <td class="paramtype">const std::multiset&lt; <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>torsion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given set of torsion elements to this group. </p>
<p>Note that this routine might be slow since calculating the new invariant factors is not trivial.</p>
<p>The torsion elements to add are described by a list of integers <em>k1</em>,...,<em>km</em>, where we are adding Z_<em>k1</em>,...,Z_<em>km</em>. Unlike invariant factors, the <em>ki</em> are not required to divide each other.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Each integer in the given list is strictly greater than 1.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>This routine takes a python list as its argument.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">torsion</td><td>a list containing the torsion elements to add, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a907b487293d4f00db3aeebecd59aede0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::AbelianGroup::countInvariantFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of invariant factors that describe the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of invariant factors. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f5a2337fdd4c4f512bdb63057968c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&amp; regina::AbelianGroup::invariantFactor </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given invariant factor describing the torsion elements of this group. </p>
<p>See the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> class notes for further details.</p>
<p>If the invariant factors are <em>d0</em>|<em>d1</em>|...|<em>dn</em>, this routine will return <em>di</em> where <em>i</em> is the value of parameter <em>index</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the invariant factor to return; this must be between 0 and <a class="el" href="classregina_1_1AbelianGroup.html#a907b487293d4f00db3aeebecd59aede0" title="Returns the number of invariant factors that describe the torsion elements of this group...">countInvariantFactors()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested invariant factor. </dd></dl>

</div>
</div>
<a class="anchor" id="af9a9a2aa3459af16c673737681b4cbc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the trivial (zero) group. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial group. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4deabd53997c113adafa4c140ba4561"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the infinite cyclic group (Z). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the infinite cyclic group. </dd></dl>

</div>
</div>
<a class="anchor" id="acca4c8fa3ce986f39444ffc888429381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::isZn </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is the non-trivial cyclic group on the given number of elements. </p>
<p>As a special case, if <em>n</em> = 0 then this routine will test for the infinite cyclic group (i.e., it will behave the same as <a class="el" href="classregina_1_1AbelianGroup.html#aa4deabd53997c113adafa4c140ba4561" title="Determines whether this is the infinite cyclic group (Z).">isZ()</a>). If <em>n</em> = 1, then this routine will test for the trivial group (i.e., it will behave the same as <a class="el" href="classregina_1_1AbelianGroup.html#af9a9a2aa3459af16c673737681b4cbc7" title="Determines whether this is the trivial (zero) group.">isTrivial()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of elements of the cyclic group in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the cyclic group Z_n. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bf769ea285f6f665c43e63673f4d093"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group are non-isomorphic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups are non-isomorphic. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ce77f2b358c31a666d0afcefe9a2e66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::AbelianGroup::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given abelian group are isomorphic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the group with which this should be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two groups are isomorphic. </dd></dl>

</div>
</div>
<a class="anchor" id="a350de40913409c4a12efa1ece1033097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of the group. </p>
<p>This is the number of included copies of <em>Z</em>.</p>
<dl class="section return"><dt>Returns</dt><dd>the rank of the group. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7edb441bb51e6d540c3f803662b0cab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::replaceTorsion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#ga2baeb9d8d3bdbbd92bbbd5537df1347c">MatrixInt</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the torsion elements of this group with those in the abelian group represented by the given Smith normal form presentation matrix. </p>
<p>Any zero columns in the matrix will also be added to the rank as additional copies of Z. Note that preexisting torsion elements will be deleted, but preexisting rank will not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix is in Smith normal form, with the diagonal consisting of a series of positive, non-decreasing integers followed by zeroes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>a matrix containing the Smith normal form presentation matrix for the new torsion elements, where each column represents a generator and each row a relation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad03685446114b8e94498f314c3fe1458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a> &amp;&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ba8a24f4ed513f5ac1ea973d3341828"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::torsionRank </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank in the group of the torsion term of given degree. </p>
<p>If the given degree is <em>d</em>, this routine will return the largest <em>m</em> for which <em>m</em>Z_<em>d</em> is a subgroup of this group.</p>
<p>For instance, if this group is Z_6+Z_12, the torsion term of degree 2 has rank 2 (one occurrence in Z_6 and one in Z_12), and the torsion term of degree 4 has rank 1 (one occurrence in Z_12).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given degree is at least 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degree</td><td>the degree of the torsion term to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank in the group of the given torsion term. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="afb6c9df60a4ebe89115cd80eb683cf58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> , supportsUtf8 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46b00e945510c041d22ced48c1598d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>The text representation will be of the form <code>3 Z + 4 Z_2 + Z_120</code>. The torsion elements will be written in terms of the invariant factors of the group, as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">utf8</td><td>if <code>true</code>, then richer unicode characters will be used to make the output more pleasant to read. In particular, the output will use subscript digits and the blackboard bold Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab39205739f100116e5fcc9a6abe01d15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::AbelianGroup::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this abelian group. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3697f3d8592b06715c111a3ab6e1096c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::multiset&lt;<a class="el" href="group__maths.html#ga0422bafdce5143174c2df7514511ace8">Integer</a>&gt; regina::AbelianGroup::invariantFactors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The invariant factors <em>d0</em>,...,<em>dn</em> as described in the <a class="el" href="classregina_1_1AbelianGroup.html" title="Represents a finitely generated abelian group.">AbelianGroup</a> notes. </p>

</div>
</div>
<a class="anchor" id="a9bb4166ec40c17c6a042f6d0609ed4db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::AbelianGroup::rank_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The rank of the group (the number of Z components). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="abeliangroup_8h.html">abeliangroup.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
