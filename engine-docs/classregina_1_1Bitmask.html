<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::Bitmask Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Bitmask-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::Bitmask Class Reference<div class="ingroups"><a class="el" href="group__utilities.html">Miscellaneous Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A bitmask that can store arbitrarily many true-or-false bits.  
 <a href="classregina_1_1Bitmask.html#details">More...</a></p>

<p><code>#include &lt;utilities/bitmask.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63b3974553c4c68a861724592166a4c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a63b3974553c4c68a861724592166a4c8">Bitmask</a> ()</td></tr>
<tr class="memdesc:a63b3974553c4c68a861724592166a4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new invalid bitmask.  <a href="#a63b3974553c4c68a861724592166a4c8">More...</a><br/></td></tr>
<tr class="separator:a63b3974553c4c68a861724592166a4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a36a6f40f432a9c1f6e47590f191229"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a9a36a6f40f432a9c1f6e47590f191229">Bitmask</a> (size_t length)</td></tr>
<tr class="memdesc:a9a36a6f40f432a9c1f6e47590f191229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new bitmask of the given length with all bits set to <code>false</code>.  <a href="#a9a36a6f40f432a9c1f6e47590f191229">More...</a><br/></td></tr>
<tr class="separator:a9a36a6f40f432a9c1f6e47590f191229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a14612fe9264e5bbb9eb18f959ef2af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a3a14612fe9264e5bbb9eb18f959ef2af">Bitmask</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a3a14612fe9264e5bbb9eb18f959ef2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the given bitmask.  <a href="#a3a14612fe9264e5bbb9eb18f959ef2af">More...</a><br/></td></tr>
<tr class="separator:a3a14612fe9264e5bbb9eb18f959ef2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da7d39788ced60309788d45157a2ff2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a7da7d39788ced60309788d45157a2ff2">~Bitmask</a> ()</td></tr>
<tr class="memdesc:a7da7d39788ced60309788d45157a2ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this bitmask.  <a href="#a7da7d39788ced60309788d45157a2ff2">More...</a><br/></td></tr>
<tr class="separator:a7da7d39788ced60309788d45157a2ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44df030ab3028996bbd038b86044ced1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a44df030ab3028996bbd038b86044ced1">get</a> (size_t index) const </td></tr>
<tr class="memdesc:a44df030ab3028996bbd038b86044ced1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask.  <a href="#a44df030ab3028996bbd038b86044ced1">More...</a><br/></td></tr>
<tr class="separator:a44df030ab3028996bbd038b86044ced1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c90eddb88301ece1e984652f1993cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#ab6c90eddb88301ece1e984652f1993cc">set</a> (size_t index, bool value)</td></tr>
<tr class="memdesc:ab6c90eddb88301ece1e984652f1993cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given bit of this bitmask to the given value.  <a href="#ab6c90eddb88301ece1e984652f1993cc">More...</a><br/></td></tr>
<tr class="separator:ab6c90eddb88301ece1e984652f1993cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cd2494dcfac16c229ed558770b05b7"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ab1cd2494dcfac16c229ed558770b05b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#ab1cd2494dcfac16c229ed558770b05b7">set</a> (ForwardIterator indexBegin, ForwardIterator indexEnd, bool value)</td></tr>
<tr class="memdesc:ab1cd2494dcfac16c229ed558770b05b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits in the given sorted list to the given value.  <a href="#ab1cd2494dcfac16c229ed558770b05b7">More...</a><br/></td></tr>
<tr class="separator:ab1cd2494dcfac16c229ed558770b05b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f54e460a4fe7ff7304fd27390d77340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a1f54e460a4fe7ff7304fd27390d77340">reset</a> ()</td></tr>
<tr class="memdesc:a1f54e460a4fe7ff7304fd27390d77340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all bits of this bitmask to <code>false</code>.  <a href="#a1f54e460a4fe7ff7304fd27390d77340">More...</a><br/></td></tr>
<tr class="separator:a1f54e460a4fe7ff7304fd27390d77340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5529fe127a3a6d4c47c93115efa43a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a5529fe127a3a6d4c47c93115efa43a46">reset</a> (size_t length)</td></tr>
<tr class="memdesc:a5529fe127a3a6d4c47c93115efa43a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes this bitmask to the given length and sets all bits to <code>false</code>.  <a href="#a5529fe127a3a6d4c47c93115efa43a46">More...</a><br/></td></tr>
<tr class="separator:a5529fe127a3a6d4c47c93115efa43a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c206093e6c4a66b9086507586595797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a8c206093e6c4a66b9086507586595797">operator=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:a8c206093e6c4a66b9086507586595797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this bitmask to a copy of the given bitmask.  <a href="#a8c206093e6c4a66b9086507586595797">More...</a><br/></td></tr>
<tr class="separator:a8c206093e6c4a66b9086507586595797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c4ab5b72cca8ed16fa05dbca51731c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a53c4ab5b72cca8ed16fa05dbca51731c">truncate</a> (size_t numBits)</td></tr>
<tr class="memdesc:a53c4ab5b72cca8ed16fa05dbca51731c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>.  <a href="#a53c4ab5b72cca8ed16fa05dbca51731c">More...</a><br/></td></tr>
<tr class="separator:a53c4ab5b72cca8ed16fa05dbca51731c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480eca198478123a1df7a346521b2885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a480eca198478123a1df7a346521b2885">operator&amp;=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:a480eca198478123a1df7a346521b2885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the intersection of this and the given bitmask.  <a href="#a480eca198478123a1df7a346521b2885">More...</a><br/></td></tr>
<tr class="separator:a480eca198478123a1df7a346521b2885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fc0370077988c012d239f8140a5d0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a10fc0370077988c012d239f8140a5d0f">operator|=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:a10fc0370077988c012d239f8140a5d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the union of this and the given bitmask.  <a href="#a10fc0370077988c012d239f8140a5d0f">More...</a><br/></td></tr>
<tr class="separator:a10fc0370077988c012d239f8140a5d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3a360a592c0f293a5dca36bd43195a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a5d3a360a592c0f293a5dca36bd43195a">operator^=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:a5d3a360a592c0f293a5dca36bd43195a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the exclusive disjunction (XOR) of this and the given bitmask.  <a href="#a5d3a360a592c0f293a5dca36bd43195a">More...</a><br/></td></tr>
<tr class="separator:a5d3a360a592c0f293a5dca36bd43195a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8941a3ce3fc72eb3b90c80e410f26f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a7d8941a3ce3fc72eb3b90c80e410f26f">operator-=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other)</td></tr>
<tr class="memdesc:a7d8941a3ce3fc72eb3b90c80e410f26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to the set difference of this and the given bitmask.  <a href="#a7d8941a3ce3fc72eb3b90c80e410f26f">More...</a><br/></td></tr>
<tr class="separator:a7d8941a3ce3fc72eb3b90c80e410f26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912eae1af8637055cd516b179d73c040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a912eae1af8637055cd516b179d73c040">flip</a> ()</td></tr>
<tr class="memdesc:a912eae1af8637055cd516b179d73c040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates every bit in this bitmask.  <a href="#a912eae1af8637055cd516b179d73c040">More...</a><br/></td></tr>
<tr class="separator:a912eae1af8637055cd516b179d73c040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13afe5d31352de9383393d8a471ce1c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a13afe5d31352de9383393d8a471ce1c8">operator==</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other) const </td></tr>
<tr class="memdesc:a13afe5d31352de9383393d8a471ce1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given bitmask are identical.  <a href="#a13afe5d31352de9383393d8a471ce1c8">More...</a><br/></td></tr>
<tr class="separator:a13afe5d31352de9383393d8a471ce1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9b12f90b04cb724c886e394dcf0b05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#aeb9b12f90b04cb724c886e394dcf0b05">lessThan</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other) const </td></tr>
<tr class="memdesc:aeb9b12f90b04cb724c886e394dcf0b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order.  <a href="#aeb9b12f90b04cb724c886e394dcf0b05">More...</a><br/></td></tr>
<tr class="separator:aeb9b12f90b04cb724c886e394dcf0b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2843c81fa1c73c09a752ff260098ef0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a2843c81fa1c73c09a752ff260098ef0a">operator&lt;=</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;other) const </td></tr>
<tr class="memdesc:a2843c81fa1c73c09a752ff260098ef0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the given bitmask.  <a href="#a2843c81fa1c73c09a752ff260098ef0a">More...</a><br/></td></tr>
<tr class="separator:a2843c81fa1c73c09a752ff260098ef0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1bc42481b37a413b96f303e149faf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a2a1bc42481b37a413b96f303e149faf3">inUnion</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;x, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;y) const </td></tr>
<tr class="memdesc:a2a1bc42481b37a413b96f303e149faf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask is entirely contained within the union of the two given bitmasks.  <a href="#a2a1bc42481b37a413b96f303e149faf3">More...</a><br/></td></tr>
<tr class="separator:a2a1bc42481b37a413b96f303e149faf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8024a5df5418a5a5e2d1c0613c1ecf7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a8024a5df5418a5a5e2d1c0613c1ecf7d">containsIntn</a> (const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;x, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;y) const </td></tr>
<tr class="memdesc:a8024a5df5418a5a5e2d1c0613c1ecf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this bitmask contains the intersection of the two given bitmasks.  <a href="#a8024a5df5418a5a5e2d1c0613c1ecf7d">More...</a><br/></td></tr>
<tr class="separator:a8024a5df5418a5a5e2d1c0613c1ecf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a56cc441da1f0cc0876f359e3efa34"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a21a56cc441da1f0cc0876f359e3efa34">bits</a> () const </td></tr>
<tr class="memdesc:a21a56cc441da1f0cc0876f359e3efa34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask.  <a href="#a21a56cc441da1f0cc0876f359e3efa34">More...</a><br/></td></tr>
<tr class="separator:a21a56cc441da1f0cc0876f359e3efa34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7863116865e79527936cab16a8aa29f2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a7863116865e79527936cab16a8aa29f2">firstBit</a> () const </td></tr>
<tr class="memdesc:a7863116865e79527936cab16a8aa29f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="#a7863116865e79527936cab16a8aa29f2">More...</a><br/></td></tr>
<tr class="separator:a7863116865e79527936cab16a8aa29f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acded2580ada05c0f2fb9e86b8337fbc1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#acded2580ada05c0f2fb9e86b8337fbc1">lastBit</a> () const </td></tr>
<tr class="memdesc:acded2580ada05c0f2fb9e86b8337fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits.  <a href="#acded2580ada05c0f2fb9e86b8337fbc1">More...</a><br/></td></tr>
<tr class="separator:acded2580ada05c0f2fb9e86b8337fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f48d714fb03f74fa867d9e714b19bc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a2f48d714fb03f74fa867d9e714b19bc8">atMostOneBit</a> () const </td></tr>
<tr class="memdesc:a2f48d714fb03f74fa867d9e714b19bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether at most one bit is set to <code>true</code> in this bitmask.  <a href="#a2f48d714fb03f74fa867d9e714b19bc8">More...</a><br/></td></tr>
<tr class="separator:a2f48d714fb03f74fa867d9e714b19bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7a48856e7eb35fdde956d27063dd67b9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Bitmask.html#a7a48856e7eb35fdde956d27063dd67b9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;mask)</td></tr>
<tr class="memdesc:a7a48856e7eb35fdde956d27063dd67b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given bitmask to the given output stream as a sequence of zeroes and ones.  <a href="#a7a48856e7eb35fdde956d27063dd67b9">More...</a><br/></td></tr>
<tr class="separator:a7a48856e7eb35fdde956d27063dd67b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A bitmask that can store arbitrarily many true-or-false bits. </p>
<p>This bitmask packs the bits together, so that (unlike an array of bools) many bits can be stored in a single byte. As a result, operations on this class are fast because the CPU can work on many bits simultaneously.</p>
<p>Nevertheless, this class still has overhead because the bits must be allocated on the heap, and because every operation requires looping through the individual bytes. For reasonably small bitmasks, see the highly optimised <a class="el" href="classregina_1_1Bitmask1.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) true-or-false bits...">Bitmask1</a> and <a class="el" href="classregina_1_1Bitmask2.html" title="A small but extremely fast bitmask class that can store up to 8 * sizeof(T) + 8 * sizeof(U) true-or-f...">Bitmask2</a> classes instead.</p>
<p>Once a bitmask is created, the only way its length (the number of bits) can be changed is by calling <a class="el" href="classregina_1_1Bitmask.html#a5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a>.</p>
<p>The length of the bitmask is not actually stored in this structure. This means that, upon construction (or reset), the length will be automatically rounded up to the next "raw unit of storage".</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000051">Todo:</a></b></dt><dd><em>Optimise:</em> Insist that sizeof(Piece) is a power of two, and replace expensive division/mod operations with cheap bit operations.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Because this class may increase the length of the bitmask (rounding up to the next unit of storage), bitwise computations may not give the results that you expect. In particular, <a class="el" href="classregina_1_1Bitmask.html#a912eae1af8637055cd516b179d73c040" title="Negates every bit in this bitmask.">flip()</a> may set additional <code>true</code> bits in the "dead space" between the intended length and the actual length, and this may have a flow-on effect for other operations (such as subset testing, bit counting and so on). Be careful!</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a63b3974553c4c68a861724592166a4c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::Bitmask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new invalid bitmask. </p>
<p>You must call the one-argument <a class="el" href="classregina_1_1Bitmask.html#a5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or use the assignment operator to give the bitmask a length before it can be used.</p>
<p>Use of this default constructor is discouraged. The only reason it exists is to support arrays and containers of bitmasks, where the bitmasks must be created in bulk and then individually assigned lengths.</p>
<dl class="section warning"><dt>Warning</dt><dd>No other routines can be used with this bitmask until it has been assigned a length via <a class="el" href="classregina_1_1Bitmask.html#a5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or the assignment operator. As the single exception, the class destructor is safe to use even if a bitmask has never been initialised. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a36a6f40f432a9c1f6e47590f191229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::Bitmask </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new bitmask of the given length with all bits set to <code>false</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of bits stored in this bitmask; this must be at least one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a14612fe9264e5bbb9eb18f959ef2af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::Bitmask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of the given bitmask. </p>
<p>It is fine if the given bitmask is invalid (but in this case, the new bitmask will be invalid also). Invalid bitmasks must be assigned a length using <a class="el" href="classregina_1_1Bitmask.html#a5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or the assignment operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7da7d39788ced60309788d45157a2ff2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Bitmask::~Bitmask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this bitmask. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2f48d714fb03f74fa867d9e714b19bc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::atMostOneBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether at most one bit is set to <code>true</code> in this bitmask. </p>
<p>If this bitmask is entirely <code>false</code> or if only one bit is set to <code>true</code>, then this routine will return <code>true</code>. Otherwise this routine will return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if at most one bit is set to <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a21a56cc441da1f0cc0876f359e3efa34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Bitmask::bits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bits currently set to <code>true</code> in this bitmask. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of <code>true</code> bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a8024a5df5418a5a5e2d1c0613c1ecf7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::containsIntn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask contains the intersection of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in <em>both</em> <em>x</em> and <em>y</em> must be set in this bitmask also.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>x</em> and <em>y</em> are the same length as this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the intersection. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the intersection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask entirely contains the intersection of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7863116865e79527936cab16a8aa29f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Bitmask::firstBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the first <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the first <code>true</code> bit. </dd></dl>

</div>
</div>
<a class="anchor" id="a912eae1af8637055cd516b179d73c040"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates every bit in this bitmask. </p>
<p>All <code>true</code> bits will be set to <code>false</code> and vice versa.</p>
<dl class="section warning"><dt>Warning</dt><dd>Because this class may increase the bitmask length (rounding up to the next unit of storage), <a class="el" href="classregina_1_1Bitmask.html#a912eae1af8637055cd516b179d73c040" title="Negates every bit in this bitmask.">flip()</a> may set additional <code>true</code> bits in the "dead space" between the intended length and the actual length. This may cause unexpected results for routines such as subset testing, bit counting and so on. Be careful! </dd></dl>

</div>
</div>
<a class="anchor" id="a44df030ab3028996bbd038b86044ced1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the given bit of this bitmask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to query; this must be at least zero and strictly less than the length of this bitmask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the (<em>index</em>)th bit. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a1bc42481b37a413b96f303e149faf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::inUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the union of the two given bitmasks. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in either <em>x</em> or <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both <em>x</em> and <em>y</em> are the same length as this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the first bitmask used to form the union. </td></tr>
    <tr><td class="paramname">y</td><td>the first bitmask used to form the union. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the union of <em>x</em> and <em>y</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="acded2580ada05c0f2fb9e86b8337fbc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Bitmask::lastBit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the last <code>true</code> bit in this bitmask, or -1 if there are no <code>true</code> bits. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of the last <code>true</code> bit. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb9b12f90b04cb724c886e394dcf0b05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::lessThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in lexicographical order. </p>
<p>Here the bit at index 0 is least significant, and the bit at index <em>length-1</em> is most significant.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>We do not use &lt; for this operation, since &lt;= represents the subset operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is lexicographically strictly smaller than the given bitmask. </dd></dl>

</div>
</div>
<a class="anchor" id="a480eca198478123a1df7a346521b2885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the intersection of this and the given bitmask. </p>
<p>Every bit that is unset in <em>other</em> will be unset in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to intersect with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d8941a3ce3fc72eb3b90c80e410f26f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the set difference of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be cleared in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a class="anchor" id="a2843c81fa1c73c09a752ff260098ef0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this bitmask is entirely contained within the given bitmask. </p>
<p>For this routine to return <code>true</code>, every bit that is set in this bitmask must also be set in the given bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation does not compare bitmasks lexicographically; moreover, it only describes a partial order, not a total order. To compare bitmasks lexicographically, use <a class="el" href="classregina_1_1Bitmask.html#aeb9b12f90b04cb724c886e394dcf0b05" title="Determines whether this bitmask appears strictly before the given bitmask when bitmasks are sorted in...">lessThan()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this bitmask is entirely contained within the given bitmask. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c206093e6c4a66b9086507586595797"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this bitmask to a copy of the given bitmask. </p>
<p>If this bitmask is invalid, this assignment operator can be used to initialise it with a length.</p>
<p>If this bitmask has already been initialised to a different length from that of the given bitmask, the length of this bitmask will be changed accordingly.</p>
<p>If the given bitmask is invalid, this bitmask will become invalid also. Invalid bitmasks must be assigned a length using <a class="el" href="classregina_1_1Bitmask.html#a5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> or this assignment operator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a class="anchor" id="a13afe5d31352de9383393d8a471ce1c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Bitmask::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this and the given bitmask are identical. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given bitmask are identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d3a360a592c0f293a5dca36bd43195a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the exclusive disjunction (XOR) of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be flipped in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to XOR with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a class="anchor" id="a10fc0370077988c012d239f8140a5d0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp; regina::Bitmask::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to the union of this and the given bitmask. </p>
<p>Every bit that is set in <em>other</em> will be set in this bitmask.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given bitmask have the same length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the bitmask to union with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this bitmask. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f54e460a4fe7ff7304fd27390d77340"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits of this bitmask to <code>false</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>The length of this bitmask must already have been initialised. In particular, if the default constructor was used, you must call the one-argument <a class="el" href="classregina_1_1Bitmask.html#a5529fe127a3a6d4c47c93115efa43a46" title="Resizes this bitmask to the given length and sets all bits to false.">reset(size_t)</a> before you can use this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="a5529fe127a3a6d4c47c93115efa43a46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::reset </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes this bitmask to the given length and sets all bits to <code>false</code>. </p>
<p>This routine can be used to change the length (number of bits) of the bitmask if desired.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of bits to store in this bitmask; this must be at least one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c90eddb88301ece1e984652f1993cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given bit of this bitmask to the given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>indicates which bit to set; this must be at least zero and strictly less than the length of this bitmask. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to the (<em>index</em>)th bit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1cd2494dcfac16c229ed558770b05b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::set </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indexEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets all bits in the given sorted list to the given value. </p>
<p>This is a convenience routine for setting many bits at once. The indices of the bits to set should be sorted and stored in some container, such as a std::set or a C-style array. This routine takes iterators over this container, and sets the bits at the corresponding indices to the given value.</p>
<p>For example, the following code would set bits 3, 5 and 6 to <code>true:</code> </p>
<div class="fragment"><div class="line">std::vector&lt;unsigned&gt; indices;</div>
<div class="line">indices.push(3); indices.push(5); indices.push(6);</div>
<div class="line">bitmask.set(indices.begin(), indices.end(), <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>Likewise, the following code would set bits 1, 4 and 7 to <code>false:</code> </p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> indices[3] = { 1, 4, 7 };</div>
<div class="line">bitmask.set(indices, indices + 3, <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>All other bits of this bitmask are unaffected by this routine.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>ForwardIterator</em> is a forward iterator type that iterates over integer values. </dd>
<dd>
The list of indices described by these iterators is in <em>sorted</em> order. This is to allow optimisations for larger bitmask types. </dd>
<dd>
All indices in the given list are at least zero and strictly less than the length of this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexBegin</td><td>the beginning of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">indexEnd</td><td>the end of the iterator range containing the sorted indices of the bits to set. </td></tr>
    <tr><td class="paramname">value</td><td>the value that will be assigned to each of the corresponding bits. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53c4ab5b72cca8ed16fa05dbca51731c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Bitmask::truncate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leaves the first <em>numBits</em> bits of this bitmask intact, but sets all subsequent bits to <code>false</code>. </p>
<p>In other words, this routine "truncates" this bitmask to the given number of bits.</p>
<p>This routine does not change the <em>length</em> of this bitmask (as passed to the contructor or to <a class="el" href="classregina_1_1Bitmask.html#a1f54e460a4fe7ff7304fd27390d77340" title="Sets all bits of this bitmask to false.">reset()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>numBits</em> is at most the length of this bitmask.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numBits</td><td>the number of bits that will <em>not</em> be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a7a48856e7eb35fdde956d27063dd67b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Bitmask.html">Bitmask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given bitmask to the given output stream as a sequence of zeroes and ones. </p>
<p>Since the length of the bitmask is not stored, the number of bits written might be greater than the length initially assigned to this bitmask (specifically, the length will be rounded up to the next "raw
unit of storage").</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">mask</td><td>the bitmask to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>utilities/<a class="el" href="bitmask_8h.html">bitmask.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
