<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::detail::TriangulationBase&lt; int &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="namespaceregina_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1detail_1_1TriangulationBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::detail::TriangulationBase&lt; int &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__detail.html">Implementation details</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides core functionality for <em>dim</em>-dimensional triangulations.  
 <a href="classregina_1_1detail_1_1TriangulationBase.html#details">More...</a></p>

<p><code>#include &lt;generic/detail/triangulation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::detail::TriangulationBase&lt; int &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1detail_1_1TriangulationBase.png" usemap="#regina::detail::TriangulationBase&lt; int &gt;_map" alt=""/>
  <map id="regina::detail::TriangulationBase&lt; int &gt;_map" name="regina::detail::TriangulationBase&lt; int &gt;_map">
<area href="classregina_1_1detail_1_1FaceListSuite.html" alt="regina::detail::FaceListSuite&lt; dim, dim-1 &gt;" shape="rect" coords="0,56,404,80"/>
<area href="classregina_1_1alias_1_1Simplices.html" alt="regina::alias::Simplices&lt; TriangulationBase&lt; dim &gt;, dim &gt;" shape="rect" coords="414,56,818,80"/>
<area href="classregina_1_1alias_1_1SimplexAt.html" alt="regina::alias::SimplexAt&lt; TriangulationBase&lt; dim &gt;, dim, true &gt;" shape="rect" coords="828,56,1232,80"/>
<area href="classregina_1_1alias_1_1FaceOfTriangulation.html" alt="regina::alias::FaceOfTriangulation&lt; TriangulationBase&lt; dim &gt;, dim &gt;" shape="rect" coords="1242,56,1646,80"/>
<area href="classregina_1_1alias_1_1FacesOfTriangulation.html" alt="regina::alias::FacesOfTriangulation&lt; TriangulationBase&lt; dim &gt;, dim &gt;" shape="rect" coords="1656,56,2060,80"/>
<area href="classregina_1_1FaceList.html" title="Stores the list of all subdim-faces of a dim-dimensional triangulation." alt="regina::FaceList&lt; dim, subdim &gt;" shape="rect" coords="0,0,404,24"/>
<area href="classregina_1_1Triangulation.html" alt="regina::Triangulation&lt; dim &gt;" shape="rect" coords="1035,168,1439,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9f3023c0479b8cc8aeec3dffa6fa62eb"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Simplex.html">Simplex</a><br class="typebreak"/>
&lt; dim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9f3023c0479b8cc8aeec3dffa6fa62eb">SimplexIterator</a></td></tr>
<tr class="memdesc:a9f3023c0479b8cc8aeec3dffa6fa62eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through top-dimensional simplices.  <a href="#a9f3023c0479b8cc8aeec3dffa6fa62eb">More...</a><br/></td></tr>
<tr class="separator:a9f3023c0479b8cc8aeec3dffa6fa62eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb85b172fe187672d3495a557aa394bf"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a><br class="typebreak"/>
&lt; dim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#acb85b172fe187672d3495a557aa394bf">ComponentIterator</a></td></tr>
<tr class="memdesc:acb85b172fe187672d3495a557aa394bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through connected components.  <a href="#acb85b172fe187672d3495a557aa394bf">More...</a><br/></td></tr>
<tr class="separator:acb85b172fe187672d3495a557aa394bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9277bf15589bb730bded019289311ac7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9277bf15589bb730bded019289311ac7">makeCanonical</a> ()</td></tr>
<tr class="memdesc:a9277bf15589bb730bded019289311ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form.  <a href="#a9277bf15589bb730bded019289311ac7">More...</a><br/></td></tr>
<tr class="separator:a9277bf15589bb730bded019289311ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3055b8c8346976930a1383dd91cba8ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3055b8c8346976930a1383dd91cba8ff"></a>
template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a3055b8c8346976930a1383dd91cba8ff"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getNumberOfFaces</b> () const </td></tr>
<tr class="separator:a3055b8c8346976930a1383dd91cba8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:aaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaa79cc9e7f5b4f6ea27045ebf3c8fabc">TriangulationBase</a> ()</td></tr>
<tr class="memdesc:aaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#aaa79cc9e7f5b4f6ea27045ebf3c8fabc">More...</a><br/></td></tr>
<tr class="separator:aaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f24cf3815b0d19d5afeae1860fcd0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a51f24cf3815b0d19d5afeae1860fcd0f">TriangulationBase</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;copy)</td></tr>
<tr class="memdesc:a51f24cf3815b0d19d5afeae1860fcd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation.  <a href="#a51f24cf3815b0d19d5afeae1860fcd0f">More...</a><br/></td></tr>
<tr class="separator:a51f24cf3815b0d19d5afeae1860fcd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace45d0a52d9a2a853f890d1006fedf7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ace45d0a52d9a2a853f890d1006fedf7c">~TriangulationBase</a> ()</td></tr>
<tr class="memdesc:ace45d0a52d9a2a853f890d1006fedf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this triangulation.  <a href="#ace45d0a52d9a2a853f890d1006fedf7c">More...</a><br/></td></tr>
<tr class="separator:ace45d0a52d9a2a853f890d1006fedf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Simplices</div></td></tr>
<tr class="memitem:a6ca55a972a8c21f7e87960431d9ef64c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c">size</a> () const </td></tr>
<tr class="memdesc:a6ca55a972a8c21f7e87960431d9ef64c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of top-dimensional simplices in the triangulation.  <a href="#a6ca55a972a8c21f7e87960431d9ef64c">More...</a><br/></td></tr>
<tr class="separator:a6ca55a972a8c21f7e87960431d9ef64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af520138d14508124ffba56446cc91aa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af520138d14508124ffba56446cc91aa5">getNumberOfSimplices</a> () const </td></tr>
<tr class="memdesc:af520138d14508124ffba56446cc91aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of top-dimensional simplices in the triangulation.  <a href="#af520138d14508124ffba56446cc91aa5">More...</a><br/></td></tr>
<tr class="separator:af520138d14508124ffba56446cc91aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721e084ec08bb631e35e14ff1c844f63"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Simplex.html">Simplex</a><br class="typebreak"/>
&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a721e084ec08bb631e35e14ff1c844f63">simplices</a> () const </td></tr>
<tr class="memdesc:a721e084ec08bb631e35e14ff1c844f63"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all top-dimensional simplices in the triangulation.  <a href="#a721e084ec08bb631e35e14ff1c844f63">More...</a><br/></td></tr>
<tr class="separator:a721e084ec08bb631e35e14ff1c844f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ba54e03f1a777d6efbb079227c2a4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
std::vector&lt; <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a53ba54e03f1a777d6efbb079227c2a4b">getSimplices</a> () const </td></tr>
<tr class="memdesc:a53ba54e03f1a777d6efbb079227c2a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns all of the top-dimensional simplices in the triangulation.  <a href="#a53ba54e03f1a777d6efbb079227c2a4b">More...</a><br/></td></tr>
<tr class="separator:a53ba54e03f1a777d6efbb079227c2a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e269a7332e80aeec3603881fd175d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">simplex</a> (size_t index)</td></tr>
<tr class="memdesc:ae2e269a7332e80aeec3603881fd175d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation.  <a href="#ae2e269a7332e80aeec3603881fd175d3">More...</a><br/></td></tr>
<tr class="separator:ae2e269a7332e80aeec3603881fd175d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ab68add2b36aa759661a3dba52f58c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a34ab68add2b36aa759661a3dba52f58c">getSimplex</a> (size_t index)</td></tr>
<tr class="memdesc:a34ab68add2b36aa759661a3dba52f58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the top-dimensional simplex at the given index in the triangulation.  <a href="#a34ab68add2b36aa759661a3dba52f58c">More...</a><br/></td></tr>
<tr class="separator:a34ab68add2b36aa759661a3dba52f58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ac843dd4a46316960d65a56c28fff8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a61ac843dd4a46316960d65a56c28fff8">simplex</a> (size_t index) const </td></tr>
<tr class="memdesc:a61ac843dd4a46316960d65a56c28fff8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation.  <a href="#a61ac843dd4a46316960d65a56c28fff8">More...</a><br/></td></tr>
<tr class="separator:a61ac843dd4a46316960d65a56c28fff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b7a336d5871fab5779f75a88a032eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
<a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a81b7a336d5871fab5779f75a88a032eb">getSimplex</a> (size_t index) const </td></tr>
<tr class="memdesc:a81b7a336d5871fab5779f75a88a032eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the top-dimensional simplex at the given index in the triangulation.  <a href="#a81b7a336d5871fab5779f75a88a032eb">More...</a><br/></td></tr>
<tr class="separator:a81b7a336d5871fab5779f75a88a032eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce68133679df7667c7347499133f240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ce68133679df7667c7347499133f240">simplexIndex</a> (const <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">simplex</a>) const </td></tr>
<tr class="memdesc:a2ce68133679df7667c7347499133f240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the index of the given top-dimensional simplex in the triangulation.  <a href="#a2ce68133679df7667c7347499133f240">More...</a><br/></td></tr>
<tr class="separator:a2ce68133679df7667c7347499133f240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107a418e2691dc5ad7bb9e90dcba437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437">newSimplex</a> ()</td></tr>
<tr class="memdesc:ad107a418e2691dc5ad7bb9e90dcba437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex and adds it to this triangulation.  <a href="#ad107a418e2691dc5ad7bb9e90dcba437">More...</a><br/></td></tr>
<tr class="separator:ad107a418e2691dc5ad7bb9e90dcba437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829224a264241e43a8f2bbdf5bfcb253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a829224a264241e43a8f2bbdf5bfcb253">newSimplex</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a829224a264241e43a8f2bbdf5bfcb253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex with the given description and adds it to this triangulation.  <a href="#a829224a264241e43a8f2bbdf5bfcb253">More...</a><br/></td></tr>
<tr class="separator:a829224a264241e43a8f2bbdf5bfcb253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba">removeSimplex</a> (<a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">simplex</a>)</td></tr>
<tr class="memdesc:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given top-dimensional simplex from this triangulation.  <a href="#a7b349c4e1fb4b27a9b20ed53b277a7ba">More...</a><br/></td></tr>
<tr class="separator:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec">removeSimplexAt</a> (size_t index)</td></tr>
<tr class="memdesc:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-dimensional simplex at the given index in this triangulation.  <a href="#ac9f36b004ba6af3d6ce11bdb655650ec">More...</a><br/></td></tr>
<tr class="separator:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91a640743f9ce2710d17eda77d520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a">removeAllSimplices</a> ()</td></tr>
<tr class="memdesc:a3e91a640743f9ce2710d17eda77d520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all simplices from the triangulation.  <a href="#a3e91a640743f9ce2710d17eda77d520a">More...</a><br/></td></tr>
<tr class="separator:a3e91a640743f9ce2710d17eda77d520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e7587b785f281f5f5c553f263484e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad43e7587b785f281f5f5c553f263484e">swapContents</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other)</td></tr>
<tr class="memdesc:ad43e7587b785f281f5f5c553f263484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given triangulation.  <a href="#ad43e7587b785f281f5f5c553f263484e">More...</a><br/></td></tr>
<tr class="separator:ad43e7587b785f281f5f5c553f263484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae3fa3daf9672da64a0fa8a82a439d65b">moveContentsTo</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;dest)</td></tr>
<tr class="memdesc:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents.  <a href="#ae3fa3daf9672da64a0fa8a82a439d65b">More...</a><br/></td></tr>
<tr class="separator:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Queries</div></td></tr>
<tr class="memitem:a2ea7f4ec2de2b34dbe345bf2ac71274d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ea7f4ec2de2b34dbe345bf2ac71274d">countComponents</a> () const </td></tr>
<tr class="memdesc:a2ea7f4ec2de2b34dbe345bf2ac71274d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of connected components in this triangulation.  <a href="#a2ea7f4ec2de2b34dbe345bf2ac71274d">More...</a><br/></td></tr>
<tr class="separator:a2ea7f4ec2de2b34dbe345bf2ac71274d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b66283609320290206e1ca4004c614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a07b66283609320290206e1ca4004c614">getNumberOfComponents</a> () const </td></tr>
<tr class="memdesc:a07b66283609320290206e1ca4004c614"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of connected components in this triangulation.  <a href="#a07b66283609320290206e1ca4004c614">More...</a><br/></td></tr>
<tr class="separator:a07b66283609320290206e1ca4004c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b62f7033765a5e146cdaa855e62c1"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ac42b62f7033765a5e146cdaa855e62c1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac42b62f7033765a5e146cdaa855e62c1">countFaces</a> () const </td></tr>
<tr class="memdesc:ac42b62f7033765a5e146cdaa855e62c1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this triangulation.  <a href="#ac42b62f7033765a5e146cdaa855e62c1">More...</a><br/></td></tr>
<tr class="separator:ac42b62f7033765a5e146cdaa855e62c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3f5cc17fb2daff24640b30287bddaf"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:abe3f5cc17fb2daff24640b30287bddaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abe3f5cc17fb2daff24640b30287bddaf">getNumberOfFaces</a> () const </td></tr>
<tr class="memdesc:abe3f5cc17fb2daff24640b30287bddaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of <em>subdim</em>-faces in this triangulation.  <a href="#abe3f5cc17fb2daff24640b30287bddaf">More...</a><br/></td></tr>
<tr class="separator:abe3f5cc17fb2daff24640b30287bddaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff2a6ce37f4021f6d93309ec29a2232"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0ff2a6ce37f4021f6d93309ec29a2232">fVector</a> () const </td></tr>
<tr class="memdesc:a0ff2a6ce37f4021f6d93309ec29a2232"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the f-vector of this triangulation, which counts the number of faces of all dimensions.  <a href="#a0ff2a6ce37f4021f6d93309ec29a2232">More...</a><br/></td></tr>
<tr class="separator:a0ff2a6ce37f4021f6d93309ec29a2232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52f03e39a1ac74ad4572d6dc3cb6081"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a><br class="typebreak"/>
&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af52f03e39a1ac74ad4572d6dc3cb6081">components</a> () const </td></tr>
<tr class="memdesc:af52f03e39a1ac74ad4572d6dc3cb6081"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all connected components of this triangulation.  <a href="#af52f03e39a1ac74ad4572d6dc3cb6081">More...</a><br/></td></tr>
<tr class="separator:af52f03e39a1ac74ad4572d6dc3cb6081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063f51a8c5f88e26ee430064d980a193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a063f51a8c5f88e26ee430064d980a193">getComponents</a> () const </td></tr>
<tr class="memdesc:a063f51a8c5f88e26ee430064d980a193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns all connected components of this triangulation.  <a href="#a063f51a8c5f88e26ee430064d980a193">More...</a><br/></td></tr>
<tr class="separator:a063f51a8c5f88e26ee430064d980a193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b031c48014d00ee9fee402dd989ef5"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a90b031c48014d00ee9fee402dd989ef5"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a90b031c48014d00ee9fee402dd989ef5">faces</a> () const </td></tr>
<tr class="memdesc:a90b031c48014d00ee9fee402dd989ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation.  <a href="#a90b031c48014d00ee9fee402dd989ef5">More...</a><br/></td></tr>
<tr class="separator:a90b031c48014d00ee9fee402dd989ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ee1eaa26fe337535ca3945ef063972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa5ee1eaa26fe337535ca3945ef063972">component</a> (size_t index) const </td></tr>
<tr class="memdesc:aa5ee1eaa26fe337535ca3945ef063972"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested connected component of this triangulation.  <a href="#aa5ee1eaa26fe337535ca3945ef063972">More...</a><br/></td></tr>
<tr class="separator:aa5ee1eaa26fe337535ca3945ef063972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855675725502f984ea24db34e6b2a9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1Component.html">Component</a><br class="typebreak"/>
&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a855675725502f984ea24db34e6b2a9d8">getComponent</a> (size_t index) const </td></tr>
<tr class="memdesc:a855675725502f984ea24db34e6b2a9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the requested connected component of this triangulation.  <a href="#a855675725502f984ea24db34e6b2a9d8">More...</a><br/></td></tr>
<tr class="separator:a855675725502f984ea24db34e6b2a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0333fa8a47302bcf44fa05e3158d9761"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:a0333fa8a47302bcf44fa05e3158d9761"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0333fa8a47302bcf44fa05e3158d9761">face</a> (size_t index) const </td></tr>
<tr class="memdesc:a0333fa8a47302bcf44fa05e3158d9761"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face of this triangulation.  <a href="#a0333fa8a47302bcf44fa05e3158d9761">More...</a><br/></td></tr>
<tr class="separator:a0333fa8a47302bcf44fa05e3158d9761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f19e3f339c50f0b40dfa28c02d31878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6f19e3f339c50f0b40dfa28c02d31878">componentIndex</a> (const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa5ee1eaa26fe337535ca3945ef063972">component</a>) const </td></tr>
<tr class="memdesc:a6f19e3f339c50f0b40dfa28c02d31878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the index of the given connected component in this triangulation.  <a href="#a6f19e3f339c50f0b40dfa28c02d31878">More...</a><br/></td></tr>
<tr class="separator:a6f19e3f339c50f0b40dfa28c02d31878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Properties</div></td></tr>
<tr class="memitem:ad26eb19438346ff47f0bf56598070a0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad26eb19438346ff47f0bf56598070a0a">isEmpty</a> () const </td></tr>
<tr class="memdesc:ad26eb19438346ff47f0bf56598070a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation is empty.  <a href="#ad26eb19438346ff47f0bf56598070a0a">More...</a><br/></td></tr>
<tr class="separator:ad26eb19438346ff47f0bf56598070a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4602a09cb4e9babf8d9bfd33031c6dc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4602a09cb4e9babf8d9bfd33031c6dc5">isValid</a> () const </td></tr>
<tr class="memdesc:a4602a09cb4e9babf8d9bfd33031c6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is valid.  <a href="#a4602a09cb4e9babf8d9bfd33031c6dc5">More...</a><br/></td></tr>
<tr class="separator:a4602a09cb4e9babf8d9bfd33031c6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517c0fd1ec5190115785b91cca9e61b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a517c0fd1ec5190115785b91cca9e61b4">hasBoundaryFacets</a> () const </td></tr>
<tr class="memdesc:a517c0fd1ec5190115785b91cca9e61b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation has any boundary facets.  <a href="#a517c0fd1ec5190115785b91cca9e61b4">More...</a><br/></td></tr>
<tr class="separator:a517c0fd1ec5190115785b91cca9e61b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f070bcbd3431b51bb680ff7c3077431"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3f070bcbd3431b51bb680ff7c3077431">countBoundaryFacets</a> () const </td></tr>
<tr class="memdesc:a3f070bcbd3431b51bb680ff7c3077431"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of boundary facets in this triangulation.  <a href="#a3f070bcbd3431b51bb680ff7c3077431">More...</a><br/></td></tr>
<tr class="separator:a3f070bcbd3431b51bb680ff7c3077431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97ba0e2d6e92e92e233d28e237b8a24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab97ba0e2d6e92e92e233d28e237b8a24">isOrientable</a> () const </td></tr>
<tr class="memdesc:ab97ba0e2d6e92e92e233d28e237b8a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is orientable.  <a href="#ab97ba0e2d6e92e92e233d28e237b8a24">More...</a><br/></td></tr>
<tr class="separator:ab97ba0e2d6e92e92e233d28e237b8a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1b7c2fbd1ea4a7a226993caa29e57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ee1b7c2fbd1ea4a7a226993caa29e57">isConnected</a> () const </td></tr>
<tr class="memdesc:a2ee1b7c2fbd1ea4a7a226993caa29e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is connected.  <a href="#a2ee1b7c2fbd1ea4a7a226993caa29e57">More...</a><br/></td></tr>
<tr class="separator:a2ee1b7c2fbd1ea4a7a226993caa29e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52193108182bb6cefd2ea267f35479ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a52193108182bb6cefd2ea267f35479ab">isOriented</a> () const </td></tr>
<tr class="memdesc:a52193108182bb6cefd2ea267f35479ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets.  <a href="#a52193108182bb6cefd2ea267f35479ab">More...</a><br/></td></tr>
<tr class="separator:a52193108182bb6cefd2ea267f35479ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Transformations</div></td></tr>
<tr class="memitem:a2711fd7c7115ce19b6833f0d61c42bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2711fd7c7115ce19b6833f0d61c42bec">orient</a> ()</td></tr>
<tr class="memdesc:a2711fd7c7115ce19b6833f0d61c42bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible.  <a href="#a2711fd7c7115ce19b6833f0d61c42bec">More...</a><br/></td></tr>
<tr class="separator:a2711fd7c7115ce19b6833f0d61c42bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subdivisions, Extensions and Covers</div></td></tr>
<tr class="memitem:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae061e36e8ecbfa2f1edc36ed9eb99a51">makeDoubleCover</a> ()</td></tr>
<tr class="memdesc:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this triangulation into its double cover.  <a href="#ae061e36e8ecbfa2f1edc36ed9eb99a51">More...</a><br/></td></tr>
<tr class="separator:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25a58b48e39f3c7f8621b84432d294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#adc25a58b48e39f3c7f8621b84432d294">finiteToIdeal</a> ()</td></tr>
<tr class="memdesc:adc25a58b48e39f3c7f8621b84432d294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts each real boundary component into a cusp (i.e., an ideal vertex).  <a href="#adc25a58b48e39f3c7f8621b84432d294">More...</a><br/></td></tr>
<tr class="separator:adc25a58b48e39f3c7f8621b84432d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decompositions</div></td></tr>
<tr class="memitem:a85435d4303792273aad5e662a7d67426"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a85435d4303792273aad5e662a7d67426">splitIntoComponents</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *componentParent=0, bool setLabels=true)</td></tr>
<tr class="memdesc:a85435d4303792273aad5e662a7d67426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a disconnected triangulation into many smaller triangulations, one for each component.  <a href="#a85435d4303792273aad5e662a7d67426">More...</a><br/></td></tr>
<tr class="separator:a85435d4303792273aad5e662a7d67426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Isomorphism Testing</div></td></tr>
<tr class="memitem:a00301fd26f1eaaa4df55b94b8369a054"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a00301fd26f1eaaa4df55b94b8369a054">isIdenticalTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const </td></tr>
<tr class="memdesc:a00301fd26f1eaaa4df55b94b8369a054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially identical to the given triangulation.  <a href="#a00301fd26f1eaaa4df55b94b8369a054">More...</a><br/></td></tr>
<tr class="separator:a00301fd26f1eaaa4df55b94b8369a054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f9aeb3cd023425abe5642deb8b8a27"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a12f9aeb3cd023425abe5642deb8b8a27">isIsomorphicTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const </td></tr>
<tr class="memdesc:a12f9aeb3cd023425abe5642deb8b8a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially isomorphic to the given triangulation.  <a href="#a12f9aeb3cd023425abe5642deb8b8a27">More...</a><br/></td></tr>
<tr class="separator:a12f9aeb3cd023425abe5642deb8b8a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae91eb26428486e1804cef4fed7bebd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaae91eb26428486e1804cef4fed7bebd">isContainedIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const </td></tr>
<tr class="memdesc:aaae91eb26428486e1804cef4fed7bebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="#aaae91eb26428486e1804cef4fed7bebd">More...</a><br/></td></tr>
<tr class="separator:aaae91eb26428486e1804cef4fed7bebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de089bc182f4e43410ea8b262d47cac"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:a5de089bc182f4e43410ea8b262d47cac"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5de089bc182f4e43410ea8b262d47cac">findAllIsomorphisms</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, OutputIterator output) const </td></tr>
<tr class="memdesc:a5de089bc182f4e43410ea8b262d47cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.  <a href="#a5de089bc182f4e43410ea8b262d47cac">More...</a><br/></td></tr>
<tr class="separator:a5de089bc182f4e43410ea8b262d47cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58db7e35de591b91e021fde0838bafd"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:ad58db7e35de591b91e021fde0838bafd"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad58db7e35de591b91e021fde0838bafd">findAllSubcomplexesIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, OutputIterator output) const </td></tr>
<tr class="memdesc:ad58db7e35de591b91e021fde0838bafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="#ad58db7e35de591b91e021fde0838bafd">More...</a><br/></td></tr>
<tr class="separator:ad58db7e35de591b91e021fde0838bafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Building Triangulations</div></td></tr>
<tr class="memitem:a2bf93dbca6715c1a455a2d47f66a6476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2bf93dbca6715c1a455a2d47f66a6476">insertTriangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a2bf93dbca6715c1a455a2d47f66a6476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given triangulation into this triangulation.  <a href="#a2bf93dbca6715c1a455a2d47f66a6476">More...</a><br/></td></tr>
<tr class="separator:a2bf93dbca6715c1a455a2d47f66a6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e8b7cf820ff452059f817d55536155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af1e8b7cf820ff452059f817d55536155">insertConstruction</a> (size_t nSimplices, const int adjacencies[][dim+1], const int gluings[][dim+1][dim+1])</td></tr>
<tr class="memdesc:af1e8b7cf820ff452059f817d55536155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a given triangulation into this triangulation, where the given triangulation is described by a pair of integer arrays.  <a href="#af1e8b7cf820ff452059f817d55536155">More...</a><br/></td></tr>
<tr class="separator:af1e8b7cf820ff452059f817d55536155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Triangulations</div></td></tr>
<tr class="memitem:afee58a1ea4ea31f25849490a7cd2afad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afee58a1ea4ea31f25849490a7cd2afad">isoSig</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; **relabelling=0) const </td></tr>
<tr class="memdesc:afee58a1ea4ea31f25849490a7cd2afad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the isomorphism signature for this triangulation.  <a href="#afee58a1ea4ea31f25849490a7cd2afad">More...</a><br/></td></tr>
<tr class="separator:afee58a1ea4ea31f25849490a7cd2afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df13959cbb5b7cc2510eb30b503c166"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5df13959cbb5b7cc2510eb30b503c166">dumpConstruction</a> () const </td></tr>
<tr class="memdesc:a5df13959cbb5b7cc2510eb30b503c166"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used with <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af1e8b7cf820ff452059f817d55536155" title="Inserts a given triangulation into this triangulation, where the given triangulation is described by ...">insertConstruction()</a> to reconstruct this triangulation.  <a href="#a5df13959cbb5b7cc2510eb30b503c166">More...</a><br/></td></tr>
<tr class="separator:a5df13959cbb5b7cc2510eb30b503c166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Importing Triangulations</div></td></tr>
<tr class="memitem:a1a40b9288ac97b1df6a702b12dbe5325"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325">fromIsoSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:a1a40b9288ac97b1df6a702b12dbe5325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a full triangulation from an isomorphism signature.  <a href="#a1a40b9288ac97b1df6a702b12dbe5325">More...</a><br/></td></tr>
<tr class="separator:a1a40b9288ac97b1df6a702b12dbe5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2309f88209fdc55a5408838e5983caf"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab2309f88209fdc55a5408838e5983caf">isoSigComponentSize</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:ab2309f88209fdc55a5408838e5983caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature.  <a href="#ab2309f88209fdc55a5408838e5983caf">More...</a><br/></td></tr>
<tr class="separator:ab2309f88209fdc55a5408838e5983caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ga0be8028a8f015b7fff2e37769a17dfac"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, <br class="typebreak"/>
subdim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a></td></tr>
<tr class="memdesc:ga0be8028a8f015b7fff2e37769a17dfac"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator type for iterating through this list of faces.  <a href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">More...</a><br/></td></tr>
<tr class="separator:ga0be8028a8f015b7fff2e37769a17dfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac385cd2115fc4eaabaf591ba58046cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac385cd2115fc4eaabaf591ba58046cad">ensureSkeleton</a> () const </td></tr>
<tr class="memdesc:ac385cd2115fc4eaabaf591ba58046cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that all "on demand" skeletal objects have been calculated.  <a href="#ac385cd2115fc4eaabaf591ba58046cad">More...</a><br/></td></tr>
<tr class="separator:ac385cd2115fc4eaabaf591ba58046cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf5ad2a8b5eb264f015405a4a89bb1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4cf5ad2a8b5eb264f015405a4a89bb1d">calculatedSkeleton</a> () const </td></tr>
<tr class="memdesc:a4cf5ad2a8b5eb264f015405a4a89bb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the skeletal objects and properties of this triangulation have been calculated.  <a href="#a4cf5ad2a8b5eb264f015405a4a89bb1d">More...</a><br/></td></tr>
<tr class="separator:a4cf5ad2a8b5eb264f015405a4a89bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d04b371303f07f238af57faf82c9402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1d04b371303f07f238af57faf82c9402">calculateSkeleton</a> ()</td></tr>
<tr class="memdesc:a1d04b371303f07f238af57faf82c9402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all skeletal objects for this triangulation.  <a href="#a1d04b371303f07f238af57faf82c9402">More...</a><br/></td></tr>
<tr class="separator:a1d04b371303f07f238af57faf82c9402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c4601f644bed4d5972eaef52c68fdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a85c4601f644bed4d5972eaef52c68fdc">deleteSkeleton</a> ()</td></tr>
<tr class="memdesc:a85c4601f644bed4d5972eaef52c68fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates all skeletal objects that are managed by this triangulation, and empties all corresponding internal lists.  <a href="#a85c4601f644bed4d5972eaef52c68fdc">More...</a><br/></td></tr>
<tr class="separator:a85c4601f644bed4d5972eaef52c68fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b34020172394d10592dd4251468bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#a45b34020172394d10592dd4251468bcc">deleteFaces</a> ()</td></tr>
<tr class="memdesc:a45b34020172394d10592dd4251468bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all faces of dimension <em>subdim</em> and below.  <a href="#a45b34020172394d10592dd4251468bcc">More...</a><br/></td></tr>
<tr class="separator:a45b34020172394d10592dd4251468bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8adeb83255137b4ba522408f77fbe58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#aa8adeb83255137b4ba522408f77fbe58">fillFVector</a> (std::vector&lt; size_t &gt; &amp;result) const</td></tr>
<tr class="memdesc:aa8adeb83255137b4ba522408f77fbe58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given vector with the first (<em>subdim</em> + 1) elements of the f-vector.  <a href="#aa8adeb83255137b4ba522408f77fbe58">More...</a><br/></td></tr>
<tr class="separator:aa8adeb83255137b4ba522408f77fbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af963f8d8cb94d216df5158e5204e4927"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#af963f8d8cb94d216df5158e5204e4927">sameFVector</a> (const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;other) const</td></tr>
<tr class="memdesc:af963f8d8cb94d216df5158e5204e4927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same number of <em>k</em>-faces, for each facial dimension <em>k</em> &le; <em>subdim</em>.  <a href="#af963f8d8cb94d216df5158e5204e4927">More...</a><br/></td></tr>
<tr class="separator:af963f8d8cb94d216df5158e5204e4927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8035ecc57099d3d28d59599b65af5feb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#a8035ecc57099d3d28d59599b65af5feb">sameDegrees</a> (const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a8035ecc57099d3d28d59599b65af5feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same <em>k</em>-face degree sequences, for each facial dimension <em>k</em> &le; <em>subdim</em>.  <a href="#a8035ecc57099d3d28d59599b65af5feb">More...</a><br/></td></tr>
<tr class="separator:a8035ecc57099d3d28d59599b65af5feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5605932cdf6dacacdfb2d90151bac356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga5605932cdf6dacacdfb2d90151bac356">sameDegrees</a> (const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp;other) const </td></tr>
<tr class="memdesc:ga5605932cdf6dacacdfb2d90151bac356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same <em>subdim</em>-face degree sequences.  <a href="group__generic.html#ga5605932cdf6dacacdfb2d90151bac356">More...</a><br/></td></tr>
<tr class="separator:ga5605932cdf6dacacdfb2d90151bac356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e9b6234d46c518a6bdd7fc0d4750cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga87e9b6234d46c518a6bdd7fc0d4750cd">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:ga87e9b6234d46c518a6bdd7fc0d4750cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face.  <a href="group__generic.html#ga87e9b6234d46c518a6bdd7fc0d4750cd">More...</a><br/></td></tr>
<tr class="separator:ga87e9b6234d46c518a6bdd7fc0d4750cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1671ff7a32ea81850ebbc402b04bfddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga1671ff7a32ea81850ebbc402b04bfddb">begin</a> () const </td></tr>
<tr class="memdesc:ga1671ff7a32ea81850ebbc402b04bfddb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing to the first <em>subdim</em>-face.  <a href="group__generic.html#ga1671ff7a32ea81850ebbc402b04bfddb">More...</a><br/></td></tr>
<tr class="separator:ga1671ff7a32ea81850ebbc402b04bfddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bd2d30911e68b272b26de716f35ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga45bd2d30911e68b272b26de716f35ad1">end</a> () const </td></tr>
<tr class="memdesc:ga45bd2d30911e68b272b26de716f35ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing beyond the last <em>subdim</em>-face.  <a href="group__generic.html#ga45bd2d30911e68b272b26de716f35ad1">More...</a><br/></td></tr>
<tr class="separator:ga45bd2d30911e68b272b26de716f35ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9055978b413d79bbb7783d4730c00ad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga9055978b413d79bbb7783d4730c00ad1">push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0333fa8a47302bcf44fa05e3158d9761">face</a>)</td></tr>
<tr class="memdesc:ga9055978b413d79bbb7783d4730c00ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given face onto the end of this list.  <a href="group__generic.html#ga9055978b413d79bbb7783d4730c00ad1">More...</a><br/></td></tr>
<tr class="separator:ga9055978b413d79bbb7783d4730c00ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd29e5cef4315d5b40c37ab997645b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga1cd29e5cef4315d5b40c37ab997645b8">destroy</a> ()</td></tr>
<tr class="memdesc:ga1cd29e5cef4315d5b40c37ab997645b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all faces in this list, and clears the list itself.  <a href="group__generic.html#ga1cd29e5cef4315d5b40c37ab997645b8">More...</a><br/></td></tr>
<tr class="separator:ga1cd29e5cef4315d5b40c37ab997645b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a356963e7a7661a0abcc9024a890652ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NMarkedVector.html">NMarkedVector</a>&lt; <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a356963e7a7661a0abcc9024a890652ba">simplices_</a></td></tr>
<tr class="memdesc:a356963e7a7661a0abcc9024a890652ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-dimensional simplices that form the triangulation.  <a href="#a356963e7a7661a0abcc9024a890652ba">More...</a><br/></td></tr>
<tr class="separator:a356963e7a7661a0abcc9024a890652ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327ad9e8143772575b5701a3c4ad6007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a327ad9e8143772575b5701a3c4ad6007">valid_</a></td></tr>
<tr class="memdesc:a327ad9e8143772575b5701a3c4ad6007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this triangulation valid? See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4602a09cb4e9babf8d9bfd33031c6dc5" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means.  <a href="#a327ad9e8143772575b5701a3c4ad6007">More...</a><br/></td></tr>
<tr class="separator:a327ad9e8143772575b5701a3c4ad6007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab021b95f9d18668036598107ce238c91"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab021b95f9d18668036598107ce238c91"></a>
template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:ab021b95f9d18668036598107ce238c91"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FaceCalculator</b></td></tr>
<tr class="separator:ab021b95f9d18668036598107ce238c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int&gt;<br/>
class regina::detail::TriangulationBase&lt; int &gt;</h3>

<p>Provides core functionality for <em>dim</em>-dimensional triangulations. </p>
<p>Such a triangulation is represented by the class <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a>, which uses this as a base class. End users should not need to refer to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> directly.</p>
<p>See the <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> class notes for further information.</p>
<p>Note that this class does not derive from <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a>. This is to avoid clashes with the output code inherited from <a class="el" href="classregina_1_1NPacket.html" title="Represents a packet of information that may be individually edited or operated upon.">NPacket</a>. Specifically:</p>
<ul>
<li>for those dimensions where <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> derives from <a class="el" href="classregina_1_1NPacket.html" title="Represents a packet of information that may be individually edited or operated upon.">NPacket</a>, the output routines are inherited from <a class="el" href="classregina_1_1NPacket.html" title="Represents a packet of information that may be individually edited or operated upon.">NPacket</a> (which derives from <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a>).</li>
</ul>
<ul>
<li>for other dimensions, <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> derives from <a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> directly.</li>
</ul>
<dl class="section user"><dt>Python:</dt><dd>This base class is not present, but the "end user" class <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> is.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>the dimension of the triangulation. This must be between 2 and 15 inclusive. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="acb85b172fe187672d3495a557aa394bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#acb85b172fe187672d3495a557aa394bf">ComponentIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through connected components. </p>

</div>
</div>
<a class="anchor" id="a9f3023c0479b8cc8aeec3dffa6fa62eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9f3023c0479b8cc8aeec3dffa6fa62eb">SimplexIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through top-dimensional simplices. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaa79cc9e7f5b4f6ea27045ebf3c8fabc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty triangulation. </p>

</div>
</div>
<a class="anchor" id="a51f24cf3815b0d19d5afeae1860fcd0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the triangulation to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace45d0a52d9a2a853f890d1006fedf7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this triangulation. </p>
<p>The simplices within this triangulation will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4cf5ad2a8b5eb264f015405a4a89bb1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::calculatedSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the skeletal objects and properties of this triangulation have been calculated. </p>
<p>These are only calculated "on demand", when a skeletal property is first queried.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the skeleton has been calculated. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d04b371303f07f238af57faf82c9402"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::calculateSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all skeletal objects for this triangulation. </p>
<p>For this parent class, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> computes properties such as connected components, orientability, and lower-dimensional faces. Some <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> subclasses may track additional skeletal data, in which case they should reimplement this function. Their reimplementations <em>must</em> call this parent implementation.</p>
<p>You should never call this function directly; instead call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac385cd2115fc4eaabaf591ba58046cad" title="Ensures that all &quot;on demand&quot; skeletal objects have been calculated.">ensureSkeleton()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>No skeletal objects have been computed, and the corresponding internal lists are all empty.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any call to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> must first cast down to <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a>. You should never directly call this parent implementation (unless of course you are reimplementing <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> in a <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> subclass). </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ee1eaa26fe337535ca3945ef063972"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::component </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested connected component of this triangulation. </p>
<p>Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore this component object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired component; this must be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ea7f4ec2de2b34dbe345bf2ac71274d" title="Returns the number of connected components in this triangulation.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested component. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f19e3f339c50f0b40dfa28c02d31878"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::componentIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the index of the given connected component in this triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000223">Deprecated:</a></b></dt><dd>This routine is deprecated, and will be removed in some future release of Regina. Just call component-&gt;index() instead.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given component belongs to this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>specifies which component to find in the triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified component; this will be an integer between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ea7f4ec2de2b34dbe345bf2ac71274d" title="Returns the number of connected components in this triangulation.">countComponents()</a>-1 inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="af52f03e39a1ac74ad4572d6dc3cb6081"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all connected components of this triangulation. </p>
<p>Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore these component objects should be considered temporary only.</p>
<p>In contrast, this reference to the <em>list</em> of all components will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all components. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f070bcbd3431b51bb680ff7c3077431"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFacets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of boundary facets in this triangulation. </p>
<p>This routine counts facets of top-dimensional simplices that are not glued to some adjacent top-dimensional simplex.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of boundary facets. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ea7f4ec2de2b34dbe345bf2ac71274d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of connected components in this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of connected components. </dd></dl>

</div>
</div>
<a class="anchor" id="ac42b62f7033765a5e146cdaa855e62c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and <em>dim</em>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>countFaces(subdim)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a class="anchor" id="a45b34020172394d10592dd4251468bcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::deleteFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all faces of dimension <em>subdim</em> and below. </p>
<p>This routine destroys the corresponding Face objects and clears the lists that contain them. </p>

</div>
</div>
<a class="anchor" id="a85c4601f644bed4d5972eaef52c68fdc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::deleteSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates all skeletal objects that are managed by this triangulation, and empties all corresponding internal lists. </p>
<p>The next time a user queries some skeletal property, the skeleton will be recalculated.</p>
<p><a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> subclasses should reimplement this if they track additional skeletal data, but they <em>must</em> call this parent implementation.</p>
<p>Note that <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> never calls this routine itself. Typically <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a85c4601f644bed4d5972eaef52c68fdc" title="Deallocates all skeletal objects that are managed by this triangulation, and empties all correspondin...">deleteSkeleton()</a> is only ever called by Triangulation&lt;dim&gt;::clearAllProperties, which in turn is called by the <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> destructor.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any call to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a85c4601f644bed4d5972eaef52c68fdc" title="Deallocates all skeletal objects that are managed by this triangulation, and empties all correspondin...">deleteSkeleton()</a> must first cast down to <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a>. You should never directly call this parent implementation (unless of course you are reimplementing <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a85c4601f644bed4d5972eaef52c68fdc" title="Deallocates all skeletal objects that are managed by this triangulation, and empties all correspondin...">deleteSkeleton()</a> in a <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> subclass). </dd></dl>

</div>
</div>
<a class="anchor" id="a5df13959cbb5b7cc2510eb30b503c166"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dumpConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used with <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af1e8b7cf820ff452059f817d55536155" title="Inserts a given triangulation into this triangulation, where the given triangulation is described by ...">insertConstruction()</a> to reconstruct this triangulation. </p>
<p>The code produced will consist of the following:</p>
<ul>
<li>the declaration and initialisation of two integer arrays, describing the gluings between simplices of this trianguation;</li>
<li>two additional lines that declare a new <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> and call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af1e8b7cf820ff452059f817d55536155" title="Inserts a given triangulation into this triangulation, where the given triangulation is described by ...">insertConstruction()</a> to rebuild this triangulation.</li>
</ul>
<p>The main purpose of this routine is to generate the two integer arrays, which can be tedious and error-prone to code up by hand.</p>
<p>Note that the number of lines of code produced grows linearly with the number of simplices. If this triangulation is very large, the returned string will be very large as well.</p>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ac385cd2115fc4eaabaf591ba58046cad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::ensureSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that all "on demand" skeletal objects have been calculated. </p>

</div>
</div>
<a class="anchor" id="a0333fa8a47302bcf44fa05e3158d9761"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face of this triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and <em>dim</em>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, index)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac42b62f7033765a5e146cdaa855e62c1" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a class="anchor" id="a90b031c48014d00ee9fee402dd989ef5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation. </p>
<p>Bear in mind that each time the triangulation changes, all face objects will be deleted and replaced with new ones. Therefore these face objects should be considered temporary only.</p>
<p>In contrast, this reference to the <a class="el" href="classregina_1_1FaceList.html" title="Stores the list of all subdim-faces of a dim-dimensional triangulation.">FaceList</a> object itself will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python:</dt><dd>Python users should call this function in the form <code>faces(subdim)</code>. It will then return a Python list containing all the <em>subdim</em>-faces of the triangulation. Be warned that, unlike in C++, this Python list will be a snapshot of the faces when this function is called, and will <em>not</em> be kept up-to-date as the triangulation changes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8adeb83255137b4ba522408f77fbe58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::fillFVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given vector with the first (<em>subdim</em> + 1) elements of the f-vector. </p>
<p>Specifically, this routine pushes the values <em>f</em>[0], ..., <em>f</em>[<em>subdim</em>] onto the end of the given vector, where <em>f</em>[<em>k</em>] denotes the number of <em>k</em>-faces that this object stores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the vector in which the results will be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5de089bc182f4e43410ea8b262d47cac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllIsomorphisms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>This routine behaves identically to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a12f9aeb3cd023425abe5642deb8b8a27" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a>, except that instead of returning just one isomorphism, all such isomorphisms are returned.</p>
<p>See the <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a12f9aeb3cd023425abe5642deb8b8a27" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> notes for additional information.</p>
<p>The isomorphisms that are found will be written to the given output iterator. This iterator must accept objects of type Isomorphism&lt;dim&gt;*. As an example, <em>output</em> might be a back_insert_iterator for a std::vector&lt;Isomorphism&lt;dim&gt;*&gt;.</p>
<p>The isomorphisms that are written to the given output iterator will be newly created, and the caller of this routine is responsible for destroying them.</p>
<dl class="section user"><dt>Python:</dt><dd>The <em>output</em> argument is not present. Instead, this routine returns a python list containing all of the isomorphisms that were found.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to which the isomorphisms will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of isomorphisms that were found. </dd></dl>

</div>
</div>
<a class="anchor" id="ad58db7e35de591b91e021fde0838bafd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllSubcomplexesIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>This routine behaves identically to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaae91eb26428486e1804cef4fed7bebd" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation...">isContainedIn()</a>, except that instead of returning just one isomorphism (which may be boundary incomplete and need not be onto), all such isomorphisms are returned.</p>
<p>See the <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaae91eb26428486e1804cef4fed7bebd" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation...">isContainedIn()</a> notes for additional information.</p>
<p>The isomorphisms that are found will be written to the given output iterator. This iterator must accept objects of type Isomorphism&lt;dim&gt;*. As an example, <em>output</em> might be a back_insert_iterator for a std::vector&lt;Isomorphism&lt;dim&gt;*&gt;.</p>
<p>The isomorphisms that are written to the given output iterator will be newly created, and the caller of this routine is responsible for destroying them.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for isomorphic copies of this triangulation. </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to which the isomorphisms will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of isomorphisms that were found. </dd></dl>

</div>
</div>
<a class="anchor" id="adc25a58b48e39f3c7f8621b84432d294"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::finiteToIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts each real boundary component into a cusp (i.e., an ideal vertex). </p>
<p>Only boundary components formed from real (<em>dim</em>-1)-faces will be affected; ideal boundary components are already cusps and so will not be changed.</p>
<p>One side-effect of this operation is that all spherical boundary components will be filled in with balls.</p>
<p>This operation is performed by attaching a new <em>dim</em>-simplex to each boundary (<em>dim</em>-1)-face, and then gluing these new simplices together in a way that mirrors the adjacencies of the underlying boundary facets. Each boundary component will thereby be pushed up through the new simplices and converted into a cusp formed using vertices of these new simplices.</p>
<p>In Regina's <a class="el" href="stddim.html">standard dimensions</a>, where triangulations also support an idealToFinite() operation, this routine is a loose converse of that operation.</p>
<p>In dimension 2, every boundary component is spherical and so this routine simply fills all the punctures in the underlying surface. (In dimension 2, triangulations cannot have cusps).</p>
<dl class="section warning"><dt>Warning</dt><dd>If a real boundary component contains vertices whose links are not discs, this operation may have unexpected results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if changes were made, or <code>false</code> if the original triangulation contained no real boundary components. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a40b9288ac97b1df6a702b12dbe5325"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::fromIsoSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a full triangulation from an isomorphism signature. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afee58a1ea4ea31f25849490a7cd2afad" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>The triangulation that is returned will be newly created, and it is the responsibility of the caller of this routine to destroy it.</p>
<p>Calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afee58a1ea4ea31f25849490a7cd2afad" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> followed by <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> is not guaranteed to produce an <em>identical</em> triangulation to the original, but it is guaranteed to produce a combinatorially <em>isomorphic</em> triangulation. In other words, <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> may reconstruct the triangulation with its simplices and/or vertices relabelled. The optional argument to <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afee58a1ea4ea31f25849490a7cd2afad" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> allows you to determine the precise relabelling that will be used, if you need to know it.</p>
<p>For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of the triangulation to construct. Note that isomorphism signature are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated triangulation if the reconstruction was successful, or <code>null</code> if the given string was not a valid <em>dim</em>-dimensional isomorphism signature. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ff2a6ce37f4021f6d93309ec29a2232"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the f-vector of this triangulation, which counts the number of faces of all dimensions. </p>
<p>The vector that is returned will have length <em>dim</em>+1. If this vector is <em>f</em>, then <em>f</em>[<em>k</em>] will be the number of <em>k</em>-faces for each 0 &le; <em>k</em> &le; <em>dim</em>.</p>
<p>This routine is significantly more heavyweight than <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac42b62f7033765a5e146cdaa855e62c1" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>. Its advantage is that, unlike the templatised <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac42b62f7033765a5e146cdaa855e62c1" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>, it allows you to count faces whose dimensions are not known until runtime.</p>
<dl class="section return"><dt>Returns</dt><dd>the f-vector of this triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="a855675725502f984ea24db34e6b2a9d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::getComponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the requested connected component of this triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000222">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa5ee1eaa26fe337535ca3945ef063972" title="Returns the requested connected component of this triangulation.">component()</a> instead.</dd></dl>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa5ee1eaa26fe337535ca3945ef063972" title="Returns the requested connected component of this triangulation.">component()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="a063f51a8c5f88e26ee430064d980a193"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::getComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns all connected components of this triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000221">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af52f03e39a1ac74ad4572d6dc3cb6081" title="Returns all connected components of this triangulation.">components()</a> instead.</dd></dl>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af52f03e39a1ac74ad4572d6dc3cb6081" title="Returns all connected components of this triangulation.">components()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="a07b66283609320290206e1ca4004c614"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::getNumberOfComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of connected components in this triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000219">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ea7f4ec2de2b34dbe345bf2ac71274d" title="Returns the number of connected components in this triangulation.">countComponents()</a> instead.</dd></dl>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ea7f4ec2de2b34dbe345bf2ac71274d" title="Returns the number of connected components in this triangulation.">countComponents()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="abe3f5cc17fb2daff24640b30287bddaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::getNumberOfFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of <em>subdim</em>-faces in this triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000220">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac42b62f7033765a5e146cdaa855e62c1" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> instead.</dd></dl>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac42b62f7033765a5e146cdaa855e62c1" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="af520138d14508124ffba56446cc91aa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::getNumberOfSimplices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of top-dimensional simplices in the triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000214">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a class="anchor" id="a34ab68add2b36aa759661a3dba52f58c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::getSimplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the top-dimensional simplex at the given index in the triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000216">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> instead.</dd></dl>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="a81b7a336d5871fab5779f75a88a032eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::getSimplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the top-dimensional simplex at the given index in the triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000217">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> instead.</dd></dl>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3" title="Returns the top-dimensional simplex at the given index in the triangulation.">simplex()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="a53ba54e03f1a777d6efbb079227c2a4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::getSimplices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns all of the top-dimensional simplices in the triangulation. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000215">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a721e084ec08bb631e35e14ff1c844f63" title="Returns all top-dimensional simplices in the triangulation.">simplices()</a> instead.</dd></dl>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a721e084ec08bb631e35e14ff1c844f63" title="Returns all top-dimensional simplices in the triangulation.">simplices()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="a517c0fd1ec5190115785b91cca9e61b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::hasBoundaryFacets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation has any boundary facets. </p>
<p>This routine returns <code>true</code> if and only if the triangulation contains some top-dimension simplex with at least one facet that is not glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there are boundary facets. </dd></dl>

</div>
</div>
<a class="anchor" id="af1e8b7cf820ff452059f817d55536155"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::insertConstruction </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>adjacencies</em>[][dim+1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>gluings</em>[][dim+1][dim+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a given triangulation into this triangulation, where the given triangulation is described by a pair of integer arrays. </p>
<p>The main purpose of this routine is to allow users to hard-code triangulations into C++ source files. In particular, all of the simplex gluings can be hard-coded into a pair of integer arrays at the beginning of the source file, avoiding an otherwise tedious sequence of many calls to <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a3a6f3e8808a02cd3c2cb30b6859d307c" title="Joins the given facet of this simplex to some facet of another simplex.">Simplex&lt;dim&gt;::join()</a>. If you have a particular triangulation that you would like to hard-code in this way, you can call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5df13959cbb5b7cc2510eb30b503c166" title="Returns C++ code that can be used with insertConstruction() to reconstruct this triangulation.">dumpConstruction()</a> to generate the corresponding integer arrays as C++ source code.</p>
<p>This routine will insert an additional <em>nSimplices</em> top-dimensional simplices into this triangulation. We number these simplices 0,1,...,<em>nSimplices</em>-1. The gluings between these new simplices should be stored in the two arrays as follows.</p>
<p>The <em>adjacencies</em> array describes which simplices are joined to which others. Specifically, <code>adjacencies[s][f]</code> indicates which of the new simplices is joined to facet <em>f</em> of simplex <em>s</em>. This should be between 0 and <em>nSimplices</em>-1 inclusive, or -1 if facet <em>f</em> of simplex <em>s</em> is to be left as a boundary facet.</p>
<p>The <em>gluings</em> array describes the particular gluing permutations used to join these simplices together. Specifically, <code>gluings[s][f][0..<em>dim</em>]</code> should describe the permutation used to join facet <em>f</em> of simplex <em>s</em> to its adjacent simplex. These <em>dim</em>+1 integers should be 0,1,...,<em>dim</em> in some order, so that <code>gluings[s][f][i]</code> contains the image of <em>i</em> under this permutation. If facet <em>f</em> of simplex <em>s</em> is to be left as a boundary facet, then <code>gluings[s][f][0..<em>dim</em>]</code> may contain anything (and will be duly ignored).</p>
<p>If this triangulation is empty before this routine is called, then the new simplices will be given indices 0,1,...,<em>nSimplices</em>-1 according to the numbering described above. Otherwise they will be inserted after any pre-existing simplices, and so they will be given larger indices instead. In the latter case, the <em>adjacencies</em> array should still refer to the new simplices as 0,1,...,<em>nSimplices</em>-1, and this routine will handle any renumbering automatically at runtime.</p>
<p>It is the responsibility of the caller of this routine to ensure that the given arrays are correct and consistent. No error checking will be performed by this routine.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of additional simplices to insert. </td></tr>
    <tr><td class="paramname">adjacencies</td><td>describes which simplices are adjace to which others, as described above. This array must have initial dimension at least <em>nSimplices</em>. </td></tr>
    <tr><td class="paramname">gluings</td><td>describes the specific gluing permutations, as described above. This array must also have initial dimension at least <em>nSimplices</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bf93dbca6715c1a455a2d47f66a6476"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::insertTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a copy of the given triangulation into this triangulation. </p>
<p>The top-dimensional simplices of <em>source</em> will be copied into this triangulation in the same order in which they appear in <em>source</em>. That is, if the original size of this triangulation was <em>S</em>, then the simplex at index <em>i</em> in <em>source</em> will be copied into this triangulation as a new simplex at index <em>S</em>+<em>i</em>.</p>
<p>The copies will use the same vertex numbering and descriptions as the original simplices from <em>source</em>, and any gluings between the simplices of <em>source</em> will likewise be copied across as gluings between their copies in this triangulation.</p>
<p>This routine behaves correctly when <em>source</em> is this triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the triangulation whose copy will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ee1b7c2fbd1ea4a7a226993caa29e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is connected. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is connected. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae91eb26428486e1804cef4fed7bebd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>Specifically, this routine determines if there is a boundary incomplete combinatorial isomorphism from this triangulation to <em>other</em>. Boundary incomplete isomorphisms are described in detail in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p>In particular, note that facets of top-dimensional simplices that lie on the boundary of this triangulation need not correspond to boundary facets of <em>other</em>, and that <em>other</em> may contain more top-dimensional simplices than this triangulation.</p>
<p>If a boundary incomplete isomorphism is found, the details of this isomorphism are returned. The isomorphism is newly constructed, and so to assist with memory management is returned as a std::unique_ptr. Thus, to test whether an isomorphism exists without having to explicitly deal with the isomorphism itself, you can call <code>if (isContainedIn(other).get())</code> and the newly created isomorphism (if it exists) will be automatically destroyed.</p>
<p>If more than one such isomorphism exists, only one will be returned. For a routine that returns all such isomorphisms, see <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad58db7e35de591b91e021fde0838bafd" title="Finds all ways in which an isomorphic copy of this triangulation is contained within the given triang...">findAllSubcomplexesIn()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for an isomorphic copy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if such a copy is found, or a null pointer otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad26eb19438346ff47f0bf56598070a0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation is empty. </p>
<p>An empty triangulation is one with no simplices at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a00301fd26f1eaaa4df55b94b8369a054"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isIdenticalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially identical to the given triangulation. </p>
<p>Here "identical" means that the triangulations have the same number of top-dimensional simplices, with gluings between the same pairs of numbered simplices using the same gluing permutations. In other words, "identical" means that the triangulations are isomorphic via the identity isomorphism.</p>
<p>For the less strict notion of <em>isomorphic</em> triangulations, which allows relabelling of the top-dimensional simplices and their vertices, see <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a12f9aeb3cd023425abe5642deb8b8a27" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> instead.</p>
<p>This test does <em>not</em> examine the textual simplex descriptions, as seen in <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a5a2fc4cc7eaa9cff459acd055c3684eb" title="Returns the description associated with this simplex.">Simplex&lt;dim&gt;::description()</a>; these may still differ. It also does not test whether lower-dimensional faces are numbered identically (vertices, edges and so on); this routine is only concerned with top-dimensional simplices.</p>
<p>(At the time of writing, two identical triangulations will always number their lower-dimensional faces in the same way. However, it is conceivable that in future versions of Regina there may be situations in which identical triangulations can acquire different numberings for vertices, edges, and so on.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangulations are combinatorially identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a12f9aeb3cd023425abe5642deb8b8a27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>Two triangulations are <em>isomorphic</em> if and only it is possible to relabel their top-dimensional simplices and the (<em>dim</em>+1) vertices of each simplex in a way that makes the two triangulations combinatorially identical, as returned by <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a00301fd26f1eaaa4df55b94b8369a054" title="Determines if this triangulation is combinatorially identical to the given triangulation.">isIdenticalTo()</a>.</p>
<p>Equivalently, two triangulations are isomorphic if and only if there is a one-to-one and onto boundary complete combinatorial isomorphism from this triangulation to <em>other</em>, as described in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p>In particular, note that this triangulation and <em>other</em> must contain the same number of top-dimensional simplices for such an isomorphism to exist.</p>
<p>If the triangulations are isomorphic, then this routine returns one such boundary complete isomorphism (i.e., one such relabelling). The isomorphism will be newly constructed, and to assist with memory management, it will be returned as a std::unique_ptr. Thus, to test whether an isomorphism exists without having to explicitly manage with the isomorphism itself, you can just call <code>if (isIsomorphicTo(other).get())</code>, in which case the newly created isomorphism (if it exists) will be automatically destroyed.</p>
<p>There may be many such isomorphisms between the two triangulations. If you need to find <em>all</em> such isomorphisms, you may call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5de089bc182f4e43410ea8b262d47cac" title="Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation...">findAllIsomorphisms()</a> instead.</p>
<p>If you need to ensure that top-dimensional simplices are labelled the same in both triangulations (i.e., that the triangulations are related by the <em>identity</em> isomorphism), you should call the stricter test <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a00301fd26f1eaaa4df55b94b8369a054" title="Determines if this triangulation is combinatorially identical to the given triangulation.">isIdenticalTo()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd><em>Optimise:</em> Improve the complexity by choosing a simplex mapping from each component and following gluings to determine the others.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if the two triangulations are combinatorially isomorphic, or a null pointer otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab97ba0e2d6e92e92e233d28e237b8a24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is orientable. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is orientable. </dd></dl>

</div>
</div>
<a class="anchor" id="a52193108182bb6cefd2ea267f35479ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets. </p>
<p>Specifically, this routine returns <code>true</code> if and only if every gluing permutation has negative sign.</p>
<p>Note that <em>orientable</em> triangulations are not always <em>oriented</em> by default. You can call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2711fd7c7115ce19b6833f0d61c42bec" title="Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are or...">orient()</a> if you need the top-dimensional simplices to be oriented consistently as described above.</p>
<p>A non-orientable triangulation can never be oriented.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all top-dimensional simplices are oriented consistently.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a class="anchor" id="afee58a1ea4ea31f25849490a7cd2afad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isoSig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; **&#160;</td>
          <td class="paramname"><em>relabelling</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the isomorphism signature for this triangulation. </p>
<p>An <em>isomorphism signature</em> is a compact text representation of a triangulation that uniquely determines the triangulation up to combinatorial isomorphism. That is, two triangulations of dimension <em>dim</em> are combinatorially isomorphic if and only if their isomorphism signatures are the same.</p>
<p>The isomorphism signature is constructed entirely of printable characters, and has length proportional to <code>n log n</code>, where <em>n</em> is the number of top-dimenisonal simplices.</p>
<p>Whilst the format of an isomorphism signature bears some similarity to dehydration strings for 3-manifolds, they are more general: isomorphism signatures can be used with any triangulations, including closed, bounded and/or disconnected triangulations, as well as triangulations with many simplices. Note also that 3-manifold dehydration strings are not unique up to isomorphism (they depend on the particular labelling of tetrahedra).</p>
<p>The time required to construct the isomorphism signature of a triangulation is <code>O((dim!) n^2 log^2 n)</code>. Whilst this is fine for large triangulation, it will be extremly slow for large <em>dimensions</em>.</p>
<p>The routine <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> can be used to recover a triangulation from an isomorphism signature. The triangulation recovered might not be identical to the original, but it will be combinatorially isomorphic.</p>
<p>If <em>relabelling</em> is non-null (i.e., it points to some <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> pointer <em>p</em>), then it will be modified to point to a new isomorphism that describes the precise relationship between this triangulation and the reconstruction from <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>. Specifically, the triangulation that is reconstructed from <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> will be combinatorially identical to <code>relabelling.apply(this)</code>.</p>
<p>For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section user"><dt>Python:</dt><dd>The isomorphism argument is not present. Instead there are two routines: <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>, which returns a string only, and fromIsoSigDetail(), which returns a pair (<em>signature</em>, <em>relabelling</em>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>relabelling</em> is non-null, then this triangulation must be non-empty and connected. The facility to return a relabelling for disconnected triangulations may be added to Regina in a later release.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relabelling</td><td>if this is non-null, it will be modified to point to a new isomorphism that describes the relationship between this triangulation and the triangulation that will be reconstructed from <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism signature of this triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2309f88209fdc55a5408838e5983caf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isoSigComponentSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afee58a1ea4ea31f25849490a7cd2afad" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>If the signature describes a connected triangulation, this routine will simply return the size of that triangulation (e.g., the number of tetrahedra in the case <em>dim</em> = 3). You can also pass an isomorphism signature that describes a disconnected triangulation; however, this routine will only return the number of top-dimensional simplices in the first connected component. If you need the total size of a disconnected triangulation, you will need to reconstruct the full triangulation by calling <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead.</p>
<p>This routine is very fast, since it only examines the first few characters of the isomorphism signature (in which the size of the first component is encoded). However, a side-effect of this is that it is possible to pass an <em>invalid</em> isomorphism signature and still receive a positive result. If you need to test whether a signature is valid or not, you must call <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead, which will examine the entire signature in full.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of a <em>dim</em>-dimensional triangulation. Note that isomorphism signature are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of top-dimensional simplices in the first connected component, or 0 if this could not be determined because the given string was not a valid isomorphism signature. </dd></dl>

</div>
</div>
<a class="anchor" id="a4602a09cb4e9babf8d9bfd33031c6dc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is valid. </p>
<p>There are several conditions that might make a <em>dim</em>-dimensional triangulation invalid:</p>
<ol type="1">
<li>if some face is identified with itself under a non-identity permutation (e.g., an edge is identified with itself in reverse, or a triangle is identified with itself under a rotation);</li>
<li>if some <em>subdim</em>-face does not have an appropriate link. Here the meaning of "appropriate" depends upon the type of face:<ul>
<li>for a face that belongs to some boundary facet(s) of this triangulation, its link must be a topological ball;</li>
<li>for a vertex that does not belong to any boundary facets, its link must be a closed (<em>dim</em> - 1)-manifold;</li>
<li>for a (<em>subdim</em> &ge; 1)-face that does not belong to any boundary facets, its link must be a topological sphere.</li>
</ul>
</li>
</ol>
<p>Condition (1) is tested for all dimensions <em>dim</em>. Condition (2) is more difficult, since it relies on undecidable problems. As a result, (2) is <em>only</em> tested when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>If a triangulation is invalid then you can call <a class="el" href="classregina_1_1detail_1_1FaceValidity.html#abd439c351f0cb7776982f09272494153" title="Determines if this face is valid.">Face&lt;dim, subdim&gt;::isValid()</a> to discover exactly which face(s) are responsible, and you can call <a class="el" href="classregina_1_1detail_1_1FaceValidity.html#abc2cf123b674397a74daac2fccfb0174" title="Determines if this face is identified with itself under a non-identity permutation.">Face&lt;dim, subdim&gt;::hasBadIdentification()</a> and/or <a class="el" href="classregina_1_1detail_1_1FaceValidity.html#a4b05fffb0dc7b9cd2f0670ea9bb3d4ef" title="Determines if this face does not have an appropriate link.">Face&lt;dim, subdim&gt;::hasBadLink()</a> to discover exactly which conditions fail.</p>
<p>Note that all invalid vertices are considered to be on the boundary; see isBoundary() for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a9277bf15589bb730bded019289311ac7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::makeCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form. </p>
<p>This is essentially the lexicographically smallest labelling when the facet gluings are written out in order.</p>
<p>Two triangulations are isomorphic if and only if their canonical forms are identical.</p>
<p>The lexicographic ordering assumes that the facet gluings are written in order of simplex index and then facet number. Each gluing is written as the destination simplex index followed by the gluing permutation (which in turn is written as the images of 0,1,...,<em>dim</em> in order).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This routine currently works only when the triangulation is connected. It may be extended to work with disconnected triangulations in later versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if the triangulation was in canonical form to begin with. </dd></dl>

</div>
</div>
<a class="anchor" id="ae061e36e8ecbfa2f1edc36ed9eb99a51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeDoubleCover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this triangulation into its double cover. </p>
<p>Each orientable component will be duplicated, and each non-orientable component will be converted into its orientable double cover. </p>

</div>
</div>
<a class="anchor" id="ae3fa3daf9672da64a0fa8a82a439d65b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::moveContentsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents. </p>
<p>All top-dimensional simplices that currently belong to <em>dest</em> will remain there (and will keep the same indices in <em>dest</em>). All top-dimensional simplices that belong to this triangulation will be moved into <em>dest</em> also (but in general their indices will change).</p>
<p>This triangulation will become empty as a result.</p>
<p>Any pointers or references to <a class="el" href="classregina_1_1Simplex.html">Simplex&lt;dim&gt;</a> objects will remain valid.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> is not this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the triangulation into which simplices should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad107a418e2691dc5ad7bb9e90dcba437"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex and adds it to this triangulation. </p>
<p>The new simplex will have an empty description. All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="a829224a264241e43a8f2bbdf5bfcb253"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex with the given description and adds it to this triangulation. </p>
<p>All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>Descriptions are optional, may have any format, and may be empty. How descriptions are used is entirely up to the user.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the description to give to the new simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="a2711fd7c7115ce19b6833f0d61c42bec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::orient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible. </p>
<p>This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of each top-dimensional simplices that has negative orientation. The result will be a triangulation where the top-dimensional simplices have their vertices labelled in a way that preserves orientation across adjacent facets. In particular, every gluing permutation will have negative sign.</p>
<p>If this triangulation includes both orientable and non-orientable components, the orientable components will be oriented as described above and the non-orientable components will be left untouched. </p>

</div>
</div>
<a class="anchor" id="a3e91a640743f9ce2710d17eda77d520a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeAllSimplices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all simplices from the triangulation. </p>
<p>As a result, this triangulation will become empty.</p>
<p>All of the simplices that belong to this triangulation will be destroyed immediately. </p>

</div>
</div>
<a class="anchor" id="a7b349c4e1fb4b27a9b20ed53b277a7ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>simplex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given top-dimensional simplex from this triangulation. </p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex is a top-dimensional simplex in this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the simplex to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9f36b004ba6af3d6ce11bdb655650ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplexAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the top-dimensional simplex at the given index in this triangulation. </p>
<p>This is equivalent to calling <code>removeSimplex(simplex(index))</code>.</p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which top-dimensionalsimplex to remove; this must be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8035ecc57099d3d28d59599b65af5feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::sameDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given triangulation have the same <em>k</em>-face degree sequences, for each facial dimension <em>k</em> &le; <em>subdim</em>. </p>
<p>For the purposes of this routine, degree sequences are considered to be unordered.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given triangulation are known to have the same number of <em>k</em>-faces as each other, for each facial dimension <em>k</em> &le; <em>subdim</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all degree sequences considered are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="af963f8d8cb94d216df5158e5204e4927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::sameFVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given triangulation have the same number of <em>k</em>-faces, for each facial dimension <em>k</em> &le; <em>subdim</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the face counts considered are identical for both triangluations. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2e269a7332e80aeec3603881fd175d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="a61ac843dd4a46316960d65a56c28fff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ce68133679df7667c7347499133f240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplexIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>simplex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the index of the given top-dimensional simplex in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000218">Deprecated:</a></b></dt><dd>This routine is deprecated, and will be removed in some future release of Regina. Just call simplex-&gt;index() instead.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex is contained in this triangulation.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Passing a null pointer to this routine will probably crash your program. If you are passing the result of some other routine that <em>might</em> return null (such as <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a4e7dc80caae081bbf7d99b40eb488e51" title="Returns the adjacent simplex that is glued to the given facet of this simplex.">Simplex&lt;dim&gt;::adjacentSimplex</a>), you should explicitly test for null beforehand.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>specifies which simplex to find in the triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the specified simplex; this will be an integer between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="a721e084ec08bb631e35e14ff1c844f63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all top-dimensional simplices in the triangulation. </p>
<p>The reference that is returned will remain valid for as long as the triangulation exists: even as simplices are added and/or removed, it will always reflect the simplices that are currently in the triangulation.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all top-dimensional simplices. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ca55a972a8c21f7e87960431d9ef64c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of top-dimensional simplices in the triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a class="anchor" id="a85435d4303792273aad5e662a7d67426"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::splitIntoComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>componentParent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setLabels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a disconnected triangulation into many smaller triangulations, one for each component. </p>
<p>The new component triangulations will be inserted as children of the given parent packet. The original triangulation (i.e., this triangulation) will be left unchanged.</p>
<p>If the given parent packet is 0, the new component triangulations will be inserted as children of this triangulation.</p>
<p>By default, this routine will assign sensible packet labels to each of the new component triangulations. If these component triangulations are only temporary objects used as part of some larger algorithm, then labels are unnecessary - in this case you can pass <em>setLabels</em> as <code>false</code> to avoid the (small) overhead that these packet labels incur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentParent</td><td>the packet beneath which the new component triangulations will be inserted, or 0 if they should be inserted directly beneath this triangulation. </td></tr>
    <tr><td class="paramname">setLabels</td><td><code>true</code> if the new component triangulations should be assigned sensible packet labels, or <code>false</code> if they should be left without labels at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of new component triangulations constructed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad43e7587b785f281f5f5c553f263484e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::swapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given triangulation. </p>
<p>All top-dimensional simplices that belong to this triangulation will be moved to <em>other</em>, and all top-dimensional simplices that belong to <em>other</em> will be moved to this triangulation.</p>
<p>Any pointers or references to <a class="el" href="classregina_1_1Simplex.html">Simplex&lt;dim&gt;</a> objects will remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a356963e7a7661a0abcc9024a890652ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NMarkedVector.html">NMarkedVector</a>&lt;<a class="el" href="classregina_1_1Simplex.html">Simplex</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::simplices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The top-dimensional simplices that form the triangulation. </p>

</div>
</div>
<a class="anchor" id="a327ad9e8143772575b5701a3c4ad6007"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this triangulation valid? See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4602a09cb4e9babf8d9bfd33031c6dc5" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>generic/detail/<a class="el" href="detail_2component_8h.html">component.h</a></li>
<li>generic/detail/<a class="el" href="detail_2triangulation_8h.html">triangulation.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
