<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Implementation details</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Implementation details</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation details that end users should not need to reference directly.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1FaceListHolder_3_01BoundaryComponentFaceStorage_3_01dim_00_01true_01_4_00_01subdim_01_4.html">regina::detail::FaceListHolder&lt; BoundaryComponentFaceStorage&lt; dim, true &gt;, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that indicates what data type is used by a boundary component class to store a list of <em>subdim</em>-faces.  <a href="structregina_1_1detail_1_1FaceListHolder_3_01BoundaryComponentFaceStorage_3_01dim_00_01true_01_4_00_01subdim_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class that stores all <em>subdim</em>-faces in a component or boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1WeakFaceList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1WeakFaceListSuite.html">regina::detail::WeakFaceListSuite&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class that helps a component or boundary component store its lists of faces.  <a href="classregina_1_1detail_1_1WeakFaceListSuite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for storing the necessary faces of a boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage_3_01dim_00_01false_01_4.html">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for storing the necessary faces of a boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1BoundaryComponentFaceStorage_3_01dim_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for querying the faces of a boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface_3_01dim_00_01allFaces_00_01false_01_4.html">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for querying the faces of a boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1BoundaryComponentFaceInterface_3_01dim_00_01allFaces_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, canBuild_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that manages all data storage for a boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1BoundaryComponentStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage_3_01dim_00_01allFaces_00_01allowVertex_00_01false_01_4.html">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that manages all data storage for a boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1BoundaryComponentStorage_3_01dim_00_01allFaces_00_01allowVertex_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides core functionality for a boundary component of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1BoundaryComponentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1FaceListHolder_3_01Component_3_01dim_01_4_00_01subdim_01_4.html">regina::detail::FaceListHolder&lt; Component&lt; dim &gt;, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that indicates what data type is used by a connected component of a triangulation to store a list of <em>subdim</em>-faces.  <a href="structregina_1_1detail_1_1FaceListHolder_3_01Component_3_01dim_01_4_00_01subdim_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides core functionality for a connected component of a <em>dim</em>-manifold triangulation.  <a href="classregina_1_1detail_1_1ComponentBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1ExampleFromLowDim.html">regina::detail::ExampleFromLowDim&lt; dim, available &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that builds various <em>dim</em>-dimensional triangulations from (<em>dim</em>-1)-dimensional triangulations.  <a href="classregina_1_1detail_1_1ExampleFromLowDim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1ExampleFromLowDim_3_01dim_00_01false_01_4.html">regina::detail::ExampleFromLowDim&lt; dim, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that builds various <em>dim</em>-dimensional triangulations from (<em>dim</em>-1)-dimensional triangulations.  <a href="classregina_1_1detail_1_1ExampleFromLowDim_3_01dim_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core functionality for constructing example <em>dim</em>-dimensional triangulations.  <a href="classregina_1_1detail_1_1ExampleBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides core functionality for describing how a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation appears within each top-dimensional simplex.  <a href="classregina_1_1detail_1_1FaceEmbeddingBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage&lt; dim, codim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for storing all the ways in which a given face of codimension <em>codim</em> in a <em>dim</em>-dimensional triangulation appears within the various top-dimensional simplices.  <a href="classregina_1_1detail_1_1FaceStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity&lt; allowsInvalid, testLinks &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that stores whether a face is valid.  <a href="classregina_1_1detail_1_1FaceValidity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity_3_01false_00_01testLinks_01_4.html">regina::detail::FaceValidity&lt; false, testLinks &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that stores whether a face is valid.  <a href="classregina_1_1detail_1_1FaceValidity_3_01false_00_01testLinks_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceValidity_3_01true_00_01false_01_4.html">regina::detail::FaceValidity&lt; true, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that stores whether a face is valid.  <a href="classregina_1_1detail_1_1FaceValidity_3_01true_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability&lt; allowsNonorientable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that stores whether the link of a face is orientable.  <a href="classregina_1_1detail_1_1FaceOrientability.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceOrientability_3_01false_01_4.html">regina::detail::FaceOrientability&lt; false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that stores whether the link of a face is orientable.  <a href="classregina_1_1detail_1_1FaceOrientability_3_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1FaceListHolder.html">regina::detail::FaceListHolder&lt; class, int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that indicates what data type <em>Base</em> uses to store its list of <em>subdim</em>-faces.  <a href="structregina_1_1detail_1_1FaceListHolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides core functionality for a <em>subdim</em>-face in the skeleton of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1FaceBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html">regina::detail::FaceNumberingAPI&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder class that outlines the functions provided by FaceNumbering&lt;dim, subdim&gt;.  <a href="classregina_1_1detail_1_1FaceNumberingAPI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl&lt; dim, subdim, lex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for numbering <em>subdim</em>-faces of a <em>dim</em>-dimensional simplex.  <a href="classregina_1_1detail_1_1FaceNumberingImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_01dim_00_01subdim_00_01false_01_4.html">regina::detail::FaceNumberingImpl&lt; dim, subdim, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_01dim_00_010_00_01true_01_4.html">regina::detail::FaceNumberingImpl&lt; dim, 0, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_011_00_010_00_01true_01_4.html">regina::detail::FaceNumberingImpl&lt; 1, 0, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_012_00_010_00_01true_01_4.html">regina::detail::FaceNumberingImpl&lt; 2, 0, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_012_00_011_00_01false_01_4.html">regina::detail::FaceNumberingImpl&lt; 2, 1, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_013_00_010_00_01true_01_4.html">regina::detail::FaceNumberingImpl&lt; 3, 0, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_013_00_011_00_01true_01_4.html">regina::detail::FaceNumberingImpl&lt; 3, 1, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_013_00_012_00_01false_01_4.html">regina::detail::FaceNumberingImpl&lt; 3, 2, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_014_00_010_00_01true_01_4.html">regina::detail::FaceNumberingImpl&lt; 4, 0, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_014_00_011_00_01true_01_4.html">regina::detail::FaceNumberingImpl&lt; 4, 1, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_014_00_012_00_01false_01_4.html">regina::detail::FaceNumberingImpl&lt; 4, 2, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl_3_014_00_013_00_01false_01_4.html">regina::detail::FaceNumberingImpl&lt; 4, 3, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core functionality for facet pairings (that is, dual graphs) of <em>dim</em>-dimensional triangulations.  <a href="classregina_1_1detail_1_1FacetPairingBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core functionality for combinatorial isomorphisms between <em>dim</em>-manifold triangulations.  <a href="classregina_1_1detail_1_1IsomorphismBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for storing which <em>subdim</em>-faces of a <em>dim</em>-dimensional triangulation appear within each top-dimensional simplex.  <a href="classregina_1_1detail_1_1SimplexFaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexFacesSuite.html">regina::detail::SimplexFacesSuite&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class that helps a simplex store the details of its lower-dimensional faces.  <a href="classregina_1_1detail_1_1SimplexFacesSuite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides core functionality for a top-dimensional simplex in a <em>dim</em>-manifold triangulation.  <a href="classregina_1_1detail_1_1SimplexBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings&lt; dim_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a collection of compile-time constant strings that describe features of the dimension <em>dim</em>.  <a href="structregina_1_1detail_1_1Strings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class that helps a triangulation store its lists of faces.  <a href="classregina_1_1detail_1_1FaceListSuite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1FaceListHolder_3_01detail_1_1TriangulationBase_3_01dim_01_4_00_01subdim_01_4.html">regina::detail::FaceListHolder&lt; detail::TriangulationBase&lt; dim &gt;, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that indicates what data type is used by a triangulation class to store a list of <em>subdim</em>-faces.  <a href="structregina_1_1detail_1_1FaceListHolder_3_01detail_1_1TriangulationBase_3_01dim_01_4_00_01subdim_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1FaceCalculator.html">regina::detail::FaceCalculator&lt; dim, subdim, codim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class used to calculate lower-dimensional faces in a triangulation.  <a href="structregina_1_1detail_1_1FaceCalculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1BoundaryComponentCalculator.html">regina::detail::BoundaryComponentCalculator&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class used to identify lower-dimensional faces in a boundary component of a triangulation.  <a href="structregina_1_1detail_1_1BoundaryComponentCalculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1EulerCalculator.html">regina::detail::EulerCalculator&lt; dim, subdim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class used to calculate the Euler characteristic of a triangulation.  <a href="structregina_1_1detail_1_1EulerCalculator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1PachnerHelper.html">regina::detail::PachnerHelper&lt; dim, k &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class used to perform Pachner moves on a triangulation.  <a href="structregina_1_1detail_1_1PachnerHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core functionality for <em>dim</em>-dimensional triangulations.  <a href="classregina_1_1detail_1_1TriangulationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase_1_1TopologyLock.html">regina::detail::TriangulationBase&lt; dim &gt;::TopologyLock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary lock on the topological properties of the given triangulation.  <a href="classregina_1_1detail_1_1TriangulationBase_1_1TopologyLock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1detail_1_1XMLTriangulationTags.html">regina::detail::XMLTriangulationTags&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class that indicates the XML tags and attributes used to describe top-dimensional simplices in a <em>dim</em>-dimensional triangulation.  <a href="structregina_1_1detail_1_1XMLTriangulationTags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1XMLSimplexReader.html">regina::detail::XMLSimplexReader&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that reads the XML element for a single top-dimensional simplex in a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1XMLSimplexReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1XMLSimplicesReader.html">regina::detail::XMLSimplicesReader&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that reads the XML element for the set of all top-dimensional simplices in a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1XMLSimplicesReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides core functionality for the XML packet reader that reads a single <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase_1_1AbelianGroupPropertyReader.html">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::AbelianGroupPropertyReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class that reads an abelian group property.  <a href="classregina_1_1detail_1_1XMLTriangulationReaderBase_1_1AbelianGroupPropertyReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase_1_1GroupPresentationPropertyReader.html">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::GroupPresentationPropertyReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class that reads a group presentation property.  <a href="classregina_1_1detail_1_1XMLTriangulationReaderBase_1_1GroupPresentationPropertyReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga418c8789d876bd8d8f8a0ddd5f3d6584"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga418c8789d876bd8d8f8a0ddd5f3d6584">regina::detail::FaceListHolder&lt; BoundaryComponentFaceStorage&lt; dim, true &gt;, subdim &gt;::Holder</a></td></tr>
<tr class="memdesc:ga418c8789d876bd8d8f8a0ddd5f3d6584"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type used by BoundaryComponent&lt;dim&gt; to store the list of all <em>subdim</em>-faces of the boundary component.  <a href="group__detail.html#ga418c8789d876bd8d8f8a0ddd5f3d6584">More...</a><br /></td></tr>
<tr class="separator:ga418c8789d876bd8d8f8a0ddd5f3d6584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b133e58ae4ace39daa2e29aaf4b928"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga35b133e58ae4ace39daa2e29aaf4b928">regina::detail::FaceListHolder&lt; Component&lt; dim &gt;, subdim &gt;::Holder</a></td></tr>
<tr class="memdesc:ga35b133e58ae4ace39daa2e29aaf4b928"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type used by Component&lt;dim&gt; to store the list of all <em>subdim</em>-faces of the connected component.  <a href="group__detail.html#ga35b133e58ae4ace39daa2e29aaf4b928">More...</a><br /></td></tr>
<tr class="separator:ga35b133e58ae4ace39daa2e29aaf4b928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29c1d0f565e50aa76cfca68714347533"><td class="memItemLeft" align="right" valign="top">typedef std::list&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">regina::detail::FacetPairingBase&lt; dim &gt;::IsoList</a></td></tr>
<tr class="memdesc:ga29c1d0f565e50aa76cfca68714347533"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of isomorphisms on facet pairings.  <a href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">More...</a><br /></td></tr>
<tr class="separator:ga29c1d0f565e50aa76cfca68714347533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga950ce31e11866d63683a435e8d76c9bf"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga950ce31e11866d63683a435e8d76c9bf">regina::detail::FacetPairingBase&lt; dim &gt;::Use</a>) (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *, const <a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">IsoList</a> *, void *)</td></tr>
<tr class="memdesc:ga950ce31e11866d63683a435e8d76c9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a facet pairing and its automorphisms.  <a href="group__detail.html#ga950ce31e11866d63683a435e8d76c9bf">More...</a><br /></td></tr>
<tr class="separator:ga950ce31e11866d63683a435e8d76c9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b7e6840cf1d720009ce05f57e837b8c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1IntOfMinSize.html">IntOfMinSize</a>&lt;(dim/8)+1 &gt;::utype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0b7e6840cf1d720009ce05f57e837b8c">regina::detail::SimplexBase&lt; dim &gt;::FacetMask</a></td></tr>
<tr class="memdesc:ga0b7e6840cf1d720009ce05f57e837b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type with at least <em>dim</em>+1 bits.  <a href="group__detail.html#ga0b7e6840cf1d720009ce05f57e837b8c">More...</a><br /></td></tr>
<tr class="separator:ga0b7e6840cf1d720009ce05f57e837b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049ca31b4779c20984f5bf00ef0cd57a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga049ca31b4779c20984f5bf00ef0cd57a">regina::detail::FaceListHolder&lt; detail::TriangulationBase&lt; dim &gt;, subdim &gt;::Holder</a></td></tr>
<tr class="memdesc:ga049ca31b4779c20984f5bf00ef0cd57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data type used by Triangulation&lt;dim&gt; to store the list of all <em>subdim</em>-faces of the triangulation.  <a href="group__detail.html#ga049ca31b4779c20984f5bf00ef0cd57a">More...</a><br /></td></tr>
<tr class="separator:ga049ca31b4779c20984f5bf00ef0cd57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1aaf376920ea61e6f69db225530b174"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae1aaf376920ea61e6f69db225530b174">regina::detail::TriangulationBase&lt; dim &gt;::SimplexIterator</a></td></tr>
<tr class="memdesc:gae1aaf376920ea61e6f69db225530b174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through top-dimensional simplices.  <a href="group__detail.html#gae1aaf376920ea61e6f69db225530b174">More...</a><br /></td></tr>
<tr class="separator:gae1aaf376920ea61e6f69db225530b174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcb97350bb6b69518e4e7592317f3c5"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gacfcb97350bb6b69518e4e7592317f3c5">regina::detail::TriangulationBase&lt; dim &gt;::ComponentIterator</a></td></tr>
<tr class="memdesc:gacfcb97350bb6b69518e4e7592317f3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through connected components.  <a href="group__detail.html#gacfcb97350bb6b69518e4e7592317f3c5">More...</a><br /></td></tr>
<tr class="separator:gacfcb97350bb6b69518e4e7592317f3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2966f74374c8455bfa3a85810094f3c"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa2966f74374c8455bfa3a85810094f3c">regina::detail::TriangulationBase&lt; dim &gt;::BoundaryComponentIterator</a></td></tr>
<tr class="memdesc:gaa2966f74374c8455bfa3a85810094f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through boundary components.  <a href="group__detail.html#gaa2966f74374c8455bfa3a85810094f3c">More...</a><br /></td></tr>
<tr class="separator:gaa2966f74374c8455bfa3a85810094f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7544f6c646dc7aed9d8a3f07d917da4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa7544f6c646dc7aed9d8a3f07d917da4">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::AbelianGroupPropertyReader::PropType</a></td></tr>
<tr class="memdesc:gaa7544f6c646dc7aed9d8a3f07d917da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the property currently being read.  <a href="group__detail.html#gaa7544f6c646dc7aed9d8a3f07d917da4">More...</a><br /></td></tr>
<tr class="separator:gaa7544f6c646dc7aed9d8a3f07d917da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d74c424017288ecce4629d2f88ae2a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab6d74c424017288ecce4629d2f88ae2a">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::GroupPresentationPropertyReader::PropType</a></td></tr>
<tr class="memdesc:gab6d74c424017288ecce4629d2f88ae2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the property currently being read.  <a href="group__detail.html#gab6d74c424017288ecce4629d2f88ae2a">More...</a><br /></td></tr>
<tr class="separator:gab6d74c424017288ecce4629d2f88ae2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2a8a26a3d5cd1642df574b639498cd88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2a8a26a3d5cd1642df574b639498cd88">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::ReorderIterator</a> ()</td></tr>
<tr class="memdesc:ga2a8a26a3d5cd1642df574b639498cd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an uninitialised iterator.  <a href="group__detail.html#ga2a8a26a3d5cd1642df574b639498cd88">More...</a><br /></td></tr>
<tr class="separator:ga2a8a26a3d5cd1642df574b639498cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c7924f66c204b8a751c87c3479b5dfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3c7924f66c204b8a751c87c3479b5dfa">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::ReorderIterator</a> (typename std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt;::const_iterator it, <a class="el" href="classregina_1_1Face.html">Face</a>&lt; tridim, subdim &gt; **map)</td></tr>
<tr class="memdesc:ga3c7924f66c204b8a751c87c3479b5dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an iterator that points to the given face of this list, using the given map to convert faces of this list to faces of the other triangulation <em>tri</em>.  <a href="group__detail.html#ga3c7924f66c204b8a751c87c3479b5dfa">More...</a><br /></td></tr>
<tr class="separator:ga3c7924f66c204b8a751c87c3479b5dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba549fd5891777b0147eec3e74733b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7ba549fd5891777b0147eec3e74733b0">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::ReorderIterator</a> (const ReorderIterator &amp;)=default</td></tr>
<tr class="memdesc:ga7ba549fd5891777b0147eec3e74733b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="group__detail.html#ga7ba549fd5891777b0147eec3e74733b0">More...</a><br /></td></tr>
<tr class="separator:ga7ba549fd5891777b0147eec3e74733b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c11cfec38b2c8329f7a8bda7700c17c"><td class="memItemLeft" align="right" valign="top">ReorderIterator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3c11cfec38b2c8329f7a8bda7700c17c">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator=</a> (const ReorderIterator &amp;)=default</td></tr>
<tr class="memdesc:ga3c11cfec38b2c8329f7a8bda7700c17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="group__detail.html#ga3c11cfec38b2c8329f7a8bda7700c17c">More...</a><br /></td></tr>
<tr class="separator:ga3c11cfec38b2c8329f7a8bda7700c17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae059e8a5184cfa1191e3866f76d8216f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae059e8a5184cfa1191e3866f76d8216f">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator==</a> (const ReorderIterator &amp;rhs) const</td></tr>
<tr class="memdesc:gae059e8a5184cfa1191e3866f76d8216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator point to the same face.  <a href="group__detail.html#gae059e8a5184cfa1191e3866f76d8216f">More...</a><br /></td></tr>
<tr class="separator:gae059e8a5184cfa1191e3866f76d8216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0ecdb62dde9a1bd5861d79f15d3a358"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf0ecdb62dde9a1bd5861d79f15d3a358">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator!=</a> (const ReorderIterator &amp;rhs) const</td></tr>
<tr class="memdesc:gaf0ecdb62dde9a1bd5861d79f15d3a358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator point to different faces.  <a href="group__detail.html#gaf0ecdb62dde9a1bd5861d79f15d3a358">More...</a><br /></td></tr>
<tr class="separator:gaf0ecdb62dde9a1bd5861d79f15d3a358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c2a5c430c3de279cc04cbb49a34027"><td class="memItemLeft" align="right" valign="top">ReorderIterator &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae8c2a5c430c3de279cc04cbb49a34027">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator++</a> ()</td></tr>
<tr class="memdesc:gae8c2a5c430c3de279cc04cbb49a34027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator that steps to the next face in this list.  <a href="group__detail.html#gae8c2a5c430c3de279cc04cbb49a34027">More...</a><br /></td></tr>
<tr class="separator:gae8c2a5c430c3de279cc04cbb49a34027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3675bcbdd1e3d45e00e488dca5cd10"><td class="memItemLeft" align="right" valign="top">ReorderIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga5c3675bcbdd1e3d45e00e488dca5cd10">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator++</a> (int)</td></tr>
<tr class="memdesc:ga5c3675bcbdd1e3d45e00e488dca5cd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator that steps to the next face in this list.  <a href="group__detail.html#ga5c3675bcbdd1e3d45e00e488dca5cd10">More...</a><br /></td></tr>
<tr class="separator:ga5c3675bcbdd1e3d45e00e488dca5cd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace94139db834bccc3cf6f2a130d90eda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; tridim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gace94139db834bccc3cf6f2a130d90eda">regina::detail::WeakFaceList&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator*</a> () const</td></tr>
<tr class="memdesc:gace94139db834bccc3cf6f2a130d90eda"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the face of the other triangulation <em>tri</em> that corresponds to the current face in this list.  <a href="group__detail.html#gace94139db834bccc3cf6f2a130d90eda">More...</a><br /></td></tr>
<tr class="separator:gace94139db834bccc3cf6f2a130d90eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga792b2bf2791de7bcb02591f76b277a0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga792b2bf2791de7bcb02591f76b277a0d">regina::detail::WeakFaceList&lt; dim, subdim &gt;::WeakFaceList</a> ()=default</td></tr>
<tr class="memdesc:ga792b2bf2791de7bcb02591f76b277a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that leaves the list of faces empty.  <a href="group__detail.html#ga792b2bf2791de7bcb02591f76b277a0d">More...</a><br /></td></tr>
<tr class="separator:ga792b2bf2791de7bcb02591f76b277a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c8335e8a11aa5f623daeedf8bc3472"><td class="memTemplParams" colspan="2">template&lt;int tridim&gt; </td></tr>
<tr class="memitem:ga49c8335e8a11aa5f623daeedf8bc3472"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga49c8335e8a11aa5f623daeedf8bc3472">regina::detail::WeakFaceList&lt; dim, subdim &gt;::reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *tri, const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;tridimFaces) const</td></tr>
<tr class="memdesc:ga49c8335e8a11aa5f623daeedf8bc3472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders and relabels all <em>subdim</em>-faces of the given triangulation so that they appear in the same order as the corresponding faces in this list, and so that their vertices are numbered in a corresponding way.  <a href="group__detail.html#ga49c8335e8a11aa5f623daeedf8bc3472">More...</a><br /></td></tr>
<tr class="separator:ga49c8335e8a11aa5f623daeedf8bc3472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b1d96683b54d9006694513b5ae92a6"><td class="memItemLeft" align="right" valign="top"><a id="ga50b1d96683b54d9006694513b5ae92a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::WeakFaceList&lt; dim, subdim &gt;::WeakFaceList</b> (const <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">WeakFaceList</a> &amp;)=delete</td></tr>
<tr class="separator:ga50b1d96683b54d9006694513b5ae92a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3234cd7d73a0e32cfe7e75129c27e830"><td class="memItemLeft" align="right" valign="top"><a id="ga3234cd7d73a0e32cfe7e75129c27e830"></a>
<a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">WeakFaceList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::WeakFaceList&lt; dim, subdim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">WeakFaceList</a> &amp;)=delete</td></tr>
<tr class="separator:ga3234cd7d73a0e32cfe7e75129c27e830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73becf4d57e83b9199775bc9b1378fae"><td class="memTemplParams" colspan="2">template&lt;int tridim&gt; </td></tr>
<tr class="memitem:ga73becf4d57e83b9199775bc9b1378fae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga73becf4d57e83b9199775bc9b1378fae">regina::detail::WeakFaceListSuite&lt; dim, subdim &gt;::reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *tri, const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;tridimFaces) const</td></tr>
<tr class="memdesc:ga73becf4d57e83b9199775bc9b1378fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders and relabels all faces of all dimensions 0,...,<em>subdim</em> of the given triangulation, so that for each <em>k</em>, the <em>k</em>-faces of the given triangulation appear in the same order as the corresponding <em>k</em>-faces in this suite, and have their vertices numbered in a corresponding way.  <a href="group__detail.html#ga73becf4d57e83b9199775bc9b1378fae">More...</a><br /></td></tr>
<tr class="separator:ga73becf4d57e83b9199775bc9b1378fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga483ae78a8682ebace035a95c4e1eac12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga483ae78a8682ebace035a95c4e1eac12">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::size</a> () const</td></tr>
<tr class="memdesc:ga483ae78a8682ebace035a95c4e1eac12"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-1)-faces in this boundary component.  <a href="group__detail.html#ga483ae78a8682ebace035a95c4e1eac12">More...</a><br /></td></tr>
<tr class="separator:ga483ae78a8682ebace035a95c4e1eac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b9175365dfc003ea3ef238ec1fb5a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaaa1b9175365dfc003ea3ef238ec1fb5a">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::countRidges</a> () const</td></tr>
<tr class="memdesc:gaaa1b9175365dfc003ea3ef238ec1fb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-2)-faces in this boundary component.  <a href="group__detail.html#gaaa1b9175365dfc003ea3ef238ec1fb5a">More...</a><br /></td></tr>
<tr class="separator:gaaa1b9175365dfc003ea3ef238ec1fb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cf61d217e99a5ae34d7b5d4f7c427e9"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga8cf61d217e99a5ae34d7b5d4f7c427e9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8cf61d217e99a5ae34d7b5d4f7c427e9">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::countFaces</a> () const</td></tr>
<tr class="memdesc:ga8cf61d217e99a5ae34d7b5d4f7c427e9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this boundary component.  <a href="group__detail.html#ga8cf61d217e99a5ae34d7b5d4f7c427e9">More...</a><br /></td></tr>
<tr class="separator:ga8cf61d217e99a5ae34d7b5d4f7c427e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133608401c59bc96e1bbc7e2785ed72d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga133608401c59bc96e1bbc7e2785ed72d">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::facets</a> () const</td></tr>
<tr class="memdesc:ga133608401c59bc96e1bbc7e2785ed72d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all (<em>dim</em>-1)-faces in this boundary component.  <a href="group__detail.html#ga133608401c59bc96e1bbc7e2785ed72d">More...</a><br /></td></tr>
<tr class="separator:ga133608401c59bc96e1bbc7e2785ed72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed8ba830f6428fba6cd71b4e9e8f58d"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga1ed8ba830f6428fba6cd71b4e9e8f58d"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1ed8ba830f6428fba6cd71b4e9e8f58d">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::faces</a> () const</td></tr>
<tr class="memdesc:ga1ed8ba830f6428fba6cd71b4e9e8f58d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all <em>subdim</em>-faces in this boundary component.  <a href="group__detail.html#ga1ed8ba830f6428fba6cd71b4e9e8f58d">More...</a><br /></td></tr>
<tr class="separator:ga1ed8ba830f6428fba6cd71b4e9e8f58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf700895bba89bdb331ae7f0a0958d947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf700895bba89bdb331ae7f0a0958d947">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::facet</a> (size_t index) const</td></tr>
<tr class="memdesc:gaf700895bba89bdb331ae7f0a0958d947"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested (<em>dim</em>-1)-face in this boundary component.  <a href="group__detail.html#gaf700895bba89bdb331ae7f0a0958d947">More...</a><br /></td></tr>
<tr class="separator:gaf700895bba89bdb331ae7f0a0958d947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eeb9248ad6e7c14665825dba89e57e5"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga7eeb9248ad6e7c14665825dba89e57e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7eeb9248ad6e7c14665825dba89e57e5">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::face</a> (size_t index) const</td></tr>
<tr class="memdesc:ga7eeb9248ad6e7c14665825dba89e57e5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face in this boundary component.  <a href="group__detail.html#ga7eeb9248ad6e7c14665825dba89e57e5">More...</a><br /></td></tr>
<tr class="separator:ga7eeb9248ad6e7c14665825dba89e57e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5035b1f08320755fa39468231aaab0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf5035b1f08320755fa39468231aaab0f">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::triangulation</a> () const</td></tr>
<tr class="memdesc:gaf5035b1f08320755fa39468231aaab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this boundary component belongs.  <a href="group__detail.html#gaf5035b1f08320755fa39468231aaab0f">More...</a><br /></td></tr>
<tr class="separator:gaf5035b1f08320755fa39468231aaab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002ba14e514d4bfc13d110bb03a8855a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga002ba14e514d4bfc13d110bb03a8855a">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::component</a> () const</td></tr>
<tr class="memdesc:ga002ba14e514d4bfc13d110bb03a8855a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this boundary component belongs.  <a href="group__detail.html#ga002ba14e514d4bfc13d110bb03a8855a">More...</a><br /></td></tr>
<tr class="separator:ga002ba14e514d4bfc13d110bb03a8855a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga433519f91dc8bb5feab3fae9ba1d7f9c"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga433519f91dc8bb5feab3fae9ba1d7f9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga433519f91dc8bb5feab3fae9ba1d7f9c">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *<a class="el" href="group__detail.html#ga7eeb9248ad6e7c14665825dba89e57e5">face</a>)</td></tr>
<tr class="memdesc:ga433519f91dc8bb5feab3fae9ba1d7f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given face onto the end of the list of <em>subdim</em>-faces of this boundary component.  <a href="group__detail.html#ga433519f91dc8bb5feab3fae9ba1d7f9c">More...</a><br /></td></tr>
<tr class="separator:ga433519f91dc8bb5feab3fae9ba1d7f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae95037dfb38a8f7488908cfa84649111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae95037dfb38a8f7488908cfa84649111">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *tri) const</td></tr>
<tr class="memdesc:gae95037dfb38a8f7488908cfa84649111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way.  <a href="group__detail.html#gae95037dfb38a8f7488908cfa84649111">More...</a><br /></td></tr>
<tr class="separator:gae95037dfb38a8f7488908cfa84649111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35950a8c9912f9a9317370b9c3614b7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga35950a8c9912f9a9317370b9c3614b7e">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::size</a> () const</td></tr>
<tr class="memdesc:ga35950a8c9912f9a9317370b9c3614b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-1)-faces in this boundary component.  <a href="group__detail.html#ga35950a8c9912f9a9317370b9c3614b7e">More...</a><br /></td></tr>
<tr class="separator:ga35950a8c9912f9a9317370b9c3614b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b7c7f51442b75f254d3ca507ca4228"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa2b7c7f51442b75f254d3ca507ca4228">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::countRidges</a> () const</td></tr>
<tr class="memdesc:gaa2b7c7f51442b75f254d3ca507ca4228"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-2)-faces in this boundary component.  <a href="group__detail.html#gaa2b7c7f51442b75f254d3ca507ca4228">More...</a><br /></td></tr>
<tr class="separator:gaa2b7c7f51442b75f254d3ca507ca4228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3b16fb3280f5ea51ee683494ddc82c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaea3b16fb3280f5ea51ee683494ddc82c">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::facets</a> () const</td></tr>
<tr class="memdesc:gaea3b16fb3280f5ea51ee683494ddc82c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all (<em>dim</em>-1)-faces in this boundary component.  <a href="group__detail.html#gaea3b16fb3280f5ea51ee683494ddc82c">More...</a><br /></td></tr>
<tr class="separator:gaea3b16fb3280f5ea51ee683494ddc82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4071539381c57d0f674bb8ec0ab242e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf4071539381c57d0f674bb8ec0ab242e">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::facet</a> (size_t index) const</td></tr>
<tr class="memdesc:gaf4071539381c57d0f674bb8ec0ab242e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested (<em>dim</em>-1)-face in this boundary component.  <a href="group__detail.html#gaf4071539381c57d0f674bb8ec0ab242e">More...</a><br /></td></tr>
<tr class="separator:gaf4071539381c57d0f674bb8ec0ab242e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac7fe03286ae8bd47dda1dee0a925ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9ac7fe03286ae8bd47dda1dee0a925ab">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::triangulation</a> () const</td></tr>
<tr class="memdesc:ga9ac7fe03286ae8bd47dda1dee0a925ab"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this boundary component belongs.  <a href="group__detail.html#ga9ac7fe03286ae8bd47dda1dee0a925ab">More...</a><br /></td></tr>
<tr class="separator:ga9ac7fe03286ae8bd47dda1dee0a925ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff1725cbcd8bda07c8692fe87511b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9ff1725cbcd8bda07c8692fe87511b3f">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::component</a> () const</td></tr>
<tr class="memdesc:ga9ff1725cbcd8bda07c8692fe87511b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this boundary component belongs.  <a href="group__detail.html#ga9ff1725cbcd8bda07c8692fe87511b3f">More...</a><br /></td></tr>
<tr class="separator:ga9ff1725cbcd8bda07c8692fe87511b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3974ccbafe67bf72ead0c6d85a51e85"><td class="memItemLeft" align="right" valign="top"><a id="gad3974ccbafe67bf72ead0c6d85a51e85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::BoundaryComponentFaceStorage</b> (const <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">BoundaryComponentFaceStorage</a> &amp;)=delete</td></tr>
<tr class="separator:gad3974ccbafe67bf72ead0c6d85a51e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9039ae10354b245e731810b7461ef95"><td class="memItemLeft" align="right" valign="top"><a id="gaf9039ae10354b245e731810b7461ef95"></a>
<a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">BoundaryComponentFaceStorage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">BoundaryComponentFaceStorage</a> &amp;)=delete</td></tr>
<tr class="separator:gaf9039ae10354b245e731810b7461ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa83c814c5ab1810e5df0ae99865e7c82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa83c814c5ab1810e5df0ae99865e7c82">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::BoundaryComponentFaceStorage</a> ()</td></tr>
<tr class="memdesc:gaa83c814c5ab1810e5df0ae99865e7c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that initialises the number of ridges to zero.  <a href="group__detail.html#gaa83c814c5ab1810e5df0ae99865e7c82">More...</a><br /></td></tr>
<tr class="separator:gaa83c814c5ab1810e5df0ae99865e7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab649c27ae3010716a1dd25a3288b46da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab649c27ae3010716a1dd25a3288b46da">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *face)</td></tr>
<tr class="memdesc:gab649c27ae3010716a1dd25a3288b46da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given face onto the end of the list of (<em>dim</em>-1)-faces of this boundary component.  <a href="group__detail.html#gab649c27ae3010716a1dd25a3288b46da">More...</a><br /></td></tr>
<tr class="separator:gab649c27ae3010716a1dd25a3288b46da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0119fa12357a0352b51c8de0de1340f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0119fa12357a0352b51c8de0de1340f9">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-2 &gt; *)</td></tr>
<tr class="memdesc:ga0119fa12357a0352b51c8de0de1340f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the number of (<em>dim</em>-2)-faces in this boundary component.  <a href="group__detail.html#ga0119fa12357a0352b51c8de0de1340f9">More...</a><br /></td></tr>
<tr class="separator:ga0119fa12357a0352b51c8de0de1340f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ef18de0beda82356f7cdb98c7fb6d5"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:gae6ef18de0beda82356f7cdb98c7fb6d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#gae6ef18de0beda82356f7cdb98c7fb6d5">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *)</td></tr>
<tr class="memdesc:gae6ef18de0beda82356f7cdb98c7fb6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing, since this boundary component does not store lower-dimensional faces.  <a href="group__detail.html#gae6ef18de0beda82356f7cdb98c7fb6d5">More...</a><br /></td></tr>
<tr class="separator:gae6ef18de0beda82356f7cdb98c7fb6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0fc09c9297c0471e6ffa647f7def8c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae0fc09c9297c0471e6ffa647f7def8c2">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::reorderAndRelabelFaces</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *) const</td></tr>
<tr class="memdesc:gae0fc09c9297c0471e6ffa647f7def8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way.  <a href="group__detail.html#gae0fc09c9297c0471e6ffa647f7def8c2">More...</a><br /></td></tr>
<tr class="separator:gae0fc09c9297c0471e6ffa647f7def8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61771dae69054fc0c9bb42a5966916de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga61771dae69054fc0c9bb42a5966916de">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;::isReal</a> () const</td></tr>
<tr class="memdesc:ga61771dae69054fc0c9bb42a5966916de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is real.  <a href="group__detail.html#ga61771dae69054fc0c9bb42a5966916de">More...</a><br /></td></tr>
<tr class="separator:ga61771dae69054fc0c9bb42a5966916de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabbc78362654ae62c31e3a2707d131e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;::isIdeal</a> () const</td></tr>
<tr class="memdesc:gaabbc78362654ae62c31e3a2707d131e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is ideal.  <a href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9">More...</a><br /></td></tr>
<tr class="separator:gaabbc78362654ae62c31e3a2707d131e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab697465cdf1282c9ae1e4ed54b9d359d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;::isInvalidVertex</a> () const</td></tr>
<tr class="memdesc:gab697465cdf1282c9ae1e4ed54b9d359d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component consists of a single invalid vertex and nothing else.  <a href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d">More...</a><br /></td></tr>
<tr class="separator:gab697465cdf1282c9ae1e4ed54b9d359d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68da49bd858b8b7f9016b7824bd7489f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga68da49bd858b8b7f9016b7824bd7489f">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga68da49bd858b8b7f9016b7824bd7489f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#ga68da49bd858b8b7f9016b7824bd7489f">More...</a><br /></td></tr>
<tr class="separator:ga68da49bd858b8b7f9016b7824bd7489f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf56261b6f8f242d925a03de69db78f35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf56261b6f8f242d925a03de69db78f35">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaf56261b6f8f242d925a03de69db78f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__detail.html#gaf56261b6f8f242d925a03de69db78f35">More...</a><br /></td></tr>
<tr class="separator:gaf56261b6f8f242d925a03de69db78f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d3a55fb04716f4fdb002e4bdf5ae88f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8d3a55fb04716f4fdb002e4bdf5ae88f">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;::buildVertexLink</a> () const</td></tr>
<tr class="memdesc:ga8d3a55fb04716f4fdb002e4bdf5ae88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulates the vertex link for an ideal or invalid vertex boundary component.  <a href="group__detail.html#ga8d3a55fb04716f4fdb002e4bdf5ae88f">More...</a><br /></td></tr>
<tr class="separator:ga8d3a55fb04716f4fdb002e4bdf5ae88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9df5a9c7bfb67c3dc8a0eb3dc4179c9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9df5a9c7bfb67c3dc8a0eb3dc4179c9c">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, false &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga9df5a9c7bfb67c3dc8a0eb3dc4179c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#ga9df5a9c7bfb67c3dc8a0eb3dc4179c9c">More...</a><br /></td></tr>
<tr class="separator:ga9df5a9c7bfb67c3dc8a0eb3dc4179c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga114bc5936a4dc942edfd9b3e8c07df32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga114bc5936a4dc942edfd9b3e8c07df32">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, false &gt;::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga114bc5936a4dc942edfd9b3e8c07df32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__detail.html#ga114bc5936a4dc942edfd9b3e8c07df32">More...</a><br /></td></tr>
<tr class="separator:ga114bc5936a4dc942edfd9b3e8c07df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1270e786c2239f1d8ebd9b2d45d4619a"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1270e786c2239f1d8ebd9b2d45d4619a">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, false &gt;::buildVertexLink</a> () const</td></tr>
<tr class="memdesc:ga1270e786c2239f1d8ebd9b2d45d4619a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns <code>null</code>.  <a href="group__detail.html#ga1270e786c2239f1d8ebd9b2d45d4619a">More...</a><br /></td></tr>
<tr class="separator:ga1270e786c2239f1d8ebd9b2d45d4619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf807470f4260056753b5efbfacaa8e7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf807470f4260056753b5efbfacaa8e7f">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, canBuild_ &gt;::~BoundaryComponentStorage</a> ()</td></tr>
<tr class="memdesc:gaf807470f4260056753b5efbfacaa8e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this object.  <a href="group__detail.html#gaf807470f4260056753b5efbfacaa8e7f">More...</a><br /></td></tr>
<tr class="separator:gaf807470f4260056753b5efbfacaa8e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga833940ddf9a9813d8a683f1ed8697999"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga833940ddf9a9813d8a683f1ed8697999">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, canBuild_ &gt;::build</a> () const</td></tr>
<tr class="memdesc:ga833940ddf9a9813d8a683f1ed8697999"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the full (<em>dim</em>-1)-dimensional triangulation of this boundary component.  <a href="group__detail.html#ga833940ddf9a9813d8a683f1ed8697999">More...</a><br /></td></tr>
<tr class="separator:ga833940ddf9a9813d8a683f1ed8697999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdc50d6153c5826b4fc0f2ba99d55b1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gafdc50d6153c5826b4fc0f2ba99d55b1c">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, canBuild_ &gt;::BoundaryComponentStorage</a> ()</td></tr>
<tr class="memdesc:gafdc50d6153c5826b4fc0f2ba99d55b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the cached boundary triangulation to <code>null</code>.  <a href="group__detail.html#gafdc50d6153c5826b4fc0f2ba99d55b1c">More...</a><br /></td></tr>
<tr class="separator:gafdc50d6153c5826b4fc0f2ba99d55b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9534baaeaff9e8f432a7e18455f3484c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9534baaeaff9e8f432a7e18455f3484c">regina::detail::BoundaryComponentBase&lt; dim &gt;::index</a> () const</td></tr>
<tr class="memdesc:ga9534baaeaff9e8f432a7e18455f3484c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this boundary component in the underlying triangulation.  <a href="group__detail.html#ga9534baaeaff9e8f432a7e18455f3484c">More...</a><br /></td></tr>
<tr class="separator:ga9534baaeaff9e8f432a7e18455f3484c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167bb8084a603316a0229b915b0f221a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga167bb8084a603316a0229b915b0f221a">regina::detail::BoundaryComponentBase&lt; dim &gt;::isOrientable</a> () const</td></tr>
<tr class="memdesc:ga167bb8084a603316a0229b915b0f221a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this boundary component is orientable.  <a href="group__detail.html#ga167bb8084a603316a0229b915b0f221a">More...</a><br /></td></tr>
<tr class="separator:ga167bb8084a603316a0229b915b0f221a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae85fbc0ce099327db584b2ac6d43de"><td class="memItemLeft" align="right" valign="top"><a id="ga5ae85fbc0ce099327db584b2ac6d43de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::BoundaryComponentBase&lt; dim &gt;::BoundaryComponentBase</b> (const <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">BoundaryComponentBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga5ae85fbc0ce099327db584b2ac6d43de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f2abe88356c483cbb41a8f21f8b05c9"><td class="memItemLeft" align="right" valign="top"><a id="ga9f2abe88356c483cbb41a8f21f8b05c9"></a>
<a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">BoundaryComponentBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::BoundaryComponentBase&lt; dim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">BoundaryComponentBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga9f2abe88356c483cbb41a8f21f8b05c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd5cf5e44180624e63eaba4caceace5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8fd5cf5e44180624e63eaba4caceace5">regina::detail::BoundaryComponentBase&lt; dim &gt;::BoundaryComponentBase</a> ()=default</td></tr>
<tr class="memdesc:ga8fd5cf5e44180624e63eaba4caceace5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that leaves orientability uninitialised.  <a href="group__detail.html#ga8fd5cf5e44180624e63eaba4caceace5">More...</a><br /></td></tr>
<tr class="separator:ga8fd5cf5e44180624e63eaba4caceace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e104f0a39be4e2167aa83588608102b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2e104f0a39be4e2167aa83588608102b">regina::detail::ComponentBase&lt; dim &gt;::index</a> () const</td></tr>
<tr class="memdesc:ga2e104f0a39be4e2167aa83588608102b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this component within the underlying triangulation.  <a href="group__detail.html#ga2e104f0a39be4e2167aa83588608102b">More...</a><br /></td></tr>
<tr class="separator:ga2e104f0a39be4e2167aa83588608102b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e197585833b2a82f9e8ed66e0a5885"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga60e197585833b2a82f9e8ed66e0a5885">regina::detail::ComponentBase&lt; dim &gt;::size</a> () const</td></tr>
<tr class="memdesc:ga60e197585833b2a82f9e8ed66e0a5885"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of top-dimensional simplices in this component.  <a href="group__detail.html#ga60e197585833b2a82f9e8ed66e0a5885">More...</a><br /></td></tr>
<tr class="separator:ga60e197585833b2a82f9e8ed66e0a5885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3fe41e995104afc85e54c9f44f560a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gace3fe41e995104afc85e54c9f44f560a">regina::detail::ComponentBase&lt; dim &gt;::simplices</a> () const</td></tr>
<tr class="memdesc:gace3fe41e995104afc85e54c9f44f560a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all top-dimensional simplices in this component.  <a href="group__detail.html#gace3fe41e995104afc85e54c9f44f560a">More...</a><br /></td></tr>
<tr class="separator:gace3fe41e995104afc85e54c9f44f560a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b240393651b978c8c842e14f175f500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga5b240393651b978c8c842e14f175f500">regina::detail::ComponentBase&lt; dim &gt;::simplex</a> (size_t <a class="el" href="group__detail.html#ga2e104f0a39be4e2167aa83588608102b">index</a>) const</td></tr>
<tr class="memdesc:ga5b240393651b978c8c842e14f175f500"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in this component.  <a href="group__detail.html#ga5b240393651b978c8c842e14f175f500">More...</a><br /></td></tr>
<tr class="separator:ga5b240393651b978c8c842e14f175f500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe9b175112531dacb7c03c59622b778"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7fe9b175112531dacb7c03c59622b778">regina::detail::ComponentBase&lt; dim &gt;::countBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:ga7fe9b175112531dacb7c03c59622b778"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of boundary components in this component.  <a href="group__detail.html#ga7fe9b175112531dacb7c03c59622b778">More...</a><br /></td></tr>
<tr class="separator:ga7fe9b175112531dacb7c03c59622b778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85bd2099351cef31315cc0e0a1cb8713"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga85bd2099351cef31315cc0e0a1cb8713">regina::detail::ComponentBase&lt; dim &gt;::boundaryComponents</a> () const</td></tr>
<tr class="memdesc:ga85bd2099351cef31315cc0e0a1cb8713"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all boundary components in this component.  <a href="group__detail.html#ga85bd2099351cef31315cc0e0a1cb8713">More...</a><br /></td></tr>
<tr class="separator:ga85bd2099351cef31315cc0e0a1cb8713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f459ae138f99ef5c6627ce8e212347"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga55f459ae138f99ef5c6627ce8e212347">regina::detail::ComponentBase&lt; dim &gt;::boundaryComponent</a> (size_t <a class="el" href="group__detail.html#ga2e104f0a39be4e2167aa83588608102b">index</a>) const</td></tr>
<tr class="memdesc:ga55f459ae138f99ef5c6627ce8e212347"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the boundary component at the given index in this component.  <a href="group__detail.html#ga55f459ae138f99ef5c6627ce8e212347">More...</a><br /></td></tr>
<tr class="separator:ga55f459ae138f99ef5c6627ce8e212347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6ddae9a9706553c8aaaed1cebb220e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa6ddae9a9706553c8aaaed1cebb220e1">regina::detail::ComponentBase&lt; dim &gt;::isValid</a> () const</td></tr>
<tr class="memdesc:gaa6ddae9a9706553c8aaaed1cebb220e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this component is valid.  <a href="group__detail.html#gaa6ddae9a9706553c8aaaed1cebb220e1">More...</a><br /></td></tr>
<tr class="separator:gaa6ddae9a9706553c8aaaed1cebb220e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1f3ecb5b025c49bc95097e9fa8577ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa1f3ecb5b025c49bc95097e9fa8577ec">regina::detail::ComponentBase&lt; dim &gt;::isOrientable</a> () const</td></tr>
<tr class="memdesc:gaa1f3ecb5b025c49bc95097e9fa8577ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this component is orientable.  <a href="group__detail.html#gaa1f3ecb5b025c49bc95097e9fa8577ec">More...</a><br /></td></tr>
<tr class="separator:gaa1f3ecb5b025c49bc95097e9fa8577ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f8a624a104f38fc62968c7ab90a50d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga21f8a624a104f38fc62968c7ab90a50d">regina::detail::ComponentBase&lt; dim &gt;::hasBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:ga21f8a624a104f38fc62968c7ab90a50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this component has any boundary facets.  <a href="group__detail.html#ga21f8a624a104f38fc62968c7ab90a50d">More...</a><br /></td></tr>
<tr class="separator:ga21f8a624a104f38fc62968c7ab90a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c432ee922ff45feb64a41d80cf5684"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab2c432ee922ff45feb64a41d80cf5684">regina::detail::ComponentBase&lt; dim &gt;::countBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:gab2c432ee922ff45feb64a41d80cf5684"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of boundary facets in this component.  <a href="group__detail.html#gab2c432ee922ff45feb64a41d80cf5684">More...</a><br /></td></tr>
<tr class="separator:gab2c432ee922ff45feb64a41d80cf5684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1653572126e354f9e6f9202679742e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf1653572126e354f9e6f9202679742e8">regina::detail::ComponentBase&lt; dim &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaf1653572126e354f9e6f9202679742e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#gaf1653572126e354f9e6f9202679742e8">More...</a><br /></td></tr>
<tr class="separator:gaf1653572126e354f9e6f9202679742e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d045df7bc861b57e89444470e47cd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad2d045df7bc861b57e89444470e47cd4">regina::detail::ComponentBase&lt; dim &gt;::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gad2d045df7bc861b57e89444470e47cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__detail.html#gad2d045df7bc861b57e89444470e47cd4">More...</a><br /></td></tr>
<tr class="separator:gad2d045df7bc861b57e89444470e47cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e58542aec373800c63645cad0b8719b"><td class="memItemLeft" align="right" valign="top"><a id="ga1e58542aec373800c63645cad0b8719b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::ComponentBase&lt; dim &gt;::ComponentBase</b> (const <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">ComponentBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga1e58542aec373800c63645cad0b8719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d5725cfc704a2a7de2aaba6e5c5c43"><td class="memItemLeft" align="right" valign="top"><a id="ga58d5725cfc704a2a7de2aaba6e5c5c43"></a>
<a class="el" href="classregina_1_1detail_1_1ComponentBase.html">ComponentBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::ComponentBase&lt; dim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">ComponentBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga58d5725cfc704a2a7de2aaba6e5c5c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20da0ee3cb23bbb6cf5a5fc2c58f3fd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga20da0ee3cb23bbb6cf5a5fc2c58f3fd4">regina::detail::ComponentBase&lt; dim &gt;::ComponentBase</a> ()</td></tr>
<tr class="memdesc:ga20da0ee3cb23bbb6cf5a5fc2c58f3fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="group__detail.html#ga20da0ee3cb23bbb6cf5a5fc2c58f3fd4">More...</a><br /></td></tr>
<tr class="separator:ga20da0ee3cb23bbb6cf5a5fc2c58f3fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4726b3b4dd7b8158041ad7b31f9a644"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad4726b3b4dd7b8158041ad7b31f9a644">regina::detail::ExampleFromLowDim&lt; dim, available &gt;::doubleCone</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; &amp;base)</td></tr>
<tr class="memdesc:gad4726b3b4dd7b8158041ad7b31f9a644"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a double cone over the given (<em>dim-1</em>)-dimensional triangulation.  <a href="group__detail.html#gad4726b3b4dd7b8158041ad7b31f9a644">More...</a><br /></td></tr>
<tr class="separator:gad4726b3b4dd7b8158041ad7b31f9a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd8b50bc9d84a3d841b1bbb38f21769c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gafd8b50bc9d84a3d841b1bbb38f21769c">regina::detail::ExampleFromLowDim&lt; dim, available &gt;::singleCone</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; &amp;base)</td></tr>
<tr class="memdesc:gafd8b50bc9d84a3d841b1bbb38f21769c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a single cone over the given (<em>dim-1</em>)-dimensional triangulation.  <a href="group__detail.html#gafd8b50bc9d84a3d841b1bbb38f21769c">More...</a><br /></td></tr>
<tr class="separator:gafd8b50bc9d84a3d841b1bbb38f21769c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44d1474b152e941ff3e57ca342095ff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac44d1474b152e941ff3e57ca342095ff">regina::detail::ExampleBase&lt; dim &gt;::sphere</a> ()</td></tr>
<tr class="memdesc:gac44d1474b152e941ff3e57ca342095ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closed Triangulations.  <a href="group__detail.html#gac44d1474b152e941ff3e57ca342095ff">More...</a><br /></td></tr>
<tr class="separator:gac44d1474b152e941ff3e57ca342095ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad291d03ffaac87219b0be9a3b6d3cc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaad291d03ffaac87219b0be9a3b6d3cc8">regina::detail::ExampleBase&lt; dim &gt;::simplicialSphere</a> ()</td></tr>
<tr class="memdesc:gaad291d03ffaac87219b0be9a3b6d3cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the standard (<em>dim</em>+2)-simplex triangulation of the <em>dim</em>-sphere as the boundary of a (<em>dim</em>+1)-simplex.  <a href="group__detail.html#gaad291d03ffaac87219b0be9a3b6d3cc8">More...</a><br /></td></tr>
<tr class="separator:gaad291d03ffaac87219b0be9a3b6d3cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac808405b4900c8fdff2153d1e404f1bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac808405b4900c8fdff2153d1e404f1bb">regina::detail::ExampleBase&lt; dim &gt;::sphereBundle</a> ()</td></tr>
<tr class="memdesc:gac808405b4900c8fdff2153d1e404f1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-simplex triangulation of the product space <code>S^(<em>dim</em>-1) x S^1</code>.  <a href="group__detail.html#gac808405b4900c8fdff2153d1e404f1bb">More...</a><br /></td></tr>
<tr class="separator:gac808405b4900c8fdff2153d1e404f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14d0b08a11aafcfe98af561437676f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf14d0b08a11aafcfe98af561437676f4">regina::detail::ExampleBase&lt; dim &gt;::twistedSphereBundle</a> ()</td></tr>
<tr class="memdesc:gaf14d0b08a11aafcfe98af561437676f4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-simplex triangulation of the twisted product space <code>S^(<em>dim</em>-1) x~ S^1</code>.  <a href="group__detail.html#gaf14d0b08a11aafcfe98af561437676f4">More...</a><br /></td></tr>
<tr class="separator:gaf14d0b08a11aafcfe98af561437676f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbc7d22517bbb59c938e7302102c110f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabbc7d22517bbb59c938e7302102c110f">regina::detail::ExampleBase&lt; dim &gt;::ball</a> ()</td></tr>
<tr class="memdesc:gabbc7d22517bbb59c938e7302102c110f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded Triangulations.  <a href="group__detail.html#gabbc7d22517bbb59c938e7302102c110f">More...</a><br /></td></tr>
<tr class="separator:gabbc7d22517bbb59c938e7302102c110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fbb67097da4b4a488d3a07efe3a5477"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4fbb67097da4b4a488d3a07efe3a5477">regina::detail::ExampleBase&lt; dim &gt;::ballBundle</a> ()</td></tr>
<tr class="memdesc:ga4fbb67097da4b4a488d3a07efe3a5477"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the product space <code>B^(<em>dim</em>-1) x S^1</code>.  <a href="group__detail.html#ga4fbb67097da4b4a488d3a07efe3a5477">More...</a><br /></td></tr>
<tr class="separator:ga4fbb67097da4b4a488d3a07efe3a5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceae3ff4fb520f6df2d13966b5cfcc22"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaceae3ff4fb520f6df2d13966b5cfcc22">regina::detail::ExampleBase&lt; dim &gt;::twistedBallBundle</a> ()</td></tr>
<tr class="memdesc:gaceae3ff4fb520f6df2d13966b5cfcc22"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the twisted product space <code>B^(<em>dim</em>-1) x~ S^1</code>.  <a href="group__detail.html#gaceae3ff4fb520f6df2d13966b5cfcc22">More...</a><br /></td></tr>
<tr class="separator:gaceae3ff4fb520f6df2d13966b5cfcc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fbc9c36a2403187bd4777d3c7749afb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga5fbc9c36a2403187bd4777d3c7749afb">regina::detail::allowsInvalidFaces</a> (int dim, int subdim)</td></tr>
<tr class="memdesc:ga5fbc9c36a2403187bd4777d3c7749afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether it is possible for a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation to be invalid.  <a href="group__detail.html#ga5fbc9c36a2403187bd4777d3c7749afb">More...</a><br /></td></tr>
<tr class="separator:ga5fbc9c36a2403187bd4777d3c7749afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26739074df0ed0ddebd791a8c641671b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga26739074df0ed0ddebd791a8c641671b">regina::detail::allowsNonOrientableLinks</a> (int dim, int subdim)</td></tr>
<tr class="memdesc:ga26739074df0ed0ddebd791a8c641671b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether it is possible for a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation to have a non-orientable link.  <a href="group__detail.html#ga26739074df0ed0ddebd791a8c641671b">More...</a><br /></td></tr>
<tr class="separator:ga26739074df0ed0ddebd791a8c641671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e2f937f310e26fb5e7885e2893aad7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga32e2f937f310e26fb5e7885e2893aad7">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::FaceEmbeddingBase</a> ()</td></tr>
<tr class="memdesc:ga32e2f937f310e26fb5e7885e2893aad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="group__detail.html#ga32e2f937f310e26fb5e7885e2893aad7">More...</a><br /></td></tr>
<tr class="separator:ga32e2f937f310e26fb5e7885e2893aad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c55e6c817630cbb355b997af1c46766"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6c55e6c817630cbb355b997af1c46766">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::FaceEmbeddingBase</a> (<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *<a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19">simplex</a>, int <a class="el" href="group__detail.html#gae681db6dcf0825aa460e60ad611b989e">face</a>)</td></tr>
<tr class="memdesc:ga6c55e6c817630cbb355b997af1c46766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object containing the given data.  <a href="group__detail.html#ga6c55e6c817630cbb355b997af1c46766">More...</a><br /></td></tr>
<tr class="separator:ga6c55e6c817630cbb355b997af1c46766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc2a373a564bf19436d0cabd2e2a1a21"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabc2a373a564bf19436d0cabd2e2a1a21">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::FaceEmbeddingBase</a> (const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gabc2a373a564bf19436d0cabd2e2a1a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given object.  <a href="group__detail.html#gabc2a373a564bf19436d0cabd2e2a1a21">More...</a><br /></td></tr>
<tr class="separator:gabc2a373a564bf19436d0cabd2e2a1a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31021256121d39fdbf952fc9f8a283a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga31021256121d39fdbf952fc9f8a283a1">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::operator=</a> (const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga31021256121d39fdbf952fc9f8a283a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this a copy of the given object.  <a href="group__detail.html#ga31021256121d39fdbf952fc9f8a283a1">More...</a><br /></td></tr>
<tr class="separator:ga31021256121d39fdbf952fc9f8a283a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f1ed30cfbd2385ce48046120c2ced19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::simplex</a> () const</td></tr>
<tr class="memdesc:ga7f1ed30cfbd2385ce48046120c2ced19"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex in which the underlying <em>subdim</em>-face of the triangulation is contained.  <a href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19">More...</a><br /></td></tr>
<tr class="separator:ga7f1ed30cfbd2385ce48046120c2ced19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae681db6dcf0825aa460e60ad611b989e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae681db6dcf0825aa460e60ad611b989e">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::face</a> () const</td></tr>
<tr class="memdesc:gae681db6dcf0825aa460e60ad611b989e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the corresponding face number of <a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a>.  <a href="group__detail.html#gae681db6dcf0825aa460e60ad611b989e">More...</a><br /></td></tr>
<tr class="separator:gae681db6dcf0825aa460e60ad611b989e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8c5079eec12de43bd3fb8d0d7e3fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8a8c5079eec12de43bd3fb8d0d7e3fdd">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::vertices</a> () const</td></tr>
<tr class="memdesc:ga8a8c5079eec12de43bd3fb8d0d7e3fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps vertices (0,...,<em>subdim</em>) of the underlying <em>subdim</em>-face of the triangulation to the corresponding vertex numbers of <a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a>.  <a href="group__detail.html#ga8a8c5079eec12de43bd3fb8d0d7e3fdd">More...</a><br /></td></tr>
<tr class="separator:ga8a8c5079eec12de43bd3fb8d0d7e3fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02216faf02338c813e0e2da00d64860b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga02216faf02338c813e0e2da00d64860b">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::operator==</a> (const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga02216faf02338c813e0e2da00d64860b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given object are identical.  <a href="group__detail.html#ga02216faf02338c813e0e2da00d64860b">More...</a><br /></td></tr>
<tr class="separator:ga02216faf02338c813e0e2da00d64860b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5f8e8cfeb79462952c899aff13ce92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3a5f8e8cfeb79462952c899aff13ce92">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::operator!=</a> (const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga3a5f8e8cfeb79462952c899aff13ce92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given object are different.  <a href="group__detail.html#ga3a5f8e8cfeb79462952c899aff13ce92">More...</a><br /></td></tr>
<tr class="separator:ga3a5f8e8cfeb79462952c899aff13ce92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7371c16f06d4776e54f2516be0d1595b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7371c16f06d4776e54f2516be0d1595b">regina::detail::FaceEmbeddingBase&lt; dim, subdim &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga7371c16f06d4776e54f2516be0d1595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#ga7371c16f06d4776e54f2516be0d1595b">More...</a><br /></td></tr>
<tr class="separator:ga7371c16f06d4776e54f2516be0d1595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace118d12364a7a78c6819280f849fe4b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gace118d12364a7a78c6819280f849fe4b">regina::detail::FaceStorage&lt; dim, codim &gt;::degree</a> () const</td></tr>
<tr class="memdesc:gace118d12364a7a78c6819280f849fe4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the degree of this face.  <a href="group__detail.html#gace118d12364a7a78c6819280f849fe4b">More...</a><br /></td></tr>
<tr class="separator:gace118d12364a7a78c6819280f849fe4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46541230040337ff42af9653b9e4a458"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga46541230040337ff42af9653b9e4a458">regina::detail::FaceStorage&lt; dim, codim &gt;::embedding</a> (size_t index) const</td></tr>
<tr class="memdesc:ga46541230040337ff42af9653b9e4a458"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the ways in which this face appears within a top-dimensional simplex of the underlying triangluation.  <a href="group__detail.html#ga46541230040337ff42af9653b9e4a458">More...</a><br /></td></tr>
<tr class="separator:ga46541230040337ff42af9653b9e4a458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb43157f5f496fd046c43cb17f9d34ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gacb43157f5f496fd046c43cb17f9d34ae">regina::detail::FaceStorage&lt; dim, codim &gt;::begin</a> () const</td></tr>
<tr class="memdesc:gacb43157f5f496fd046c43cb17f9d34ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A begin function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation.  <a href="group__detail.html#gacb43157f5f496fd046c43cb17f9d34ae">More...</a><br /></td></tr>
<tr class="separator:gacb43157f5f496fd046c43cb17f9d34ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e2a10c6d41b492299960f23eb729264"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4e2a10c6d41b492299960f23eb729264">regina::detail::FaceStorage&lt; dim, codim &gt;::end</a> () const</td></tr>
<tr class="memdesc:ga4e2a10c6d41b492299960f23eb729264"><td class="mdescLeft">&#160;</td><td class="mdescRight">An end function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation.  <a href="group__detail.html#ga4e2a10c6d41b492299960f23eb729264">More...</a><br /></td></tr>
<tr class="separator:ga4e2a10c6d41b492299960f23eb729264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f659c8eb6a4ce037ebf5b65aa32d45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga63f659c8eb6a4ce037ebf5b65aa32d45">regina::detail::FaceStorage&lt; dim, codim &gt;::front</a> () const</td></tr>
<tr class="memdesc:ga63f659c8eb6a4ce037ebf5b65aa32d45"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first appearance of this face within a top-dimensional simplex of the underlying triangluation.  <a href="group__detail.html#ga63f659c8eb6a4ce037ebf5b65aa32d45">More...</a><br /></td></tr>
<tr class="separator:ga63f659c8eb6a4ce037ebf5b65aa32d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga947d961f6901c0998cecb0392c8b1a66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga947d961f6901c0998cecb0392c8b1a66">regina::detail::FaceStorage&lt; dim, codim &gt;::back</a> () const</td></tr>
<tr class="memdesc:ga947d961f6901c0998cecb0392c8b1a66"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the last appearance of this face within a top-dimensional simplex of the underlying triangluation.  <a href="group__detail.html#ga947d961f6901c0998cecb0392c8b1a66">More...</a><br /></td></tr>
<tr class="separator:ga947d961f6901c0998cecb0392c8b1a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877ff60449a48d5a8da5b3e32bb6dde2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga877ff60449a48d5a8da5b3e32bb6dde2">regina::detail::FaceStorage&lt; dim, codim &gt;::inMaximalForest</a> () const</td></tr>
<tr class="memdesc:ga877ff60449a48d5a8da5b3e32bb6dde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a codimension-1-face represents a dual edge in the maximal forest that has been chosen for the dual 1-skeleton of the triangulation.  <a href="group__detail.html#ga877ff60449a48d5a8da5b3e32bb6dde2">More...</a><br /></td></tr>
<tr class="separator:ga877ff60449a48d5a8da5b3e32bb6dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7573349512e968ff214e20c88a6b07"><td class="memItemLeft" align="right" valign="top"><a id="gabb7573349512e968ff214e20c88a6b07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::FaceStorage&lt; dim, codim &gt;::FaceStorage</b> (const <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">FaceStorage</a> &amp;)=delete</td></tr>
<tr class="separator:gabb7573349512e968ff214e20c88a6b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab121404e132afe310d67e5bd020b114a"><td class="memItemLeft" align="right" valign="top"><a id="gab121404e132afe310d67e5bd020b114a"></a>
<a class="el" href="classregina_1_1detail_1_1FaceStorage.html">FaceStorage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::FaceStorage&lt; dim, codim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">FaceStorage</a> &amp;)=delete</td></tr>
<tr class="separator:gab121404e132afe310d67e5bd020b114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090ff000af7de557979739c253d771ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga090ff000af7de557979739c253d771ba">regina::detail::FaceStorage&lt; dim, codim &gt;::FaceStorage</a> ()=default</td></tr>
<tr class="memdesc:ga090ff000af7de557979739c253d771ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor that leaves the list of embeddings empty.  <a href="group__detail.html#ga090ff000af7de557979739c253d771ba">More...</a><br /></td></tr>
<tr class="separator:ga090ff000af7de557979739c253d771ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga838e59de45da9b3f10ff3088bc127f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga838e59de45da9b3f10ff3088bc127f3f">regina::detail::FaceStorage&lt; dim, codim &gt;::push_back</a> (const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp;emb)</td></tr>
<tr class="memdesc:ga838e59de45da9b3f10ff3088bc127f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal routine to help build the skeleton of a triangulation.  <a href="group__detail.html#ga838e59de45da9b3f10ff3088bc127f3f">More...</a><br /></td></tr>
<tr class="separator:ga838e59de45da9b3f10ff3088bc127f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19f45c3ec59aa252e78ec4e13963c54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54">regina::detail::FaceValidity&lt; allowsInvalid, testLinks &gt;::isValid</a> () const</td></tr>
<tr class="memdesc:gae19f45c3ec59aa252e78ec4e13963c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face is valid.  <a href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54">More...</a><br /></td></tr>
<tr class="separator:gae19f45c3ec59aa252e78ec4e13963c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72c0522efd2a0b8df7b632ad82b36760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga72c0522efd2a0b8df7b632ad82b36760">regina::detail::FaceValidity&lt; allowsInvalid, testLinks &gt;::hasBadIdentification</a> () const</td></tr>
<tr class="memdesc:ga72c0522efd2a0b8df7b632ad82b36760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face is identified with itself under a non-identity permutation.  <a href="group__detail.html#ga72c0522efd2a0b8df7b632ad82b36760">More...</a><br /></td></tr>
<tr class="separator:ga72c0522efd2a0b8df7b632ad82b36760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab16c59e486f840192f63a4268f53b3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaab16c59e486f840192f63a4268f53b3d">regina::detail::FaceValidity&lt; allowsInvalid, testLinks &gt;::hasBadLink</a> () const</td></tr>
<tr class="memdesc:gaab16c59e486f840192f63a4268f53b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face does not have an appropriate link.  <a href="group__detail.html#gaab16c59e486f840192f63a4268f53b3d">More...</a><br /></td></tr>
<tr class="separator:gaab16c59e486f840192f63a4268f53b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1291a45c3fd76e8d4cd2e2f6e0eb5260"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1291a45c3fd76e8d4cd2e2f6e0eb5260">regina::detail::FaceValidity&lt; allowsInvalid, testLinks &gt;::FaceValidity</a> ()</td></tr>
<tr class="memdesc:ga1291a45c3fd76e8d4cd2e2f6e0eb5260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this face as valid.  <a href="group__detail.html#ga1291a45c3fd76e8d4cd2e2f6e0eb5260">More...</a><br /></td></tr>
<tr class="separator:ga1291a45c3fd76e8d4cd2e2f6e0eb5260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a26ac5852aa92757743c04baca2e319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8a26ac5852aa92757743c04baca2e319">regina::detail::FaceValidity&lt; allowsInvalid, testLinks &gt;::markBadIdentification</a> ()</td></tr>
<tr class="memdesc:ga8a26ac5852aa92757743c04baca2e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this face as having a non-identity self-identification.  <a href="group__detail.html#ga8a26ac5852aa92757743c04baca2e319">More...</a><br /></td></tr>
<tr class="separator:ga8a26ac5852aa92757743c04baca2e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cefa7ced48da051d277243cba998d6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7cefa7ced48da051d277243cba998d6f">regina::detail::FaceValidity&lt; allowsInvalid, testLinks &gt;::markBadLink</a> ()</td></tr>
<tr class="memdesc:ga7cefa7ced48da051d277243cba998d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this face as having a bad link.  <a href="group__detail.html#ga7cefa7ced48da051d277243cba998d6f">More...</a><br /></td></tr>
<tr class="separator:ga7cefa7ced48da051d277243cba998d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dbb2e405ff3e7ab5b804a8b6463bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga52dbb2e405ff3e7ab5b804a8b6463bbd">regina::detail::FaceValidity&lt; false, testLinks &gt;::isValid</a> () const</td></tr>
<tr class="memdesc:ga52dbb2e405ff3e7ab5b804a8b6463bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns <code>true</code>.  <a href="group__detail.html#ga52dbb2e405ff3e7ab5b804a8b6463bbd">More...</a><br /></td></tr>
<tr class="separator:ga52dbb2e405ff3e7ab5b804a8b6463bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845da3689d775f5d980edbcee918f13a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga845da3689d775f5d980edbcee918f13a">regina::detail::FaceValidity&lt; false, testLinks &gt;::markBadIdentification</a> ()</td></tr>
<tr class="memdesc:ga845da3689d775f5d980edbcee918f13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this face as having a non-identity self-identification.  <a href="group__detail.html#ga845da3689d775f5d980edbcee918f13a">More...</a><br /></td></tr>
<tr class="separator:ga845da3689d775f5d980edbcee918f13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d351a6e3d1409a6a61c2dd8c0c3331e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9d351a6e3d1409a6a61c2dd8c0c3331e">regina::detail::FaceValidity&lt; false, testLinks &gt;::markBadLink</a> ()</td></tr>
<tr class="memdesc:ga9d351a6e3d1409a6a61c2dd8c0c3331e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this face as having a bad link.  <a href="group__detail.html#ga9d351a6e3d1409a6a61c2dd8c0c3331e">More...</a><br /></td></tr>
<tr class="separator:ga9d351a6e3d1409a6a61c2dd8c0c3331e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af63adfc417388aa6b68c0fea7f8086"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3af63adfc417388aa6b68c0fea7f8086">regina::detail::FaceValidity&lt; true, false &gt;::isValid</a> () const</td></tr>
<tr class="memdesc:ga3af63adfc417388aa6b68c0fea7f8086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face is valid.  <a href="group__detail.html#ga3af63adfc417388aa6b68c0fea7f8086">More...</a><br /></td></tr>
<tr class="separator:ga3af63adfc417388aa6b68c0fea7f8086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fa547d187dfb41e0c3f44ce9ab73b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga54fa547d187dfb41e0c3f44ce9ab73b5">regina::detail::FaceValidity&lt; true, false &gt;::hasBadIdentification</a> () const</td></tr>
<tr class="memdesc:ga54fa547d187dfb41e0c3f44ce9ab73b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face is identified with itself under a non-identity permutation.  <a href="group__detail.html#ga54fa547d187dfb41e0c3f44ce9ab73b5">More...</a><br /></td></tr>
<tr class="separator:ga54fa547d187dfb41e0c3f44ce9ab73b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa564cf57a3e438c5e055a029f0bf43a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa564cf57a3e438c5e055a029f0bf43a3">regina::detail::FaceValidity&lt; true, false &gt;::FaceValidity</a> ()</td></tr>
<tr class="memdesc:gaa564cf57a3e438c5e055a029f0bf43a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises this face as valid.  <a href="group__detail.html#gaa564cf57a3e438c5e055a029f0bf43a3">More...</a><br /></td></tr>
<tr class="separator:gaa564cf57a3e438c5e055a029f0bf43a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga136c6a0bffab85d8fed3eab6cd6fb23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga136c6a0bffab85d8fed3eab6cd6fb23f">regina::detail::FaceValidity&lt; true, false &gt;::markBadIdentification</a> ()</td></tr>
<tr class="memdesc:ga136c6a0bffab85d8fed3eab6cd6fb23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks this face as having a non-identity self-identification.  <a href="group__detail.html#ga136c6a0bffab85d8fed3eab6cd6fb23f">More...</a><br /></td></tr>
<tr class="separator:ga136c6a0bffab85d8fed3eab6cd6fb23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2c5d71573616354c885ac7250568d8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad2c5d71573616354c885ac7250568d8d">regina::detail::FaceOrientability&lt; allowsNonorientable &gt;::isLinkOrientable</a> () const</td></tr>
<tr class="memdesc:gad2c5d71573616354c885ac7250568d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the link of this face is orientable.  <a href="group__detail.html#gad2c5d71573616354c885ac7250568d8d">More...</a><br /></td></tr>
<tr class="separator:gad2c5d71573616354c885ac7250568d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9cff3435bc7205129717c4b20e005fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa9cff3435bc7205129717c4b20e005fb">regina::detail::FaceOrientability&lt; allowsNonorientable &gt;::FaceOrientability</a> ()</td></tr>
<tr class="memdesc:gaa9cff3435bc7205129717c4b20e005fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the link of this face as orientable.  <a href="group__detail.html#gaa9cff3435bc7205129717c4b20e005fb">More...</a><br /></td></tr>
<tr class="separator:gaa9cff3435bc7205129717c4b20e005fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f328344dd6d04f49de244edda465b15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3f328344dd6d04f49de244edda465b15">regina::detail::FaceOrientability&lt; allowsNonorientable &gt;::markLinkNonorientable</a> ()</td></tr>
<tr class="memdesc:ga3f328344dd6d04f49de244edda465b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the link of this face as non-orientable.  <a href="group__detail.html#ga3f328344dd6d04f49de244edda465b15">More...</a><br /></td></tr>
<tr class="separator:ga3f328344dd6d04f49de244edda465b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7234fa2254e5ae60efd4786359edee9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac7234fa2254e5ae60efd4786359edee9">regina::detail::FaceOrientability&lt; false &gt;::isLinkOrientable</a> () const</td></tr>
<tr class="memdesc:gac7234fa2254e5ae60efd4786359edee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the link of this face is orientable.  <a href="group__detail.html#gac7234fa2254e5ae60efd4786359edee9">More...</a><br /></td></tr>
<tr class="separator:gac7234fa2254e5ae60efd4786359edee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48972219692f228981f9409240c68032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga48972219692f228981f9409240c68032">regina::detail::FaceOrientability&lt; false &gt;::markLinkNonorientable</a> ()</td></tr>
<tr class="memdesc:ga48972219692f228981f9409240c68032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the link of this face as non-orientable.  <a href="group__detail.html#ga48972219692f228981f9409240c68032">More...</a><br /></td></tr>
<tr class="separator:ga48972219692f228981f9409240c68032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2c029dbdfaaccfaebc6b620757e7baa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab2c029dbdfaaccfaebc6b620757e7baa">regina::detail::FaceBase&lt; dim, subdim &gt;::index</a> () const</td></tr>
<tr class="memdesc:gab2c029dbdfaaccfaebc6b620757e7baa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this face within the underlying triangulation.  <a href="group__detail.html#gab2c029dbdfaaccfaebc6b620757e7baa">More...</a><br /></td></tr>
<tr class="separator:gab2c029dbdfaaccfaebc6b620757e7baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4526d27d6771e5288209fac8caabd57d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4526d27d6771e5288209fac8caabd57d">regina::detail::FaceBase&lt; dim, subdim &gt;::triangulation</a> () const</td></tr>
<tr class="memdesc:ga4526d27d6771e5288209fac8caabd57d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this face belongs.  <a href="group__detail.html#ga4526d27d6771e5288209fac8caabd57d">More...</a><br /></td></tr>
<tr class="separator:ga4526d27d6771e5288209fac8caabd57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa028dd42232ab0137ab65be7ea4adef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa028dd42232ab0137ab65be7ea4adef1">regina::detail::FaceBase&lt; dim, subdim &gt;::component</a> () const</td></tr>
<tr class="memdesc:gaa028dd42232ab0137ab65be7ea4adef1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the component of the triangulation to which this face belongs.  <a href="group__detail.html#gaa028dd42232ab0137ab65be7ea4adef1">More...</a><br /></td></tr>
<tr class="separator:gaa028dd42232ab0137ab65be7ea4adef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c947040ab5f5c42975b6f3be8cfa59f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8c947040ab5f5c42975b6f3be8cfa59f">regina::detail::FaceBase&lt; dim, subdim &gt;::boundaryComponent</a> () const</td></tr>
<tr class="memdesc:ga8c947040ab5f5c42975b6f3be8cfa59f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the boundary component of the triangulation to which this face belongs.  <a href="group__detail.html#ga8c947040ab5f5c42975b6f3be8cfa59f">More...</a><br /></td></tr>
<tr class="separator:ga8c947040ab5f5c42975b6f3be8cfa59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fc849ef77244993696cbfe08083f336"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2fc849ef77244993696cbfe08083f336">regina::detail::FaceBase&lt; dim, subdim &gt;::isBoundary</a> () const</td></tr>
<tr class="memdesc:ga2fc849ef77244993696cbfe08083f336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this face lies entirely on the boundary of the triangulation.  <a href="group__detail.html#ga2fc849ef77244993696cbfe08083f336">More...</a><br /></td></tr>
<tr class="separator:ga2fc849ef77244993696cbfe08083f336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aca90c1c4e48f547b4295f3cc4dab92"><td class="memTemplParams" colspan="2">template&lt;int lowerdim&gt; </td></tr>
<tr class="memitem:ga8aca90c1c4e48f547b4295f3cc4dab92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, lowerdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8aca90c1c4e48f547b4295f3cc4dab92">regina::detail::FaceBase&lt; dim, subdim &gt;::face</a> (int face) const</td></tr>
<tr class="memdesc:ga8aca90c1c4e48f547b4295f3cc4dab92"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>lowerdim</em>-face of the underlying triangulation that appears as the given <em>lowerdim</em>-dimensional subface of this face.  <a href="group__detail.html#ga8aca90c1c4e48f547b4295f3cc4dab92">More...</a><br /></td></tr>
<tr class="separator:ga8aca90c1c4e48f547b4295f3cc4dab92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed9ed0245ebec8f610f9d262fbf19d22"><td class="memTemplParams" colspan="2">template&lt;int lowerdim&gt; </td></tr>
<tr class="memitem:gaed9ed0245ebec8f610f9d262fbf19d22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#gaed9ed0245ebec8f610f9d262fbf19d22">regina::detail::FaceBase&lt; dim, subdim &gt;::faceMapping</a> (int <a class="el" href="group__detail.html#ga8aca90c1c4e48f547b4295f3cc4dab92">face</a>) const</td></tr>
<tr class="memdesc:gaed9ed0245ebec8f610f9d262fbf19d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the given <em>lowerdim</em>-dimensional subface of this face, and returns the mapping between the underlying <em>lowerdim</em>-face of the triangulation and the individual vertices of this face.  <a href="group__detail.html#gaed9ed0245ebec8f610f9d262fbf19d22">More...</a><br /></td></tr>
<tr class="separator:gaed9ed0245ebec8f610f9d262fbf19d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb461314ec9b661a4476b24d1f07c9d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gacb461314ec9b661a4476b24d1f07c9d0">regina::detail::FaceBase&lt; dim, subdim &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gacb461314ec9b661a4476b24d1f07c9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#gacb461314ec9b661a4476b24d1f07c9d0">More...</a><br /></td></tr>
<tr class="separator:gacb461314ec9b661a4476b24d1f07c9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ffac0e0ca2f4ffe3b61a54d6bce4bbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4ffac0e0ca2f4ffe3b61a54d6bce4bbd">regina::detail::FaceBase&lt; dim, subdim &gt;::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga4ffac0e0ca2f4ffe3b61a54d6bce4bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__detail.html#ga4ffac0e0ca2f4ffe3b61a54d6bce4bbd">More...</a><br /></td></tr>
<tr class="separator:ga4ffac0e0ca2f4ffe3b61a54d6bce4bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18fb1875029b16633326ad5da4199b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac18fb1875029b16633326ad5da4199b1">regina::detail::FaceBase&lt; dim, subdim &gt;::FaceBase</a> (<a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *<a class="el" href="group__detail.html#gaa028dd42232ab0137ab65be7ea4adef1">component</a>)</td></tr>
<tr class="memdesc:gac18fb1875029b16633326ad5da4199b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new face.  <a href="group__detail.html#gac18fb1875029b16633326ad5da4199b1">More...</a><br /></td></tr>
<tr class="separator:gac18fb1875029b16633326ad5da4199b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317bc3a01d0543daddb4c00ab4d27d5b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b">regina::detail::FaceNumberingAPI&lt; dim, subdim &gt;::ordering</a> (unsigned face)</td></tr>
<tr class="memdesc:ga317bc3a01d0543daddb4c00ab4d27d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a <em>subdim</em>-face number within a <em>dim</em>-dimensional simplex, returns the corresponding canonical ordering of the simplex vertices.  <a href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b">More...</a><br /></td></tr>
<tr class="separator:ga317bc3a01d0543daddb4c00ab4d27d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7466eaf4d128e641797687eb31f13e7e"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7466eaf4d128e641797687eb31f13e7e">regina::detail::FaceNumberingAPI&lt; dim, subdim &gt;::faceNumber</a> (<a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="namespaceregina.html#a6a2887a1b27ad78c08a44432fd55cc1b">vertices</a>)</td></tr>
<tr class="memdesc:ga7466eaf4d128e641797687eb31f13e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies which <em>subdim</em>-face in a <em>dim</em>-dimensional simplex is represented by the first (<em>subdim</em> + 1) elements of the given permutation.  <a href="group__detail.html#ga7466eaf4d128e641797687eb31f13e7e">More...</a><br /></td></tr>
<tr class="separator:ga7466eaf4d128e641797687eb31f13e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bd32f838bfb204c98ddb985ce1ba3c0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0bd32f838bfb204c98ddb985ce1ba3c0">regina::detail::FaceNumberingAPI&lt; dim, subdim &gt;::containsVertex</a> (unsigned face, unsigned vertex)</td></tr>
<tr class="memdesc:ga0bd32f838bfb204c98ddb985ce1ba3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the given <em>subdim</em>-face of a <em>dim</em>-dimensional simplex contains the given vertex of the simplex.  <a href="group__detail.html#ga0bd32f838bfb204c98ddb985ce1ba3c0">More...</a><br /></td></tr>
<tr class="separator:ga0bd32f838bfb204c98ddb985ce1ba3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ea3d56e931eb3175f3929bd8d463dec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga5ea3d56e931eb3175f3929bd8d463dec">regina::detail::IsomorphismBase&lt; dim &gt;::IsomorphismBase</a> (unsigned nSimplices)</td></tr>
<tr class="memdesc:ga5ea3d56e931eb3175f3929bd8d463dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new isomorphism with no initialisation.  <a href="group__detail.html#ga5ea3d56e931eb3175f3929bd8d463dec">More...</a><br /></td></tr>
<tr class="separator:ga5ea3d56e931eb3175f3929bd8d463dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8318824f0b86102a8608194a2d9e8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabe8318824f0b86102a8608194a2d9e8c">regina::detail::IsomorphismBase&lt; dim &gt;::IsomorphismBase</a> (const <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp;src)</td></tr>
<tr class="memdesc:gabe8318824f0b86102a8608194a2d9e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given isomorphism.  <a href="group__detail.html#gabe8318824f0b86102a8608194a2d9e8c">More...</a><br /></td></tr>
<tr class="separator:gabe8318824f0b86102a8608194a2d9e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f702a81c31e4a4af8a88ab6181267e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3f702a81c31e4a4af8a88ab6181267e3">regina::detail::IsomorphismBase&lt; dim &gt;::IsomorphismBase</a> (<a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ga3f702a81c31e4a4af8a88ab6181267e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given isomorphism into this new isomorphism.  <a href="group__detail.html#ga3f702a81c31e4a4af8a88ab6181267e3">More...</a><br /></td></tr>
<tr class="separator:ga3f702a81c31e4a4af8a88ab6181267e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabacfd5bb07ccd3a47d692b3d1f4b75b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabacfd5bb07ccd3a47d692b3d1f4b75b0">regina::detail::IsomorphismBase&lt; dim &gt;::~IsomorphismBase</a> ()</td></tr>
<tr class="memdesc:gabacfd5bb07ccd3a47d692b3d1f4b75b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this isomorphism.  <a href="group__detail.html#gabacfd5bb07ccd3a47d692b3d1f4b75b0">More...</a><br /></td></tr>
<tr class="separator:gabacfd5bb07ccd3a47d692b3d1f4b75b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506a621286cfaa5ce6ec3bd528711eac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga506a621286cfaa5ce6ec3bd528711eac">regina::detail::IsomorphismBase&lt; dim &gt;::operator=</a> (const <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a> &amp;src)</td></tr>
<tr class="memdesc:ga506a621286cfaa5ce6ec3bd528711eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the given isomorphism into this isomorphism.  <a href="group__detail.html#ga506a621286cfaa5ce6ec3bd528711eac">More...</a><br /></td></tr>
<tr class="separator:ga506a621286cfaa5ce6ec3bd528711eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16c95c5faac35d2deed02a9df25615df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga16c95c5faac35d2deed02a9df25615df">regina::detail::IsomorphismBase&lt; dim &gt;::operator=</a> (<a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a> &amp;&amp;src) noexcept</td></tr>
<tr class="memdesc:ga16c95c5faac35d2deed02a9df25615df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the given isomorphism into this isomorphism.  <a href="group__detail.html#ga16c95c5faac35d2deed02a9df25615df">More...</a><br /></td></tr>
<tr class="separator:ga16c95c5faac35d2deed02a9df25615df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c659599534e20778107158e2246958"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958">regina::detail::IsomorphismBase&lt; dim &gt;::size</a> () const</td></tr>
<tr class="memdesc:ga43c659599534e20778107158e2246958"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of simplices in the source triangulation associated with this isomorphism.  <a href="group__detail.html#ga43c659599534e20778107158e2246958">More...</a><br /></td></tr>
<tr class="separator:ga43c659599534e20778107158e2246958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc12157b7e664b84894574e149ee1023"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gacc12157b7e664b84894574e149ee1023">regina::detail::IsomorphismBase&lt; dim &gt;::simpImage</a> (unsigned sourceSimp)</td></tr>
<tr class="memdesc:gacc12157b7e664b84894574e149ee1023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex under this isomorphism.  <a href="group__detail.html#gacc12157b7e664b84894574e149ee1023">More...</a><br /></td></tr>
<tr class="separator:gacc12157b7e664b84894574e149ee1023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac18646a12377b7965cbc58606082b659"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac18646a12377b7965cbc58606082b659">regina::detail::IsomorphismBase&lt; dim &gt;::simpImage</a> (unsigned sourceSimp) const</td></tr>
<tr class="memdesc:gac18646a12377b7965cbc58606082b659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex under this isomorphism.  <a href="group__detail.html#gac18646a12377b7965cbc58606082b659">More...</a><br /></td></tr>
<tr class="separator:gac18646a12377b7965cbc58606082b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb0ad0ed6aad84455848858b1df4c682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaeb0ad0ed6aad84455848858b1df4c682">regina::detail::IsomorphismBase&lt; dim &gt;::facetPerm</a> (unsigned sourceSimp)</td></tr>
<tr class="memdesc:gaeb0ad0ed6aad84455848858b1df4c682"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write reference to the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism.  <a href="group__detail.html#gaeb0ad0ed6aad84455848858b1df4c682">More...</a><br /></td></tr>
<tr class="separator:gaeb0ad0ed6aad84455848858b1df4c682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1f4e57841e1621eccba6a95c18faa43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae1f4e57841e1621eccba6a95c18faa43">regina::detail::IsomorphismBase&lt; dim &gt;::facetPerm</a> (unsigned sourceSimp) const</td></tr>
<tr class="memdesc:gae1f4e57841e1621eccba6a95c18faa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism.  <a href="group__detail.html#gae1f4e57841e1621eccba6a95c18faa43">More...</a><br /></td></tr>
<tr class="separator:gae1f4e57841e1621eccba6a95c18faa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeeddeeed72ee738b58dea71c0e056fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gadeeddeeed72ee738b58dea71c0e056fb">regina::detail::IsomorphismBase&lt; dim &gt;::operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:gadeeddeeed72ee738b58dea71c0e056fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the image of the given source simplex facet under this isomorphism.  <a href="group__detail.html#gadeeddeeed72ee738b58dea71c0e056fb">More...</a><br /></td></tr>
<tr class="separator:gadeeddeeed72ee738b58dea71c0e056fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52235513aeff37221ee92a654397e32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa52235513aeff37221ee92a654397e32">regina::detail::IsomorphismBase&lt; dim &gt;::isIdentity</a> () const</td></tr>
<tr class="memdesc:gaa52235513aeff37221ee92a654397e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this is an identity isomorphism.  <a href="group__detail.html#gaa52235513aeff37221ee92a654397e32">More...</a><br /></td></tr>
<tr class="separator:gaa52235513aeff37221ee92a654397e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33569d2db61ab4a22cb8a70441949033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga33569d2db61ab4a22cb8a70441949033">regina::detail::IsomorphismBase&lt; dim &gt;::apply</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *original) const</td></tr>
<tr class="memdesc:ga33569d2db61ab4a22cb8a70441949033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.  <a href="group__detail.html#ga33569d2db61ab4a22cb8a70441949033">More...</a><br /></td></tr>
<tr class="separator:ga33569d2db61ab4a22cb8a70441949033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182d11ecefd8675e271db64481fd1a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga182d11ecefd8675e271db64481fd1a0e">regina::detail::IsomorphismBase&lt; dim &gt;::applyInPlace</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri) const</td></tr>
<tr class="memdesc:ga182d11ecefd8675e271db64481fd1a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies this isomorphism to the given triangulation, modifying the given triangulation directly.  <a href="group__detail.html#ga182d11ecefd8675e271db64481fd1a0e">More...</a><br /></td></tr>
<tr class="separator:ga182d11ecefd8675e271db64481fd1a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fcd528876a8ef03ada27dc99004b871"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1fcd528876a8ef03ada27dc99004b871">regina::detail::IsomorphismBase&lt; dim &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga1fcd528876a8ef03ada27dc99004b871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#ga1fcd528876a8ef03ada27dc99004b871">More...</a><br /></td></tr>
<tr class="separator:ga1fcd528876a8ef03ada27dc99004b871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12bb303f0c62cae604c2bfe2eadc602d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga12bb303f0c62cae604c2bfe2eadc602d">regina::detail::IsomorphismBase&lt; dim &gt;::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga12bb303f0c62cae604c2bfe2eadc602d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__detail.html#ga12bb303f0c62cae604c2bfe2eadc602d">More...</a><br /></td></tr>
<tr class="separator:ga12bb303f0c62cae604c2bfe2eadc602d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b4a13ff55946309b4969dc76183432"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga87b4a13ff55946309b4969dc76183432">regina::detail::IsomorphismBase&lt; dim &gt;::identity</a> (unsigned nSimplices)</td></tr>
<tr class="memdesc:ga87b4a13ff55946309b4969dc76183432"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the identity isomorphism for the given number of simplices.  <a href="group__detail.html#ga87b4a13ff55946309b4969dc76183432">More...</a><br /></td></tr>
<tr class="separator:ga87b4a13ff55946309b4969dc76183432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2a40f3357732361a596788206daccf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaef2a40f3357732361a596788206daccf">regina::detail::IsomorphismBase&lt; dim &gt;::random</a> (unsigned nSimplices, bool even=false)</td></tr>
<tr class="memdesc:gaef2a40f3357732361a596788206daccf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a random isomorphism for the given number of simplices.  <a href="group__detail.html#gaef2a40f3357732361a596788206daccf">More...</a><br /></td></tr>
<tr class="separator:gaef2a40f3357732361a596788206daccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadedf21e482ff437b437980568da0b852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gadedf21e482ff437b437980568da0b852">regina::detail::SimplexFaces&lt; dim, subdim &gt;::clear</a> ()</td></tr>
<tr class="memdesc:gadedf21e482ff437b437980568da0b852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all face pointers to null.  <a href="group__detail.html#gadedf21e482ff437b437980568da0b852">More...</a><br /></td></tr>
<tr class="separator:gadedf21e482ff437b437980568da0b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga314fb6c464b9d2b0f1169233a75f5a68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga314fb6c464b9d2b0f1169233a75f5a68">regina::detail::SimplexFaces&lt; dim, subdim &gt;::sameDegrees</a> (const <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">SimplexFaces</a>&lt; dim, subdim &gt; &amp;other, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; p) const</td></tr>
<tr class="memdesc:ga314fb6c464b9d2b0f1169233a75f5a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the <em>subdim</em>-face degrees of this and the given simplex are identical, under the given relabelling.  <a href="group__detail.html#ga314fb6c464b9d2b0f1169233a75f5a68">More...</a><br /></td></tr>
<tr class="separator:ga314fb6c464b9d2b0f1169233a75f5a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9bf6549de48e3e7d52dc8b8879181d7"><td class="memItemLeft" align="right" valign="top"><a id="gab9bf6549de48e3e7d52dc8b8879181d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexFaces&lt; dim, subdim &gt;::SimplexFaces</b> (const <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">SimplexFaces</a> &amp;)=delete</td></tr>
<tr class="separator:gab9bf6549de48e3e7d52dc8b8879181d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5a1a5231ab9293aef6cf5366980b89"><td class="memItemLeft" align="right" valign="top"><a id="gaec5a1a5231ab9293aef6cf5366980b89"></a>
<a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">SimplexFaces</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexFaces&lt; dim, subdim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">SimplexFaces</a> &amp;)=delete</td></tr>
<tr class="separator:gaec5a1a5231ab9293aef6cf5366980b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4c39e0a3b8437d2c3540b183de7b97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gadc4c39e0a3b8437d2c3540b183de7b97">regina::detail::SimplexFacesSuite&lt; dim, subdim &gt;::sameDegrees</a> (const <a class="el" href="classregina_1_1detail_1_1SimplexFacesSuite.html">SimplexFacesSuite</a>&lt; dim, subdim &gt; &amp;other, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; p) const</td></tr>
<tr class="memdesc:gadc4c39e0a3b8437d2c3540b183de7b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the <em>k</em>-face degrees of this and the given simplex are identical, under the given relabelling, for all faces of all dimensions <em>k</em> &le; <em>subdim</em>.  <a href="group__detail.html#gadc4c39e0a3b8437d2c3540b183de7b97">More...</a><br /></td></tr>
<tr class="separator:gadc4c39e0a3b8437d2c3540b183de7b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00178392c44456529f5250de6bc448ef"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga00178392c44456529f5250de6bc448ef">regina::detail::SimplexBase&lt; dim &gt;::description</a> () const</td></tr>
<tr class="memdesc:ga00178392c44456529f5250de6bc448ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the description associated with this simplex.  <a href="group__detail.html#ga00178392c44456529f5250de6bc448ef">More...</a><br /></td></tr>
<tr class="separator:ga00178392c44456529f5250de6bc448ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6d949a6ec9b90b7c9fce5c9da6dc52d6">regina::detail::SimplexBase&lt; dim &gt;::setDescription</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:ga6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the description associated with this simplex.  <a href="group__detail.html#ga6d949a6ec9b90b7c9fce5c9da6dc52d6">More...</a><br /></td></tr>
<tr class="separator:ga6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbf51cda05f67725962436cae590a0ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabbf51cda05f67725962436cae590a0ff">regina::detail::SimplexBase&lt; dim &gt;::index</a> () const</td></tr>
<tr class="memdesc:gabbf51cda05f67725962436cae590a0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this simplex in the underlying triangulation.  <a href="group__detail.html#gabbf51cda05f67725962436cae590a0ff">More...</a><br /></td></tr>
<tr class="separator:gabbf51cda05f67725962436cae590a0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c12cf55a47ae78e9b4e91ce46c838d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad0c12cf55a47ae78e9b4e91ce46c838d">regina::detail::SimplexBase&lt; dim &gt;::adjacentSimplex</a> (int facet) const</td></tr>
<tr class="memdesc:gad0c12cf55a47ae78e9b4e91ce46c838d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the adjacent simplex that is glued to the given facet of this simplex.  <a href="group__detail.html#gad0c12cf55a47ae78e9b4e91ce46c838d">More...</a><br /></td></tr>
<tr class="separator:gad0c12cf55a47ae78e9b4e91ce46c838d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ac592b6db07dba1487e054be273799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga39ac592b6db07dba1487e054be273799">regina::detail::SimplexBase&lt; dim &gt;::adjacentGluing</a> (int facet) const</td></tr>
<tr class="memdesc:ga39ac592b6db07dba1487e054be273799"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation that indicates precisely how this simplex is glued to the adjacent simplex across the given facet.  <a href="group__detail.html#ga39ac592b6db07dba1487e054be273799">More...</a><br /></td></tr>
<tr class="separator:ga39ac592b6db07dba1487e054be273799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09416bf06b05b67bad21b9e5184e3584"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga09416bf06b05b67bad21b9e5184e3584">regina::detail::SimplexBase&lt; dim &gt;::adjacentFacet</a> (int facet) const</td></tr>
<tr class="memdesc:ga09416bf06b05b67bad21b9e5184e3584"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given facet of this simplex is glued to facet <em>f</em> of some adjacent simplex, then this routine returns the adjacent facet number <em>f</em>.  <a href="group__detail.html#ga09416bf06b05b67bad21b9e5184e3584">More...</a><br /></td></tr>
<tr class="separator:ga09416bf06b05b67bad21b9e5184e3584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cdb23e0e94cf30e7fe953691c926af6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9cdb23e0e94cf30e7fe953691c926af6">regina::detail::SimplexBase&lt; dim &gt;::hasBoundary</a> () const</td></tr>
<tr class="memdesc:ga9cdb23e0e94cf30e7fe953691c926af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this simplex has any facets that lie on the triangulation boundary.  <a href="group__detail.html#ga9cdb23e0e94cf30e7fe953691c926af6">More...</a><br /></td></tr>
<tr class="separator:ga9cdb23e0e94cf30e7fe953691c926af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f0a3046ec46f13f270bbc82193c5cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad1f0a3046ec46f13f270bbc82193c5cc">regina::detail::SimplexBase&lt; dim &gt;::join</a> (int myFacet, <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *you, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; gluing)</td></tr>
<tr class="memdesc:gad1f0a3046ec46f13f270bbc82193c5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins the given facet of this simplex to some facet of another simplex.  <a href="group__detail.html#gad1f0a3046ec46f13f270bbc82193c5cc">More...</a><br /></td></tr>
<tr class="separator:gad1f0a3046ec46f13f270bbc82193c5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d139902e93c8ddd7c17cd6f67729b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4d139902e93c8ddd7c17cd6f67729b22">regina::detail::SimplexBase&lt; dim &gt;::unjoin</a> (int myFacet)</td></tr>
<tr class="memdesc:ga4d139902e93c8ddd7c17cd6f67729b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unglues the given facet of this simplex from whatever it is joined to.  <a href="group__detail.html#ga4d139902e93c8ddd7c17cd6f67729b22">More...</a><br /></td></tr>
<tr class="separator:ga4d139902e93c8ddd7c17cd6f67729b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0df524a7bf262cb0c43ec9d7c39b7687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0df524a7bf262cb0c43ec9d7c39b7687">regina::detail::SimplexBase&lt; dim &gt;::isolate</a> ()</td></tr>
<tr class="memdesc:ga0df524a7bf262cb0c43ec9d7c39b7687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unglues this simplex from any adjacent simplices.  <a href="group__detail.html#ga0df524a7bf262cb0c43ec9d7c39b7687">More...</a><br /></td></tr>
<tr class="separator:ga0df524a7bf262cb0c43ec9d7c39b7687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36f84802bd71d9affff8a90a6e8ea9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga36f84802bd71d9affff8a90a6e8ea9f0">regina::detail::SimplexBase&lt; dim &gt;::triangulation</a> () const</td></tr>
<tr class="memdesc:ga36f84802bd71d9affff8a90a6e8ea9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this simplex belongs.  <a href="group__detail.html#ga36f84802bd71d9affff8a90a6e8ea9f0">More...</a><br /></td></tr>
<tr class="separator:ga36f84802bd71d9affff8a90a6e8ea9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae91a7cee2cdc36220b08d9fe96985f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaae91a7cee2cdc36220b08d9fe96985f7">regina::detail::SimplexBase&lt; dim &gt;::component</a> () const</td></tr>
<tr class="memdesc:gaae91a7cee2cdc36220b08d9fe96985f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this simplex belongs.  <a href="group__detail.html#gaae91a7cee2cdc36220b08d9fe96985f7">More...</a><br /></td></tr>
<tr class="separator:gaae91a7cee2cdc36220b08d9fe96985f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727ea46d74705043806e29b1fe32c460"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga727ea46d74705043806e29b1fe32c460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga727ea46d74705043806e29b1fe32c460">regina::detail::SimplexBase&lt; dim &gt;::face</a> (int face) const</td></tr>
<tr class="memdesc:ga727ea46d74705043806e29b1fe32c460"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>subdim</em>-face of the underlying triangulation that appears as the given <em>subdim</em>-face of this simplex.  <a href="group__detail.html#ga727ea46d74705043806e29b1fe32c460">More...</a><br /></td></tr>
<tr class="separator:ga727ea46d74705043806e29b1fe32c460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea2c2312ed1484b55eb1db2f25d041e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2ea2c2312ed1484b55eb1db2f25d041e">regina::detail::SimplexBase&lt; dim &gt;::edge</a> (int i, int j) const</td></tr>
<tr class="memdesc:ga2ea2c2312ed1484b55eb1db2f25d041e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the edge of this simplex that connects the two given vertices of this simplex.  <a href="group__detail.html#ga2ea2c2312ed1484b55eb1db2f25d041e">More...</a><br /></td></tr>
<tr class="separator:ga2ea2c2312ed1484b55eb1db2f25d041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:gab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#gab5f66b0a702a6b374af4f0830d9b2fe0">regina::detail::SimplexBase&lt; dim &gt;::faceMapping</a> (int <a class="el" href="group__detail.html#ga727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:gab5f66b0a702a6b374af4f0830d9b2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the given <em>subdim</em>-face of this simplex, and returns the mapping between the underlying <em>subdim</em>-face of the triangulation and the individual vertices of this simplex.  <a href="group__detail.html#gab5f66b0a702a6b374af4f0830d9b2fe0">More...</a><br /></td></tr>
<tr class="separator:gab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0d5105d19509368d155e9f8c497f5e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa0d5105d19509368d155e9f8c497f5e4">regina::detail::SimplexBase&lt; dim &gt;::orientation</a> () const</td></tr>
<tr class="memdesc:gaa0d5105d19509368d155e9f8c497f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the orientation of this simplex in the <em>dim</em>-dimensional triangulation.  <a href="group__detail.html#gaa0d5105d19509368d155e9f8c497f5e4">More...</a><br /></td></tr>
<tr class="separator:gaa0d5105d19509368d155e9f8c497f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9da19b23a42f47afe636a2cff5f0eee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9da19b23a42f47afe636a2cff5f0eee7">regina::detail::SimplexBase&lt; dim &gt;::facetInMaximalForest</a> (int facet) const</td></tr>
<tr class="memdesc:ga9da19b23a42f47afe636a2cff5f0eee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given facet of this simplex belongs to the maximal forest that has been chosen for the dual 1-skeleton of the underlying triangulation.  <a href="group__detail.html#ga9da19b23a42f47afe636a2cff5f0eee7">More...</a><br /></td></tr>
<tr class="separator:ga9da19b23a42f47afe636a2cff5f0eee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb07d86f5e49e7cf9effbcfa7645b7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gadb07d86f5e49e7cf9effbcfa7645b7ce">regina::detail::SimplexBase&lt; dim &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gadb07d86f5e49e7cf9effbcfa7645b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__detail.html#gadb07d86f5e49e7cf9effbcfa7645b7ce">More...</a><br /></td></tr>
<tr class="separator:gadb07d86f5e49e7cf9effbcfa7645b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf98d5138a8528b99a8a77b4533784a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabf98d5138a8528b99a8a77b4533784a4">regina::detail::SimplexBase&lt; dim &gt;::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gabf98d5138a8528b99a8a77b4533784a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__detail.html#gabf98d5138a8528b99a8a77b4533784a4">More...</a><br /></td></tr>
<tr class="separator:gabf98d5138a8528b99a8a77b4533784a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ae0422e6904cdf32ce0d50793bb23fc"><td class="memItemLeft" align="right" valign="top"><a id="ga9ae0422e6904cdf32ce0d50793bb23fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexBase&lt; dim &gt;::SimplexBase</b> (const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga9ae0422e6904cdf32ce0d50793bb23fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff825598c04d8f9c369007f95cdbb75e"><td class="memItemLeft" align="right" valign="top"><a id="gaff825598c04d8f9c369007f95cdbb75e"></a>
<a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexBase&lt; dim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> &amp;)=delete</td></tr>
<tr class="separator:gaff825598c04d8f9c369007f95cdbb75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f6e247acf0c607c9a86722492ca5a1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1f6e247acf0c607c9a86722492ca5a1e">regina::detail::SimplexBase&lt; dim &gt;::SimplexBase</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri)</td></tr>
<tr class="memdesc:ga1f6e247acf0c607c9a86722492ca5a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simplex with no description and no facets joined to anything.  <a href="group__detail.html#ga1f6e247acf0c607c9a86722492ca5a1e">More...</a><br /></td></tr>
<tr class="separator:ga1f6e247acf0c607c9a86722492ca5a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62524114f62901a475255bda387be265"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga62524114f62901a475255bda387be265">regina::detail::SimplexBase&lt; dim &gt;::SimplexBase</a> (const std::string &amp;desc, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri)</td></tr>
<tr class="memdesc:ga62524114f62901a475255bda387be265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simplex with the given description and no facets joined to anything.  <a href="group__detail.html#ga62524114f62901a475255bda387be265">More...</a><br /></td></tr>
<tr class="separator:ga62524114f62901a475255bda387be265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45b34020172394d10592dd4251468bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga45b34020172394d10592dd4251468bcc">regina::detail::FaceListSuite&lt; dim, subdim &gt;::deleteFaces</a> ()</td></tr>
<tr class="memdesc:ga45b34020172394d10592dd4251468bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all faces of dimension <em>subdim</em> and below.  <a href="group__detail.html#ga45b34020172394d10592dd4251468bcc">More...</a><br /></td></tr>
<tr class="separator:ga45b34020172394d10592dd4251468bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013abf7fffeba839fb47a2dcfaee19f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga013abf7fffeba839fb47a2dcfaee19f5">regina::detail::FaceListSuite&lt; dim, subdim &gt;::swapFaces</a> (<a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;other)</td></tr>
<tr class="memdesc:ga013abf7fffeba839fb47a2dcfaee19f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all faces of dimension <em>subdim</em> and below with those of the given triangulation.  <a href="group__detail.html#ga013abf7fffeba839fb47a2dcfaee19f5">More...</a><br /></td></tr>
<tr class="separator:ga013abf7fffeba839fb47a2dcfaee19f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca15c283aec839dfa1fe5819beeeab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2ca15c283aec839dfa1fe5819beeeab4">regina::detail::FaceListSuite&lt; dim, subdim &gt;::fillFVector</a> (std::vector&lt; size_t &gt; &amp;result) const</td></tr>
<tr class="memdesc:ga2ca15c283aec839dfa1fe5819beeeab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given vector with the first (<em>subdim</em> + 1) elements of the f-vector.  <a href="group__detail.html#ga2ca15c283aec839dfa1fe5819beeeab4">More...</a><br /></td></tr>
<tr class="separator:ga2ca15c283aec839dfa1fe5819beeeab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga493b5c6f975ab3ce7cb253532c365b21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga493b5c6f975ab3ce7cb253532c365b21">regina::detail::FaceListSuite&lt; dim, subdim &gt;::sameFVector</a> (const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga493b5c6f975ab3ce7cb253532c365b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same number of <em>k</em>-faces, for each facial dimension <em>k</em> &le; <em>subdim</em>.  <a href="group__detail.html#ga493b5c6f975ab3ce7cb253532c365b21">More...</a><br /></td></tr>
<tr class="separator:ga493b5c6f975ab3ce7cb253532c365b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d39751508a86b39473b628f04fdbcc1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4d39751508a86b39473b628f04fdbcc1">regina::detail::FaceListSuite&lt; dim, subdim &gt;::sameDegrees</a> (const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga4d39751508a86b39473b628f04fdbcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same <em>k</em>-face degree sequences, for each facial dimension <em>k</em> &le; <em>subdim</em>.  <a href="group__detail.html#ga4d39751508a86b39473b628f04fdbcc1">More...</a><br /></td></tr>
<tr class="separator:ga4d39751508a86b39473b628f04fdbcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadea24ee7f48ea98bf8e83347b96589f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaadea24ee7f48ea98bf8e83347b96589f">regina::detail::FaceCalculator&lt; dim, subdim, codim &gt;::calculate</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;t)</td></tr>
<tr class="memdesc:gaadea24ee7f48ea98bf8e83347b96589f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all faces of dimension &le; <em>subdim</em> in the given triangulation.  <a href="group__detail.html#gaadea24ee7f48ea98bf8e83347b96589f">More...</a><br /></td></tr>
<tr class="separator:gaadea24ee7f48ea98bf8e83347b96589f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33716287df00263ec10dade47146d3dd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga33716287df00263ec10dade47146d3dd">regina::detail::BoundaryComponentCalculator&lt; dim, subdim &gt;::identify</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;t, <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *bc, <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *facet)</td></tr>
<tr class="memdesc:ga33716287df00263ec10dade47146d3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies and marks all faces of dimension &le; <em>subdim</em> within the given boundary facet of the given <em>dim</em>-dimensional triangulation.  <a href="group__detail.html#ga33716287df00263ec10dade47146d3dd">More...</a><br /></td></tr>
<tr class="separator:ga33716287df00263ec10dade47146d3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc7b079d5d0b7347b0f1fd5b0f398a1"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaadc7b079d5d0b7347b0f1fd5b0f398a1">regina::detail::EulerCalculator&lt; dim, subdim &gt;::compute</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;tri)</td></tr>
<tr class="memdesc:gaadc7b079d5d0b7347b0f1fd5b0f398a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the alternating sum of the number of faces of <em>tri</em> of dimensions <em>subdim</em>, ..., <em>dim</em>.  <a href="group__detail.html#gaadc7b079d5d0b7347b0f1fd5b0f398a1">More...</a><br /></td></tr>
<tr class="separator:gaadc7b079d5d0b7347b0f1fd5b0f398a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0839df9b50533553b1604fb41fab84d6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0839df9b50533553b1604fb41fab84d6">regina::detail::PachnerHelper&lt; dim, k &gt;::pachner</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri, <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f, bool check, bool perform)</td></tr>
<tr class="memdesc:ga0839df9b50533553b1604fb41fab84d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a (<em>dim</em> - <em>k</em> + 1)-(<em>k</em> + 1) move about the given face.  <a href="group__detail.html#ga0839df9b50533553b1604fb41fab84d6">More...</a><br /></td></tr>
<tr class="separator:ga0839df9b50533553b1604fb41fab84d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae29b538c61d91b627f9e29c589c041fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae29b538c61d91b627f9e29c589c041fd">regina::detail::TriangulationBase&lt; dim &gt;::TopologyLock::TopologyLock</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; *tri)</td></tr>
<tr class="memdesc:gae29b538c61d91b627f9e29c589c041fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new lock on the given triangulation.  <a href="group__detail.html#gae29b538c61d91b627f9e29c589c041fd">More...</a><br /></td></tr>
<tr class="separator:gae29b538c61d91b627f9e29c589c041fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefde423061c7aefa342235a791458765"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaefde423061c7aefa342235a791458765">regina::detail::TriangulationBase&lt; dim &gt;::TopologyLock::~TopologyLock</a> ()</td></tr>
<tr class="memdesc:gaefde423061c7aefa342235a791458765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this lock on the associated triangulation.  <a href="group__detail.html#gaefde423061c7aefa342235a791458765">More...</a><br /></td></tr>
<tr class="separator:gaefde423061c7aefa342235a791458765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e725bd9bbbd6fd5d23d1d20e43f6e43"><td class="memItemLeft" align="right" valign="top">constexpr static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7e725bd9bbbd6fd5d23d1d20e43f6e43">regina::detail::XMLTriangulationTags&lt; dim &gt;::simplices</a> ()</td></tr>
<tr class="memdesc:ga7e725bd9bbbd6fd5d23d1d20e43f6e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The XML tag that stores the set of all top-dimensional simplices for a <em>dim</em>-dimensional triangulation.  <a href="group__detail.html#ga7e725bd9bbbd6fd5d23d1d20e43f6e43">More...</a><br /></td></tr>
<tr class="separator:ga7e725bd9bbbd6fd5d23d1d20e43f6e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2dd807132d852de6cecde560be685a"><td class="memItemLeft" align="right" valign="top">constexpr static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4a2dd807132d852de6cecde560be685a">regina::detail::XMLTriangulationTags&lt; dim &gt;::simplex</a> ()</td></tr>
<tr class="memdesc:ga4a2dd807132d852de6cecde560be685a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The XML tag that stores a single top-dimensional simplex in a <em>dim</em>-dimensional triangulation.  <a href="group__detail.html#ga4a2dd807132d852de6cecde560be685a">More...</a><br /></td></tr>
<tr class="separator:ga4a2dd807132d852de6cecde560be685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43861bd25d2417da9172b1f4c1310370"><td class="memItemLeft" align="right" valign="top">constexpr static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga43861bd25d2417da9172b1f4c1310370">regina::detail::XMLTriangulationTags&lt; dim &gt;::size</a> ()</td></tr>
<tr class="memdesc:ga43861bd25d2417da9172b1f4c1310370"><td class="mdescLeft">&#160;</td><td class="mdescRight">The XML attribute that stores the number of top-dimensional simplices in a <em>dim</em>-dimensional triangulation.  <a href="group__detail.html#ga43861bd25d2417da9172b1f4c1310370">More...</a><br /></td></tr>
<tr class="separator:ga43861bd25d2417da9172b1f4c1310370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90e2cc364bcba8f0aecb268523a708e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad90e2cc364bcba8f0aecb268523a708e">regina::detail::XMLSimplexReader&lt; dim &gt;::XMLSimplexReader</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri, size_t whichSimplex)</td></tr>
<tr class="memdesc:gad90e2cc364bcba8f0aecb268523a708e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simplex element reader.  <a href="group__detail.html#gad90e2cc364bcba8f0aecb268523a708e">More...</a><br /></td></tr>
<tr class="separator:gad90e2cc364bcba8f0aecb268523a708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2454f3da462ae0e806eefcdfbe75654f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2454f3da462ae0e806eefcdfbe75654f">regina::detail::XMLSimplexReader&lt; dim &gt;::startElement</a> (const std::string &amp;, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;props, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *) override</td></tr>
<tr class="memdesc:ga2454f3da462ae0e806eefcdfbe75654f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__detail.html#ga2454f3da462ae0e806eefcdfbe75654f">More...</a><br /></td></tr>
<tr class="separator:ga2454f3da462ae0e806eefcdfbe75654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a3e885cec01b8c8f9f45be1b97fe7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga49a3e885cec01b8c8f9f45be1b97fe7f">regina::detail::XMLSimplexReader&lt; dim &gt;::initialChars</a> (const std::string &amp;chars) override</td></tr>
<tr class="memdesc:ga49a3e885cec01b8c8f9f45be1b97fe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__detail.html#ga49a3e885cec01b8c8f9f45be1b97fe7f">More...</a><br /></td></tr>
<tr class="separator:ga49a3e885cec01b8c8f9f45be1b97fe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07d1fe2808f661e90e0f4cc0e90df4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa07d1fe2808f661e90e0f4cc0e90df4c">regina::detail::XMLSimplicesReader&lt; dim &gt;::XMLSimplicesReader</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *tri)</td></tr>
<tr class="memdesc:gaa07d1fe2808f661e90e0f4cc0e90df4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new simplices element reader.  <a href="group__detail.html#gaa07d1fe2808f661e90e0f4cc0e90df4c">More...</a><br /></td></tr>
<tr class="separator:gaa07d1fe2808f661e90e0f4cc0e90df4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fc09ae4b089c0e8e2642d11e4191aaf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7fc09ae4b089c0e8e2642d11e4191aaf">regina::detail::XMLSimplicesReader&lt; dim &gt;::startElement</a> (const std::string &amp;, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;props, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *) override</td></tr>
<tr class="memdesc:ga7fc09ae4b089c0e8e2642d11e4191aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__detail.html#ga7fc09ae4b089c0e8e2642d11e4191aaf">More...</a><br /></td></tr>
<tr class="separator:ga7fc09ae4b089c0e8e2642d11e4191aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad62f372e5d358a752bd3ed6d70d0447"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaad62f372e5d358a752bd3ed6d70d0447">regina::detail::XMLSimplicesReader&lt; dim &gt;::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;) override</td></tr>
<tr class="memdesc:gaad62f372e5d358a752bd3ed6d70d0447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__detail.html#gaad62f372e5d358a752bd3ed6d70d0447">More...</a><br /></td></tr>
<tr class="separator:gaad62f372e5d358a752bd3ed6d70d0447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f5c18a6fce0eefc6c22179b39dc18f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2f5c18a6fce0eefc6c22179b39dc18f8">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::XMLTriangulationReaderBase</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga2f5c18a6fce0eefc6c22179b39dc18f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new triangulation reader.  <a href="group__detail.html#ga2f5c18a6fce0eefc6c22179b39dc18f8">More...</a><br /></td></tr>
<tr class="separator:ga2f5c18a6fce0eefc6c22179b39dc18f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4de5260704d60064eaacb40fe2f286bc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4de5260704d60064eaacb40fe2f286bc">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::packet</a> () override</td></tr>
<tr class="memdesc:ga4de5260704d60064eaacb40fe2f286bc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__detail.html#ga4de5260704d60064eaacb40fe2f286bc">More...</a><br /></td></tr>
<tr class="separator:ga4de5260704d60064eaacb40fe2f286bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15f7e12e1c4be36e550c0873d227cdca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga15f7e12e1c4be36e550c0873d227cdca">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga15f7e12e1c4be36e550c0873d227cdca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__detail.html#ga15f7e12e1c4be36e550c0873d227cdca">More...</a><br /></td></tr>
<tr class="separator:ga15f7e12e1c4be36e550c0873d227cdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga855ad4db27697cc648b45736957f1224"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga855ad4db27697cc648b45736957f1224">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga855ad4db27697cc648b45736957f1224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__detail.html#ga855ad4db27697cc648b45736957f1224">More...</a><br /></td></tr>
<tr class="separator:ga855ad4db27697cc648b45736957f1224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67641d434d7613123641fe31162abef2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga67641d434d7613123641fe31162abef2">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::AbelianGroupPropertyReader::AbelianGroupPropertyReader</a> (<a class="el" href="group__detail.html#gaa7544f6c646dc7aed9d8a3f07d917da4">PropType</a> &amp;prop)</td></tr>
<tr class="memdesc:ga67641d434d7613123641fe31162abef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new reader that stores its results in the given triangulation property.  <a href="group__detail.html#ga67641d434d7613123641fe31162abef2">More...</a><br /></td></tr>
<tr class="separator:ga67641d434d7613123641fe31162abef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8b2a5ac795f6b22ad0eec7565adc83"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabe8b2a5ac795f6b22ad0eec7565adc83">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::AbelianGroupPropertyReader::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;) override</td></tr>
<tr class="memdesc:gabe8b2a5ac795f6b22ad0eec7565adc83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__detail.html#gabe8b2a5ac795f6b22ad0eec7565adc83">More...</a><br /></td></tr>
<tr class="separator:gabe8b2a5ac795f6b22ad0eec7565adc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8e43e711504f672541536e05006f9b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab8e43e711504f672541536e05006f9b8">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::AbelianGroupPropertyReader::endSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:gab8e43e711504f672541536e05006f9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing has finished for a subelement of this XML element.  <a href="group__detail.html#gab8e43e711504f672541536e05006f9b8">More...</a><br /></td></tr>
<tr class="separator:gab8e43e711504f672541536e05006f9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e7a460d4b7805c994a594d092309ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga28e7a460d4b7805c994a594d092309ee">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::GroupPresentationPropertyReader::GroupPresentationPropertyReader</a> (<a class="el" href="group__detail.html#gab6d74c424017288ecce4629d2f88ae2a">PropType</a> &amp;prop)</td></tr>
<tr class="memdesc:ga28e7a460d4b7805c994a594d092309ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new reader that stores its results in the given triangulation property.  <a href="group__detail.html#ga28e7a460d4b7805c994a594d092309ee">More...</a><br /></td></tr>
<tr class="separator:ga28e7a460d4b7805c994a594d092309ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga543f461338d4187e278f74c8dc7e54f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga543f461338d4187e278f74c8dc7e54f3">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::GroupPresentationPropertyReader::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;) override</td></tr>
<tr class="memdesc:ga543f461338d4187e278f74c8dc7e54f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__detail.html#ga543f461338d4187e278f74c8dc7e54f3">More...</a><br /></td></tr>
<tr class="separator:ga543f461338d4187e278f74c8dc7e54f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03128cad1fee0766645aabe04a5d5174"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga03128cad1fee0766645aabe04a5d5174">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::GroupPresentationPropertyReader::endSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga03128cad1fee0766645aabe04a5d5174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing has finished for a subelement of this XML element.  <a href="group__detail.html#ga03128cad1fee0766645aabe04a5d5174">More...</a><br /></td></tr>
<tr class="separator:ga03128cad1fee0766645aabe04a5d5174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb1a1ac23cabf7edbef79395a0e8af46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gacb1a1ac23cabf7edbef79395a0e8af46">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::propertyReader</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps)</td></tr>
<tr class="memdesc:gacb1a1ac23cabf7edbef79395a0e8af46"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reader for the generic triangulation property with the given subtag name.  <a href="group__detail.html#gacb1a1ac23cabf7edbef79395a0e8af46">More...</a><br /></td></tr>
<tr class="separator:gacb1a1ac23cabf7edbef79395a0e8af46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga7a9e624f86239df884711385ff208eb2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7a9e624f86239df884711385ff208eb2">regina::detail::WeakFaceList&lt; dim, subdim &gt;::faces_</a></td></tr>
<tr class="memdesc:ga7a9e624f86239df884711385ff208eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list of faces.  <a href="group__detail.html#ga7a9e624f86239df884711385ff208eb2">More...</a><br /></td></tr>
<tr class="separator:ga7a9e624f86239df884711385ff208eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga695616fda7f4a0360ce6b94458a879c8"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">regina::detail::BoundaryComponentFaceStorage&lt; dim, allFaces_ &gt;::allFaces</a> = true</td></tr>
<tr class="memdesc:ga695616fda7f4a0360ce6b94458a879c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>).  <a href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">More...</a><br /></td></tr>
<tr class="separator:ga695616fda7f4a0360ce6b94458a879c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1362d526ead23fd9e3d1f8516c89ac2"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa1362d526ead23fd9e3d1f8516c89ac2">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::allFaces</a> = false</td></tr>
<tr class="memdesc:gaa1362d526ead23fd9e3d1f8516c89ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>).  <a href="group__detail.html#gaa1362d526ead23fd9e3d1f8516c89ac2">More...</a><br /></td></tr>
<tr class="separator:gaa1362d526ead23fd9e3d1f8516c89ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a4a6bcc51b669d96a730f2a16aa2728"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0a4a6bcc51b669d96a730f2a16aa2728">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::facets_</a></td></tr>
<tr class="memdesc:ga0a4a6bcc51b669d96a730f2a16aa2728"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all (dim-1)-simplices in the boundary component.  <a href="group__detail.html#ga0a4a6bcc51b669d96a730f2a16aa2728">More...</a><br /></td></tr>
<tr class="separator:ga0a4a6bcc51b669d96a730f2a16aa2728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5239cb90bcbf7e12bbebc2f731645e60"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga5239cb90bcbf7e12bbebc2f731645e60">regina::detail::BoundaryComponentFaceStorage&lt; dim, false &gt;::nRidges_</a></td></tr>
<tr class="memdesc:ga5239cb90bcbf7e12bbebc2f731645e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of (dim-2)-faces in the boundary component.  <a href="group__detail.html#ga5239cb90bcbf7e12bbebc2f731645e60">More...</a><br /></td></tr>
<tr class="separator:ga5239cb90bcbf7e12bbebc2f731645e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2259be5e070ee6a88808f21026a8e2e"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, allowVertex_ &gt;::allowVertex</a> = true</td></tr>
<tr class="memdesc:gae2259be5e070ee6a88808f21026a8e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class.  <a href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">More...</a><br /></td></tr>
<tr class="separator:gae2259be5e070ee6a88808f21026a8e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a92943d330e4e11f8b012dc218e5be8"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3a92943d330e4e11f8b012dc218e5be8">regina::detail::BoundaryComponentFaceInterface&lt; dim, allFaces, false &gt;::allowVertex</a> = false</td></tr>
<tr class="memdesc:ga3a92943d330e4e11f8b012dc218e5be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class.  <a href="group__detail.html#ga3a92943d330e4e11f8b012dc218e5be8">More...</a><br /></td></tr>
<tr class="separator:ga3a92943d330e4e11f8b012dc218e5be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga743fcbbe87613ad86f844f5fbe07e2e3"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga743fcbbe87613ad86f844f5fbe07e2e3">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, canBuild_ &gt;::canBuild</a> = true</td></tr>
<tr class="memdesc:ga743fcbbe87613ad86f844f5fbe07e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class supports triangulating boundary components.  <a href="group__detail.html#ga743fcbbe87613ad86f844f5fbe07e2e3">More...</a><br /></td></tr>
<tr class="separator:ga743fcbbe87613ad86f844f5fbe07e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ba41612ae02ea47c1953758ec2e604d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7ba41612ae02ea47c1953758ec2e604d">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, canBuild_ &gt;::boundary_</a></td></tr>
<tr class="memdesc:ga7ba41612ae02ea47c1953758ec2e604d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A full triangulation of the boundary component.  <a href="group__detail.html#ga7ba41612ae02ea47c1953758ec2e604d">More...</a><br /></td></tr>
<tr class="separator:ga7ba41612ae02ea47c1953758ec2e604d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f4309f2e7b617da85e6585e198dab58"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2f4309f2e7b617da85e6585e198dab58">regina::detail::BoundaryComponentStorage&lt; dim, allFaces, allowVertex, false &gt;::canBuild</a> = false</td></tr>
<tr class="memdesc:ga2f4309f2e7b617da85e6585e198dab58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant indicating whether this boundary component class supports triangulating boundary components.  <a href="group__detail.html#ga2f4309f2e7b617da85e6585e198dab58">More...</a><br /></td></tr>
<tr class="separator:ga2f4309f2e7b617da85e6585e198dab58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa836bb693c00ec5ceed9f9fa8b1404e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa836bb693c00ec5ceed9f9fa8b1404e1">regina::detail::BoundaryComponentBase&lt; dim &gt;::orientable_</a></td></tr>
<tr class="memdesc:gaa836bb693c00ec5ceed9f9fa8b1404e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this boundary component orientable?  <a href="group__detail.html#gaa836bb693c00ec5ceed9f9fa8b1404e1">More...</a><br /></td></tr>
<tr class="separator:gaa836bb693c00ec5ceed9f9fa8b1404e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd43bf111d0354a3e490a44e651cff8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaafd43bf111d0354a3e490a44e651cff8">regina::detail::ComponentBase&lt; dim &gt;::valid_</a></td></tr>
<tr class="memdesc:gaafd43bf111d0354a3e490a44e651cff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this component valid? See <a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">Triangulation&lt;dim&gt;::isValid()</a> for details on what this means.  <a href="group__detail.html#gaafd43bf111d0354a3e490a44e651cff8">More...</a><br /></td></tr>
<tr class="separator:gaafd43bf111d0354a3e490a44e651cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdd4377e3549620d4c90f967729df88"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4cdd4377e3549620d4c90f967729df88">regina::detail::FaceNumberingImpl&lt; dim, subdim, lex &gt;::nFaces</a></td></tr>
<tr class="memdesc:ga4cdd4377e3549620d4c90f967729df88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of <em>subdim</em>-dimensional faces in each <em>dim</em>-dimensional simplex.  <a href="group__detail.html#ga4cdd4377e3549620d4c90f967729df88">More...</a><br /></td></tr>
<tr class="separator:ga4cdd4377e3549620d4c90f967729df88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d9ebb9486886520057d3a1314a2048"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga86d9ebb9486886520057d3a1314a2048">regina::detail::FaceNumberingImpl&lt; dim, subdim, false &gt;::nFaces</a></td></tr>
<tr class="memdesc:ga86d9ebb9486886520057d3a1314a2048"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of <em>subdim</em>-dimensional faces in each <em>dim</em>-dimensional simplex.  <a href="group__detail.html#ga86d9ebb9486886520057d3a1314a2048">More...</a><br /></td></tr>
<tr class="separator:ga86d9ebb9486886520057d3a1314a2048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabea9bb5ad05839b9754d37db00330ffc"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabea9bb5ad05839b9754d37db00330ffc">regina::detail::FaceNumberingImpl&lt; dim, 0, true &gt;::nFaces</a> = dim + 1</td></tr>
<tr class="memdesc:gabea9bb5ad05839b9754d37db00330ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of vertices in each <em>dim</em>-dimensional simplex.  <a href="group__detail.html#gabea9bb5ad05839b9754d37db00330ffc">More...</a><br /></td></tr>
<tr class="separator:gabea9bb5ad05839b9754d37db00330ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e9bde1d818124634239fa08b97ddcb"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga72e9bde1d818124634239fa08b97ddcb">regina::detail::FaceNumberingImpl&lt; 1, 0, true &gt;::nFaces</a> = 2</td></tr>
<tr class="memdesc:ga72e9bde1d818124634239fa08b97ddcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of vertices in each edge.  <a href="group__detail.html#ga72e9bde1d818124634239fa08b97ddcb">More...</a><br /></td></tr>
<tr class="separator:ga72e9bde1d818124634239fa08b97ddcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfcdb70e7b91bd5f9fb3397c909f7376"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabfcdb70e7b91bd5f9fb3397c909f7376">regina::detail::FaceNumberingImpl&lt; 2, 0, true &gt;::nFaces</a> = 3</td></tr>
<tr class="memdesc:gabfcdb70e7b91bd5f9fb3397c909f7376"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of vertices in each triangle.  <a href="group__detail.html#gabfcdb70e7b91bd5f9fb3397c909f7376">More...</a><br /></td></tr>
<tr class="separator:gabfcdb70e7b91bd5f9fb3397c909f7376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561d3baacf7d62429bfaf54c74ac5620"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga561d3baacf7d62429bfaf54c74ac5620">regina::detail::FaceNumberingImpl&lt; 2, 1, false &gt;::nFaces</a> = 3</td></tr>
<tr class="memdesc:ga561d3baacf7d62429bfaf54c74ac5620"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in each triangle.  <a href="group__detail.html#ga561d3baacf7d62429bfaf54c74ac5620">More...</a><br /></td></tr>
<tr class="separator:ga561d3baacf7d62429bfaf54c74ac5620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f9178658917428c841e5b7037bd6fac"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6f9178658917428c841e5b7037bd6fac">regina::detail::FaceNumberingImpl&lt; 3, 0, true &gt;::nFaces</a> = 4</td></tr>
<tr class="memdesc:ga6f9178658917428c841e5b7037bd6fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of vertices in each tetrahedron.  <a href="group__detail.html#ga6f9178658917428c841e5b7037bd6fac">More...</a><br /></td></tr>
<tr class="separator:ga6f9178658917428c841e5b7037bd6fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877171328c1fd9a7cf682fa82aa5d4ab"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga877171328c1fd9a7cf682fa82aa5d4ab">regina::detail::FaceNumberingImpl&lt; 3, 1, true &gt;::edgeNumber</a> [4][4]</td></tr>
<tr class="memdesc:ga877171328c1fd9a7cf682fa82aa5d4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that maps vertices of a tetrahedron to edge numbers.  <a href="group__detail.html#ga877171328c1fd9a7cf682fa82aa5d4ab">More...</a><br /></td></tr>
<tr class="separator:ga877171328c1fd9a7cf682fa82aa5d4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e898cc5186d8191017763dc299bc5b4"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1e898cc5186d8191017763dc299bc5b4">regina::detail::FaceNumberingImpl&lt; 3, 1, true &gt;::edgeVertex</a> [6][2]</td></tr>
<tr class="memdesc:ga1e898cc5186d8191017763dc299bc5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that maps edges of a tetrahedron to vertex numbers.  <a href="group__detail.html#ga1e898cc5186d8191017763dc299bc5b4">More...</a><br /></td></tr>
<tr class="separator:ga1e898cc5186d8191017763dc299bc5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a16a5a64c9968e42e2fab8fa6a276da"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6a16a5a64c9968e42e2fab8fa6a276da">regina::detail::FaceNumberingImpl&lt; 3, 1, true &gt;::nFaces</a> = 6</td></tr>
<tr class="memdesc:ga6a16a5a64c9968e42e2fab8fa6a276da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in each tetrahedron.  <a href="group__detail.html#ga6a16a5a64c9968e42e2fab8fa6a276da">More...</a><br /></td></tr>
<tr class="separator:ga6a16a5a64c9968e42e2fab8fa6a276da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951e2f7720dd304d302851530555cf55"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga951e2f7720dd304d302851530555cf55">regina::detail::FaceNumberingImpl&lt; 3, 2, false &gt;::nFaces</a> = 4</td></tr>
<tr class="memdesc:ga951e2f7720dd304d302851530555cf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of triangles in each tetrahedron.  <a href="group__detail.html#ga951e2f7720dd304d302851530555cf55">More...</a><br /></td></tr>
<tr class="separator:ga951e2f7720dd304d302851530555cf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb57d403ea32c9b1c2b37cef6ac524a4"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gadb57d403ea32c9b1c2b37cef6ac524a4">regina::detail::FaceNumberingImpl&lt; 4, 0, true &gt;::nFaces</a> = 5</td></tr>
<tr class="memdesc:gadb57d403ea32c9b1c2b37cef6ac524a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of vertices in each pentachoron.  <a href="group__detail.html#gadb57d403ea32c9b1c2b37cef6ac524a4">More...</a><br /></td></tr>
<tr class="separator:gadb57d403ea32c9b1c2b37cef6ac524a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91840579e8e12130cd43671271bf87ed"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga91840579e8e12130cd43671271bf87ed">regina::detail::FaceNumberingImpl&lt; 4, 1, true &gt;::edgeNumber</a> [5][5]</td></tr>
<tr class="memdesc:ga91840579e8e12130cd43671271bf87ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that maps vertices of a pentachoron to edge numbers.  <a href="group__detail.html#ga91840579e8e12130cd43671271bf87ed">More...</a><br /></td></tr>
<tr class="separator:ga91840579e8e12130cd43671271bf87ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb616ff04b0862dbd9f98323b05275e"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2fb616ff04b0862dbd9f98323b05275e">regina::detail::FaceNumberingImpl&lt; 4, 1, true &gt;::edgeVertex</a> [10][2]</td></tr>
<tr class="memdesc:ga2fb616ff04b0862dbd9f98323b05275e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that maps edges of a pentachoron to vertex numbers.  <a href="group__detail.html#ga2fb616ff04b0862dbd9f98323b05275e">More...</a><br /></td></tr>
<tr class="separator:ga2fb616ff04b0862dbd9f98323b05275e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42109270ca84f6b0c758857778ca0d75"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga42109270ca84f6b0c758857778ca0d75">regina::detail::FaceNumberingImpl&lt; 4, 1, true &gt;::nFaces</a> = 10</td></tr>
<tr class="memdesc:ga42109270ca84f6b0c758857778ca0d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in each pentachoron.  <a href="group__detail.html#ga42109270ca84f6b0c758857778ca0d75">More...</a><br /></td></tr>
<tr class="separator:ga42109270ca84f6b0c758857778ca0d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3ccaec69e1f90488bf9049359619987"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac3ccaec69e1f90488bf9049359619987">regina::detail::FaceNumberingImpl&lt; 4, 2, false &gt;::triangleNumber</a> [5][5][5]</td></tr>
<tr class="memdesc:gac3ccaec69e1f90488bf9049359619987"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that maps vertices of a pentachoron to triangle numbers.  <a href="group__detail.html#gac3ccaec69e1f90488bf9049359619987">More...</a><br /></td></tr>
<tr class="separator:gac3ccaec69e1f90488bf9049359619987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f560f0f9b54225b09656f55759c19b8"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1f560f0f9b54225b09656f55759c19b8">regina::detail::FaceNumberingImpl&lt; 4, 2, false &gt;::triangleVertex</a> [10][3]</td></tr>
<tr class="memdesc:ga1f560f0f9b54225b09656f55759c19b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A table that maps triangles of a pentachoron to vertex numbers.  <a href="group__detail.html#ga1f560f0f9b54225b09656f55759c19b8">More...</a><br /></td></tr>
<tr class="separator:ga1f560f0f9b54225b09656f55759c19b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953ee94de3460062fe72c90ca5d46b43"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga953ee94de3460062fe72c90ca5d46b43">regina::detail::FaceNumberingImpl&lt; 4, 2, false &gt;::nFaces</a> = 10</td></tr>
<tr class="memdesc:ga953ee94de3460062fe72c90ca5d46b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of triangles in each pentachoron.  <a href="group__detail.html#ga953ee94de3460062fe72c90ca5d46b43">More...</a><br /></td></tr>
<tr class="separator:ga953ee94de3460062fe72c90ca5d46b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffab7483c82d7fdbda006de9a4511a37"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaffab7483c82d7fdbda006de9a4511a37">regina::detail::FaceNumberingImpl&lt; 4, 3, false &gt;::nFaces</a> = 5</td></tr>
<tr class="memdesc:gaffab7483c82d7fdbda006de9a4511a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of tetrahedra in each pentachoron.  <a href="group__detail.html#gaffab7483c82d7fdbda006de9a4511a37">More...</a><br /></td></tr>
<tr class="separator:gaffab7483c82d7fdbda006de9a4511a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga663cb963d4d177f69ec39c7f7409d278"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga663cb963d4d177f69ec39c7f7409d278">regina::detail::FacetPairingBase&lt; dim &gt;::size_</a></td></tr>
<tr class="memdesc:ga663cb963d4d177f69ec39c7f7409d278"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simplices under consideration.  <a href="group__detail.html#ga663cb963d4d177f69ec39c7f7409d278">More...</a><br /></td></tr>
<tr class="separator:ga663cb963d4d177f69ec39c7f7409d278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee05ce55cfad3b49aae171e5baa4a5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaee05ce55cfad3b49aae171e5baa4a5e0">regina::detail::FacetPairingBase&lt; dim &gt;::pairs_</a></td></tr>
<tr class="memdesc:gaee05ce55cfad3b49aae171e5baa4a5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The other facet to which each simplex facet is paired.  <a href="group__detail.html#gaee05ce55cfad3b49aae171e5baa4a5e0">More...</a><br /></td></tr>
<tr class="separator:gaee05ce55cfad3b49aae171e5baa4a5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e2edc9a84b4f7bb1afc4636f86222b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga85e2edc9a84b4f7bb1afc4636f86222b">regina::detail::IsomorphismBase&lt; dim &gt;::nSimplices_</a></td></tr>
<tr class="memdesc:ga85e2edc9a84b4f7bb1afc4636f86222b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of simplices in the source triangulation.  <a href="group__detail.html#ga85e2edc9a84b4f7bb1afc4636f86222b">More...</a><br /></td></tr>
<tr class="separator:ga85e2edc9a84b4f7bb1afc4636f86222b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8b9b5acd02cbd669cdfdd5d3bb0631"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaec8b9b5acd02cbd669cdfdd5d3bb0631">regina::detail::IsomorphismBase&lt; dim &gt;::simpImage_</a></td></tr>
<tr class="memdesc:gaec8b9b5acd02cbd669cdfdd5d3bb0631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the simplex of the destination triangulation that each simplex of the source triangulation maps to.  <a href="group__detail.html#gaec8b9b5acd02cbd669cdfdd5d3bb0631">More...</a><br /></td></tr>
<tr class="separator:gaec8b9b5acd02cbd669cdfdd5d3bb0631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f897c95d4c464b5c56ed5a370b1fd5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6f897c95d4c464b5c56ed5a370b1fd5f">regina::detail::IsomorphismBase&lt; dim &gt;::facetPerm_</a></td></tr>
<tr class="memdesc:ga6f897c95d4c464b5c56ed5a370b1fd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The permutation applied to the facets of each source simplex.  <a href="group__detail.html#ga6f897c95d4c464b5c56ed5a370b1fd5f">More...</a><br /></td></tr>
<tr class="separator:ga6f897c95d4c464b5c56ed5a370b1fd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1f62c40c2775c7d2d03412925c5a2bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab1f62c40c2775c7d2d03412925c5a2bf">regina::detail::SimplexFaces&lt; dim, subdim &gt;::face_</a> [<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td></tr>
<tr class="memdesc:gab1f62c40c2775c7d2d03412925c5a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The faces of the underlying triangulation that form the individual <em>subdim</em>-faces of this simplex.  <a href="group__detail.html#gab1f62c40c2775c7d2d03412925c5a2bf">More...</a><br /></td></tr>
<tr class="separator:gab1f62c40c2775c7d2d03412925c5a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b08af7c20829b137cd1840cc4f2022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad0b08af7c20829b137cd1840cc4f2022">regina::detail::SimplexFaces&lt; dim, subdim &gt;::mapping_</a> [<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td></tr>
<tr class="memdesc:gad0b08af7c20829b137cd1840cc4f2022"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each <em>subdim</em>-face of this simplex, maps vertices (0,1,...,<em>subdim</em>) of the underlying <em>subdim</em>-face of the triangulation to the corresponding vertices of this simplex, as described by faceMapping().  <a href="group__detail.html#gad0b08af7c20829b137cd1840cc4f2022">More...</a><br /></td></tr>
<tr class="separator:gad0b08af7c20829b137cd1840cc4f2022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea7ef789765f01c7b6268e5627bf242"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4ea7ef789765f01c7b6268e5627bf242">regina::detail::Strings&lt; dim_ &gt;::dim</a></td></tr>
<tr class="memdesc:ga4ea7ef789765f01c7b6268e5627bf242"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that gives the dimension <em>dim</em> as a number.  <a href="group__detail.html#ga4ea7ef789765f01c7b6268e5627bf242">More...</a><br /></td></tr>
<tr class="separator:ga4ea7ef789765f01c7b6268e5627bf242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7790e75ecfe5dbc2767e5eb98b666ba9"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7790e75ecfe5dbc2767e5eb98b666ba9">regina::detail::Strings&lt; dim_ &gt;::face</a></td></tr>
<tr class="memdesc:ga7790e75ecfe5dbc2767e5eb98b666ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that gives the name of a <em>dim</em>-face, all in lower case.  <a href="group__detail.html#ga7790e75ecfe5dbc2767e5eb98b666ba9">More...</a><br /></td></tr>
<tr class="separator:ga7790e75ecfe5dbc2767e5eb98b666ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e35cef0bb3781117debcbe0e83ce03d"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7e35cef0bb3781117debcbe0e83ce03d">regina::detail::Strings&lt; dim_ &gt;::Face</a></td></tr>
<tr class="memdesc:ga7e35cef0bb3781117debcbe0e83ce03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that gives the name of a <em>dim</em>-face, with the first word capitalised.  <a href="group__detail.html#ga7e35cef0bb3781117debcbe0e83ce03d">More...</a><br /></td></tr>
<tr class="separator:ga7e35cef0bb3781117debcbe0e83ce03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f55617b786f4756eb088fc991536278"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4f55617b786f4756eb088fc991536278">regina::detail::Strings&lt; dim_ &gt;::faces</a></td></tr>
<tr class="memdesc:ga4f55617b786f4756eb088fc991536278"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that gives the plural name of a <em>dim</em>-face, all in lower case.  <a href="group__detail.html#ga4f55617b786f4756eb088fc991536278">More...</a><br /></td></tr>
<tr class="separator:ga4f55617b786f4756eb088fc991536278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac21414f54259a5efc3dc0b8a4350142"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaac21414f54259a5efc3dc0b8a4350142">regina::detail::Strings&lt; dim_ &gt;::Faces</a></td></tr>
<tr class="memdesc:gaac21414f54259a5efc3dc0b8a4350142"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that gives the plural name of a <em>dim</em>-face, with the first word capitalised.  <a href="group__detail.html#gaac21414f54259a5efc3dc0b8a4350142">More...</a><br /></td></tr>
<tr class="separator:gaac21414f54259a5efc3dc0b8a4350142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga183b7a36759cba046d255dc8e3ba055a"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga183b7a36759cba046d255dc8e3ba055a">regina::detail::Strings&lt; dim_ &gt;::simplex</a></td></tr>
<tr class="memdesc:ga183b7a36759cba046d255dc8e3ba055a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that gives the name of a <em>dim</em>-simplex, all in lower case.  <a href="group__detail.html#ga183b7a36759cba046d255dc8e3ba055a">More...</a><br /></td></tr>
<tr class="separator:ga183b7a36759cba046d255dc8e3ba055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed2ac79d147176672e6cdc9e09267c6"><td class="memItemLeft" align="right" valign="top">static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3ed2ac79d147176672e6cdc9e09267c6">regina::detail::Strings&lt; dim_ &gt;::Simplex</a></td></tr>
<tr class="memdesc:ga3ed2ac79d147176672e6cdc9e09267c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string that gives the name of a <em>dim</em>-simplex, with the first word capitalised.  <a href="group__detail.html#ga3ed2ac79d147176672e6cdc9e09267c6">More...</a><br /></td></tr>
<tr class="separator:ga3ed2ac79d147176672e6cdc9e09267c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa177dda3276927267a3ae0130765a6f1"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa177dda3276927267a3ae0130765a6f1">regina::detail::TriangulationBase&lt; dim &gt;::dimension</a> = dim</td></tr>
<tr class="memdesc:gaa177dda3276927267a3ae0130765a6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant that gives the dimension of the triangulation.  <a href="group__detail.html#gaa177dda3276927267a3ae0130765a6f1">More...</a><br /></td></tr>
<tr class="separator:gaa177dda3276927267a3ae0130765a6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1739e33bdbb5c52cb77de81ec93c1ec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1739e33bdbb5c52cb77de81ec93c1ec8">regina::detail::TriangulationBase&lt; dim &gt;::simplices_</a></td></tr>
<tr class="memdesc:ga1739e33bdbb5c52cb77de81ec93c1ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-dimensional simplices that form the triangulation.  <a href="group__detail.html#ga1739e33bdbb5c52cb77de81ec93c1ec8">More...</a><br /></td></tr>
<tr class="separator:ga1739e33bdbb5c52cb77de81ec93c1ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6e46682d3ce5b05f7e693f863018f66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa6e46682d3ce5b05f7e693f863018f66">regina::detail::TriangulationBase&lt; dim &gt;::boundaryComponents_</a></td></tr>
<tr class="memdesc:gaa6e46682d3ce5b05f7e693f863018f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">The components that form the boundary of the triangulation.  <a href="group__detail.html#gaa6e46682d3ce5b05f7e693f863018f66">More...</a><br /></td></tr>
<tr class="separator:gaa6e46682d3ce5b05f7e693f863018f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga106dc9d8ffc9e2bd1dd35ad35d52773c">regina::detail::TriangulationBase&lt; dim &gt;::valid_</a></td></tr>
<tr class="memdesc:ga106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this triangulation valid? See <a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means.  <a href="group__detail.html#ga106dc9d8ffc9e2bd1dd35ad35d52773c">More...</a><br /></td></tr>
<tr class="separator:ga106dc9d8ffc9e2bd1dd35ad35d52773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga100785957f37cd392acc3ab420d44928"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga100785957f37cd392acc3ab420d44928">regina::detail::TriangulationBase&lt; dim &gt;::topologyLock_</a></td></tr>
<tr class="memdesc:ga100785957f37cd392acc3ab420d44928"><td class="mdescLeft">&#160;</td><td class="mdescRight">If non-zero, this will cause Triangulation&lt;dim&gt;::clearAllProperties() to preserve any computed properties that related to the manifold (as opposed to the specific triangulation).  <a href="group__detail.html#ga100785957f37cd392acc3ab420d44928">More...</a><br /></td></tr>
<tr class="separator:ga100785957f37cd392acc3ab420d44928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa698ed74854bbf07083babe002b9ef2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa698ed74854bbf07083babe002b9ef2d">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;::tri_</a></td></tr>
<tr class="memdesc:gaa698ed74854bbf07083babe002b9ef2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation currently being read.  <a href="group__detail.html#gaa698ed74854bbf07083babe002b9ef2d">More...</a><br /></td></tr>
<tr class="separator:gaa698ed74854bbf07083babe002b9ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4ac4dded60d8f6ec4e40d49ca37e9057">regina::detail::BoundaryComponentBase&lt; dim &gt;::Triangulation&lt; dim &gt;</a></td></tr>
<tr class="memdesc:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow access to private members.  <a href="group__detail.html#ga4ac4dded60d8f6ec4e40d49ca37e9057">More...</a><br /></td></tr>
<tr class="separator:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memItemLeft" align="right" valign="top"><a id="ga4ac4dded60d8f6ec4e40d49ca37e9057"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::ComponentBase&lt; dim &gt;::Triangulation&lt; dim &gt;</b></td></tr>
<tr class="separator:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5568151bbbf92a4593d1836c8e954c07"><td class="memItemLeft" align="right" valign="top"><a id="ga5568151bbbf92a4593d1836c8e954c07"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::ComponentBase&lt; dim &gt;::TriangulationBase&lt; dim &gt;</b></td></tr>
<tr class="separator:ga5568151bbbf92a4593d1836c8e954c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memItemLeft" align="right" valign="top"><a id="ga4ac4dded60d8f6ec4e40d49ca37e9057"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::FaceBase&lt; dim, subdim &gt;::Triangulation&lt; dim &gt;</b></td></tr>
<tr class="separator:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5568151bbbf92a4593d1836c8e954c07"><td class="memItemLeft" align="right" valign="top"><a id="ga5568151bbbf92a4593d1836c8e954c07"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::FaceBase&lt; dim, subdim &gt;::TriangulationBase&lt; dim &gt;</b></td></tr>
<tr class="separator:ga5568151bbbf92a4593d1836c8e954c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5568151bbbf92a4593d1836c8e954c07"><td class="memItemLeft" align="right" valign="top"><a id="ga5568151bbbf92a4593d1836c8e954c07"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexBase&lt; dim &gt;::TriangulationBase&lt; dim &gt;</b></td></tr>
<tr class="separator:ga5568151bbbf92a4593d1836c8e954c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memItemLeft" align="right" valign="top"><a id="ga4ac4dded60d8f6ec4e40d49ca37e9057"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexBase&lt; dim &gt;::Triangulation&lt; dim &gt;</b></td></tr>
<tr class="separator:ga4ac4dded60d8f6ec4e40d49ca37e9057"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Importing Triangulations</h2></td></tr>
<tr class="memitem:gab021b95f9d18668036598107ce238c91"><td class="memTemplParams" colspan="2"><a id="gab021b95f9d18668036598107ce238c91"></a>
template&lt;int , int , int &gt; </td></tr>
<tr class="memitem:gab021b95f9d18668036598107ce238c91"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::detail::TriangulationBase&lt; dim &gt;::FaceCalculator</b></td></tr>
<tr class="separator:gab021b95f9d18668036598107ce238c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6435846e3ce3cf6cd9a6e30cc75c8aa"><td class="memTemplParams" colspan="2"><a id="gae6435846e3ce3cf6cd9a6e30cc75c8aa"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:gae6435846e3ce3cf6cd9a6e30cc75c8aa"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::detail::TriangulationBase&lt; dim &gt;::BoundaryComponentCalculator</b></td></tr>
<tr class="separator:gae6435846e3ce3cf6cd9a6e30cc75c8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac64f8d4de2263723b89b039faf139e7a"><td class="memTemplParams" colspan="2"><a id="gac64f8d4de2263723b89b039faf139e7a"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:gac64f8d4de2263723b89b039faf139e7a"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::detail::TriangulationBase&lt; dim &gt;::PachnerHelper</b></td></tr>
<tr class="separator:gac64f8d4de2263723b89b039faf139e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37eb06ce1f7f56644a2a8a6e8d6d6498"><td class="memTemplParams" colspan="2"><a id="ga37eb06ce1f7f56644a2a8a6e8d6d6498"></a>
template&lt;int , int &gt; </td></tr>
<tr class="memitem:ga37eb06ce1f7f56644a2a8a6e8d6d6498"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>regina::detail::TriangulationBase&lt; dim &gt;::WeakFaceList</b></td></tr>
<tr class="separator:ga37eb06ce1f7f56644a2a8a6e8d6d6498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e81e1477448bd234992c2991afb05e"><td class="memItemLeft" align="right" valign="top"><a id="ga97e81e1477448bd234992c2991afb05e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::XMLTriangulationReaderBase&lt; dim &gt;</b></td></tr>
<tr class="separator:ga97e81e1477448bd234992c2991afb05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7a5a9449f2de027e0cae40ff8a3ee38"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38">regina::detail::TriangulationBase&lt; dim &gt;::fromIsoSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:gac7a5a9449f2de027e0cae40ff8a3ee38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a full triangulation from an isomorphism signature.  <a href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38">More...</a><br /></td></tr>
<tr class="separator:gac7a5a9449f2de027e0cae40ff8a3ee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0eedc0b1fc037af0d9c6c23c32d79f2b">regina::detail::TriangulationBase&lt; dim &gt;::isoSigComponentSize</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:ga0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature.  <a href="group__detail.html#ga0eedc0b1fc037af0d9c6c23c32d79f2b">More...</a><br /></td></tr>
<tr class="separator:ga0eedc0b1fc037af0d9c6c23c32d79f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b30977254d11ae9bd0ab4c7e2c32533"><td class="memItemLeft" align="right" valign="top"><a id="ga0b30977254d11ae9bd0ab4c7e2c32533"></a>
<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::TriangulationBase&lt; dim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga0b30977254d11ae9bd0ab4c7e2c32533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa87b9f9c40a48cee3a1ee9c71bd70fef">regina::detail::TriangulationBase&lt; dim &gt;::ensureSkeleton</a> () const</td></tr>
<tr class="memdesc:gaa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that all "on demand" skeletal objects have been calculated.  <a href="group__detail.html#gaa87b9f9c40a48cee3a1ee9c71bd70fef">More...</a><br /></td></tr>
<tr class="separator:gaa87b9f9c40a48cee3a1ee9c71bd70fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99eccc799a49667455b78f790f258098"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga99eccc799a49667455b78f790f258098">regina::detail::TriangulationBase&lt; dim &gt;::calculatedSkeleton</a> () const</td></tr>
<tr class="memdesc:ga99eccc799a49667455b78f790f258098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the skeletal objects and properties of this triangulation have been calculated.  <a href="group__detail.html#ga99eccc799a49667455b78f790f258098">More...</a><br /></td></tr>
<tr class="separator:ga99eccc799a49667455b78f790f258098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d04b371303f07f238af57faf82c9402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1d04b371303f07f238af57faf82c9402">regina::detail::TriangulationBase&lt; dim &gt;::calculateSkeleton</a> ()</td></tr>
<tr class="memdesc:ga1d04b371303f07f238af57faf82c9402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates all skeletal objects for this triangulation.  <a href="group__detail.html#ga1d04b371303f07f238af57faf82c9402">More...</a><br /></td></tr>
<tr class="separator:ga1d04b371303f07f238af57faf82c9402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571569a34bb4173bd5eb6b521ff503cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga571569a34bb4173bd5eb6b521ff503cb">regina::detail::TriangulationBase&lt; dim &gt;::clearBaseProperties</a> ()</td></tr>
<tr class="memdesc:ga571569a34bb4173bd5eb6b521ff503cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all properties that are managed by this base class.  <a href="group__detail.html#ga571569a34bb4173bd5eb6b521ff503cb">More...</a><br /></td></tr>
<tr class="separator:ga571569a34bb4173bd5eb6b521ff503cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2c7206559a6f253ba033c69afe2a54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga0b2c7206559a6f253ba033c69afe2a54">regina::detail::TriangulationBase&lt; dim &gt;::swapBaseProperties</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;other)</td></tr>
<tr class="memdesc:ga0b2c7206559a6f253ba033c69afe2a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all properties that are managed by this base class, including skeletal data, with the given triangulation.  <a href="group__detail.html#ga0b2c7206559a6f253ba033c69afe2a54">More...</a><br /></td></tr>
<tr class="separator:ga0b2c7206559a6f253ba033c69afe2a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad1d1a2ca27fd966c3c7403f0a1c6080d">regina::detail::TriangulationBase&lt; dim &gt;::writeXMLBaseProperties</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing properties of this triangulation.  <a href="group__detail.html#gad1d1a2ca27fd966c3c7403f0a1c6080d">More...</a><br /></td></tr>
<tr class="separator:gad1d1a2ca27fd966c3c7403f0a1c6080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:ga03ab9eda74347bfa8ad909e9d6ecf0bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga03ab9eda74347bfa8ad909e9d6ecf0bd">regina::detail::FacetPairingBase&lt; dim &gt;::FacetPairingBase</a> (const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga03ab9eda74347bfa8ad909e9d6ecf0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new facet pairing that is a clone of the given facet pairing.  <a href="group__detail.html#ga03ab9eda74347bfa8ad909e9d6ecf0bd">More...</a><br /></td></tr>
<tr class="separator:ga03ab9eda74347bfa8ad909e9d6ecf0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f49a37db6de4fe56424d1edecf3705d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1f49a37db6de4fe56424d1edecf3705d">regina::detail::FacetPairingBase&lt; dim &gt;::FacetPairingBase</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;tri)</td></tr>
<tr class="memdesc:ga1f49a37db6de4fe56424d1edecf3705d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the facet pairing of given triangulation.  <a href="group__detail.html#ga1f49a37db6de4fe56424d1edecf3705d">More...</a><br /></td></tr>
<tr class="separator:ga1f49a37db6de4fe56424d1edecf3705d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb4499d89fb9517b882720cf3b81a48"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gafdb4499d89fb9517b882720cf3b81a48">regina::detail::FacetPairingBase&lt; dim &gt;::~FacetPairingBase</a> ()</td></tr>
<tr class="memdesc:gafdb4499d89fb9517b882720cf3b81a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates any memory used by this structure.  <a href="group__detail.html#gafdb4499d89fb9517b882720cf3b81a48">More...</a><br /></td></tr>
<tr class="separator:gafdb4499d89fb9517b882720cf3b81a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Basic Queries</h2></td></tr>
<tr class="memitem:ga05fd123494c0f9d15ffed9f226728b83"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga05fd123494c0f9d15ffed9f226728b83">regina::detail::FacetPairingBase&lt; dim &gt;::size</a> () const</td></tr>
<tr class="memdesc:ga05fd123494c0f9d15ffed9f226728b83"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of simplices whose facets are described by this facet pairing.  <a href="group__detail.html#ga05fd123494c0f9d15ffed9f226728b83">More...</a><br /></td></tr>
<tr class="separator:ga05fd123494c0f9d15ffed9f226728b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a751dcff6edea48d5407a9de3247927"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4a751dcff6edea48d5407a9de3247927">regina::detail::FacetPairingBase&lt; dim &gt;::dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:ga4a751dcff6edea48d5407a9de3247927"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="group__detail.html#ga4a751dcff6edea48d5407a9de3247927">More...</a><br /></td></tr>
<tr class="separator:ga4a751dcff6edea48d5407a9de3247927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b80d0f2604bc161b99f4faa5ac6e7b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga08b80d0f2604bc161b99f4faa5ac6e7b">regina::detail::FacetPairingBase&lt; dim &gt;::dest</a> (size_t simp, unsigned facet) const</td></tr>
<tr class="memdesc:ga08b80d0f2604bc161b99f4faa5ac6e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="group__detail.html#ga08b80d0f2604bc161b99f4faa5ac6e7b">More...</a><br /></td></tr>
<tr class="separator:ga08b80d0f2604bc161b99f4faa5ac6e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012c646f9f7388f3f4379f2f3281ed69"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga012c646f9f7388f3f4379f2f3281ed69">regina::detail::FacetPairingBase&lt; dim &gt;::operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:ga012c646f9f7388f3f4379f2f3281ed69"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="group__detail.html#ga012c646f9f7388f3f4379f2f3281ed69">More...</a><br /></td></tr>
<tr class="separator:ga012c646f9f7388f3f4379f2f3281ed69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86c56d584b417d3fb51507fb92809721"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga86c56d584b417d3fb51507fb92809721">regina::detail::FacetPairingBase&lt; dim &gt;::isUnmatched</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:ga86c56d584b417d3fb51507fb92809721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <a href="group__detail.html#ga86c56d584b417d3fb51507fb92809721">More...</a><br /></td></tr>
<tr class="separator:ga86c56d584b417d3fb51507fb92809721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed7d81f46e1382e0ab6937f410f6b230"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaed7d81f46e1382e0ab6937f410f6b230">regina::detail::FacetPairingBase&lt; dim &gt;::isUnmatched</a> (size_t simp, unsigned facet) const</td></tr>
<tr class="memdesc:gaed7d81f46e1382e0ab6937f410f6b230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given simplex facet has been left deliberately unmatched.  <a href="group__detail.html#gaed7d81f46e1382e0ab6937f410f6b230">More...</a><br /></td></tr>
<tr class="separator:gaed7d81f46e1382e0ab6937f410f6b230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b81d609b3827899604f1e8a829c884"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga55b81d609b3827899604f1e8a829c884">regina::detail::FacetPairingBase&lt; dim &gt;::isClosed</a> () const</td></tr>
<tr class="memdesc:ga55b81d609b3827899604f1e8a829c884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is closed.  <a href="group__detail.html#ga55b81d609b3827899604f1e8a829c884">More...</a><br /></td></tr>
<tr class="separator:ga55b81d609b3827899604f1e8a829c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Isomorphic Representations</h2></td></tr>
<tr class="memitem:gad720be5515121b69f7ce62e5bbda9b5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b">regina::detail::FacetPairingBase&lt; dim &gt;::isCanonical</a> () const</td></tr>
<tr class="memdesc:gad720be5515121b69f7ce62e5bbda9b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal representative of its isomorphism class.  <a href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b">More...</a><br /></td></tr>
<tr class="separator:gad720be5515121b69f7ce62e5bbda9b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b40f375b3813b8ee467fd5e0e2f7cab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2b40f375b3813b8ee467fd5e0e2f7cab">regina::detail::FacetPairingBase&lt; dim &gt;::findAutomorphisms</a> (<a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;list) const</td></tr>
<tr class="memdesc:ga2b40f375b3813b8ee467fd5e0e2f7cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given list with the set of all combinatorial automorphisms of this facet pairing.  <a href="group__detail.html#ga2b40f375b3813b8ee467fd5e0e2f7cab">More...</a><br /></td></tr>
<tr class="separator:ga2b40f375b3813b8ee467fd5e0e2f7cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Input and Output</h2></td></tr>
<tr class="memitem:ga2e3a9b5851e0f984a28cc88fa64717c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2e3a9b5851e0f984a28cc88fa64717c1">regina::detail::FacetPairingBase&lt; dim &gt;::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga2e3a9b5851e0f984a28cc88fa64717c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a human-readable representation of this facet pairing to the given output stream.  <a href="group__detail.html#ga2e3a9b5851e0f984a28cc88fa64717c1">More...</a><br /></td></tr>
<tr class="separator:ga2e3a9b5851e0f984a28cc88fa64717c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afb56a1370b063c12c4efe634eb771b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6afb56a1370b063c12c4efe634eb771b">regina::detail::FacetPairingBase&lt; dim &gt;::toTextRep</a> () const</td></tr>
<tr class="memdesc:ga6afb56a1370b063c12c4efe634eb771b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text-based representation of this facet pairing that can be used to reconstruct the facet pairing.  <a href="group__detail.html#ga6afb56a1370b063c12c4efe634eb771b">More...</a><br /></td></tr>
<tr class="separator:ga6afb56a1370b063c12c4efe634eb771b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac869dd2ea2d4ca009f1e6474920fe65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b">regina::detail::FacetPairingBase&lt; dim &gt;::writeDot</a> (std::ostream &amp;out, const char *prefix=0, bool subgraph=false, bool labels=false) const</td></tr>
<tr class="memdesc:gac869dd2ea2d4ca009f1e6474920fe65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the graph corresponding to this facet pairing in the Graphviz DOT language.  <a href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b">More...</a><br /></td></tr>
<tr class="separator:gac869dd2ea2d4ca009f1e6474920fe65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9212638b8863bd3dd2402371c521906b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga9212638b8863bd3dd2402371c521906b">regina::detail::FacetPairingBase&lt; dim &gt;::dot</a> (const char *prefix=0, bool subgraph=false, bool labels=false) const</td></tr>
<tr class="memdesc:ga9212638b8863bd3dd2402371c521906b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of the graph that describes this facet pairing.  <a href="group__detail.html#ga9212638b8863bd3dd2402371c521906b">More...</a><br /></td></tr>
<tr class="separator:ga9212638b8863bd3dd2402371c521906b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3241a34885f4b644773edccf65225ac4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3241a34885f4b644773edccf65225ac4">regina::detail::FacetPairingBase&lt; dim &gt;::fromTextRep</a> (const std::string &amp;rep)</td></tr>
<tr class="memdesc:ga3241a34885f4b644773edccf65225ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs a facet pairing from a text-based representation.  <a href="group__detail.html#ga3241a34885f4b644773edccf65225ac4">More...</a><br /></td></tr>
<tr class="separator:ga3241a34885f4b644773edccf65225ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e368406092dd1c1c349dd07958f6145"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7e368406092dd1c1c349dd07958f6145">regina::detail::FacetPairingBase&lt; dim &gt;::writeDotHeader</a> (std::ostream &amp;out, const char *graphName=0)</td></tr>
<tr class="memdesc:ga7e368406092dd1c1c349dd07958f6145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <a href="group__detail.html#ga7e368406092dd1c1c349dd07958f6145">More...</a><br /></td></tr>
<tr class="separator:ga7e368406092dd1c1c349dd07958f6145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf1e9a32a2820fc0215afd89a6566c32"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gadf1e9a32a2820fc0215afd89a6566c32">regina::detail::FacetPairingBase&lt; dim &gt;::dotHeader</a> (const char *graphName=0)</td></tr>
<tr class="memdesc:gadf1e9a32a2820fc0215afd89a6566c32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings.  <a href="group__detail.html#gadf1e9a32a2820fc0215afd89a6566c32">More...</a><br /></td></tr>
<tr class="separator:gadf1e9a32a2820fc0215afd89a6566c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf37845787a6a80399160c535b9344d08"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08">regina::detail::FacetPairingBase&lt; dim &gt;::findAllPairings</a> (size_t nSimplices, <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> boundary, int nBdryFacets, <a class="el" href="group__detail.html#ga950ce31e11866d63683a435e8d76c9bf">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gaf37845787a6a80399160c535b9344d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible facet pairings satisfying the given constraints.  <a href="group__detail.html#gaf37845787a6a80399160c535b9344d08">More...</a><br /></td></tr>
<tr class="separator:gaf37845787a6a80399160c535b9344d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga470903b27248e49bcff8ed5739c66282"><td class="memItemLeft" align="right" valign="top"><a id="ga470903b27248e49bcff8ed5739c66282"></a>
<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::FacetPairingBase&lt; dim &gt;::operator=</b> (const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a> &amp;)=delete</td></tr>
<tr class="separator:ga470903b27248e49bcff8ed5739c66282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7427ba20ec700dab650cb40931f95e43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7427ba20ec700dab650cb40931f95e43">regina::detail::FacetPairingBase&lt; dim &gt;::FacetPairingBase</a> (size_t <a class="el" href="group__detail.html#ga05fd123494c0f9d15ffed9f226728b83">size</a>)</td></tr>
<tr class="memdesc:ga7427ba20ec700dab650cb40931f95e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new facet pairing.  <a href="group__detail.html#ga7427ba20ec700dab650cb40931f95e43">More...</a><br /></td></tr>
<tr class="separator:ga7427ba20ec700dab650cb40931f95e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6beef317a48670f0a4b015b6a9677c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6beef317a48670f0a4b015b6a9677c62">regina::detail::FacetPairingBase&lt; dim &gt;::dest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>)</td></tr>
<tr class="memdesc:ga6beef317a48670f0a4b015b6a9677c62"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="group__detail.html#ga6beef317a48670f0a4b015b6a9677c62">More...</a><br /></td></tr>
<tr class="separator:ga6beef317a48670f0a4b015b6a9677c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0426cec394e5b98ec2134c12dcaed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaec0426cec394e5b98ec2134c12dcaed9">regina::detail::FacetPairingBase&lt; dim &gt;::dest</a> (size_t simp, unsigned facet)</td></tr>
<tr class="memdesc:gaec0426cec394e5b98ec2134c12dcaed9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="group__detail.html#gaec0426cec394e5b98ec2134c12dcaed9">More...</a><br /></td></tr>
<tr class="separator:gaec0426cec394e5b98ec2134c12dcaed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74fc68b1801eae6f8a62220accb4c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab74fc68b1801eae6f8a62220accb4c72">regina::detail::FacetPairingBase&lt; dim &gt;::operator[]</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>)</td></tr>
<tr class="memdesc:gab74fc68b1801eae6f8a62220accb4c72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired.  <a href="group__detail.html#gab74fc68b1801eae6f8a62220accb4c72">More...</a><br /></td></tr>
<tr class="separator:gab74fc68b1801eae6f8a62220accb4c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11c57ad6815d5771c941ec03eeb326d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad11c57ad6815d5771c941ec03eeb326d">regina::detail::FacetPairingBase&lt; dim &gt;::noDest</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:gad11c57ad6815d5771c941ec03eeb326d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <a href="group__detail.html#gad11c57ad6815d5771c941ec03eeb326d">More...</a><br /></td></tr>
<tr class="separator:gad11c57ad6815d5771c941ec03eeb326d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bccd3160594ba66ba13edd3735e664b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8bccd3160594ba66ba13edd3735e664b">regina::detail::FacetPairingBase&lt; dim &gt;::noDest</a> (size_t simp, unsigned facet) const</td></tr>
<tr class="memdesc:ga8bccd3160594ba66ba13edd3735e664b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the matching for the given simplex facet has not yet been determined.  <a href="group__detail.html#ga8bccd3160594ba66ba13edd3735e664b">More...</a><br /></td></tr>
<tr class="separator:ga8bccd3160594ba66ba13edd3735e664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b11f9aa0e0746204354dfa13e418156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6b11f9aa0e0746204354dfa13e418156">regina::detail::FacetPairingBase&lt; dim &gt;::isCanonicalInternal</a> (<a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;list) const</td></tr>
<tr class="memdesc:ga6b11f9aa0e0746204354dfa13e418156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions.  <a href="group__detail.html#ga6b11f9aa0e0746204354dfa13e418156">More...</a><br /></td></tr>
<tr class="separator:ga6b11f9aa0e0746204354dfa13e418156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:gaaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaaa79cc9e7f5b4f6ea27045ebf3c8fabc">regina::detail::TriangulationBase&lt; dim &gt;::TriangulationBase</a> ()</td></tr>
<tr class="memdesc:gaaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="group__detail.html#gaaa79cc9e7f5b4f6ea27045ebf3c8fabc">More...</a><br /></td></tr>
<tr class="separator:gaaa79cc9e7f5b4f6ea27045ebf3c8fabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f24cf3815b0d19d5afeae1860fcd0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga51f24cf3815b0d19d5afeae1860fcd0f">regina::detail::TriangulationBase&lt; dim &gt;::TriangulationBase</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;copy)</td></tr>
<tr class="memdesc:ga51f24cf3815b0d19d5afeae1860fcd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation.  <a href="group__detail.html#ga51f24cf3815b0d19d5afeae1860fcd0f">More...</a><br /></td></tr>
<tr class="separator:ga51f24cf3815b0d19d5afeae1860fcd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa664ef0a04f31b2df1594f2a8dbb1322"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaa664ef0a04f31b2df1594f2a8dbb1322">regina::detail::TriangulationBase&lt; dim &gt;::TriangulationBase</a> (const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;copy, bool cloneProps)</td></tr>
<tr class="memdesc:gaa664ef0a04f31b2df1594f2a8dbb1322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties also.  <a href="group__detail.html#gaa664ef0a04f31b2df1594f2a8dbb1322">More...</a><br /></td></tr>
<tr class="separator:gaa664ef0a04f31b2df1594f2a8dbb1322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace45d0a52d9a2a853f890d1006fedf7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gace45d0a52d9a2a853f890d1006fedf7c">regina::detail::TriangulationBase&lt; dim &gt;::~TriangulationBase</a> ()</td></tr>
<tr class="memdesc:gace45d0a52d9a2a853f890d1006fedf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this triangulation.  <a href="group__detail.html#gace45d0a52d9a2a853f890d1006fedf7c">More...</a><br /></td></tr>
<tr class="separator:gace45d0a52d9a2a853f890d1006fedf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Simplices</h2></td></tr>
<tr class="memitem:ga3871caa1f02ccda957f22ebd9a646ff5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5">regina::detail::TriangulationBase&lt; dim &gt;::size</a> () const</td></tr>
<tr class="memdesc:ga3871caa1f02ccda957f22ebd9a646ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of top-dimensional simplices in the triangulation.  <a href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5">More...</a><br /></td></tr>
<tr class="separator:ga3871caa1f02ccda957f22ebd9a646ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8322ef559fdee45b8905c8eef682ac77"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8322ef559fdee45b8905c8eef682ac77">regina::detail::TriangulationBase&lt; dim &gt;::simplices</a> () const</td></tr>
<tr class="memdesc:ga8322ef559fdee45b8905c8eef682ac77"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all top-dimensional simplices in the triangulation.  <a href="group__detail.html#ga8322ef559fdee45b8905c8eef682ac77">More...</a><br /></td></tr>
<tr class="separator:ga8322ef559fdee45b8905c8eef682ac77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e269a7332e80aeec3603881fd175d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae2e269a7332e80aeec3603881fd175d3">regina::detail::TriangulationBase&lt; dim &gt;::simplex</a> (size_t index)</td></tr>
<tr class="memdesc:gae2e269a7332e80aeec3603881fd175d3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation.  <a href="group__detail.html#gae2e269a7332e80aeec3603881fd175d3">More...</a><br /></td></tr>
<tr class="separator:gae2e269a7332e80aeec3603881fd175d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdadce4ea703518064241597cf1514b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7cdadce4ea703518064241597cf1514b">regina::detail::TriangulationBase&lt; dim &gt;::simplex</a> (size_t index) const</td></tr>
<tr class="memdesc:ga7cdadce4ea703518064241597cf1514b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation.  <a href="group__detail.html#ga7cdadce4ea703518064241597cf1514b">More...</a><br /></td></tr>
<tr class="separator:ga7cdadce4ea703518064241597cf1514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad107a418e2691dc5ad7bb9e90dcba437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437">regina::detail::TriangulationBase&lt; dim &gt;::newSimplex</a> ()</td></tr>
<tr class="memdesc:gad107a418e2691dc5ad7bb9e90dcba437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex and adds it to this triangulation.  <a href="group__detail.html#gad107a418e2691dc5ad7bb9e90dcba437">More...</a><br /></td></tr>
<tr class="separator:gad107a418e2691dc5ad7bb9e90dcba437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829224a264241e43a8f2bbdf5bfcb253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga829224a264241e43a8f2bbdf5bfcb253">regina::detail::TriangulationBase&lt; dim &gt;::newSimplex</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:ga829224a264241e43a8f2bbdf5bfcb253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex with the given description and adds it to this triangulation.  <a href="group__detail.html#ga829224a264241e43a8f2bbdf5bfcb253">More...</a><br /></td></tr>
<tr class="separator:ga829224a264241e43a8f2bbdf5bfcb253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga7b349c4e1fb4b27a9b20ed53b277a7ba">regina::detail::TriangulationBase&lt; dim &gt;::removeSimplex</a> (<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *<a class="el" href="group__detail.html#gae2e269a7332e80aeec3603881fd175d3">simplex</a>)</td></tr>
<tr class="memdesc:ga7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given top-dimensional simplex from this triangulation.  <a href="group__detail.html#ga7b349c4e1fb4b27a9b20ed53b277a7ba">More...</a><br /></td></tr>
<tr class="separator:ga7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f36b004ba6af3d6ce11bdb655650ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gac9f36b004ba6af3d6ce11bdb655650ec">regina::detail::TriangulationBase&lt; dim &gt;::removeSimplexAt</a> (size_t index)</td></tr>
<tr class="memdesc:gac9f36b004ba6af3d6ce11bdb655650ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-dimensional simplex at the given index in this triangulation.  <a href="group__detail.html#gac9f36b004ba6af3d6ce11bdb655650ec">More...</a><br /></td></tr>
<tr class="separator:gac9f36b004ba6af3d6ce11bdb655650ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e91a640743f9ce2710d17eda77d520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3e91a640743f9ce2710d17eda77d520a">regina::detail::TriangulationBase&lt; dim &gt;::removeAllSimplices</a> ()</td></tr>
<tr class="memdesc:ga3e91a640743f9ce2710d17eda77d520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all simplices from the triangulation.  <a href="group__detail.html#ga3e91a640743f9ce2710d17eda77d520a">More...</a><br /></td></tr>
<tr class="separator:ga3e91a640743f9ce2710d17eda77d520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad43e7587b785f281f5f5c553f263484e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad43e7587b785f281f5f5c553f263484e">regina::detail::TriangulationBase&lt; dim &gt;::swapContents</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other)</td></tr>
<tr class="memdesc:gad43e7587b785f281f5f5c553f263484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given triangulation.  <a href="group__detail.html#gad43e7587b785f281f5f5c553f263484e">More...</a><br /></td></tr>
<tr class="separator:gad43e7587b785f281f5f5c553f263484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fa3daf9672da64a0fa8a82a439d65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae3fa3daf9672da64a0fa8a82a439d65b">regina::detail::TriangulationBase&lt; dim &gt;::moveContentsTo</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;dest)</td></tr>
<tr class="memdesc:gae3fa3daf9672da64a0fa8a82a439d65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents.  <a href="group__detail.html#gae3fa3daf9672da64a0fa8a82a439d65b">More...</a><br /></td></tr>
<tr class="separator:gae3fa3daf9672da64a0fa8a82a439d65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Skeletal Queries</h2></td></tr>
<tr class="memitem:ga20e5dba7654710e79eecaf849f248d38"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga20e5dba7654710e79eecaf849f248d38">regina::detail::TriangulationBase&lt; dim &gt;::countComponents</a> () const</td></tr>
<tr class="memdesc:ga20e5dba7654710e79eecaf849f248d38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of connected components in this triangulation.  <a href="group__detail.html#ga20e5dba7654710e79eecaf849f248d38">More...</a><br /></td></tr>
<tr class="separator:ga20e5dba7654710e79eecaf849f248d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658bf830fdf052e1beaa5423298c51b2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga658bf830fdf052e1beaa5423298c51b2">regina::detail::TriangulationBase&lt; dim &gt;::countBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:ga658bf830fdf052e1beaa5423298c51b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of boundary components in this triangulation.  <a href="group__detail.html#ga658bf830fdf052e1beaa5423298c51b2">More...</a><br /></td></tr>
<tr class="separator:ga658bf830fdf052e1beaa5423298c51b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929d32300a09aa008d03099e4b84e873"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga929d32300a09aa008d03099e4b84e873"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga929d32300a09aa008d03099e4b84e873">regina::detail::TriangulationBase&lt; dim &gt;::countFaces</a> () const</td></tr>
<tr class="memdesc:ga929d32300a09aa008d03099e4b84e873"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this triangulation.  <a href="group__detail.html#ga929d32300a09aa008d03099e4b84e873">More...</a><br /></td></tr>
<tr class="separator:ga929d32300a09aa008d03099e4b84e873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5c48ed1736e27aa09620cd924507ef4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gad5c48ed1736e27aa09620cd924507ef4">regina::detail::TriangulationBase&lt; dim &gt;::fVector</a> () const</td></tr>
<tr class="memdesc:gad5c48ed1736e27aa09620cd924507ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the f-vector of this triangulation, which counts the number of faces of all dimensions.  <a href="group__detail.html#gad5c48ed1736e27aa09620cd924507ef4">More...</a><br /></td></tr>
<tr class="separator:gad5c48ed1736e27aa09620cd924507ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga718c3a940b08ef6b5b5c8f48f8dd196a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga718c3a940b08ef6b5b5c8f48f8dd196a">regina::detail::TriangulationBase&lt; dim &gt;::components</a> () const</td></tr>
<tr class="memdesc:ga718c3a940b08ef6b5b5c8f48f8dd196a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all connected components of this triangulation.  <a href="group__detail.html#ga718c3a940b08ef6b5b5c8f48f8dd196a">More...</a><br /></td></tr>
<tr class="separator:ga718c3a940b08ef6b5b5c8f48f8dd196a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a17ad3357163f3692415bae427882a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga29a17ad3357163f3692415bae427882a">regina::detail::TriangulationBase&lt; dim &gt;::boundaryComponents</a> () const</td></tr>
<tr class="memdesc:ga29a17ad3357163f3692415bae427882a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all boundary components of this triangulation.  <a href="group__detail.html#ga29a17ad3357163f3692415bae427882a">More...</a><br /></td></tr>
<tr class="separator:ga29a17ad3357163f3692415bae427882a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6d83a36cc07a69d4f3148fa08d1fd6"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:gaff6d83a36cc07a69d4f3148fa08d1fd6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#gaff6d83a36cc07a69d4f3148fa08d1fd6">regina::detail::TriangulationBase&lt; dim &gt;::faces</a> () const</td></tr>
<tr class="memdesc:gaff6d83a36cc07a69d4f3148fa08d1fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation.  <a href="group__detail.html#gaff6d83a36cc07a69d4f3148fa08d1fd6">More...</a><br /></td></tr>
<tr class="separator:gaff6d83a36cc07a69d4f3148fa08d1fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd435c05fdb9ad2ce0229c08965e87d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4dd435c05fdb9ad2ce0229c08965e87d">regina::detail::TriangulationBase&lt; dim &gt;::component</a> (size_t index) const</td></tr>
<tr class="memdesc:ga4dd435c05fdb9ad2ce0229c08965e87d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested connected component of this triangulation.  <a href="group__detail.html#ga4dd435c05fdb9ad2ce0229c08965e87d">More...</a><br /></td></tr>
<tr class="separator:ga4dd435c05fdb9ad2ce0229c08965e87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6eee4278d413b28cc3519ea07d90d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaef6eee4278d413b28cc3519ea07d90d0">regina::detail::TriangulationBase&lt; dim &gt;::boundaryComponent</a> (size_t index) const</td></tr>
<tr class="memdesc:gaef6eee4278d413b28cc3519ea07d90d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested boundary component of this triangulation.  <a href="group__detail.html#gaef6eee4278d413b28cc3519ea07d90d0">More...</a><br /></td></tr>
<tr class="separator:gaef6eee4278d413b28cc3519ea07d90d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802ea1cdd46af32418fb76c49712ccb8"><td class="memTemplParams" colspan="2">template&lt;int subdim&gt; </td></tr>
<tr class="memitem:ga802ea1cdd46af32418fb76c49712ccb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga802ea1cdd46af32418fb76c49712ccb8">regina::detail::TriangulationBase&lt; dim &gt;::face</a> (size_t index) const</td></tr>
<tr class="memdesc:ga802ea1cdd46af32418fb76c49712ccb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face of this triangulation.  <a href="group__detail.html#ga802ea1cdd46af32418fb76c49712ccb8">More...</a><br /></td></tr>
<tr class="separator:ga802ea1cdd46af32418fb76c49712ccb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Basic Properties</h2></td></tr>
<tr class="memitem:ga6b111a8470576f19f950a2347ff9f3f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6b111a8470576f19f950a2347ff9f3f5">regina::detail::TriangulationBase&lt; dim &gt;::isEmpty</a> () const</td></tr>
<tr class="memdesc:ga6b111a8470576f19f950a2347ff9f3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation is empty.  <a href="group__detail.html#ga6b111a8470576f19f950a2347ff9f3f5">More...</a><br /></td></tr>
<tr class="separator:ga6b111a8470576f19f950a2347ff9f3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6cf08805f1b496f644e75c1a0b34dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde">regina::detail::TriangulationBase&lt; dim &gt;::isValid</a> () const</td></tr>
<tr class="memdesc:gab6cf08805f1b496f644e75c1a0b34dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is valid.  <a href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde">More...</a><br /></td></tr>
<tr class="separator:gab6cf08805f1b496f644e75c1a0b34dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ffca92f7a401c3beb7a603d997a088e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga5ffca92f7a401c3beb7a603d997a088e">regina::detail::TriangulationBase&lt; dim &gt;::hasBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:ga5ffca92f7a401c3beb7a603d997a088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation has any boundary facets.  <a href="group__detail.html#ga5ffca92f7a401c3beb7a603d997a088e">More...</a><br /></td></tr>
<tr class="separator:ga5ffca92f7a401c3beb7a603d997a088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1a05fe022a95b928a068f9909b036c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8c1a05fe022a95b928a068f9909b036c">regina::detail::TriangulationBase&lt; dim &gt;::countBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:ga8c1a05fe022a95b928a068f9909b036c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of boundary facets in this triangulation.  <a href="group__detail.html#ga8c1a05fe022a95b928a068f9909b036c">More...</a><br /></td></tr>
<tr class="separator:ga8c1a05fe022a95b928a068f9909b036c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6223875697502990070b0e7587f63ce7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6223875697502990070b0e7587f63ce7">regina::detail::TriangulationBase&lt; dim &gt;::isOrientable</a> () const</td></tr>
<tr class="memdesc:ga6223875697502990070b0e7587f63ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is orientable.  <a href="group__detail.html#ga6223875697502990070b0e7587f63ce7">More...</a><br /></td></tr>
<tr class="separator:ga6223875697502990070b0e7587f63ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576e6c66cfbb7fabd21cc782c38f300d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga576e6c66cfbb7fabd21cc782c38f300d">regina::detail::TriangulationBase&lt; dim &gt;::isConnected</a> () const</td></tr>
<tr class="memdesc:ga576e6c66cfbb7fabd21cc782c38f300d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is connected.  <a href="group__detail.html#ga576e6c66cfbb7fabd21cc782c38f300d">More...</a><br /></td></tr>
<tr class="separator:ga576e6c66cfbb7fabd21cc782c38f300d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab712e58bba1242110e49b2fac979e98f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gab712e58bba1242110e49b2fac979e98f">regina::detail::TriangulationBase&lt; dim &gt;::isOriented</a> () const</td></tr>
<tr class="memdesc:gab712e58bba1242110e49b2fac979e98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets.  <a href="group__detail.html#gab712e58bba1242110e49b2fac979e98f">More...</a><br /></td></tr>
<tr class="separator:gab712e58bba1242110e49b2fac979e98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8063bd8d3c1ff8d896ae0a24db2203d5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga8063bd8d3c1ff8d896ae0a24db2203d5">regina::detail::TriangulationBase&lt; dim &gt;::eulerCharTri</a> () const</td></tr>
<tr class="memdesc:ga8063bd8d3c1ff8d896ae0a24db2203d5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this triangulation.  <a href="group__detail.html#ga8063bd8d3c1ff8d896ae0a24db2203d5">More...</a><br /></td></tr>
<tr class="separator:ga8063bd8d3c1ff8d896ae0a24db2203d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Algebraic Properties</h2></td></tr>
<tr class="memitem:ga408718df2c6cc65f21adabc50850ec63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga408718df2c6cc65f21adabc50850ec63">regina::detail::TriangulationBase&lt; dim &gt;::fundamentalGroup</a> () const</td></tr>
<tr class="memdesc:ga408718df2c6cc65f21adabc50850ec63"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the fundamental group of this triangulation.  <a href="group__detail.html#ga408718df2c6cc65f21adabc50850ec63">More...</a><br /></td></tr>
<tr class="separator:ga408718df2c6cc65f21adabc50850ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74cde5c3b790195df3e10e2e53e390b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf74cde5c3b790195df3e10e2e53e390b">regina::detail::TriangulationBase&lt; dim &gt;::simplifiedFundamentalGroup</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> *newGroup)</td></tr>
<tr class="memdesc:gaf74cde5c3b790195df3e10e2e53e390b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the triangulation that you have simplified the presentation of its fundamental group.  <a href="group__detail.html#gaf74cde5c3b790195df3e10e2e53e390b">More...</a><br /></td></tr>
<tr class="separator:gaf74cde5c3b790195df3e10e2e53e390b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1388f2c849d9010c22e1c2b569b624de"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de">regina::detail::TriangulationBase&lt; dim &gt;::homology</a> () const</td></tr>
<tr class="memdesc:ga1388f2c849d9010c22e1c2b569b624de"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group for this triangulation.  <a href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de">More...</a><br /></td></tr>
<tr class="separator:ga1388f2c849d9010c22e1c2b569b624de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec045e78809792a92042c583aac0741"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabec045e78809792a92042c583aac0741">regina::detail::TriangulationBase&lt; dim &gt;::homologyH1</a> () const</td></tr>
<tr class="memdesc:gabec045e78809792a92042c583aac0741"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group for this triangulation.  <a href="group__detail.html#gabec045e78809792a92042c583aac0741">More...</a><br /></td></tr>
<tr class="separator:gabec045e78809792a92042c583aac0741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Skeletal Transformations</h2></td></tr>
<tr class="memitem:ga2711fd7c7115ce19b6833f0d61c42bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2711fd7c7115ce19b6833f0d61c42bec">regina::detail::TriangulationBase&lt; dim &gt;::orient</a> ()</td></tr>
<tr class="memdesc:ga2711fd7c7115ce19b6833f0d61c42bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible.  <a href="group__detail.html#ga2711fd7c7115ce19b6833f0d61c42bec">More...</a><br /></td></tr>
<tr class="separator:ga2711fd7c7115ce19b6833f0d61c42bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f5583fe8731e5186eac30bb7dfeafa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga3f5583fe8731e5186eac30bb7dfeafa6">regina::detail::TriangulationBase&lt; dim &gt;::reflect</a> ()</td></tr>
<tr class="memdesc:ga3f5583fe8731e5186eac30bb7dfeafa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices reflect their orientation.  <a href="group__detail.html#ga3f5583fe8731e5186eac30bb7dfeafa6">More...</a><br /></td></tr>
<tr class="separator:ga3f5583fe8731e5186eac30bb7dfeafa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39dc5df8252f6e34ea45b19ca33c3964"><td class="memTemplParams" colspan="2">template&lt;int k&gt; </td></tr>
<tr class="memitem:ga39dc5df8252f6e34ea45b19ca33c3964"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga39dc5df8252f6e34ea45b19ca33c3964">regina::detail::TriangulationBase&lt; dim &gt;::pachner</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *f, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ga39dc5df8252f6e34ea45b19ca33c3964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face.  <a href="group__detail.html#ga39dc5df8252f6e34ea45b19ca33c3964">More...</a><br /></td></tr>
<tr class="separator:ga39dc5df8252f6e34ea45b19ca33c3964"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Subdivisions, Extensions and Covers</h2></td></tr>
<tr class="memitem:gae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gae061e36e8ecbfa2f1edc36ed9eb99a51">regina::detail::TriangulationBase&lt; dim &gt;::makeDoubleCover</a> ()</td></tr>
<tr class="memdesc:gae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this triangulation into its double cover.  <a href="group__detail.html#gae061e36e8ecbfa2f1edc36ed9eb99a51">More...</a><br /></td></tr>
<tr class="separator:gae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13345c67f4c82d9976863c8c5372db5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga13345c67f4c82d9976863c8c5372db5b">regina::detail::TriangulationBase&lt; dim &gt;::barycentricSubdivision</a> ()</td></tr>
<tr class="memdesc:ga13345c67f4c82d9976863c8c5372db5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a barycentric subdivision of the triangulation.  <a href="group__detail.html#ga13345c67f4c82d9976863c8c5372db5b">More...</a><br /></td></tr>
<tr class="separator:ga13345c67f4c82d9976863c8c5372db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc25a58b48e39f3c7f8621b84432d294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gadc25a58b48e39f3c7f8621b84432d294">regina::detail::TriangulationBase&lt; dim &gt;::finiteToIdeal</a> ()</td></tr>
<tr class="memdesc:gadc25a58b48e39f3c7f8621b84432d294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts each real boundary component into a cusp (i.e., an ideal vertex).  <a href="group__detail.html#gadc25a58b48e39f3c7f8621b84432d294">More...</a><br /></td></tr>
<tr class="separator:gadc25a58b48e39f3c7f8621b84432d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Decompositions</h2></td></tr>
<tr class="memitem:ga4c57b6a7340d4f289b51469e62a8a66c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4c57b6a7340d4f289b51469e62a8a66c">regina::detail::TriangulationBase&lt; dim &gt;::splitIntoComponents</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *componentParent=nullptr, bool setLabels=true)</td></tr>
<tr class="memdesc:ga4c57b6a7340d4f289b51469e62a8a66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a disconnected triangulation into many smaller triangulations, one for each component.  <a href="group__detail.html#ga4c57b6a7340d4f289b51469e62a8a66c">More...</a><br /></td></tr>
<tr class="separator:ga4c57b6a7340d4f289b51469e62a8a66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Isomorphism Testing</h2></td></tr>
<tr class="memitem:ga46646fc0c55c3bdd6fe280fb72294534"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga46646fc0c55c3bdd6fe280fb72294534">regina::detail::TriangulationBase&lt; dim &gt;::isIdenticalTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga46646fc0c55c3bdd6fe280fb72294534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially identical to the given triangulation.  <a href="group__detail.html#ga46646fc0c55c3bdd6fe280fb72294534">More...</a><br /></td></tr>
<tr class="separator:ga46646fc0c55c3bdd6fe280fb72294534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf68572c80fc27fc3a069ad01d9615952"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf68572c80fc27fc3a069ad01d9615952">regina::detail::TriangulationBase&lt; dim &gt;::isIsomorphicTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:gaf68572c80fc27fc3a069ad01d9615952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially isomorphic to the given triangulation.  <a href="group__detail.html#gaf68572c80fc27fc3a069ad01d9615952">More...</a><br /></td></tr>
<tr class="separator:gaf68572c80fc27fc3a069ad01d9615952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ce7adfff99f476365aa7af3a37f650"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga61ce7adfff99f476365aa7af3a37f650">regina::detail::TriangulationBase&lt; dim &gt;::isContainedIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:ga61ce7adfff99f476365aa7af3a37f650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="group__detail.html#ga61ce7adfff99f476365aa7af3a37f650">More...</a><br /></td></tr>
<tr class="separator:ga61ce7adfff99f476365aa7af3a37f650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f6909b62bdeb58b6b0f4a43646fa0f7"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga6f6909b62bdeb58b6b0f4a43646fa0f7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga6f6909b62bdeb58b6b0f4a43646fa0f7">regina::detail::TriangulationBase&lt; dim &gt;::findAllIsomorphisms</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, OutputIterator output) const</td></tr>
<tr class="memdesc:ga6f6909b62bdeb58b6b0f4a43646fa0f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.  <a href="group__detail.html#ga6f6909b62bdeb58b6b0f4a43646fa0f7">More...</a><br /></td></tr>
<tr class="separator:ga6f6909b62bdeb58b6b0f4a43646fa0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13bd275984bd2e6241fc220229f39490"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga13bd275984bd2e6241fc220229f39490"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__detail.html#ga13bd275984bd2e6241fc220229f39490">regina::detail::TriangulationBase&lt; dim &gt;::findAllSubcomplexesIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, OutputIterator output) const</td></tr>
<tr class="memdesc:ga13bd275984bd2e6241fc220229f39490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="group__detail.html#ga13bd275984bd2e6241fc220229f39490">More...</a><br /></td></tr>
<tr class="separator:ga13bd275984bd2e6241fc220229f39490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe58df75da67242635ddcea5398d1b77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gabe58df75da67242635ddcea5398d1b77">regina::detail::TriangulationBase&lt; dim &gt;::makeCanonical</a> ()</td></tr>
<tr class="memdesc:gabe58df75da67242635ddcea5398d1b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form.  <a href="group__detail.html#gabe58df75da67242635ddcea5398d1b77">More...</a><br /></td></tr>
<tr class="separator:gabe58df75da67242635ddcea5398d1b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Building Triangulations</h2></td></tr>
<tr class="memitem:ga2bf93dbca6715c1a455a2d47f66a6476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga2bf93dbca6715c1a455a2d47f66a6476">regina::detail::TriangulationBase&lt; dim &gt;::insertTriangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>)</td></tr>
<tr class="memdesc:ga2bf93dbca6715c1a455a2d47f66a6476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given triangulation into this triangulation.  <a href="group__detail.html#ga2bf93dbca6715c1a455a2d47f66a6476">More...</a><br /></td></tr>
<tr class="separator:ga2bf93dbca6715c1a455a2d47f66a6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e8b7cf820ff452059f817d55536155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gaf1e8b7cf820ff452059f817d55536155">regina::detail::TriangulationBase&lt; dim &gt;::insertConstruction</a> (size_t nSimplices, const int adjacencies[][dim+1], const int gluings[][dim+1][dim+1])</td></tr>
<tr class="memdesc:gaf1e8b7cf820ff452059f817d55536155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a given triangulation into this triangulation, where the given triangulation is described by a pair of integer arrays.  <a href="group__detail.html#gaf1e8b7cf820ff452059f817d55536155">More...</a><br /></td></tr>
<tr class="separator:gaf1e8b7cf820ff452059f817d55536155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Exporting Triangulations</h2></td></tr>
<tr class="memitem:ga4f5592a00cb4a895564e5b8169850879"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879">regina::detail::TriangulationBase&lt; dim &gt;::isoSig</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; **relabelling=0) const</td></tr>
<tr class="memdesc:ga4f5592a00cb4a895564e5b8169850879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the isomorphism signature for this triangulation.  <a href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879">More...</a><br /></td></tr>
<tr class="separator:ga4f5592a00cb4a895564e5b8169850879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__detail.html#gace7c9ec1168ef9e7cb34b3e4a5b9b873">regina::detail::TriangulationBase&lt; dim &gt;::dumpConstruction</a> () const</td></tr>
<tr class="memdesc:gace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used with <a class="el" href="group__detail.html#gaf1e8b7cf820ff452059f817d55536155" title="Inserts a given triangulation into this triangulation, where the given triangulation is described by ...">insertConstruction()</a> to reconstruct this triangulation.  <a href="group__detail.html#gace7c9ec1168ef9e7cb34b3e4a5b9b873">More...</a><br /></td></tr>
<tr class="separator:gace7c9ec1168ef9e7cb34b3e4a5b9b873"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Implementation details that end users should not need to reference directly. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa2966f74374c8455bfa3a85810094f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2966f74374c8455bfa3a85810094f3c">&#9670;&nbsp;</a></span>BoundaryComponentIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="group__detail.html#gaa2966f74374c8455bfa3a85810094f3c">BoundaryComponentIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through boundary components. </p>

</div>
</div>
<a id="gacfcb97350bb6b69518e4e7592317f3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfcb97350bb6b69518e4e7592317f3c5">&#9670;&nbsp;</a></span>ComponentIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="group__detail.html#gacfcb97350bb6b69518e4e7592317f3c5">ComponentIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through connected components. </p>

</div>
</div>
<a id="ga0b7e6840cf1d720009ce05f57e837b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b7e6840cf1d720009ce05f57e837b8c">&#9670;&nbsp;</a></span>FacetMask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1IntOfMinSize.html">IntOfMinSize</a>&lt;(dim / 8) + 1&gt;::utype <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::<a class="el" href="group__detail.html#ga0b7e6840cf1d720009ce05f57e837b8c">FacetMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned integer type with at least <em>dim</em>+1 bits. </p>
<p>This can be used as a bitmask for the <em>dim</em>+1 facets (or vertices) of a <em>dim</em>-simplex. </p>

</div>
</div>
<a id="ga418c8789d876bd8d8f8a0ddd5f3d6584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga418c8789d876bd8d8f8a0ddd5f3d6584">&#9670;&nbsp;</a></span>Holder <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;*&gt; <a class="el" href="structregina_1_1detail_1_1FaceListHolder.html">regina::detail::FaceListHolder</a>&lt; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">BoundaryComponentFaceStorage</a>&lt; dim, true &gt;, subdim &gt;::<a class="el" href="group__detail.html#ga418c8789d876bd8d8f8a0ddd5f3d6584">Holder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data type used by BoundaryComponent&lt;dim&gt; to store the list of all <em>subdim</em>-faces of the boundary component. </p>
<p>The function BoundaryComponent&lt;dim&gt;::faces&lt;subdim&gt;() returns a const reference to this type. </p>

</div>
</div>
<a id="ga35b133e58ae4ace39daa2e29aaf4b928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b133e58ae4ace39daa2e29aaf4b928">&#9670;&nbsp;</a></span>Holder <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;*&gt; <a class="el" href="structregina_1_1detail_1_1FaceListHolder.html">regina::detail::FaceListHolder</a>&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt;, subdim &gt;::<a class="el" href="group__detail.html#ga35b133e58ae4ace39daa2e29aaf4b928">Holder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data type used by Component&lt;dim&gt; to store the list of all <em>subdim</em>-faces of the connected component. </p>
<p>The function Component&lt;dim&gt;::faces&lt;subdim&gt;() returns a const reference to this type. </p>

</div>
</div>
<a id="ga049ca31b4779c20984f5bf00ef0cd57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga049ca31b4779c20984f5bf00ef0cd57a">&#9670;&nbsp;</a></span>Holder <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;dim, subdim&gt; <a class="el" href="structregina_1_1detail_1_1FaceListHolder.html">regina::detail::FaceListHolder</a>&lt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">detail::TriangulationBase</a>&lt; dim &gt;, subdim &gt;::<a class="el" href="group__detail.html#ga049ca31b4779c20984f5bf00ef0cd57a">Holder</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The data type used by Triangulation&lt;dim&gt; to store the list of all <em>subdim</em>-faces of the triangulation. </p>
<p>The function Triangulation&lt;dim&gt;::faces&lt;subdim&gt;() returns a const reference to this type. </p>

</div>
</div>
<a id="ga29c1d0f565e50aa76cfca68714347533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29c1d0f565e50aa76cfca68714347533">&#9670;&nbsp;</a></span>IsoList</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::list&lt;<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt;dim&gt;*&gt; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::<a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">IsoList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of isomorphisms on facet pairings. </p>
<p>Such an isomorphism can be used to convert one facet pairing into another.</p>
<p>This type is used to store all <em>automorphisms</em> of a facet pairing; that is, all isomorphisms that map the facet pairing to itself. </p>

</div>
</div>
<a id="gaa7544f6c646dc7aed9d8a3f07d917da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7544f6c646dc7aed9d8a3f07d917da4">&#9670;&nbsp;</a></span>PropType <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a>&gt; <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::<a class="el" href="group__detail.html#gaa7544f6c646dc7aed9d8a3f07d917da4">AbelianGroupPropertyReader::PropType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the property currently being read. </p>

</div>
</div>
<a id="gab6d74c424017288ecce4629d2f88ae2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d74c424017288ecce4629d2f88ae2a">&#9670;&nbsp;</a></span>PropType <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>, <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a>&gt; <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::<a class="el" href="group__detail.html#gab6d74c424017288ecce4629d2f88ae2a">GroupPresentationPropertyReader::PropType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the property currently being read. </p>

</div>
</div>
<a id="gae1aaf376920ea61e6f69db225530b174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1aaf376920ea61e6f69db225530b174">&#9670;&nbsp;</a></span>SimplexIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="group__detail.html#gae1aaf376920ea61e6f69db225530b174">SimplexIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through top-dimensional simplices. </p>

</div>
</div>
<a id="ga950ce31e11866d63683a435e8d76c9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga950ce31e11866d63683a435e8d76c9bf">&#9670;&nbsp;</a></span>Use</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::Use) (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *, const <a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">IsoList</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A routine that can do arbitrary processing upon a facet pairing and its automorphisms. </p>
<p>Such routines are used to process pairings that are found when running <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">findAllPairings()</a>.</p>
<p>The first parameter passed should be a facet pairing (this should not be deallocated by this routine). The second parameter should be a list of all automorphisms of this pairing (this should not be deallocated either). The third parameter may contain arbitrary data as passed to <a class="el" href="group__detail.html#gaf37845787a6a80399160c535b9344d08" title="Generates all possible facet pairings satisfying the given constraints.">findAllPairings()</a>.</p>
<p>Note that the first two parameters passed might be <code>null</code> to signal that facet pairing generation has finished. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga67641d434d7613123641fe31162abef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67641d434d7613123641fe31162abef2">&#9670;&nbsp;</a></span>AbelianGroupPropertyReader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::AbelianGroupPropertyReader::AbelianGroupPropertyReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detail.html#gaa7544f6c646dc7aed9d8a3f07d917da4">PropType</a> &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new reader that stores its results in the given triangulation property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td>a reference to the triangulation property in which the data that is read should be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga09416bf06b05b67bad21b9e5184e3584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09416bf06b05b67bad21b9e5184e3584">&#9670;&nbsp;</a></span>adjacentFacet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentFacet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the given facet of this simplex is glued to facet <em>f</em> of some adjacent simplex, then this routine returns the adjacent facet number <em>f</em>. </p>
<p>The return value from this routine is identical to adjacentGluing(<em>facet</em>)[<em>facet</em>].</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet of this simplex has some adjacent simplex (possibly this one) glued to it. In other words, adjacentSimplex(<em>facet</em>) is not <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding facet number of the adjacent simplex that is glued to the given facet of this simplex. </dd></dl>

</div>
</div>
<a id="ga39ac592b6db07dba1487e054be273799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39ac592b6db07dba1487e054be273799">&#9670;&nbsp;</a></span>adjacentGluing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentGluing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation that indicates precisely how this simplex is glued to the adjacent simplex across the given facet. </p>
<p>In detail: suppose that the given facet of this simplex is glued to an adjacent simplex <em>A</em>. Then this gluing induces a mapping from the vertices of this simplex to the vertices of <em>A</em>. We can express this mapping in the form of a permutation <em>p</em>, where:</p>
<ul>
<li>for any <em>v</em> &ne; <em>facet</em>, the gluing identifies vertex <em>v</em> of this simplex with vertex <em>p</em>[<em>v</em>] of simplex <em>A</em>;</li>
<li><em>p</em>[<em>facet</em>] indicates the facet of <em>A</em> that is on the other side of the gluing (i.e., the facet of <em>A</em> that is glued to the given facet of this simplex).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet of this simplex has some adjacent simplex (possibly this one) glued to it. In other words, adjacentSimplex(<em>facet</em>) is not <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a permutation that maps the vertices of this simplex to the vertices of the adjacent simplex, as described above. </dd></dl>

</div>
</div>
<a id="gad0c12cf55a47ae78e9b4e91ce46c838d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0c12cf55a47ae78e9b4e91ce46c838d">&#9670;&nbsp;</a></span>adjacentSimplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentSimplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the adjacent simplex that is glued to the given facet of this simplex. </p>
<p>If there is no adjacent simplex (i.e., the given facet lies on the triangulation boundary), then this routine will return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex to examine; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adjacent simplex glued to the given facet, or 0 if the given facet lies on the boundary. </dd></dl>

</div>
</div>
<a id="ga5fbc9c36a2403187bd4777d3c7749afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fbc9c36a2403187bd4777d3c7749afb">&#9670;&nbsp;</a></span>allowsInvalidFaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool regina::detail::allowsInvalidFaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether it is possible for a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation to be invalid. </p>
<p>This compile-time constant function is used to determine the first template argument that should be passed to <a class="el" href="classregina_1_1detail_1_1FaceValidity.html" title="Helper class that stores whether a face is valid.">FaceValidity</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulations. </td></tr>
    <tr><td class="paramname">subdim</td><td>the dimension of the faces in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if such faces may be invalid, or <code>false</code> if <em>subdim</em>-faces of <em>dim</em>-dimensional triangluations are always valid. </dd></dl>

</div>
</div>
<a id="ga26739074df0ed0ddebd791a8c641671b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26739074df0ed0ddebd791a8c641671b">&#9670;&nbsp;</a></span>allowsNonOrientableLinks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool regina::detail::allowsNonOrientableLinks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether it is possible for a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation to have a non-orientable link. </p>
<p>This compile-time constant function is used to determine the template argument that should be passed to <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html" title="Helper class that stores whether the link of a face is orientable.">FaceOrientability</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>the dimension of the underlying triangulations. </td></tr>
    <tr><td class="paramname">subdim</td><td>the dimension of the faces in question. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if such faces may have non-orientable links, or <code>false</code> if the links of <em>subdim</em>-faces of <em>dim</em>-dimensional triangluations are always orientable. </dd></dl>

</div>
</div>
<a id="ga33569d2db61ab4a22cb8a70441949033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33569d2db61ab4a22cb8a70441949033">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>original</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies this isomorphism to the given triangulation, and returns the result as a new triangulation. </p>
<p>An isomorphism represents a combinatorial map from a triangulation <em>T</em> to a triangulation <em>U</em>. This routine treats the given triangulation as the domain <em>T</em>, and returns the corresponding range <em>U</em>. The given triangulation <em>T</em> is not modified in any way.</p>
<p>In more detail: A new triangulation <em>U</em> is returned, so that this isomorphism represents a one-to-one, onto and boundary complete isomorphism from <em>T</em> to <em>U</em>. That is, <em>T</em> and <em>U</em> will be combinatorially identical triangulations, and this isomorphism describes the mapping from the simplices of <em>T</em> and their facets to the simplices of <em>U</em> and their facets.</p>
<p>The resulting triangulation <em>U</em> is newly created, and must be destroyed by the caller of this routine.</p>
<p>There are several preconditions to this routine. This routine does a small amount of sanity checking (and returns 0 if an error is detected), but it certainly does not check the full set of preconditions. It is up to the caller of this routine to verify that all of the following preconditions are met.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The number of simplices in the given triangulation is precisely the number returned by <a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism. </dd>
<dd>
The simplex images are precisely 0,1,...,<a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000046">Todo:</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>the triangulation to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new isomorphic triangulation, or 0 if a problem was encountered (i.e., an unmet precondition was noticed). </dd></dl>

</div>
</div>
<a id="ga182d11ecefd8675e271db64481fd1a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182d11ecefd8675e271db64481fd1a0e">&#9670;&nbsp;</a></span>applyInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::applyInPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies this isomorphism to the given triangulation, modifying the given triangulation directly. </p>
<p>This is similar to <a class="el" href="group__detail.html#ga33569d2db61ab4a22cb8a70441949033" title="Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.">apply()</a>, except that instead of creating a new triangulation, the simplices and vertices of the given triangulation are modified in-place.</p>
<p>See <a class="el" href="group__detail.html#ga33569d2db61ab4a22cb8a70441949033" title="Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.">apply()</a> for further details on how this operation is performed.</p>
<p>As with <a class="el" href="group__detail.html#ga33569d2db61ab4a22cb8a70441949033" title="Applies this isomorphism to the given triangulation, and returns the result as a new triangulation.">apply()</a>, there are several preconditions to this routine. This routine does a small amount of sanity checking (and returns without changes if an error is detected), but it certainly does not check the full set of preconditions. It is up to the caller of this routine to verify that all of the following preconditions are met.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The number of simplices in the given triangulation is precisely the number returned by <a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> for this isomorphism. </dd>
<dd>
The simplex images are precisely 0,1,...,<a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1 in some order (i.e., this isomorphism does not represent a mapping from a smaller triangulation into a larger triangulation).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000047">Todo:</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the isomorphism is applied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to which this isomorphism should be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga947d961f6901c0998cecb0392c8b1a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga947d961f6901c0998cecb0392c8b1a66">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::back</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the last appearance of this face within a top-dimensional simplex of the underlying triangluation. </p>
<p>This is equivalent to calling <code>embedding(<a class="el" href="group__detail.html#gace118d12364a7a78c6819280f849fe4b" title="Returns the degree of this face.">degree()</a>-1)</code>.</p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where the appearances of a face are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle). In particular, for a boundary face of codimension 2, both <a class="el" href="group__detail.html#ga63f659c8eb6a4ce037ebf5b65aa32d45" title="Returns the first appearance of this face within a top-dimensional simplex of the underlying trianglu...">front()</a> and <a class="el" href="group__detail.html#ga947d961f6901c0998cecb0392c8b1a66" title="Returns the last appearance of this face within a top-dimensional simplex of the underlying trianglua...">back()</a> will refer to the two appearances of this face on the (<em>dim</em>-1)-dimensional boundary.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the last appearance. </dd></dl>

</div>
</div>
<a id="gabbc7d22517bbb59c938e7302102c110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbc7d22517bbb59c938e7302102c110f">&#9670;&nbsp;</a></span>ball()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase</a>&lt; dim &gt;::ball</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bounded Triangulations. </p>
<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a one-simplex triangulation of the <em>dim</em>-ball.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga4fbb67097da4b4a488d3a07efe3a5477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fbb67097da4b4a488d3a07efe3a5477">&#9670;&nbsp;</a></span>ballBundle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase</a>&lt; dim &gt;::ballBundle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the product space <code>B^(<em>dim</em>-1) x S^1</code>. </p>
<p>This will use one simplex in odd dimensions, or two simplices in even dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga13345c67f4c82d9976863c8c5372db5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13345c67f4c82d9976863c8c5372db5b">&#9670;&nbsp;</a></span>barycentricSubdivision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::barycentricSubdivision</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does a barycentric subdivision of the triangulation. </p>
<p>This is done in-place, i.e., the triangulation will be modified directly.</p>
<p>Each top-dimensional simplex <em>s</em> is divided into (<em>dim</em> + 1) factorial sub-simplices by placing an extra vertex at the centroid of every face of every dimension. Each of these sub-simplices <em>t</em> is described by a permutation <em>p</em> of (0, ..., <em>dim</em>). The vertices of such a sub-simplex <em>t</em> are:</p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em>;</li>
<li>...</li>
<li>the centroid of face (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2], <em>p</em>[<em>dim</em>]) of <em>s</em>, which is the entire simplex <em>s</em> itself.</li>
</ul>
<p>The sub-simplices have their vertices numbered in a way that mirrors the original simplex <em>s:</em> </p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em> will be labelled <em>p</em>[0] in <em>t</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em> will be labelled <em>p</em>[1] in <em>t</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em> will be labelled <em>p</em>[2] in <em>t</em>;</li>
<li>...</li>
<li>the centroid of <em>s</em> itself will be labelled <em>p</em>[<em>dim</em>] in <em>t</em>.</li>
</ul>
<p>In particular, if this triangulation is currently oriented, then this barycentric subdivision will preserve the orientation.</p>
<p>If simplex <em>s</em> has index <em>i</em> in the original triangulation, then its sub-simplex corresponding to permutation <em>p</em> will have index <code>((dim + 1)! * i + p.index())</code> in the resulting triangulation. In other words: sub-simplices are ordered first according to the original simplex that contains them, and then according to the lexicographical ordering of the corresponding permutations <em>p</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dim</em> is one of Regina's standard dimensions. This precondition is a safety net, since in higher dimensions the triangulation would explode too quickly in size (and for the highest dimensions, possibly beyond the limits of <code>size_t</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimensions 3 and 4, both the labelling and ordering of sub-simplices in the subdivided triangulation has changed as of Regina 5.1. (Earlier versions of Regina made no guarantee about the labelling and ordering; these guarantees are also new to Regina 5.1).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd>Lock the topological properties of the underlying manifold, to avoid recomputing them after the subdivision. However, only do this for <em>valid</em> triangulations (since we can have scenarios where invalid triangulations becoming valid and ideal after subdivision, which may change properties such as Triangulation&lt;4&gt;::knownSimpleLinks). </dd></dl>

</div>
</div>
<a id="gacb43157f5f496fd046c43cb17f9d34ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb43157f5f496fd046c43cb17f9d34ae">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::begin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A begin function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation. </p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where these appearances are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle).</p>
<p>An iteration from <a class="el" href="group__detail.html#gacb43157f5f496fd046c43cb17f9d34ae" title="A begin function for iterating through all appearances of this face within the various top-dimensiona...">begin()</a> to <a class="el" href="group__detail.html#ga4e2a10c6d41b492299960f23eb729264" title="An end function for iterating through all appearances of this face within the various top-dimensional...">end()</a> will run through <a class="el" href="group__detail.html#gace118d12364a7a78c6819280f849fe4b" title="Returns the degree of this face.">degree()</a> appearances in total.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. However, Python users can call the Python-only routine embeddings(), which will return all appearances (from <a class="el" href="group__detail.html#gacb43157f5f496fd046c43cb17f9d34ae" title="A begin function for iterating through all appearances of this face within the various top-dimensiona...">begin()</a> through to <a class="el" href="group__detail.html#ga4e2a10c6d41b492299960f23eb729264" title="An end function for iterating through all appearances of this face within the various top-dimensional...">end()</a>) in a Python sequence.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a iterator that points to the first appearance. </dd></dl>

</div>
</div>
<a id="ga8c947040ab5f5c42975b6f3be8cfa59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c947040ab5f5c42975b6f3be8cfa59f">&#9670;&nbsp;</a></span>boundaryComponent() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::boundaryComponent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the boundary component of the triangulation to which this face belongs. </p>
<p>See the note in the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> overview regarding what happens if the link of the face itself has more than one boundary component. Note that such a link makes both the face and the underlying triangulation invalid.</p>
<p>For dimensions in which ideal and/or invalid vertices are both possible and recognised: an ideal vertex will have its own individual boundary component to which it belongs, and so will an invalid vertex boundary component if the invalid vertex does not already belong to some real boundary component.</p>
<dl class="section return"><dt>Returns</dt><dd>the boundary component containing this face, or 0 if this face does not lie entirely within the boundary of the triangulation. </dd></dl>

</div>
</div>
<a id="ga55f459ae138f99ef5c6627ce8e212347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55f459ae138f99ef5c6627ce8e212347">&#9670;&nbsp;</a></span>boundaryComponent() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::boundaryComponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the boundary component at the given index in this component. </p>
<p>Note that the index of a boundary component within this component may not be the same as its index within the overall triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which boundary component to return; this should be between 0 and <a class="el" href="group__detail.html#ga7fe9b175112531dacb7c03c59622b778" title="Returns the number of boundary components in this component.">countBoundaryComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested boundary component. </dd></dl>

</div>
</div>
<a id="gaef6eee4278d413b28cc3519ea07d90d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef6eee4278d413b28cc3519ea07d90d0">&#9670;&nbsp;</a></span>boundaryComponent() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested boundary component of this triangulation. </p>
<p>Note that each time the triangulation changes, all boundary components will be deleted and replaced with new ones. Therefore this object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired boundary component; this must be between 0 and <a class="el" href="group__detail.html#ga658bf830fdf052e1beaa5423298c51b2" title="Returns the number of boundary components in this triangulation.">countBoundaryComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested boundary component. </dd></dl>

</div>
</div>
<a id="ga8fd5cf5e44180624e63eaba4caceace5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd5cf5e44180624e63eaba4caceace5">&#9670;&nbsp;</a></span>BoundaryComponentBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">BoundaryComponentBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor that leaves orientability uninitialised. </p>

</div>
</div>
<a id="gaa83c814c5ab1810e5df0ae99865e7c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa83c814c5ab1810e5df0ae99865e7c82">&#9670;&nbsp;</a></span>BoundaryComponentFaceStorage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::<a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">BoundaryComponentFaceStorage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor that initialises the number of ridges to zero. </p>

</div>
</div>
<a id="ga85bd2099351cef31315cc0e0a1cb8713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85bd2099351cef31315cc0e0a1cb8713">&#9670;&nbsp;</a></span>boundaryComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::boundaryComponents</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all boundary components in this component. </p>
<p>The reference that is returned will remain valid only for as long as this component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all boundary components. </dd></dl>

</div>
</div>
<a id="ga29a17ad3357163f3692415bae427882a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29a17ad3357163f3692415bae427882a">&#9670;&nbsp;</a></span>boundaryComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all boundary components of this triangulation. </p>
<p>Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<p>Bear in mind that each time the triangulation changes, all boundary component objects will be deleted and replaced with new ones. Therefore these boundary component objects should be considered temporary only.</p>
<p>In contrast, this reference to the <em>list</em> of <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> objects will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all boundary components. </dd></dl>

</div>
</div>
<a id="gafdc50d6153c5826b4fc0f2ba99d55b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdc50d6153c5826b4fc0f2ba99d55b1c">&#9670;&nbsp;</a></span>BoundaryComponentStorage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex, bool canBuild_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, <a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::<a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">BoundaryComponentStorage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the cached boundary triangulation to <code>null</code>. </p>

</div>
</div>
<a id="ga833940ddf9a9813d8a683f1ed8697999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga833940ddf9a9813d8a683f1ed8697999">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex, bool canBuild_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, <a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the full (<em>dim</em>-1)-dimensional triangulation of this boundary component. </p>
<p>Note that this triangulation is read-only (though of course you can clone it and then operate upon the clone).</p>
<p>If this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the triangulation of this boundary component is as follows:</p>
<ul>
<li>Let <em>i</em> lie between 0 and <a class="el" href="group__detail.html#ga483ae78a8682ebace035a95c4e1eac12" title="Returns the number of (dim-1)-faces in this boundary component.">size()</a>-1 inclusive. Then simplex <em>i</em> of the returned (<em>dim</em>-1)-dimensional triangulation is a copy of <code>facet(i)</code> of this boundary component, and its vertices 0,...,<em>dim</em>-1 are numbered in the same way. To relate these (<em>dim</em>-1)-face vertex numbers to the vertex numbers of top-dimensional simplices in the overall <em>dim</em>-dimensional triangulation, see <a class="el" href="group__detail.html#gab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">Simplex&lt;dim&gt;::faceMapping</a>&lt;dim-1&gt;().</li>
<li>If this boundary component stores lower-dimensional faces (i.e., if the template argument <em>allFaces</em> is <code>true</code>), then a similar correspondence holds for these lower-dimensional faces also: for each <em>i</em>, <em>k</em>-face <em>i</em> of the returned triangulation is a copy of <code>face&lt;k&gt;(i)</code> of this boundary component, and its vertices are numbered in the same way.</li>
</ul>
<p>If this boundary component consists only of a single vertex (i.e., this is an ideal or invalid vertex boundary component), then this routine returns the triangulation of the corresponding vertex link. See Vertex::link() for details.</p>
<p>This routine is fast, since it caches the boundary triangulation. Moreover, it is guaranteed that the full skeleton of this (<em>dim</em>-1)-dimensional triangulation will have been generated already.</p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation of this boundary component. </dd></dl>

</div>
</div>
<a id="ga8d3a55fb04716f4fdb002e4bdf5ae88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d3a55fb04716f4fdb002e4bdf5ae88f">&#9670;&nbsp;</a></span>buildVertexLink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::buildVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Triangulates the vertex link for an ideal or invalid vertex boundary component. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulated vertex link. </dd></dl>

</div>
</div>
<a id="ga1270e786c2239f1d8ebd9b2d45d4619a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1270e786c2239f1d8ebd9b2d45d4619a">&#9670;&nbsp;</a></span>buildVertexLink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, false &gt;::buildVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Always returns <code>null</code>. </p>
<p>In general, this routine triangulates the vertex link for an ideal or invalid vertex boundary component. However, this specialisation is used for cases where such boundary components are either not recognised or not possible, and so this routine returns <code>null</code> always.</p>
<dl class="section return"><dt>Returns</dt><dd><code>null</code>. </dd></dl>

</div>
</div>
<a id="gaadea24ee7f48ea98bf8e83347b96589f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadea24ee7f48ea98bf8e83347b96589f">&#9670;&nbsp;</a></span>calculate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structregina_1_1detail_1_1FaceCalculator.html">regina::detail::FaceCalculator</a>&lt; dim, subdim, codim &gt;::calculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all faces of dimension &le; <em>subdim</em> in the given triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the triangulation whose faces should be calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99eccc799a49667455b78f790f258098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99eccc799a49667455b78f790f258098">&#9670;&nbsp;</a></span>calculatedSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::calculatedSkeleton</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the skeletal objects and properties of this triangulation have been calculated. </p>
<p>These are only calculated "on demand", when a skeletal property is first queried.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the skeleton has been calculated. </dd></dl>

</div>
</div>
<a id="ga1d04b371303f07f238af57faf82c9402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d04b371303f07f238af57faf82c9402">&#9670;&nbsp;</a></span>calculateSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::calculateSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates all skeletal objects for this triangulation. </p>
<p>For this parent class, <a class="el" href="group__detail.html#ga1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> computes properties such as connected components, orientability, and lower-dimensional faces. Some Triangulation&lt;dim&gt; subclasses may track additional skeletal data, in which case they should reimplement this function. Their reimplementations <em>must</em> call this parent implementation.</p>
<p>You should never call this function directly; instead call <a class="el" href="group__detail.html#gaa87b9f9c40a48cee3a1ee9c71bd70fef" title="Ensures that all &quot;on demand&quot; skeletal objects have been calculated.">ensureSkeleton()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>No skeletal objects have been computed, and the corresponding internal lists are all empty.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any call to <a class="el" href="group__detail.html#ga1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> must first cast down to Triangulation&lt;dim&gt;. You should never directly call this parent implementation (unless of course you are reimplementing <a class="el" href="group__detail.html#ga1d04b371303f07f238af57faf82c9402" title="Calculates all skeletal objects for this triangulation.">calculateSkeleton()</a> in a Triangulation&lt;dim&gt; subclass). </dd></dl>

</div>
</div>
<a id="gadedf21e482ff437b437980568da0b852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadedf21e482ff437b437980568da0b852">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::clear</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all face pointers to null. </p>
<p>The faces themselves are not destroyed, and the mapping permutations are not touched. </p>

</div>
</div>
<a id="ga571569a34bb4173bd5eb6b521ff503cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga571569a34bb4173bd5eb6b521ff503cb">&#9670;&nbsp;</a></span>clearBaseProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::clearBaseProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all properties that are managed by this base class. </p>
<p>This includes deleting all skeletal objects and emptying the corresponding internal lists, as well as clearing other cached properties and deallocating the corresponding memory where required.</p>
<p>Note that <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> never calls this routine itself. Typically <a class="el" href="group__detail.html#ga571569a34bb4173bd5eb6b521ff503cb" title="Clears all properties that are managed by this base class.">clearBaseProperties()</a> is only ever called by Triangulation&lt;dim&gt;::clearAllProperties(), which in turn is called by "atomic" routines that change the triangluation (before firing packet change events), as well as the Triangulation&lt;dim&gt; destructor. </p>

</div>
</div>
<a id="ga002ba14e514d4bfc13d110bb03a8855a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga002ba14e514d4bfc13d110bb03a8855a">&#9670;&nbsp;</a></span>component() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this boundary component. </dd></dl>

</div>
</div>
<a id="ga9ff1725cbcd8bda07c8692fe87511b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ff1725cbcd8bda07c8692fe87511b3f">&#9670;&nbsp;</a></span>component() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this boundary component. </dd></dl>

</div>
</div>
<a id="gaa028dd42232ab0137ab65be7ea4adef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa028dd42232ab0137ab65be7ea4adef1">&#9670;&nbsp;</a></span>component() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the component of the triangulation to which this face belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this face. </dd></dl>

</div>
</div>
<a id="gaae91a7cee2cdc36220b08d9fe96985f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae91a7cee2cdc36220b08d9fe96985f7">&#9670;&nbsp;</a></span>component() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this simplex belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this simplex. </dd></dl>

</div>
</div>
<a id="ga4dd435c05fdb9ad2ce0229c08965e87d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd435c05fdb9ad2ce0229c08965e87d">&#9670;&nbsp;</a></span>component() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::component </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested connected component of this triangulation. </p>
<p>Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore this component object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired component; this must be between 0 and <a class="el" href="group__detail.html#ga20e5dba7654710e79eecaf849f248d38" title="Returns the number of connected components in this triangulation.">countComponents()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested component. </dd></dl>

</div>
</div>
<a id="ga20da0ee3cb23bbb6cf5a5fc2c58f3fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20da0ee3cb23bbb6cf5a5fc2c58f3fd4">&#9670;&nbsp;</a></span>ComponentBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1ComponentBase.html">ComponentBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Marks the component as orientable, with no boundary facets. </p>

</div>
</div>
<a id="ga718c3a940b08ef6b5b5c8f48f8dd196a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga718c3a940b08ef6b5b5c8f48f8dd196a">&#9670;&nbsp;</a></span>components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all connected components of this triangulation. </p>
<p>Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore these component objects should be considered temporary only.</p>
<p>In contrast, this reference to the <em>list</em> of all components will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all components. </dd></dl>

</div>
</div>
<a id="gaadc7b079d5d0b7347b0f1fd5b0f398a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadc7b079d5d0b7347b0f1fd5b0f398a1">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long <a class="el" href="structregina_1_1detail_1_1EulerCalculator.html">regina::detail::EulerCalculator</a>&lt; dim, subdim &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the alternating sum of the number of faces of <em>tri</em> of dimensions <em>subdim</em>, ..., <em>dim</em>. </p>
<p>Specifically, this computes <code>tri.countFaces&lt;subdim&gt;() - tri.countFaces&lt;subdim+1&gt;() + ... +/- tri.countFaces&lt;dim&gt;()</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulations whose face counts are to be computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting "partial" Euler characteristic. </dd></dl>

</div>
</div>
<a id="ga0bd32f838bfb204c98ddb985ce1ba3c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bd32f838bfb204c98ddb985ce1ba3c0">&#9670;&nbsp;</a></span>containsVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html">regina::detail::FaceNumberingAPI</a>&lt; dim, subdim &gt;::containsVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the given <em>subdim</em>-face of a <em>dim</em>-dimensional simplex contains the given vertex of the simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>a <em>subdim</em>-face number in a <em>dim</em>-simplex; this must be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>a vertex number in a <em>dim</em>-simplex; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given <em>subdim</em>-face contains the given vertex. </dd></dl>

</div>
</div>
<a id="ga7fe9b175112531dacb7c03c59622b778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe9b175112531dacb7c03c59622b778">&#9670;&nbsp;</a></span>countBoundaryComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::countBoundaryComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of boundary components in this component. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary components. </dd></dl>

</div>
</div>
<a id="ga658bf830fdf052e1beaa5423298c51b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga658bf830fdf052e1beaa5423298c51b2">&#9670;&nbsp;</a></span>countBoundaryComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of boundary components in this triangulation. </p>
<p>Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary components. </dd></dl>

</div>
</div>
<a id="gab2c432ee922ff45feb64a41d80cf5684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2c432ee922ff45feb64a41d80cf5684">&#9670;&nbsp;</a></span>countBoundaryFacets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::countBoundaryFacets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of boundary facets in this component. </p>
<p>A boundary facet is a (<em>dim</em>-1)-dimensional facet of a top-dimensional simplex that is not joined to any adjacent simplex.</p>
<p>This routine runs in constant time (since the result is computed in advance, when the component is first created).</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of boundary facets. </dd></dl>

</div>
</div>
<a id="ga8c1a05fe022a95b928a068f9909b036c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c1a05fe022a95b928a068f9909b036c">&#9670;&nbsp;</a></span>countBoundaryFacets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countBoundaryFacets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of boundary facets in this triangulation. </p>
<p>This routine counts facets of top-dimensional simplices that are not glued to some adjacent top-dimensional simplex.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of boundary facets. </dd></dl>

</div>
</div>
<a id="ga20e5dba7654710e79eecaf849f248d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20e5dba7654710e79eecaf849f248d38">&#9670;&nbsp;</a></span>countComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countComponents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of connected components in this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of connected components. </dd></dl>

</div>
</div>
<a id="ga8cf61d217e99a5ae34d7b5d4f7c427e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cf61d217e99a5ae34d7b5d4f7c427e9">&#9670;&nbsp;</a></span>countFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::countFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this boundary component. </p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>countFaces(subdim)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the faces to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ga929d32300a09aa008d03099e4b84e873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga929d32300a09aa008d03099e4b84e873">&#9670;&nbsp;</a></span>countFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::countFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of <em>subdim</em>-faces in this triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and <em>dim</em>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>countFaces(subdim)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="gaaa1b9175365dfc003ea3ef238ec1fb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1b9175365dfc003ea3ef238ec1fb5a">&#9670;&nbsp;</a></span>countRidges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::countRidges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-2)-faces in this boundary component. </p>
<p>If this is an ideal or invalid vertex boundary component, then this routine will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-2)-faces in this boundary component. </dd></dl>

</div>
</div>
<a id="gaa2b7c7f51442b75f254d3ca507ca4228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b7c7f51442b75f254d3ca507ca4228">&#9670;&nbsp;</a></span>countRidges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::countRidges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-2)-faces in this boundary component. </p>
<p>If this is an ideal or invalid vertex boundary component, then this routine will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-2)-faces in this boundary component. </dd></dl>

</div>
</div>
<a id="gace118d12364a7a78c6819280f849fe4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace118d12364a7a78c6819280f849fe4b">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::degree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the degree of this face. </p>
<p>This is the number of different ways in which the face appears within the various top-dimensional simplices of the underlying triangulation.</p>
<p>Note that if this face appears multiple times within the same top-dimensional simplex, then it will be counted multiple times by this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>the degree of this face. </dd></dl>

</div>
</div>
<a id="ga45b34020172394d10592dd4251468bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45b34020172394d10592dd4251468bcc">&#9670;&nbsp;</a></span>deleteFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim &gt;::deleteFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all faces of dimension <em>subdim</em> and below. </p>
<p>This routine destroys the corresponding <a class="el" href="classregina_1_1Face.html" title="Represents a subdim-face in the skeleton of a dim-dimensional triangulation.">Face</a> objects and clears the lists that contain them. </p>

</div>
</div>
<a id="ga00178392c44456529f5250de6bc448ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00178392c44456529f5250de6bc448ef">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::description</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the description associated with this simplex. </p>
<dl class="section return"><dt>Returns</dt><dd>the description of this simplex, or the empty string if no description is stored. </dd></dl>

</div>
</div>
<a id="ga6beef317a48670f0a4b015b6a9677c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6beef317a48670f0a4b015b6a9677c62">&#9670;&nbsp;</a></span>dest() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="ga4a751dcff6edea48d5407a9de3247927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a751dcff6edea48d5407a9de3247927">&#9670;&nbsp;</a></span>dest() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="gaec0426cec394e5b98ec2134c12dcaed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec0426cec394e5b98ec2134c12dcaed9">&#9670;&nbsp;</a></span>dest() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="ga08b80d0f2604bc161b99f4faa5ac6e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08b80d0f2604bc161b99f4faa5ac6e7b">&#9670;&nbsp;</a></span>dest() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="ga9212638b8863bd3dd2402371c521906b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9212638b8863bd3dd2402371c521906b">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subgraph</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of the graph that describes this facet pairing. </p>
<p>This routine simply returns the output of <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> as a string, instead of dumping it to an output stream.</p>
<p>All arguments are the same as for <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a>; see the <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="gadf1e9a32a2820fc0215afd89a6566c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1e9a32a2820fc0215afd89a6566c32">&#9670;&nbsp;</a></span>dotHeader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::dotHeader </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>graphName</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p>This routine simply returns the output of <a class="el" href="group__detail.html#ga7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a> as a string, instead of dumping it to an output stream.</p>
<p>All arguments are the same as for <a class="el" href="group__detail.html#ga7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>; see the <a class="el" href="group__detail.html#ga7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="group__detail.html#ga7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="gad4726b3b4dd7b8158041ad7b31f9a644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4726b3b4dd7b8158041ad7b31f9a644">&#9670;&nbsp;</a></span>doubleCone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool available&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleFromLowDim.html">regina::detail::ExampleFromLowDim</a>&lt; dim, available &gt;::doubleCone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a double cone over the given (<em>dim-1</em>)-dimensional triangulation. </p>
<p>If the given triangulation represents the manifold <code>M</code>, then this returns an ideal triangulation of the product <code>M x I</code> (with two ideal boundary components). A copy of the original triangulation <em>base</em> can be found at the centre of this construction, formed from the <em>dim</em>-simplices that sit between the two ideal vertices.</p>
<p>Note that, as a special case, if <code>M</code> is either a sphere or a ball, then this routine returns a (<em>dim</em>)-sphere or a (<em>dim</em>)-ball (since "ideal spheres" and "ideal balls" just become regular internal and boundary vertices respectively).</p>
<p>This construction is essentially the suspension of the triangulation <em>base</em>. We do not call it this however, since from a topological point of view, to form the ideal triangulation of <code>M x I</code> we "remove" the vertices at the apex of each cone.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the given (<em>dim</em>-1)-dimensional triangulation has any boundary whatsoever (either real or ideal), then unless it is a (<em>dim</em>-1)-ball, you will obtain an invalid <em>dim</em>-manifold triangulation as a result.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gace7c9ec1168ef9e7cb34b3e4a5b9b873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace7c9ec1168ef9e7cb34b3e4a5b9b873">&#9670;&nbsp;</a></span>dumpConstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dumpConstruction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> C++ code that can be used with <a class="el" href="group__detail.html#gaf1e8b7cf820ff452059f817d55536155" title="Inserts a given triangulation into this triangulation, where the given triangulation is described by ...">insertConstruction()</a> to reconstruct this triangulation. </p>
<p>The code produced will consist of the following:</p>
<ul>
<li>the declaration and initialisation of two integer arrays, describing the gluings between simplices of this trianguation;</li>
<li>two additional lines that declare a new Triangulation&lt;dim&gt; and call <a class="el" href="group__detail.html#gaf1e8b7cf820ff452059f817d55536155" title="Inserts a given triangulation into this triangulation, where the given triangulation is described by ...">insertConstruction()</a> to rebuild this triangulation.</li>
</ul>
<p>The main purpose of this routine is to generate the two integer arrays, which can be tedious and error-prone to code up by hand.</p>
<p>Note that the number of lines of code produced grows linearly with the number of simplices. If this triangulation is very large, the returned string will be very large as well.</p>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a id="ga2ea2c2312ed1484b55eb1db2f25d041e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea2c2312ed1484b55eb1db2f25d041e">&#9670;&nbsp;</a></span>edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, 1&gt;* <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the edge of this simplex that connects the two given vertices of this simplex. </p>
<p>This is a convenience routine to avoid more cumbersome calls to Edge&lt;dim&gt;::faceNumber(). In dimensions 3 and 4 (where the array Edge&lt;dim&gt;::edgeNumber is defined), this routine is identical to calling <code>edge(Edge&lt;dim&gt;::edgeNumber[i][j])</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the vertex of this simplex that forms one endpoint of the edge; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">j</td><td>the vertex of this simplex that forms the other endpoint of the edge; this must be between 0 and <em>dim</em> inclusive, and must also be different from <em>i</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge of this simplex that connects vertices <em>i</em> and <em>j</em> of this simplex. </dd></dl>

</div>
</div>
<a id="ga46541230040337ff42af9653b9e4a458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46541230040337ff42af9653b9e4a458">&#9670;&nbsp;</a></span>embedding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::embedding </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> one of the ways in which this face appears within a top-dimensional simplex of the underlying triangluation. </p>
<p>For convenience, you can also use <a class="el" href="group__detail.html#gacb43157f5f496fd046c43cb17f9d34ae" title="A begin function for iterating through all appearances of this face within the various top-dimensiona...">begin()</a> and <a class="el" href="group__detail.html#ga4e2a10c6d41b492299960f23eb729264" title="An end function for iterating through all appearances of this face within the various top-dimensional...">end()</a> to iterate through all such appearances.</p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where these appearances are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested appearance. This must be between 0 and <a class="el" href="group__detail.html#gace118d12364a7a78c6819280f849fe4b" title="Returns the degree of this face.">degree()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the requested appearance. </dd></dl>

</div>
</div>
<a id="ga4e2a10c6d41b492299960f23eb729264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e2a10c6d41b492299960f23eb729264">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An end function for iterating through all appearances of this face within the various top-dimensional simplices of the underlying triangulation. </p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where these appearances are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle).</p>
<p>An iteration from <a class="el" href="group__detail.html#gacb43157f5f496fd046c43cb17f9d34ae" title="A begin function for iterating through all appearances of this face within the various top-dimensiona...">begin()</a> to <a class="el" href="group__detail.html#ga4e2a10c6d41b492299960f23eb729264" title="An end function for iterating through all appearances of this face within the various top-dimensional...">end()</a> will run through <a class="el" href="group__detail.html#gace118d12364a7a78c6819280f849fe4b" title="Returns the degree of this face.">degree()</a> appearances in total.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. However, Python users can call the Python-only routine embeddings(), which will return all appearances (from <a class="el" href="group__detail.html#gacb43157f5f496fd046c43cb17f9d34ae" title="A begin function for iterating through all appearances of this face within the various top-dimensiona...">begin()</a> through to <a class="el" href="group__detail.html#ga4e2a10c6d41b492299960f23eb729264" title="An end function for iterating through all appearances of this face within the various top-dimensional...">end()</a>) in a Python sequence.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a "beyond the end" iterator that comes immediately after the last appearance. </dd></dl>

</div>
</div>
<a id="ga855ad4db27697cc648b45736957f1224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga855ad4db27697cc648b45736957f1224">&#9670;&nbsp;</a></span>endContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__detail.html#ga15f7e12e1c4be36e550c0873d227cdca" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gab8e43e711504f672541536e05006f9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8e43e711504f672541536e05006f9b8">&#9670;&nbsp;</a></span>endSubElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::AbelianGroupPropertyReader::endSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing has finished for a subelement of this XML element. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__detail.html#gabe8b2a5ac795f6b22ad0eec7565adc83" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga6957484c2540429d42866348285f0cf7">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga03128cad1fee0766645aabe04a5d5174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03128cad1fee0766645aabe04a5d5174">&#9670;&nbsp;</a></span>endSubElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::GroupPresentationPropertyReader::endSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing has finished for a subelement of this XML element. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__detail.html#ga543f461338d4187e278f74c8dc7e54f3" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga6957484c2540429d42866348285f0cf7">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gaa87b9f9c40a48cee3a1ee9c71bd70fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa87b9f9c40a48cee3a1ee9c71bd70fef">&#9670;&nbsp;</a></span>ensureSkeleton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::ensureSkeleton</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that all "on demand" skeletal objects have been calculated. </p>

</div>
</div>
<a id="ga8063bd8d3c1ff8d896ae0a24db2203d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8063bd8d3c1ff8d896ae0a24db2203d5">&#9670;&nbsp;</a></span>eulerCharTri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::eulerCharTri</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this triangulation. </p>
<p>This will be evaluated strictly as the alternating sum of the number of <em>i</em>-faces (that is, <code>countVertices() - countEdges() + countTriangles() - ...</code>).</p>
<p>Note that this routine handles ideal triangulations in a non-standard way. Since it computes the Euler characteristic of the triangulation (and not the underlying manifold), this routine will treat each ideal boundary component as a single vertex, and <em>not</em> as an entire (<em>dim</em>-1)-dimensional boundary component.</p>
<p>In Regina's <a class="el" href="stddim.html">standard dimensions</a>, for a routine that handles ideal boundary components properly (by treating them as (<em>dim</em>-1)-dimensional boundary components when computing Euler characteristic), you can use the routine eulerCharManifold() instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of this triangulation. </dd></dl>

</div>
</div>
<a id="gae681db6dcf0825aa460e60ad611b989e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae681db6dcf0825aa460e60ad611b989e">&#9670;&nbsp;</a></span>face() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the corresponding face number of <a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a>. </p>
<p>This identifies which face of the top-dimensional simplex <a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a> refers to the underlying <em>subdim</em>-face of the triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding face number of the top-dimensional simplex. This will be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </dd></dl>

</div>
</div>
<a id="ga8aca90c1c4e48f547b4295f3cc4dab92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aca90c1c4e48f547b4295f3cc4dab92">&#9670;&nbsp;</a></span>face() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int lowerdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, lowerdim &gt; * <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>lowerdim</em>-face of the underlying triangulation that appears as the given <em>lowerdim</em>-dimensional subface of this face. </p>
<p>The argument <em>face</em> must represent a <em>lowerdim</em>-face number within a <em>subdim</em>-simplex. This <em>lowerdim</em>-face number will be interpreted with respect to the inherent labelling (0, ..., <em>subdim</em>) of the vertices of this <em>subdim</em>-face. See <a class="el" href="group__detail.html#ga8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">FaceEmbedding&lt;dim, subdim&gt;::vertices()</a> for details on how these map to the vertex numbers of the <em>dim</em>-dimensional simplices that contain this face in the overall triangulation.</p>
<p>See FaceNumbering&lt;subdim, lowerdim&gt; for the conventions of how <em>lowerdim</em>-faces are numbered within a <em>subdim</em>-simplex.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(lowerdim, face)</code>; that is, the template parameter <em>lowerdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>lowerdim</em>-face of this <em>subdim</em>-face to examine. This should be between 0 and (<em>subdim</em>+1 choose <em>lowerdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding <em>lowerdim</em>-face of the triangulation. </dd></dl>

</div>
</div>
<a id="ga727ea46d74705043806e29b1fe32c460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga727ea46d74705043806e29b1fe32c460">&#9670;&nbsp;</a></span>face() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>subdim</em>-face of the underlying triangulation that appears as the given <em>subdim</em>-face of this simplex. </p>
<p>See FaceNumbering&lt;dim, subdim&gt; for the conventions of how <em>subdim</em>-faces are numbered within a <em>dim</em>-simplex.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, face)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>subdim</em>-face of this simplex to examine. This should be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding <em>subdim</em>-face of the triangulation. </dd></dl>

</div>
</div>
<a id="ga7eeb9248ad6e7c14665825dba89e57e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eeb9248ad6e7c14665825dba89e57e5">&#9670;&nbsp;</a></span>face() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face in this boundary component. </p>
<p>Note that the index of a face in the boundary component need not be the index of the same face in the overall triangulation. However, if this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the index of each <em>subdim</em>-face in this boundary component will match the index of the corresponding <em>subdim</em>-face in the (<em>dim</em>-1)-manifold triangulation returned by build().</p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, index)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the face to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="group__detail.html#ga8cf61d217e99a5ae34d7b5d4f7c427e9" title="Returns the number of subdim-faces in this boundary component.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="ga802ea1cdd46af32418fb76c49712ccb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga802ea1cdd46af32418fb76c49712ccb8">&#9670;&nbsp;</a></span>face() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face of this triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and <em>dim</em>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, index)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="group__detail.html#ga929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces&lt;subdim&gt;()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="gac18fb1875029b16633326ad5da4199b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac18fb1875029b16633326ad5da4199b1">&#9670;&nbsp;</a></span>FaceBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::<a class="el" href="classregina_1_1detail_1_1FaceBase.html">FaceBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new face. </p>
<p>The face will be initialised as belong to no boundary component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">component</td><td>the component of the underlying triangulation to which the new face belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32e2f937f310e26fb5e7885e2893aad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32e2f937f310e26fb5e7885e2893aad7">&#9670;&nbsp;</a></span>FaceEmbeddingBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::<a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>This object is unusable until it has some data assigned to it using <code>operator =</code>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gabc2a373a564bf19436d0cabd2e2a1a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc2a373a564bf19436d0cabd2e2a1a21">&#9670;&nbsp;</a></span>FaceEmbeddingBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::<a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c55e6c817630cbb355b997af1c46766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c55e6c817630cbb355b997af1c46766">&#9670;&nbsp;</a></span>FaceEmbeddingBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::<a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>simplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object containing the given data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the top-dimensional simplex in which the underlying <em>subdim</em>-face of the triangulation is contained. </td></tr>
    <tr><td class="paramname">face</td><td>the corresponding face number of <em>simplex</em>. This must be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed9ed0245ebec8f610f9d262fbf19d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed9ed0245ebec8f610f9d262fbf19d22">&#9670;&nbsp;</a></span>faceMapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int lowerdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::faceMapping </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Examines the given <em>lowerdim</em>-dimensional subface of this face, and returns the mapping between the underlying <em>lowerdim</em>-face of the triangulation and the individual vertices of this face. </p>
<p>The argument <em>face</em> must represent a <em>lowerdim</em>-face number within a <em>subdim</em>-simplex. This <em>lowerdim</em>-face number will be interpreted with respect to the inherent labelling (0, ..., <em>subdim</em>) of the vertices of this <em>subdim</em>-face. See <a class="el" href="group__detail.html#ga8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">FaceEmbedding&lt;dim, subdim&gt;::vertices()</a> for details on how these map to the vertex numbers of the <em>dim</em>-dimensional simplices that contain this face in the overall triangulation.</p>
<p>Let <em>F</em> denote this <em>subdim</em>-face of the triangulation, and let <em>L</em> denote the <em>lowerdim</em>-face of the triangulation that corresponds to the given subface of <em>F</em>. Then the permutation returned by this routine maps the vertex numbers (0, ..., <em>lowerdim</em>) of <em>L</em> to the corresponding vertex numbers of <em>F</em>. This is with respect to the inherent labellings (0, ..., <em>lowerdim</em>) and (0, ..., <em>subdim</em>) of the vertices of <em>L</em> and <em>F</em> respectively.</p>
<p>In particular, if this routine returns the permutation <em>p</em>, then the images <em>p</em>[0,...,<em>lowerdim</em>] will be some permutation of the vertices Face&lt;subdim, lowerdim&gt;::ordering(face)[0,...,<em>lowerdim</em>].</p>
<p>This routine differs from <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3" title="Refers to a top-dimensional simplex in a dim-dimensional triangulation.">Simplex&lt;dim&gt;::faceMapping&lt;lowerdim&gt;()</a> in how it handles the images of (<em>lowerdim</em>+1, ..., <em>dim</em>):</p>
<ul>
<li>This routine will map (<em>lowerdim</em>+1, ..., <em>subdim</em>) to the remaining vertices of this face in an arbitrary order, and will map (<em>subdim</em>+1, ..., <em>dim</em>) to (<em>subdim</em>+1, ..., <em>dim</em>) again in an arbitrary order.</li>
<li>In contrast, <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3" title="Refers to a top-dimensional simplex in a dim-dimensional triangulation.">Simplex&lt;dim&gt;::faceMapping&lt;lowerdim&gt;()</a> chooses the images of (<em>lowerdim</em>+1, ..., <em>dim</em>) to satisfy an additional orientability constraint.</li>
</ul>
<p>See FaceNumbering&lt;subdim, lowerdim&gt; for the conventions of how <em>lowerdim</em>-faces are numbered within a <em>subdim</em>-simplex.</p>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>faceMapping(lowerdim, face)</code>; that is, the template parameter <em>lowerdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>lowerdim</em>-face of this <em>subdim</em>-face to examine. This should be between 0 and (<em>subdim</em>+1 choose <em>lowerdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mapping from the vertices of the underlying <em>lowerdim</em>-face of the triangulation to the vertices of this <em>subdim</em>-face. </dd></dl>

</div>
</div>
<a id="gab5f66b0a702a6b374af4f0830d9b2fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5f66b0a702a6b374af4f0830d9b2fe0">&#9670;&nbsp;</a></span>faceMapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::faceMapping </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the given <em>subdim</em>-face of this simplex, and returns the mapping between the underlying <em>subdim</em>-face of the triangulation and the individual vertices of this simplex. </p>
<p>Specifically:</p>
<ul>
<li>Suppose several <em>subdim</em>-faces of several top-dimensional simplices are identified within the overall triangulation. Then we call this a single "&lt;i&gt;subdim&lt;/i&gt;-face of the triangulation", and arbitrarily label its vertices (0, ..., <em>subdim</em>).</li>
<li>Now let <em>F</em> denote the <em>subdim</em>-face of the triangulation that corresponds to <em>subdim</em>-face number <em>face</em> of this simplex. Then this routine returns a map from vertices (0, ..., <em>subdim</em>) of <em>F</em> to the corresponding vertex numbers of this simplex.</li>
<li>In particular, if this routine returns the permutation <em>p</em>, then the images <em>p</em>[0,...,<em>subdim</em>] will be some permutation of the vertices Face&lt;dim, subdim&gt;::ordering[0,...,<em>subdim</em>].</li>
<li>If <em>F</em> also appears as face number <em>k</em> in some other simplex <em>s</em>, then for each <em>i</em> in the range 0 &le; <em>i</em> &le; <em>subdim</em>, vertex <code>p[i]</code> of this simplex will be identified with vertex <em>s</em>.faceMapping(<em>k</em>)[<em>i</em>] of simplex <em>s</em>.</li>
</ul>
<p>If the link of the underlying <em>subdim</em>-face is orientable, then this permutation maps the remaining numbers (<em>subdim</em>+1, ..., <em>dim</em>) to the remaining vertex numbers of this simplex in a manner that preserves orientation as you walk through the many different simplices that contain the same underlying <em>subdim</em>-face. Specifically:</p>
<ul>
<li>The images of (<em>subdim</em>+1, ..., <em>dim</em>) under this permutation imply an orientation for the (<em>dim</em> - <em>subdim</em> - 1)-face opposite <em>F</em> in this simplex. These orientations will be consistent for all simplices containing <em>F</em>.</li>
<li>For faces of codimension two (e.g., edges in a 3-manifold triangulation), this orientation condition is even stronger. Here the link of the face <em>F</em> must be a path (for a boundary face) or a cycle (for an internal face). In each simplex we can form a directed edge from the image of <em>dim</em>-1 to the image of <em>dim</em> under this permutation, and together these directed edges form a directed path or cycle that follows the link of the face <em>F</em>. Moreover, an iteration through the corresponding FaceEmbedding&lt;dim, subdim&gt; objects in order from <code>F.begin()</code> to <code>F.end()</code>, will follow this directed path in order from start to end. (In the case where the link of <em>F</em> is a cycle, the start point in the list of <a class="el" href="classregina_1_1FaceEmbedding.html" title="Details how a subdim-face of a dim-dimensional triangulation appears within each top-dimensional simp...">FaceEmbedding</a> objects will be arbitrary.)</li>
</ul>
<p>Note that, even if the link is orientable, there are still arbitrary decisions to be made for the images of (<em>subdim</em>+1, ..., <em>dim</em>), since there will always be (<em>dim</em>-<em>subdim</em>)!/2 possible mappings that yield the correct orientation.</p>
<dl class="section note"><dt>Note</dt><dd>This routine returns the same permutation as <a class="el" href="group__detail.html#ga8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">FaceEmbedding&lt;dim, subdim&gt;::vertices()</a>, in the context of the FaceEmbedding&lt;dim, subdim&gt; object that refers to <em>subdim</em>-face number <em>face</em> of this simplex.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>faceMapping(subdim, face)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>subdim</em>-face of this simplex to examine. This should be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mapping from the vertices of the underlying <em>subdim</em>-face of the triangulation to the vertices of this simplex. </dd></dl>

</div>
</div>
<a id="ga7466eaf4d128e641797687eb31f13e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7466eaf4d128e641797687eb31f13e7e">&#9670;&nbsp;</a></span>faceNumber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned <a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html">regina::detail::FaceNumberingAPI</a>&lt; dim, subdim &gt;::faceNumber </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies which <em>subdim</em>-face in a <em>dim</em>-dimensional simplex is represented by the first (<em>subdim</em> + 1) elements of the given permutation. </p>
<p>In other words, this routine identifies which <em>subdim</em>-face number within a <em>dim</em>-dimensional simplex spans vertices <code>vertices[0, ..., <em>subdim</em>]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>a permutation whose first (<em>subdim</em> + 1) elements represent some vertex numbers in a <em>dim</em>-simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding <em>subdim</em>-face number in the <em>dim</em>-simplex. This will be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </dd></dl>

</div>
</div>
<a id="gaa9cff3435bc7205129717c4b20e005fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9cff3435bc7205129717c4b20e005fb">&#9670;&nbsp;</a></span>FaceOrientability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsNonorientable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability</a>&lt; allowsNonorientable &gt;::<a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">FaceOrientability</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the link of this face as orientable. </p>

</div>
</div>
<a id="ga1ed8ba830f6428fba6cd71b4e9e8f58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed8ba830f6428fba6cd71b4e9e8f58d">&#9670;&nbsp;</a></span>faces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all <em>subdim</em>-faces in this boundary component. </p>
<p>The reference that is returned will remain valid only for as long as this boundary component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all boundary component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python</dt><dd>Python users should call this function in the form <code>faces(subdim)</code>. It will then return a Python list containing all the <em>subdim</em>-faces of the boundary component. Be warned that, unlike in C++, this Python list will be a snapshot of the faces when this function is called, and will <em>not</em> be kept up-to-date as the triangulation changes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the faces to query. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="gaff6d83a36cc07a69d4f3148fa08d1fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff6d83a36cc07a69d4f3148fa08d1fd6">&#9670;&nbsp;</a></span>faces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation. </p>
<p>Bear in mind that each time the triangulation changes, all face objects will be deleted and replaced with new ones. Therefore these face objects should be considered temporary only.</p>
<p>In contrast, this reference to the <a class="el" href="classregina_1_1FaceList.html" title="Stores the list of all subdim-faces of a dim-dimensional triangulation.">FaceList</a> object itself will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python</dt><dd>Python users should call this function in the form <code>faces(subdim)</code>. It will then return a Python list containing all the <em>subdim</em>-faces of the triangulation. Be warned that, unlike in C++, this Python list will be a snapshot of the faces when this function is called, and will <em>not</em> be kept up-to-date as the triangulation changes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a id="ga090ff000af7de557979739c253d771ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga090ff000af7de557979739c253d771ba">&#9670;&nbsp;</a></span>FaceStorage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::<a class="el" href="classregina_1_1detail_1_1FaceStorage.html">FaceStorage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor that leaves the list of embeddings empty. </p>

</div>
</div>
<a id="gaf700895bba89bdb331ae7f0a0958d947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf700895bba89bdb331ae7f0a0958d947">&#9670;&nbsp;</a></span>facet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::facet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested (<em>dim</em>-1)-face in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<p>Note that the index of a face in the boundary component need not be the index of the same face in the overall triangulation. However, if this is a real boundary component (i.e., it is built from one or more (<em>dim</em>-1)-faces), then the index of each (<em>dim</em>-1)-face in this boundary component will match the index of the corresponding top-dimensional simplex in the (<em>dim</em>-1)-manifold triangulation returned by build().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="group__detail.html#ga483ae78a8682ebace035a95c4e1eac12" title="Returns the number of (dim-1)-faces in this boundary component.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="gaf4071539381c57d0f674bb8ec0ab242e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4071539381c57d0f674bb8ec0ab242e">&#9670;&nbsp;</a></span>facet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::facet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested (<em>dim</em>-1)-face in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<p>Note that the index of a face in the boundary component need not be the index of the same face in the overall triangulation. However, the index of each (<em>dim</em>-1)-face in this boundary component will match the index of the corresponding top-dimensional simplex in the (<em>dim</em>-1)-manifold triangulation returned by build().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to <a class="el" href="group__detail.html#ga35950a8c9912f9a9317370b9c3614b7e" title="Returns the number of (dim-1)-faces in this boundary component.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a id="ga9da19b23a42f47afe636a2cff5f0eee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9da19b23a42f47afe636a2cff5f0eee7">&#9670;&nbsp;</a></span>facetInMaximalForest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::facetInMaximalForest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given facet of this simplex belongs to the maximal forest that has been chosen for the dual 1-skeleton of the underlying triangulation. </p>
<p>When the skeletal structure of a triangulation is first computed, a maximal forest in the dual 1-skeleton of the triangulation is also constructed. Each dual edge in this maximal forest represents a (<em>dim</em>-1)-face of the (primal) triangulation.</p>
<p>This maximal forest will remain fixed until the triangulation changes, at which point it will be recomputed (as will all other skeletal objects, such as connected components and so on). There is no guarantee that, when it is recomputed, the maximal forest will use the same dual edges as before.</p>
<p>This routine identifies which (<em>dim</em>-1)-faces of the triangulation belong to the dual forest. Because it lives in the Simplex class, this routine can even be used for those dimensions that do not have explicit classes for (<em>dim</em>-1)-faces of the triangulation.</p>
<p>If the skeleton has already been computed, then this routine is very fast (since it just returns a precomputed answer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given facet of this simplex corresponds to a dual edge in the maximal forest chosen for the dual 1-skeleton. </dd></dl>

</div>
</div>
<a id="ga03ab9eda74347bfa8ad909e9d6ecf0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03ab9eda74347bfa8ad909e9d6ecf0bd">&#9670;&nbsp;</a></span>FacetPairingBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new facet pairing that is a clone of the given facet pairing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the facet pairing to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f49a37db6de4fe56424d1edecf3705d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f49a37db6de4fe56424d1edecf3705d">&#9670;&nbsp;</a></span>FacetPairingBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the facet pairing of given triangulation. </p>
<p>This is the facet pairing that describes how the facets of simplices in the given triangulation are joined together, as described in the class notes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is not empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation whose facet pairing should be constructed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7427ba20ec700dab650cb40931f95e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7427ba20ec700dab650cb40931f95e43">&#9670;&nbsp;</a></span>FacetPairingBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new facet pairing. </p>
<p>All internal arrays will be allocated but not initialised.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>size</em> is at least 1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the number of simplices under consideration in this new facet pairing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb0ad0ed6aad84455848858b1df4c682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb0ad0ed6aad84455848858b1df4c682">&#9670;&nbsp;</a></span>facetPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::facetPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a read-write reference to the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism. </p>
<p>Facet <em>i</em> of source simplex <em>sourceSimp</em> will be mapped to facet <code>facetPerm(sourceSimp)[i]</code> of simplex <code>simpImage(sourceSimp)</code>.</p>
<dl class="section user"><dt>Python</dt><dd>This is not available for Python users. However, the read-only version of this routine is.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex containing the original (<em>dim</em> + 1) facets; this must be between 0 and <code><a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a read-write reference to the permutation applied to the facets of the source simplex. </dd></dl>

</div>
</div>
<a id="gae1f4e57841e1621eccba6a95c18faa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1f4e57841e1621eccba6a95c18faa43">&#9670;&nbsp;</a></span>facetPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::facetPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the permutation that is applied to the (<em>dim</em> + 1) facets of the given source simplex under this isomorphism. </p>
<p>Facet <em>i</em> of source simplex <em>sourceSimp</em> will be mapped to face <code>facetPerm(sourceSimp)[i]</code> of simplex <code>simpImage(sourceSimp)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex containing the original (<em>dim</em> + 1) facets; this must be between 0 and <code><a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the permutation applied to the facets of the source simplex. </dd></dl>

</div>
</div>
<a id="ga133608401c59bc96e1bbc7e2785ed72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133608401c59bc96e1bbc7e2785ed72d">&#9670;&nbsp;</a></span>facets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all (<em>dim</em>-1)-faces in this boundary component. </p>
<p>The reference that is returned will remain valid only for as long as this boundary component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all boundary component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all (<em>dim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="gaea3b16fb3280f5ea51ee683494ddc82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea3b16fb3280f5ea51ee683494ddc82c">&#9670;&nbsp;</a></span>facets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::facets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all (<em>dim</em>-1)-faces in this boundary component. </p>
<p>The reference that is returned will remain valid only for as long as this boundary component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all boundary component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all (<em>dim</em>-1)-faces. </dd></dl>

</div>
</div>
<a id="ga1291a45c3fd76e8d4cd2e2f6e0eb5260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1291a45c3fd76e8d4cd2e2f6e0eb5260">&#9670;&nbsp;</a></span>FaceValidity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsInvalid, bool testLinks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::<a class="el" href="classregina_1_1detail_1_1FaceValidity.html">FaceValidity</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this face as valid. </p>

</div>
</div>
<a id="gaa564cf57a3e438c5e055a029f0bf43a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa564cf57a3e438c5e055a029f0bf43a3">&#9670;&nbsp;</a></span>FaceValidity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; true, false &gt;::<a class="el" href="classregina_1_1detail_1_1FaceValidity.html">FaceValidity</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises this face as valid. </p>

</div>
</div>
<a id="ga2ca15c283aec839dfa1fe5819beeeab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca15c283aec839dfa1fe5819beeeab4">&#9670;&nbsp;</a></span>fillFVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim &gt;::fillFVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given vector with the first (<em>subdim</em> + 1) elements of the f-vector. </p>
<p>Specifically, this routine pushes the values <em>f</em>[0], ..., <em>f</em>[<em>subdim</em>] onto the end of the given vector, where <em>f</em>[<em>k</em>] denotes the number of <em>k</em>-faces that this object stores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the vector in which the results will be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f6909b62bdeb58b6b0f4a43646fa0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f6909b62bdeb58b6b0f4a43646fa0f7">&#9670;&nbsp;</a></span>findAllIsomorphisms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllIsomorphisms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>This routine behaves identically to <a class="el" href="group__detail.html#gaf68572c80fc27fc3a069ad01d9615952" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a>, except that instead of returning just one isomorphism, all such isomorphisms are returned.</p>
<p>See the <a class="el" href="group__detail.html#gaf68572c80fc27fc3a069ad01d9615952" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> notes for additional information.</p>
<p>The isomorphisms that are found will be written to the given output iterator. This iterator must accept objects of type Isomorphism&lt;dim&gt;*. As an example, <em>output</em> might be a back_insert_iterator for a std::vector&lt;Isomorphism&lt;dim&gt;*&gt;.</p>
<p>The isomorphisms that are written to the given output iterator will be newly created, and the caller of this routine is responsible for destroying them.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>output</em> argument is not present. Instead, this routine returns a python list containing all of the isomorphisms that were found.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to which the isomorphisms will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of isomorphisms that were found. </dd></dl>

</div>
</div>
<a id="gaf37845787a6a80399160c535b9344d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf37845787a6a80399160c535b9344d08">&#9670;&nbsp;</a></span>findAllPairings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAllPairings </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nBdryFacets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__detail.html#ga950ce31e11866d63683a435e8d76c9bf">Use</a>&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>useArgs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates all possible facet pairings satisfying the given constraints. </p>
<p>Only connected facet pairings (pairings in which each simplex can be reached from each other via a series of individual matched facets) will be produced.</p>
<p>Each facet pairing will be produced precisely once up to isomorphism. Facet pairings are considered isomorphic if they are related by a relabelling of the simplices and/or a renumbering of the (<em>dim</em> + 1) facets of each simplex. Each facet pairing that is generated will be a lexicographically minimal representative of its isomorphism class, i.e., will be in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">isCanonical()</a>.</p>
<p>For each facet pairing that is generated, routine <em>use</em> (as passed to this function) will be called with that pairing and its automorphisms as arguments.</p>
<p>Once the generation of facet pairings has finished, routine <em>use</em> will be called once more, this time with <code>null</code> as its first two arguments (for the facet pairing and its automorphisms).</p>
<p>Because this class cannot represent an empty facet pairing, if the argument <em>nSimplices</em> is zero then no facet pairings will be generated at all.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000045">Todo:</a></b></dt><dd><p class="startdd"><em>Optimise (long-term):</em> When generating facet pairings, do some checking to eliminate cases in which simplex (<em>k</em> &gt; 0) can be swapped with simplex 0 to produce a smaller representation of the same pairing. </p>
<p class="enddd"><em>Feature:</em> Allow cancellation of facet pairing generation.</p>
</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, even in the dimension-specific subclasses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices whose facets should be (potentially) matched. </td></tr>
    <tr><td class="paramname">boundary</td><td>determines whether any facets may be left unmatched. This set should contain <code>true</code> if pairings with at least one unmatched facet are to be generated, and should contain <code>false</code> if pairings with no unmatched facets are to be generated. </td></tr>
    <tr><td class="paramname">nBdryFacets</td><td>specifies the precise number of facets that should be left unmatched. If this parameter is negative, it is ignored and no additional restriction is imposed. If parameter <em>boundary</em> does not contain <code>true</code>, this parameter is likewise ignored. If parameter <em>boundary</em> does contain true and this parameter is non-negative, only pairings with precisely this many unmatched facets will be generated. In particular, if this parameter is positive then pairings with no unmatched facets will not be produced irrespective of whether <code>false</code> is contained in parameter <em>boundary</em>. Note that, in order to produce any pairings at all, this parameter must be of the same parity as <code>nSimplices * (dim+1)</code>, and can be at most <code>(dim-1) * nSimplices + 2</code>. </td></tr>
    <tr><td class="paramname">use</td><td>the function to call upon each facet pairing that is found. The first parameter passed to this function will be a facet pairing. The second parameter will be a list of all its automorphisms (relabellings of simplices and individual simplex facets that produce the exact same pairing). The third parameter will be parameter <em>useArgs</em> as was passed to this routine. </td></tr>
    <tr><td class="paramname">useArgs</td><td>the pointer to pass as the final parameter for the function <em>use</em> which will be called upon each pairing found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga13bd275984bd2e6241fc220229f39490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13bd275984bd2e6241fc220229f39490">&#9670;&nbsp;</a></span>findAllSubcomplexesIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::findAllSubcomplexesIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>This routine behaves identically to <a class="el" href="group__detail.html#ga61ce7adfff99f476365aa7af3a37f650" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation,...">isContainedIn()</a>, except that instead of returning just one isomorphism (which may be boundary incomplete and need not be onto), all such isomorphisms are returned.</p>
<p>See the <a class="el" href="group__detail.html#ga61ce7adfff99f476365aa7af3a37f650" title="Determines if an isomorphic copy of this triangulation is contained within the given triangulation,...">isContainedIn()</a> notes for additional information.</p>
<p>The isomorphisms that are found will be written to the given output iterator. This iterator must accept objects of type Isomorphism&lt;dim&gt;*. As an example, <em>output</em> might be a back_insert_iterator for a std::vector&lt;Isomorphism&lt;dim&gt;*&gt;.</p>
<p>The isomorphisms that are written to the given output iterator will be newly created, and the caller of this routine is responsible for destroying them.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for isomorphic copies of this triangulation. </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to which the isomorphisms will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of isomorphisms that were found. </dd></dl>

</div>
</div>
<a id="ga2b40f375b3813b8ee467fd5e0e2f7cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b40f375b3813b8ee467fd5e0e2f7cab">&#9670;&nbsp;</a></span>findAutomorphisms()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::findAutomorphisms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given list with the set of all combinatorial automorphisms of this facet pairing. </p>
<p>An automorphism is a relabelling of the simplices and/or a renumbering of the (<em>dim</em> + 1) facets of each simplex resulting in precisely the same facet pairing.</p>
<p>This routine uses optimisations that can cause unpredictable breakages if this facet pairing is not in canonical form.</p>
<p>The automorphisms placed in the given list will be newly created; it is the responsibility of the caller of this routine to deallocate them.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given list is empty. </dd>
<dd>
This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs. </dd>
<dd>
This facet pairing is in canonical form as described by <a class="el" href="group__detail.html#gad720be5515121b69f7ce62e5bbda9b5b" title="Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal repr...">isCanonical()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present, even in the dimension-specific subclasses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list into which the newly created automorphisms will be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc25a58b48e39f3c7f8621b84432d294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc25a58b48e39f3c7f8621b84432d294">&#9670;&nbsp;</a></span>finiteToIdeal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::finiteToIdeal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts each real boundary component into a cusp (i.e., an ideal vertex). </p>
<p>Only boundary components formed from real (<em>dim</em>-1)-faces will be affected; ideal boundary components are already cusps and so will not be changed.</p>
<p>One side-effect of this operation is that all spherical boundary components will be filled in with balls.</p>
<p>This operation is performed by attaching a new <em>dim</em>-simplex to each boundary (<em>dim</em>-1)-face, and then gluing these new simplices together in a way that mirrors the adjacencies of the underlying boundary facets. Each boundary component will thereby be pushed up through the new simplices and converted into a cusp formed using vertices of these new simplices.</p>
<p>In Regina's <a class="el" href="stddim.html">standard dimensions</a>, where triangulations also support an idealToFinite() operation, this routine is a loose converse of that operation.</p>
<p>In dimension 2, every boundary component is spherical and so this routine simply fills all the punctures in the underlying surface. (In dimension 2, triangulations cannot have cusps).</p>
<dl class="section warning"><dt>Warning</dt><dd>If a real boundary component contains vertices whose links are not discs, this operation may have unexpected results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if changes were made, or <code>false</code> if the original triangulation contained no real boundary components. </dd></dl>

</div>
</div>
<a id="gac7a5a9449f2de027e0cae40ff8a3ee38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7a5a9449f2de027e0cae40ff8a3ee38">&#9670;&nbsp;</a></span>fromIsoSig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fromIsoSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a full triangulation from an isomorphism signature. </p>
<p>See <a class="el" href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>The triangulation that is returned will be newly created, and it is the responsibility of the caller of this routine to destroy it.</p>
<p>Calling <a class="el" href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> followed by <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> is not guaranteed to produce an <em>identical</em> triangulation to the original, but it is guaranteed to produce a combinatorially <em>isomorphic</em> triangulation. In other words, <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> may reconstruct the triangulation with its simplices and/or vertices relabelled. The optional argument to <a class="el" href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> allows you to determine the precise relabelling that will be used, if you need to know it.</p>
<p>For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of the triangulation to construct. Note that isomorphism signatures are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated triangulation if the reconstruction was successful, or <code>null</code> if the given string was not a valid <em>dim</em>-dimensional isomorphism signature. </dd></dl>

</div>
</div>
<a id="ga3241a34885f4b644773edccf65225ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3241a34885f4b644773edccf65225ac4">&#9670;&nbsp;</a></span>fromTextRep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::fromTextRep </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reconstructs a facet pairing from a text-based representation. </p>
<p>This text-based representation must be in the format produced by routine <a class="el" href="group__detail.html#ga6afb56a1370b063c12c4efe634eb771b" title="Returns a text-based representation of this facet pairing that can be used to reconstruct the facet p...">toTextRep()</a>.</p>
<p>The facet pairing returned will be newly constructed; it is the responsibility of the caller of this routine to deallocate it.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The facet pairing to be reconstructed involves at least one simplex.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rep</td><td>a text-based representation of a facet pairing, as produced by routine <a class="el" href="group__detail.html#ga6afb56a1370b063c12c4efe634eb771b" title="Returns a text-based representation of this facet pairing that can be used to reconstruct the facet p...">toTextRep()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding newly constructed facet pairing, or <code>null</code> if the given text-based representation was invalid. </dd></dl>

</div>
</div>
<a id="ga63f659c8eb6a4ce037ebf5b65aa32d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f659c8eb6a4ce037ebf5b65aa32d45">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::front</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first appearance of this face within a top-dimensional simplex of the underlying triangluation. </p>
<p>This is equivalent to calling <code>*begin()</code>, or <code>embedding(0)</code>.</p>
<p>In most cases, the ordering of appearances is arbitrary. The exception is for codimension 2, where the appearances of a face are ordered in a way that follows the link around the face (which in codimension 2 is always a path or a cycle). In particular, for a boundary face of codimension 2, both <a class="el" href="group__detail.html#ga63f659c8eb6a4ce037ebf5b65aa32d45" title="Returns the first appearance of this face within a top-dimensional simplex of the underlying trianglu...">front()</a> and <a class="el" href="group__detail.html#ga947d961f6901c0998cecb0392c8b1a66" title="Returns the last appearance of this face within a top-dimensional simplex of the underlying trianglua...">back()</a> will refer to the two appearances of this face on the (<em>dim</em>-1)-dimensional boundary.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the first appearance. </dd></dl>

</div>
</div>
<a id="ga408718df2c6cc65f21adabc50850ec63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga408718df2c6cc65f21adabc50850ec63">&#9670;&nbsp;</a></span>fundamentalGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fundamentalGroup</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the fundamental group of this triangulation. </p>
<p>The fundamental group is computed in the dual 2-skeleton. This means:</p>
<ul>
<li>If the triangulation contains any ideal vertices, the fundamental group will be calculated as if each such vertex had been truncated.</li>
<li>Likewise, if the triangulation contains any invalid faces of dimension 0,1,...,(<em>dim</em>-3), these will effectively be truncated also.</li>
<li>In contrast, if the triangulation contains any invalid (<em>dim</em>-2)-faces (i.e., codimension-2-faces that are identified with themselves under a non-trivial map), the fundamental group will be computed <em>without</em> truncating the centroid of the face. For instance, if a 3-manifold triangulation has an edge identified with itself in reverse, then the fundamental group will be computed without truncating the resulting projective plane cusp. This means that, if a barycentric subdivision is performed on a such a triangulation, the result of <a class="el" href="group__detail.html#ga408718df2c6cc65f21adabc50850ec63" title="Returns the fundamental group of this triangulation.">fundamentalGroup()</a> might change.</li>
</ul>
<p>Bear in mind that each time the triangulation changes, the fundamental group will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__detail.html#ga408718df2c6cc65f21adabc50850ec63" title="Returns the fundamental group of this triangulation.">fundamentalGroup()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation has at most one component.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute the fundamental group with fillings, call <a class="el" href="group__snappea.html#gad00a04f8c82acb0a4fd5fee0e2f23fd6" title="Returns the fundamental group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::fundamentalGroupFilled()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the fundamental group. </dd></dl>

</div>
</div>
<a id="gad5c48ed1736e27aa09620cd924507ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5c48ed1736e27aa09620cd924507ef4">&#9670;&nbsp;</a></span>fVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::fVector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the f-vector of this triangulation, which counts the number of faces of all dimensions. </p>
<p>The vector that is returned will have length <em>dim</em>+1. If this vector is <em>f</em>, then <em>f</em>[<em>k</em>] will be the number of <em>k</em>-faces for each 0 &le; <em>k</em> &le; <em>dim</em>.</p>
<p>This routine is significantly more heavyweight than <a class="el" href="group__detail.html#ga929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>. Its advantage is that, unlike the templatised <a class="el" href="group__detail.html#ga929d32300a09aa008d03099e4b84e873" title="Returns the number of subdim-faces in this triangulation.">countFaces()</a>, it allows you to count faces whose dimensions are not known until runtime.</p>
<dl class="section return"><dt>Returns</dt><dd>the f-vector of this triangulation. </dd></dl>

</div>
</div>
<a id="ga28e7a460d4b7805c994a594d092309ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e7a460d4b7805c994a594d092309ee">&#9670;&nbsp;</a></span>GroupPresentationPropertyReader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::GroupPresentationPropertyReader::GroupPresentationPropertyReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detail.html#gab6d74c424017288ecce4629d2f88ae2a">PropType</a> &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new reader that stores its results in the given triangulation property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td>a reference to the triangulation property in which the data that is read should be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga72c0522efd2a0b8df7b632ad82b36760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72c0522efd2a0b8df7b632ad82b36760">&#9670;&nbsp;</a></span>hasBadIdentification() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsInvalid, bool testLinks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::hasBadIdentification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this face is identified with itself under a non-identity permutation. </p>
<p>For example, if this face is an edge then this routine tests whether the edge is identified with itself in reverse.</p>
<p>Such a face will always be marked as invalid. Note that, for <a class="el" href="stddim.html">standard dimensions</a> <em>dim</em>, there are other types of invalid faces also. See <a class="el" href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54" title="Determines if this face is valid.">isValid()</a> for a full discussion of what it means for a face to be valid.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face is identified with itself under a non-identity permutation. </dd></dl>

</div>
</div>
<a id="ga54fa547d187dfb41e0c3f44ce9ab73b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54fa547d187dfb41e0c3f44ce9ab73b5">&#9670;&nbsp;</a></span>hasBadIdentification() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; true, false &gt;::hasBadIdentification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face is identified with itself under a non-identity permutation. </p>
<p>For example, if this face is an edge then this routine tests whether the edge is identified with itself in reverse.</p>
<p>For this class, <a class="el" href="group__detail.html#ga54fa547d187dfb41e0c3f44ce9ab73b5" title="Determines if this face is identified with itself under a non-identity permutation.">hasBadIdentification()</a> returns <code>true</code> if and only if <a class="el" href="group__detail.html#ga3af63adfc417388aa6b68c0fea7f8086" title="Determines if this face is valid.">isValid()</a> returns <code>false</code>. This is in contrast to <a class="el" href="stddim.html">standard dimensions</a>, where there are other types of invalid faces also. See <a class="el" href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54" title="Determines if this face is valid.">FaceValidity&lt;true, true&gt;::isValid()</a> for a full discussion of what it means for a face to be valid, and how this differs between standard and non-standard dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face is identified with itself under a non-identity permutation. </dd></dl>

</div>
</div>
<a id="gaab16c59e486f840192f63a4268f53b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab16c59e486f840192f63a4268f53b3d">&#9670;&nbsp;</a></span>hasBadLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsInvalid, bool testLinks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::hasBadLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this face does not have an appropriate link. </p>
<p>See condition (2) in the documentation for <a class="el" href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54" title="Determines if this face is valid.">isValid()</a> for a full description of what "appropriate" means.</p>
<p>This routine is only available where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>, since testing this condition in arbitrary dimensions is undecidable. For higher dimensions <em>dim</em>, this routine is not present.</p>
<p>A face whose link is not appropriate will always be marked as invalid. Note that there are other types of invalid faces also. See <a class="el" href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54" title="Determines if this face is valid.">isValid()</a> for a full discussion of what it means for a face to be valid.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link of this face is not appropriate. </dd></dl>

</div>
</div>
<a id="ga9cdb23e0e94cf30e7fe953691c926af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cdb23e0e94cf30e7fe953691c926af6">&#9670;&nbsp;</a></span>hasBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::hasBoundary</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this simplex has any facets that lie on the triangulation boundary. </p>
<p>In other words, this routine determines whether any facet of this simplex is not currently glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this simplex has any boundary facets. </dd></dl>

</div>
</div>
<a id="ga21f8a624a104f38fc62968c7ab90a50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21f8a624a104f38fc62968c7ab90a50d">&#9670;&nbsp;</a></span>hasBoundaryFacets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::hasBoundaryFacets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this component has any boundary facets. </p>
<p>This routine returns <code>true</code> if and only if this component contains some top-dimensional simplex with at least one facet that is not glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this component has boundary facet(s). </dd></dl>

</div>
</div>
<a id="ga5ffca92f7a401c3beb7a603d997a088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ffca92f7a401c3beb7a603d997a088e">&#9670;&nbsp;</a></span>hasBoundaryFacets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::hasBoundaryFacets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation has any boundary facets. </p>
<p>This routine returns <code>true</code> if and only if the triangulation contains some top-dimension simplex with at least one facet that is not glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there are boundary facets. </dd></dl>

</div>
</div>
<a id="ga1388f2c849d9010c22e1c2b569b624de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1388f2c849d9010c22e1c2b569b624de">&#9670;&nbsp;</a></span>homology()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::homology</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group for this triangulation. </p>
<p>The homology is computed in the dual 2-skeleton. This means:</p>
<ul>
<li>If the triangulation contains any ideal vertices, the homology will be calculated as if each such vertex had been truncated.</li>
<li>Likewise, if the triangulation contains any invalid faces of dimension 0,1,...,(<em>dim</em>-3), these will effectively be truncated also.</li>
<li>In contrast, if the triangulation contains any invalid (<em>dim</em>-2)-faces (i.e., codimension-2-faces that are identified with themselves under a non-trivial map), the homology will be computed <em>without</em> truncating the centroid of the face. For instance, if a 3-manifold triangulation has an edge identified with itself in reverse, then the homology will be computed without truncating the resulting projective plane cusp. This means that, if a barycentric subdivision is performed on a such a triangulation, the result of <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">homology()</a> might change.</li>
</ul>
<p>This routine can also be accessed via the alias <a class="el" href="group__detail.html#gabec045e78809792a92042c583aac0741" title="Returns the first homology group for this triangulation.">homologyH1()</a> (a name that is more specific, but a little longer to type).</p>
<p>Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">homology()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a> then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class.) If you wish to compute homology with fillings, call <a class="el" href="group__snappea.html#ga339374d863b53b6050b0ae39b779937d" title="Returns the first homology group of the manifold with respect to the current Dehn filling (if any).">SnapPeaTriangulation::homologyFilled()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group. </dd></dl>

</div>
</div>
<a id="gabec045e78809792a92042c583aac0741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabec045e78809792a92042c583aac0741">&#9670;&nbsp;</a></span>homologyH1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::homologyH1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group for this triangulation. </p>
<p>This is identical to calling <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">homology()</a>. See the <a class="el" href="group__detail.html#ga1388f2c849d9010c22e1c2b569b624de" title="Returns the first homology group for this triangulation.">homology()</a> documentation for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group. </dd></dl>

</div>
</div>
<a id="ga33716287df00263ec10dade47146d3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33716287df00263ec10dade47146d3dd">&#9670;&nbsp;</a></span>identify()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="structregina_1_1detail_1_1BoundaryComponentCalculator.html">regina::detail::BoundaryComponentCalculator</a>&lt; dim, subdim &gt;::identify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies and marks all faces of dimension &le; <em>subdim</em> within the given boundary facet of the given <em>dim</em>-dimensional triangulation. </p>
<p>This routine pushes all such <em>subdim</em>-faces onto the relevant list for the given boundary component, and also marks the boundary component within these <em>subdim</em>-faces themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the underlying triangulation. </td></tr>
    <tr><td class="paramname">bc</td><td>the boundary component of <em>t</em> currently under construction. </td></tr>
    <tr><td class="paramname">facet</td><td>a boundary facet that belongs to <em>bc</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga87b4a13ff55946309b4969dc76183432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b4a13ff55946309b4969dc76183432">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::identity </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nSimplices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the identity isomorphism for the given number of simplices. </p>
<p>This isomorphism sends every simplex and every vertex to itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices that the new isomorphism should operate upon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identity isomorphism. </dd></dl>

</div>
</div>
<a id="ga9534baaeaff9e8f432a7e18455f3484c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9534baaeaff9e8f432a7e18455f3484c">&#9670;&nbsp;</a></span>index() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase</a>&lt; dim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this boundary component in the underlying triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of this boundary component. </dd></dl>

</div>
</div>
<a id="ga2e104f0a39be4e2167aa83588608102b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e104f0a39be4e2167aa83588608102b">&#9670;&nbsp;</a></span>index() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this component within the underlying triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of this component. </dd></dl>

</div>
</div>
<a id="gab2c029dbdfaaccfaebc6b620757e7baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2c029dbdfaaccfaebc6b620757e7baa">&#9670;&nbsp;</a></span>index() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this face within the underlying triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the index of this face. </dd></dl>

</div>
</div>
<a id="gabbf51cda05f67725962436cae590a0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf51cda05f67725962436cae590a0ff">&#9670;&nbsp;</a></span>index() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this simplex in the underlying triangulation. </p>
<p>The index will be an integer between 0 and <code><a class="el" href="group__detail.html#ga36f84802bd71d9affff8a90a6e8ea9f0" title="Returns the triangulation to which this simplex belongs.">triangulation()</a>-&gt;size()-1</code> inclusive.</p>
<p>Note that indexing may change when a simplex is added to or removed from the underlying triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the index of this simplex. </dd></dl>

</div>
</div>
<a id="ga49a3e885cec01b8c8f9f45be1b97fe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a3e885cec01b8c8f9f45be1b97fe7f">&#9670;&nbsp;</a></span>initialChars()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1XMLSimplexReader.html">regina::detail::XMLSimplexReader</a>&lt; dim &gt;::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga877ff60449a48d5a8da5b3e32bb6dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga877ff60449a48d5a8da5b3e32bb6dde2">&#9670;&nbsp;</a></span>inMaximalForest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::inMaximalForest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a codimension-1-face represents a dual edge in the maximal forest that has been chosen for the dual 1-skeleton of the triangulation. </p>
<p>This routine is only available for faces of codimension 1; that is, (<em>dim</em>-1)-faces of a <em>dim</em>-dimensional triangulation.</p>
<p>When the skeletal structure of a triangulation is first computed, a maximal forest in the dual 1-skeleton of the triangulation is also constructed. Each dual edge in this maximal forest represents a (<em>dim</em>-1)-face of the (primal) triangulation.</p>
<p>This maximal forest will remain fixed until the triangulation changes, at which point it will be recomputed (as will all other skeletal objects, such as connected components and so on). There is no guarantee that, when it is recomputed, the maximal forest will use the same dual edges as before.</p>
<p>This routine identifies whether this (<em>dim</em>-1)-face belongs to the dual forest. In this sense it performs a similar role to <a class="el" href="group__detail.html#ga9da19b23a42f47afe636a2cff5f0eee7" title="Determines whether the given facet of this simplex belongs to the maximal forest that has been chosen...">Simplex::facetInMaximalForest()</a>, but this routine is typically easier to use.</p>
<p>If the skeleton has already been computed, then this routine is very fast (since it just returns a precomputed answer).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this (<em>dim</em>-1)-face represents a dual edge in the maximal forest. </dd></dl>

</div>
</div>
<a id="gaf1e8b7cf820ff452059f817d55536155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1e8b7cf820ff452059f817d55536155">&#9670;&nbsp;</a></span>insertConstruction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::insertConstruction </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>adjacencies</em>[][dim+1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>gluings</em>[][dim+1][dim+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a given triangulation into this triangulation, where the given triangulation is described by a pair of integer arrays. </p>
<p>The main purpose of this routine is to allow users to hard-code triangulations into C++ source files. In particular, all of the simplex gluings can be hard-coded into a pair of integer arrays at the beginning of the source file, avoiding an otherwise tedious sequence of many calls to <a class="el" href="group__detail.html#gad1f0a3046ec46f13f270bbc82193c5cc" title="Joins the given facet of this simplex to some facet of another simplex.">Simplex&lt;dim&gt;::join()</a>. If you have a particular triangulation that you would like to hard-code in this way, you can call <a class="el" href="group__detail.html#gace7c9ec1168ef9e7cb34b3e4a5b9b873" title="Returns C++ code that can be used with insertConstruction() to reconstruct this triangulation.">dumpConstruction()</a> to generate the corresponding integer arrays as C++ source code.</p>
<p>This routine will insert an additional <em>nSimplices</em> top-dimensional simplices into this triangulation. We number these simplices 0,1,...,<em>nSimplices</em>-1. The gluings between these new simplices should be stored in the two arrays as follows.</p>
<p>The <em>adjacencies</em> array describes which simplices are joined to which others. Specifically, <code>adjacencies[s][f]</code> indicates which of the new simplices is joined to facet <em>f</em> of simplex <em>s</em>. This should be between 0 and <em>nSimplices</em>-1 inclusive, or -1 if facet <em>f</em> of simplex <em>s</em> is to be left as a boundary facet.</p>
<p>The <em>gluings</em> array describes the particular gluing permutations used to join these simplices together. Specifically, <code>gluings[s][f][0..<em>dim</em>]</code> should describe the permutation used to join facet <em>f</em> of simplex <em>s</em> to its adjacent simplex. These <em>dim</em>+1 integers should be 0,1,...,<em>dim</em> in some order, so that <code>gluings[s][f][i]</code> contains the image of <em>i</em> under this permutation. If facet <em>f</em> of simplex <em>s</em> is to be left as a boundary facet, then <code>gluings[s][f][0..<em>dim</em>]</code> may contain anything (and will be duly ignored).</p>
<p>If this triangulation is empty before this routine is called, then the new simplices will be given indices 0,1,...,<em>nSimplices</em>-1 according to the numbering described above. Otherwise they will be inserted after any pre-existing simplices, and so they will be given larger indices instead. In the latter case, the <em>adjacencies</em> array should still refer to the new simplices as 0,1,...,<em>nSimplices</em>-1, and this routine will handle any renumbering automatically at runtime.</p>
<p>It is the responsibility of the caller of this routine to ensure that the given arrays are correct and consistent. No error checking will be performed by this routine.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of additional simplices to insert. </td></tr>
    <tr><td class="paramname">adjacencies</td><td>describes which simplices are adjace to which others, as described above. This array must have initial dimension at least <em>nSimplices</em>. </td></tr>
    <tr><td class="paramname">gluings</td><td>describes the specific gluing permutations, as described above. This array must also have initial dimension at least <em>nSimplices</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bf93dbca6715c1a455a2d47f66a6476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bf93dbca6715c1a455a2d47f66a6476">&#9670;&nbsp;</a></span>insertTriangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::insertTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a copy of the given triangulation into this triangulation. </p>
<p>The top-dimensional simplices of <em>source</em> will be copied into this triangulation in the same order in which they appear in <em>source</em>. That is, if the original size of this triangulation was <em>S</em>, then the simplex at index <em>i</em> in <em>source</em> will be copied into this triangulation as a new simplex at index <em>S</em>+<em>i</em>.</p>
<p>The copies will use the same vertex numbering and descriptions as the original simplices from <em>source</em>, and any gluings between the simplices of <em>source</em> will likewise be copied across as gluings between their copies in this triangulation.</p>
<p>This routine behaves correctly when <em>source</em> is this triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the triangulation whose copy will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2fc849ef77244993696cbfe08083f336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fc849ef77244993696cbfe08083f336">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::isBoundary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face lies entirely on the boundary of the triangulation. </p>
<p>For dimensions in which ideal and/or invalid vertices are both possible and recognised: both ideal and invalid vertices are considered to be on the boundary.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face lies on the boundary. </dd></dl>

</div>
</div>
<a id="gad720be5515121b69f7ce62e5bbda9b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad720be5515121b69f7ce62e5bbda9b5b">&#9670;&nbsp;</a></span>isCanonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical form, i.e., is a lexicographically minimal representative of its isomorphism class. </p>
<p>Isomorphisms of facet pairings correspond to relabellings of simplices and relabellings of the (<em>dim</em> + 1) facets within each simplex.</p>
<p>Facet pairings are ordered by lexicographical comparison of <code>dest(0,0)</code>, <code>dest(0,1)</code>, ..., <code>dest(<a class="el" href="group__detail.html#ga05fd123494c0f9d15ffed9f226728b83" title="Returns the number of simplices whose facets are described by this facet pairing.">size()</a>-1,<em>dim</em>)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This facet pairing is connected, i.e., it is possible to reach any simplex from any other simplex via a series of matched facet pairs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a id="ga6b11f9aa0e0746204354dfa13e418156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b11f9aa0e0746204354dfa13e418156">&#9670;&nbsp;</a></span>isCanonicalInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isCanonicalInternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__detail.html#ga29c1d0f565e50aa76cfca68714347533">IsoList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is in canonical (smallest lexicographical) form, given a small set of assumptions. </p>
<p>If this facet pairing is in canonical form, the given list will be filled with the set of all combinatorial automorphisms of this facet pairing. If not, the given list will be left empty.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given list is empty. </dd>
<dd>
For each simplex <em>t</em>, the only case in which <code>dest(t,i)</code> is greater than <code>dest(t,i+1)</code> is where facets <code>(t,i)</code> and <code>(t,i+1)</code> are paired together. </dd>
<dd>
For each simplex <em>t</em> &gt; 0, it is true that <code>dest(t,0).simp &lt; t</code>. </dd>
<dd>
The sequence <code>dest(1,0)</code>, <code>dest(2,0)</code>, ..., <code>dest(n-1,0)</code> is strictly increasing, where <em>n</em> is the total number of simplices under investigation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the list into which automorphisms will be placed if appropriate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this facet pairing is in canonical form. </dd></dl>

</div>
</div>
<a id="ga55b81d609b3827899604f1e8a829c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b81d609b3827899604f1e8a829c884">&#9670;&nbsp;</a></span>isClosed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this facet pairing is closed. </p>
<p>A closed facet pairing has no unmatched facets. </p>

</div>
</div>
<a id="ga576e6c66cfbb7fabd21cc782c38f300d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga576e6c66cfbb7fabd21cc782c38f300d">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isConnected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is connected. </p>
<p>This routine returns <code>false</code> only if there is more than one connected component. In particular, it returns <code>true</code> for the empty triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is connected. </dd></dl>

</div>
</div>
<a id="ga61ce7adfff99f476365aa7af3a37f650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61ce7adfff99f476365aa7af3a37f650">&#9670;&nbsp;</a></span>isContainedIn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>Specifically, this routine determines if there is a boundary incomplete combinatorial isomorphism from this triangulation to <em>other</em>. Boundary incomplete isomorphisms are described in detail in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p>In particular, note that facets of top-dimensional simplices that lie on the boundary of this triangulation need not correspond to boundary facets of <em>other</em>, and that <em>other</em> may contain more top-dimensional simplices than this triangulation.</p>
<p>If a boundary incomplete isomorphism is found, the details of this isomorphism are returned. The isomorphism is newly constructed, and so to assist with memory management is returned as a std::unique_ptr. Thus, to test whether an isomorphism exists without having to explicitly deal with the isomorphism itself, you can call <code>if (isContainedIn(other).<a class="el" href="namespaceregina.html#a301c1157be3e5f4de9d93956ef1a7eb6" title="Returns the index of the given vertex of the underlying graph of a knot or link.">get()</a>)</code> and the newly created isomorphism (if it exists) will be automatically destroyed.</p>
<p>If more than one such isomorphism exists, only one will be returned. For a routine that returns all such isomorphisms, see <a class="el" href="group__detail.html#ga13bd275984bd2e6241fc220229f39490" title="Finds all ways in which an isomorphic copy of this triangulation is contained within the given triang...">findAllSubcomplexesIn()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for an isomorphic copy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if such a copy is found, or a null pointer otherwise. </dd></dl>

</div>
</div>
<a id="ga6b111a8470576f19f950a2347ff9f3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b111a8470576f19f950a2347ff9f3f5">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isEmpty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation is empty. </p>
<p>An empty triangulation is one with no simplices at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is empty. </dd></dl>

</div>
</div>
<a id="gaabbc78362654ae62c31e3a2707d131e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabbc78362654ae62c31e3a2707d131e9">&#9670;&nbsp;</a></span>isIdeal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is ideal. </p>
<p>This is the case if and only if it consists of a single ideal vertex and no faces of any other dimensions.</p>
<p>See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for an overview of ideal boundary components, which can only occur in dimensions &ge; 3, and which are only recognised where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>Note that a boundary component formed from a single <em>invalid</em> vertex is <em>not</em> considered to be ideal. This means that, if a boundary component contains no faces of positive dimension, then one and only one of <a class="el" href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9" title="Determines if this boundary component is ideal.">isIdeal()</a> and <a class="el" href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d" title="Determines if this boundary component consists of a single invalid vertex and nothing else.">isInvalidVertex()</a> will return <code>true</code>.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is ideal. </dd></dl>

</div>
</div>
<a id="ga46646fc0c55c3bdd6fe280fb72294534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46646fc0c55c3bdd6fe280fb72294534">&#9670;&nbsp;</a></span>isIdenticalTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isIdenticalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially identical to the given triangulation. </p>
<p>Here "identical" means that the triangulations have the same number of top-dimensional simplices, with gluings between the same pairs of numbered simplices using the same gluing permutations. In other words, "identical" means that the triangulations are isomorphic via the identity isomorphism.</p>
<p>For the less strict notion of <em>isomorphic</em> triangulations, which allows relabelling of the top-dimensional simplices and their vertices, see <a class="el" href="group__detail.html#gaf68572c80fc27fc3a069ad01d9615952" title="Determines if this triangulation is combinatorially isomorphic to the given triangulation.">isIsomorphicTo()</a> instead.</p>
<p>This test does <em>not</em> examine the textual simplex descriptions, as seen in <a class="el" href="group__detail.html#ga00178392c44456529f5250de6bc448ef" title="Returns the description associated with this simplex.">Simplex&lt;dim&gt;::description()</a>; these may still differ. It also does not test whether lower-dimensional faces are numbered identically (vertices, edges and so on); this routine is only concerned with top-dimensional simplices.</p>
<p>(At the time of writing, two identical triangulations will always number their lower-dimensional faces in the same way. However, it is conceivable that in future versions of Regina there may be situations in which identical triangulations can acquire different numberings for vertices, edges, and so on.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangulations are combinatorially identical. </dd></dl>

</div>
</div>
<a id="gaa52235513aeff37221ee92a654397e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52235513aeff37221ee92a654397e32">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::isIdentity</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not this is an identity isomorphism. </p>
<p>In an identity isomorphism, each simplex image is itself, and within each simplex the facet/vertex permutation is the identity permutation.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an identity isomorphism, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab697465cdf1282c9ae1e4ed54b9d359d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab697465cdf1282c9ae1e4ed54b9d359d">&#9670;&nbsp;</a></span>isInvalidVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::isInvalidVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component consists of a single invalid vertex and nothing else. </p>
<p>In particular, such a boundary component must contain no faces of any positive dimension.</p>
<p>See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for an overview of invalid vertex boundary components, which can only occur in dimensions &ge; 4, and which are only recognised where <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>An invalid vertex is only placed in its own boundary component if it does not already belong to some larger boundary component (for instance, if its link is an ideal (<em>dim</em>-1)-manifold triangulation). This means that, for a boundary component consisting of one or more (<em>dim</em>-1)-faces, this routine will return <code>false</code> even if the boundary component also includes one or more invalid vertices.</p>
<p>Note that, if a boundary component contains no faces of positive dimension, then one and only one of <a class="el" href="group__detail.html#gaabbc78362654ae62c31e3a2707d131e9" title="Determines if this boundary component is ideal.">isIdeal()</a> and <a class="el" href="group__detail.html#gab697465cdf1282c9ae1e4ed54b9d359d" title="Determines if this boundary component consists of a single invalid vertex and nothing else.">isInvalidVertex()</a> will return <code>true</code>.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component consists of a single invalid vertex and nothing else. </dd></dl>

</div>
</div>
<a id="gaf68572c80fc27fc3a069ad01d9615952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf68572c80fc27fc3a069ad01d9615952">&#9670;&nbsp;</a></span>isIsomorphicTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>Two triangulations are <em>isomorphic</em> if and only it is possible to relabel their top-dimensional simplices and the (<em>dim</em>+1) vertices of each simplex in a way that makes the two triangulations combinatorially identical, as returned by <a class="el" href="group__detail.html#ga46646fc0c55c3bdd6fe280fb72294534" title="Determines if this triangulation is combinatorially identical to the given triangulation.">isIdenticalTo()</a>.</p>
<p>Equivalently, two triangulations are isomorphic if and only if there is a one-to-one and onto boundary complete combinatorial isomorphism from this triangulation to <em>other</em>, as described in the <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> class notes.</p>
<p>In particular, note that this triangulation and <em>other</em> must contain the same number of top-dimensional simplices for such an isomorphism to exist.</p>
<p>If the triangulations are isomorphic, then this routine returns one such boundary complete isomorphism (i.e., one such relabelling). The isomorphism will be newly constructed, and to assist with memory management, it will be returned as a std::unique_ptr. Thus, to test whether an isomorphism exists without having to explicitly manage with the isomorphism itself, you can just call <code>if (isIsomorphicTo(other).<a class="el" href="namespaceregina.html#a301c1157be3e5f4de9d93956ef1a7eb6" title="Returns the index of the given vertex of the underlying graph of a knot or link.">get()</a>)</code>, in which case the newly created isomorphism (if it exists) will be automatically destroyed.</p>
<p>There may be many such isomorphisms between the two triangulations. If you need to find <em>all</em> such isomorphisms, you may call <a class="el" href="group__detail.html#ga6f6909b62bdeb58b6b0f4a43646fa0f7" title="Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.">findAllIsomorphisms()</a> instead.</p>
<p>If you need to ensure that top-dimensional simplices are labelled the same in both triangulations (i.e., that the triangulations are related by the <em>identity</em> isomorphism), you should call the stricter test <a class="el" href="group__detail.html#ga46646fc0c55c3bdd6fe280fb72294534" title="Determines if this triangulation is combinatorially identical to the given triangulation.">isIdenticalTo()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000049">Todo:</a></b></dt><dd><em>Optimise:</em> Improve the complexity by choosing a simplex mapping from each component and following gluings to determine the others.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if the two triangulations are combinatorially isomorphic, or a null pointer otherwise. </dd></dl>

</div>
</div>
<a id="gad2c5d71573616354c885ac7250568d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2c5d71573616354c885ac7250568d8d">&#9670;&nbsp;</a></span>isLinkOrientable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsNonorientable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability</a>&lt; allowsNonorientable &gt;::isLinkOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the link of this face is orientable. </p>
<p>This routine is fast: it uses pre-computed information, and does not need to build a full triangulation of the link.</p>
<dl class="section warning"><dt>Warning</dt><dd>If this face is identified with itself under a non-identity permutation (which makes the face invalid), then the return value of this routine is undefined.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the link is orientable. </dd></dl>

</div>
</div>
<a id="gac7234fa2254e5ae60efd4786359edee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7234fa2254e5ae60efd4786359edee9">&#9670;&nbsp;</a></span>isLinkOrientable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability</a>&lt; false &gt;::isLinkOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the link of this face is orientable. </p>
<p>This routine always returns <code>true</code>, since this specialisation of <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html" title="Helper class that stores whether the link of a face is orientable.">FaceOrientability</a> is for dimensions in which links of faces are always orientable.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>. </dd></dl>

</div>
</div>
<a id="ga0df524a7bf262cb0c43ec9d7c39b7687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0df524a7bf262cb0c43ec9d7c39b7687">&#9670;&nbsp;</a></span>isolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::isolate</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unglues this simplex from any adjacent simplices. </p>
<p>As a result, every facet of this simplex will become a boundary facet, and this simplex will form its own separate component of the underlying triangulation.</p>
<p>If there were any adjacent simplices to begin with, these will be updated automatically.</p>
<p>This routine is safe to call even if there are no adjacent simplices (in which case it will do nothing). </p>

</div>
</div>
<a id="gabe8318824f0b86102a8608194a2d9e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8318824f0b86102a8608194a2d9e8c">&#9670;&nbsp;</a></span>IsomorphismBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given isomorphism. </p>
<p>This constructor induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f702a81c31e4a4af8a88ab6181267e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f702a81c31e4a4af8a88ab6181267e3">&#9670;&nbsp;</a></span>IsomorphismBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given isomorphism into this new isomorphism. </p>
<p>This is a fast (constant time) operation.</p>
<p>The isomorphism that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ea3d56e931eb3175f3929bd8d463dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ea3d56e931eb3175f3929bd8d463dec">&#9670;&nbsp;</a></span>IsomorphismBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nSimplices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new isomorphism with no initialisation. </p>
<p>The images of the simplices and their vertices must be explicitly set using <a class="el" href="group__detail.html#gacc12157b7e664b84894574e149ee1023" title="Determines the image of the given source simplex under this isomorphism.">simpImage()</a> and <a class="el" href="group__detail.html#gaeb0ad0ed6aad84455848858b1df4c682" title="Returns a read-write reference to the permutation that is applied to the (dim + 1) facets of the give...">facetPerm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices in the source triangulation associated with this isomorphism. This is allowed to be zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga167bb8084a603316a0229b915b0f221a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167bb8084a603316a0229b915b0f221a">&#9670;&nbsp;</a></span>isOrientable() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase</a>&lt; dim &gt;::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is orientable. </p>
<p>If this is an ideal or invalid vertex boundary component, then the orientability of the corresponding vertex link is returned.</p>
<p>This routine is fast; in particular, it is pre-computed and does not build a full triangulation of the boundary component.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is orientable. </dd></dl>

</div>
</div>
<a id="gaa1f3ecb5b025c49bc95097e9fa8577ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1f3ecb5b025c49bc95097e9fa8577ec">&#9670;&nbsp;</a></span>isOrientable() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::isOrientable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this component is orientable. </p>
<p>This routine runs in constant time (since orientability is determined in advance, when the component is first created).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this component is orientable. </dd></dl>

</div>
</div>
<a id="ga6223875697502990070b0e7587f63ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6223875697502990070b0e7587f63ce7">&#9670;&nbsp;</a></span>isOrientable() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOrientable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is orientable. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is orientable. </dd></dl>

</div>
</div>
<a id="gab712e58bba1242110e49b2fac979e98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab712e58bba1242110e49b2fac979e98f">&#9670;&nbsp;</a></span>isOriented()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isOriented</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets. </p>
<p>Specifically, this routine returns <code>true</code> if and only if every gluing permutation has negative sign.</p>
<p>Note that <em>orientable</em> triangulations are not always <em>oriented</em> by default. You can call <a class="el" href="group__detail.html#ga2711fd7c7115ce19b6833f0d61c42bec" title="Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are or...">orient()</a> if you need the top-dimensional simplices to be oriented consistently as described above.</p>
<p>A non-orientable triangulation can never be oriented.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all top-dimensional simplices are oriented consistently.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a id="ga4f5592a00cb4a895564e5b8169850879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f5592a00cb4a895564e5b8169850879">&#9670;&nbsp;</a></span>isoSig()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; **&#160;</td>
          <td class="paramname"><em>relabelling</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the isomorphism signature for this triangulation. </p>
<p>An <em>isomorphism signature</em> is a compact text representation of a triangulation that uniquely determines the triangulation up to combinatorial isomorphism. That is, two triangulations of dimension <em>dim</em> are combinatorially isomorphic if and only if their isomorphism signatures are the same.</p>
<p>The isomorphism signature is constructed entirely of printable characters, and has length proportional to <code>n log n</code>, where <em>n</em> is the number of top-dimenisonal simplices.</p>
<p>Whilst the format of an isomorphism signature bears some similarity to dehydration strings for 3-manifolds, they are more general: isomorphism signatures can be used with any triangulations, including closed, bounded and/or disconnected triangulations, as well as triangulations with many simplices. Note also that 3-manifold dehydration strings are not unique up to isomorphism (they depend on the particular labelling of tetrahedra).</p>
<p>The time required to construct the isomorphism signature of a triangulation is <code>O((dim!) n^2 log^2 n)</code>. Whilst this is fine for large triangulation, it will be extremly slow for large <em>dimensions</em>.</p>
<p>The routine <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> can be used to recover a triangulation from an isomorphism signature. The triangulation recovered might not be identical to the original, but it will be combinatorially isomorphic.</p>
<p>If <em>relabelling</em> is non-null (i.e., it points to some <a class="el" href="classregina_1_1Isomorphism.html" title="Represents a combinatorial isomorphism from one dim-manifold triangulation into another.">Isomorphism</a> pointer <em>p</em>), then it will be modified to point to a new isomorphism that describes the precise relationship between this triangulation and the reconstruction from <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>. Specifically, the triangulation that is reconstructed from <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> will be combinatorially identical to <code>relabelling.apply(this)</code>.</p>
<p>For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section user"><dt>Python</dt><dd>The isomorphism argument is not present. Instead there are two routines: <a class="el" href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a>, which returns a string only, and isoSigDetail(), which returns a pair (<em>signature</em>, <em>relabelling</em>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>relabelling</em> is non-null, then this triangulation must be non-empty and connected. The facility to return a relabelling for disconnected triangulations may be added to Regina in a later release.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relabelling</td><td>if this is non-null, it will be modified to point to a new isomorphism that describes the relationship between this triangulation and the triangulation that will be reconstructed from <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism signature of this triangulation. </dd></dl>

</div>
</div>
<a id="ga0eedc0b1fc037af0d9c6c23c32d79f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eedc0b1fc037af0d9c6c23c32d79f2b">&#9670;&nbsp;</a></span>isoSigComponentSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isoSigComponentSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature. </p>
<p>See <a class="el" href="group__detail.html#ga4f5592a00cb4a895564e5b8169850879" title="Constructs the isomorphism signature for this triangulation.">isoSig()</a> for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>If the signature describes a connected triangulation, this routine will simply return the size of that triangulation (e.g., the number of tetrahedra in the case <em>dim</em> = 3). You can also pass an isomorphism signature that describes a disconnected triangulation; however, this routine will only return the number of top-dimensional simplices in the first connected component. If you need the total size of a disconnected triangulation, you will need to reconstruct the full triangulation by calling <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead.</p>
<p>This routine is very fast, since it only examines the first few characters of the isomorphism signature (in which the size of the first component is encoded). However, a side-effect of this is that it is possible to pass an <em>invalid</em> isomorphism signature and still receive a positive result. If you need to test whether a signature is valid or not, you must call <a class="el" href="group__detail.html#gac7a5a9449f2de027e0cae40ff8a3ee38" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a> instead, which will examine the entire signature in full.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of a <em>dim</em>-dimensional triangulation. Note that isomorphism signature are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of top-dimensional simplices in the first connected component, or 0 if this could not be determined because the given string was not a valid isomorphism signature. </dd></dl>

</div>
</div>
<a id="ga61771dae69054fc0c9bb42a5966916de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61771dae69054fc0c9bb42a5966916de">&#9670;&nbsp;</a></span>isReal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::isReal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this boundary component is real. </p>
<p>This is the case if and only if it is formed from one or more (dim-1)-faces.</p>
<p>See the <a class="el" href="classregina_1_1BoundaryComponent.html" title="A component of the boundary of a dim-manifold triangulation.">BoundaryComponent</a> class notes for an overview of real, ideal, and invalid vertex boundary components.</p>
<p>This routine is only available where <em>dim</em> is at least 3 and is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>. (In other dimensions, real boundary components are the only types of boundary component that Regina will recognise.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this boundary component is real. </dd></dl>

</div>
</div>
<a id="ga86c56d584b417d3fb51507fb92809721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86c56d584b417d3fb51507fb92809721">&#9670;&nbsp;</a></span>isUnmatched() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a id="gaed7d81f46e1382e0ab6937f410f6b230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed7d81f46e1382e0ab6937f410f6b230">&#9670;&nbsp;</a></span>isUnmatched() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::isUnmatched </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given simplex facet has been left deliberately unmatched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given facet has been left unmatched, or <code>false</code> if the given facet is paired with some other facet. </dd></dl>

</div>
</div>
<a id="gaa6ddae9a9706553c8aaaed1cebb220e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6ddae9a9706553c8aaaed1cebb220e1">&#9670;&nbsp;</a></span>isValid() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::isValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this component is valid. </p>
<p>This uses the same criteria as <a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">Triangulation&lt;dim&gt;::isValid()</a>; see the <a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">Triangulation&lt;dim&gt;::isValid()</a> documentation for details.</p>
<p>As with Triangulation&lt;dim&gt;, this tests for bad self-identifications in all dimensions, but only tests for bad links in Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this component is valid. </dd></dl>

</div>
</div>
<a id="gae19f45c3ec59aa252e78ec4e13963c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae19f45c3ec59aa252e78ec4e13963c54">&#9670;&nbsp;</a></span>isValid() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsInvalid, bool testLinks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this face is valid. </p>
<p>There are several conditions that might make a <em>subdim</em>-face of a <em>dim</em>-dimensional triangulation invalid:</p>
<ol type="1">
<li>if the face is identified with itself under a non-identity permutation (e.g., an edge is identified with itself in reverse, or a triangle is identified with itself under a rotation);</li>
<li>if the face does not have an appropriate link. Here the meaning of "appropriate" depends upon the type of face:<ul>
<li>for a face that belongs to some boundary facet(s) of the triangulation, its link must be a topological ball;</li>
<li>for a vertex that does not belong to any boundary facets, its link must be a closed (<em>dim</em> - 1)-manifold;</li>
<li>for a (<em>subdim</em> &ge; 1)-face that does not belong to any boundary facets, its link must be a topological sphere.</li>
</ul>
</li>
</ol>
<p>Condition (1) is tested for all dimensions <em>subdim</em> and <em>dim</em>. Condition (2) is more difficult, since it relies on undecidable problems. As a result, (2) is <em>only</em> tested when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>If this face is invalid, then it is possible to find out why. In non-standard dimensions, this must mean that the face fails condition (1) above. In standard dimensions, you can call the functions <a class="el" href="group__detail.html#ga72c0522efd2a0b8df7b632ad82b36760" title="Determines if this face is identified with itself under a non-identity permutation.">hasBadIdentification()</a> and/or <a class="el" href="group__detail.html#gaab16c59e486f840192f63a4268f53b3d" title="Determines if this face does not have an appropriate link.">hasBadLink()</a> to determine whether the failure is due to conditions (1) or (2) respectively.</p>
<dl class="section return"><dt>Returns</dt><dd>for standard dimensions <em>dim</em>, returns <code>true</code> if and only if this face is valid according to both conditions (1) and (2) above; for non-standard dimensions <em>dim</em>, returns <code>true</code> if and only if this face is valid according to condition (1). </dd></dl>

</div>
</div>
<a id="ga52dbb2e405ff3e7ab5b804a8b6463bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52dbb2e405ff3e7ab5b804a8b6463bbd">&#9670;&nbsp;</a></span>isValid() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool testLinks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; false, testLinks &gt;::isValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Always returns <code>true</code>. </p>
<p>In general, this routine determines whether a face is valid. However, this particular class is used for dimensions in which faces are always valid, and so this routine returns <code>true</code> always.</p>
<p>See <a class="el" href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54" title="Determines if this face is valid.">FaceValidity&lt;true, true&gt;::isValid()</a> for a general discussion on what it means for a face to be valid.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code>. </dd></dl>

</div>
</div>
<a id="ga3af63adfc417388aa6b68c0fea7f8086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3af63adfc417388aa6b68c0fea7f8086">&#9670;&nbsp;</a></span>isValid() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; true, false &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this face is valid. </p>
<p>This class is used for <a class="el" href="stddim.html">non-standard dimensions</a>, where a face is defined to be valid if and only if it is not identified with itself under a non-identity permutation. For example, an edge is valid if and only if it is not identified with itself in reverse, and a triangle is valid if and only if it is is not identified with itself under a non-trivial rotation or reflection.</p>
<p>Note that the definition of validity is richer in Regina's standard dimensions, where we also consider the topology of the link of a face. See FaceValidity&lt;true, true&gt; for a full discussion of what it means for a face to be valid, and how this differs between standard and non-standard dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this face is not identified with itself under a non-identity permutation. </dd></dl>

</div>
</div>
<a id="gab6cf08805f1b496f644e75c1a0b34dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6cf08805f1b496f644e75c1a0b34dde">&#9670;&nbsp;</a></span>isValid() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::isValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is valid. </p>
<p>There are several conditions that might make a <em>dim</em>-dimensional triangulation invalid:</p>
<ol type="1">
<li>if some face is identified with itself under a non-identity permutation (e.g., an edge is identified with itself in reverse, or a triangle is identified with itself under a rotation);</li>
<li>if some <em>subdim</em>-face does not have an appropriate link. Here the meaning of "appropriate" depends upon the type of face:<ul>
<li>for a face that belongs to some boundary facet(s) of this triangulation, its link must be a topological ball;</li>
<li>for a vertex that does not belong to any boundary facets, its link must be a closed (<em>dim</em> - 1)-manifold;</li>
<li>for a (<em>subdim</em> &ge; 1)-face that does not belong to any boundary facets, its link must be a topological sphere.</li>
</ul>
</li>
</ol>
<p>Condition (1) is tested for all dimensions <em>dim</em>. Condition (2) is more difficult, since it relies on undecidable problems. As a result, (2) is <em>only</em> tested when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>If a triangulation is invalid then you can call <a class="el" href="group__detail.html#gae19f45c3ec59aa252e78ec4e13963c54" title="Determines if this face is valid.">Face&lt;dim, subdim&gt;::isValid()</a> to discover exactly which face(s) are responsible, and you can call <a class="el" href="group__detail.html#ga72c0522efd2a0b8df7b632ad82b36760" title="Determines if this face is identified with itself under a non-identity permutation.">Face&lt;dim, subdim&gt;::hasBadIdentification()</a> and/or <a class="el" href="group__detail.html#gaab16c59e486f840192f63a4268f53b3d" title="Determines if this face does not have an appropriate link.">Face&lt;dim, subdim&gt;::hasBadLink()</a> to discover exactly which conditions fail.</p>
<p>Note that all invalid vertices are considered to be on the boundary; see isBoundary() for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is valid. </dd></dl>

</div>
</div>
<a id="gad1f0a3046ec46f13f270bbc82193c5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f0a3046ec46f13f270bbc82193c5cc">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::join </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myFacet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>you</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins the given facet of this simplex to some facet of another simplex. </p>
<p>The other simplex will be updated automatically (i.e., you only need to call <a class="el" href="group__detail.html#gad1f0a3046ec46f13f270bbc82193c5cc" title="Joins the given facet of this simplex to some facet of another simplex.">join()</a> from one side of the gluing).</p>
<p>You may join a facet of this simplex to some different facet of the same simplex (i.e., you may pass <em>you</em> == <code>this</code>), though you cannot join a facet to itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given simplex belong to the same triangulation. </dd>
<dd>
The given facet of this simplex is not currently glued to anything. </dd>
<dd>
The corresponding facet of the other simplex (i.e., facet <em>gluing</em>[<em>myFacet</em>] of <em>you</em>) is likewise not currently glued to anything. </dd>
<dd>
We are not attempting to glue a facet to itself (i.e., we do not have both <em>you</em> == <code>this</code> and <em>gluing</em>[<em>myFacet</em>] == <em>myFacet</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myFacet</td><td>the facet of this simplex that will be glued to the given simplex <em>you</em>. This facet number must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">you</td><td>the other simplex that will be glued to the given facet of this simplex. </td></tr>
    <tr><td class="paramname">gluing</td><td>a permutation that describes how the vertices of this simplex will map to the vertices of <em>you</em> across the new gluing. This permutation should be in the form described by <a class="el" href="group__detail.html#ga39ac592b6db07dba1487e054be273799" title="Returns a permutation that indicates precisely how this simplex is glued to the adjacent simplex acro...">adjacentGluing()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe58df75da67242635ddcea5398d1b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe58df75da67242635ddcea5398d1b77">&#9670;&nbsp;</a></span>makeCanonical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form. </p>
<p>This is essentially the lexicographically smallest labelling when the facet gluings are written out in order.</p>
<p>Two triangulations are isomorphic if and only if their canonical forms are identical.</p>
<p>The lexicographic ordering assumes that the facet gluings are written in order of simplex index and then facet number. Each gluing is written as the destination simplex index followed by the gluing permutation (which in turn is written as the images of 0,1,...,<em>dim</em> in order).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This routine currently works only when the triangulation is connected. It may be extended to work with disconnected triangulations in later versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if the triangulation was in canonical form to begin with. </dd></dl>

</div>
</div>
<a id="gae061e36e8ecbfa2f1edc36ed9eb99a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae061e36e8ecbfa2f1edc36ed9eb99a51">&#9670;&nbsp;</a></span>makeDoubleCover()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::makeDoubleCover</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this triangulation into its double cover. </p>
<p>Each orientable component will be duplicated, and each non-orientable component will be converted into its orientable double cover. </p>

</div>
</div>
<a id="ga8a26ac5852aa92757743c04baca2e319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a26ac5852aa92757743c04baca2e319">&#9670;&nbsp;</a></span>markBadIdentification() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsInvalid, bool testLinks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::markBadIdentification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this face as having a non-identity self-identification. </p>

</div>
</div>
<a id="ga845da3689d775f5d980edbcee918f13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga845da3689d775f5d980edbcee918f13a">&#9670;&nbsp;</a></span>markBadIdentification() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool testLinks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; false, testLinks &gt;::markBadIdentification</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this face as having a non-identity self-identification. </p>
<p>This routine should never be called, since this specialisation of <a class="el" href="classregina_1_1detail_1_1FaceValidity.html" title="Helper class that stores whether a face is valid.">FaceValidity</a> is for dimensions in which faces are always valid.</p>
<p>It is provided to support dimension-agnostic code, but its implementation does nothing. </p>

</div>
</div>
<a id="ga136c6a0bffab85d8fed3eab6cd6fb23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga136c6a0bffab85d8fed3eab6cd6fb23f">&#9670;&nbsp;</a></span>markBadIdentification() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; true, false &gt;::markBadIdentification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this face as having a non-identity self-identification. </p>

</div>
</div>
<a id="ga7cefa7ced48da051d277243cba998d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cefa7ced48da051d277243cba998d6f">&#9670;&nbsp;</a></span>markBadLink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsInvalid, bool testLinks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; allowsInvalid, testLinks &gt;::markBadLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this face as having a bad link. </p>

</div>
</div>
<a id="ga9d351a6e3d1409a6a61c2dd8c0c3331e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d351a6e3d1409a6a61c2dd8c0c3331e">&#9670;&nbsp;</a></span>markBadLink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool testLinks&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceValidity.html">regina::detail::FaceValidity</a>&lt; false, testLinks &gt;::markBadLink</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks this face as having a bad link. </p>
<p>This routine should never be called, since this specialisation of <a class="el" href="classregina_1_1detail_1_1FaceValidity.html" title="Helper class that stores whether a face is valid.">FaceValidity</a> is for dimensions in which faces are always valid.</p>
<p>It is provided to support dimension-agnostic code, but its implementation does nothing. </p>

</div>
</div>
<a id="ga3f328344dd6d04f49de244edda465b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f328344dd6d04f49de244edda465b15">&#9670;&nbsp;</a></span>markLinkNonorientable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool allowsNonorientable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability</a>&lt; allowsNonorientable &gt;::markLinkNonorientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the link of this face as non-orientable. </p>

</div>
</div>
<a id="ga48972219692f228981f9409240c68032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48972219692f228981f9409240c68032">&#9670;&nbsp;</a></span>markLinkNonorientable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html">regina::detail::FaceOrientability</a>&lt; false &gt;::markLinkNonorientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the link of this face as non-orientable. </p>
<p>This routine should never be called, since this specialisation of <a class="el" href="classregina_1_1detail_1_1FaceOrientability.html" title="Helper class that stores whether the link of a face is orientable.">FaceOrientability</a> is for dimensions in which links of faces are always orientable.</p>
<p>It is provided to support dimension-agnostic code, but its implementation does nothing. </p>

</div>
</div>
<a id="gae3fa3daf9672da64a0fa8a82a439d65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3fa3daf9672da64a0fa8a82a439d65b">&#9670;&nbsp;</a></span>moveContentsTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::moveContentsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents. </p>
<p>All top-dimensional simplices that currently belong to <em>dest</em> will remain there (and will keep the same indices in <em>dest</em>). All top-dimensional simplices that belong to this triangulation will be moved into <em>dest</em> also (but in general their indices will change).</p>
<p>This triangulation will become empty as a result.</p>
<p>Any pointers or references to Simplex&lt;dim&gt; objects will remain valid.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> is not this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the triangulation into which simplices should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad107a418e2691dc5ad7bb9e90dcba437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad107a418e2691dc5ad7bb9e90dcba437">&#9670;&nbsp;</a></span>newSimplex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex and adds it to this triangulation. </p>
<p>The new simplex will have an empty description. All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a id="ga829224a264241e43a8f2bbdf5bfcb253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829224a264241e43a8f2bbdf5bfcb253">&#9670;&nbsp;</a></span>newSimplex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex with the given description and adds it to this triangulation. </p>
<p>All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>Descriptions are optional, may have any format, and may be empty. How descriptions are used is entirely up to the user.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the description to give to the new simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a id="gad11c57ad6815d5771c941ec03eeb326d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad11c57ad6815d5771c941ec03eeb326d">&#9670;&nbsp;</a></span>noDest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p>This is signalled by a facet matched to itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga8bccd3160594ba66ba13edd3735e664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bccd3160594ba66ba13edd3735e664b">&#9670;&nbsp;</a></span>noDest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::noDest </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the matching for the given simplex facet has not yet been determined. </p>
<p>This is signalled by a facet matched to itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the matching for the given facet has not yet been determined, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga3a5f8e8cfeb79462952c899aff13ce92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a5f8e8cfeb79462952c899aff13ce92">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given object are different. </p>
<p>Here "different" means that they do not refer to the same face of the same top-dimensional simplex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the object to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both object are identical. </dd></dl>

</div>
</div>
<a id="gaf0ecdb62dde9a1bd5861d79f15d3a358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ecdb62dde9a1bd5861d79f15d3a358">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const ReorderIterator&lt; tridim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator point to different faces. </p>

</div>
</div>
<a id="gace94139db834bccc3cf6f2a130d90eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace94139db834bccc3cf6f2a130d90eda">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;tridim, subdim&gt;* <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the face of the other triangulation <em>tri</em> that corresponds to the current face in this list. </p>
<p>See the iterator class notes for details. </p>

</div>
</div>
<a id="gae8c2a5c430c3de279cc04cbb49a34027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8c2a5c430c3de279cc04cbb49a34027">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReorderIterator&amp; <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator that steps to the next face in this list. </p>

</div>
</div>
<a id="ga5c3675bcbdd1e3d45e00e488dca5cd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c3675bcbdd1e3d45e00e488dca5cd10">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReorderIterator <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator that steps to the next face in this list. </p>

</div>
</div>
<a id="ga31021256121d39fdbf952fc9f8a283a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31021256121d39fdbf952fc9f8a283a1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a>&amp; <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this a copy of the given object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga506a621286cfaa5ce6ec3bd528711eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga506a621286cfaa5ce6ec3bd528711eac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the given isomorphism into this isomorphism. </p>
<p>It does not matter if this and the given isomorphism use different numbers of simplices; if they do then this isomorphism will be resized as a result.</p>
<p>This operator induces a deep copy of <em>src</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this isomorphism. </dd></dl>

</div>
</div>
<a id="ga3c11cfec38b2c8329f7a8bda7700c17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c11cfec38b2c8329f7a8bda7700c17c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReorderIterator&amp; <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const ReorderIterator&lt; tridim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a id="ga16c95c5faac35d2deed02a9df25615df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16c95c5faac35d2deed02a9df25615df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a>&lt; dim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the given isomorphism into this isomorphism. </p>
<p>This is a fast (constant time) operation.</p>
<p>It does not matter if this and the given isomorphism use different numbers of simplices; if they do then this isomorphism will be resized as a result.</p>
<p>The isomorphism that is passed (<em>src</em>) will no longer be usable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the isomorphism to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this isomorphism. </dd></dl>

</div>
</div>
<a id="ga02216faf02338c813e0e2da00d64860b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02216faf02338c813e0e2da00d64860b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">FaceEmbeddingBase</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given object are identical. </p>
<p>Here "identical" means that they refer to the same face of the same top-dimensional simplex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the object to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both object are identical. </dd></dl>

</div>
</div>
<a id="gae059e8a5184cfa1191e3866f76d8216f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae059e8a5184cfa1191e3866f76d8216f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const ReorderIterator&lt; tridim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator point to the same face. </p>

</div>
</div>
<a id="gab74fc68b1801eae6f8a62220accb4c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab74fc68b1801eae6f8a62220accb4c72">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>This is a convenience operator whose behaviour is identical to that of <a class="el" href="group__detail.html#ga6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="ga012c646f9f7388f3f4379f2f3281ed69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga012c646f9f7388f3f4379f2f3281ed69">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp; <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the other facet to which the given simplex facet is paired. </p>
<p>This is a convenience operator whose behaviour is identical to that of <a class="el" href="group__detail.html#ga6beef317a48670f0a4b015b6a9677c62" title="Returns the other facet to which the given simplex facet is paired.">dest(const FacetSpec&lt;dim&gt;&amp;)</a>.</p>
<p>If the given facet is left deliberately unmatched, the value returned will be boundary (as returned by <a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other facet to which the given facet is paired. </dd></dl>

</div>
</div>
<a id="gadeeddeeed72ee738b58dea71c0e056fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeeddeeed72ee738b58dea71c0e056fb">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex facet under this isomorphism. </p>
<p>This operator returns by value: it cannot be used to alter the isomorphism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the given source simplex facet; this must be one of the (<em>dim</em> + 1) facets of one of the <a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a> simplices in the source triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image of the source simplex facet under this isomorphism. </dd></dl>

</div>
</div>
<a id="ga317bc3a01d0543daddb4c00ab4d27d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga317bc3a01d0543daddb4c00ab4d27d5b">&#9670;&nbsp;</a></span>ordering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim + 1&gt; <a class="el" href="classregina_1_1detail_1_1FaceNumberingAPI.html">regina::detail::FaceNumberingAPI</a>&lt; dim, subdim &gt;::ordering </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a <em>subdim</em>-face number within a <em>dim</em>-dimensional simplex, returns the corresponding canonical ordering of the simplex vertices. </p>
<p>If this canonical ordering is <em>c</em>, then <em>c</em>[0,...,<em>subdim</em>] will be the vertices of the given face in increasing numerical order. That is, <em>c</em>[0] &lt; ... &lt; <em>c</em>[<em>subdim</em>]. The remaining images <em>c</em>[(<em>subdim</em> + 1),...,<em>dim</em>] will be ordered arbitrarily.</p>
<p>Note that this is <em>not</em> the same permutation as returned by <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3" title="Refers to a top-dimensional simplex in a dim-dimensional triangulation.">Simplex&lt;dim&gt;::faceMapping&lt;subdim&gt;()</a>:</p>
<ul>
<li><a class="el" href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">ordering()</a> is a static function, which returns the same permutation for the same face number, regardless of which <em>dim</em>-simplex we are looking at. The images of 0,...,<em>subdim</em> will always appear in increasing order, and the images of (<em>subdim</em> + 1),...,<em>dim</em> will be arbitrary.</li>
<li>faceMapping() examines the underlying face <em>F</em> of the triangulation and, across all appearances of <em>F</em> in different <em>dim</em>-simplices: (i) chooses the images of 0,...,<em>subdim</em> to map to the same respective vertices of <em>F</em>; and (ii) chooses the images of (<em>subdim</em> + 1),...,<em>dim</em> to maintain a "consistent
  orientation" constraint.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>identifies which <em>subdim</em>-face of a <em>dim</em>-dimensional simplex to query. This must be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding canonical ordering of the simplex vertices. </dd></dl>

</div>
</div>
<a id="ga2711fd7c7115ce19b6833f0d61c42bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2711fd7c7115ce19b6833f0d61c42bec">&#9670;&nbsp;</a></span>orient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::orient</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible. </p>
<p>This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of each top-dimensional simplices that has negative orientation. The result will be a triangulation where the top-dimensional simplices have their vertices labelled in a way that preserves orientation across adjacent facets. In particular, every gluing permutation will have negative sign.</p>
<p>If this triangulation includes both orientable and non-orientable components, the orientable components will be oriented as described above and the non-orientable components will be left untouched. </p>

</div>
</div>
<a id="gaa0d5105d19509368d155e9f8c497f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0d5105d19509368d155e9f8c497f5e4">&#9670;&nbsp;</a></span>orientation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::orientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the orientation of this simplex in the <em>dim</em>-dimensional triangulation. </p>
<p>The orientation of each top-dimensional simplex is always +1 or -1. In an orientable component of a triangulation, adjacent simplices have the same orientations if one could be transposed onto the other without reflection, and they have opposite orientations if a reflection would be required. In a non-orientable component, orientations are arbitrary (but they will still all be +1 or -1).</p>
<dl class="section return"><dt>Returns</dt><dd>+1 or -1 according to the orientation of this triangle. </dd></dl>

</div>
</div>
<a id="ga39dc5df8252f6e34ea45b19ca33c3964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39dc5df8252f6e34ea45b19ca33c3964">&#9670;&nbsp;</a></span>pachner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::pachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a (<em>dim</em> + 1 - <em>k</em>)-(<em>k</em> + 1) Pachner move about the given <em>k</em>-face. </p>
<p>This involves replacing the (<em>dim</em> + 1 - <em>k</em>) top-dimensional simplices meeting that <em>k</em>-face with (<em>k</em> + 1) new top-dimensional simplices joined along a new internal (<em>dim</em> - <em>k</em>)-face. This can be done iff (i) the given <em>k</em>-face is valid and non-boundary; (ii) the (<em>dim</em> + 1 - <em>k</em>) top-dimensional simplices that contain it are distinct; and (iii) these simplices are joined in such a way that the link of the given <em>k</em>-face is the standard triangulation of the (<em>dim</em> - 1 - <em>k</em>)-sphere as the boundary of a (<em>dim</em> - <em>k</em>)-simplex.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal. In In the special case <em>k</em> = <em>dim</em>, the move is always legal and so the <em>check</em> argument will simply be ignored.</p>
<p>Note that after performing this move, all skeletal objects (facets, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>v</em>) can no longer be used.</p>
<p>If this triangulation is currently oriented, then this Pachner move will label the new top-dimensional simplices in a way that preserves the orientation.</p>
<p>See the page on <a class="el" href="pachner.html">Pachner moves on triangulations</a> for definitions and terminology relating to Pachner moves. After the move, the new belt face will be formed from vertices 0,1,...,(<em>dim</em> - <em>k</em>) of <code><a class="el" href="group__detail.html#ga8322ef559fdee45b8905c8eef682ac77" title="Returns all top-dimensional simplices in the triangulation.">simplices()</a>.back()</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>For the case <em>k</em> = <em>dim</em> in Regina's <a class="el" href="stddim.html">standard dimensions</a>, the labelling of the belt face has changed as of Regina 5.96 (the first prerelease for Regina 6.0). In versions 5.1 and earlier, the belt face was <code><a class="el" href="group__detail.html#ga8322ef559fdee45b8905c8eef682ac77" title="Returns all top-dimensional simplices in the triangulation.">simplices()</a>.back()-&gt;vertex(dim)</code>, and as of version 5.96 it is now <code><a class="el" href="group__detail.html#ga8322ef559fdee45b8905c8eef682ac77" title="Returns all top-dimensional simplices in the triangulation.">simplices()</a>.back()-&gt;vertex(0)</code>. The deprecated routines <a class="el" href="group__dim2.html#gaf849ca722b703fb8973fcad4ea7d4a90" title="Deprecated function that checks the eligibility of and/or performs a 1-3 Pachner move upon the given ...">Triangulation&lt;2&gt;::oneThreeMove()</a>, <a class="el" href="group__dim3.html#ga4e014a14f3ab909fb0774190725c1898" title="Deprecated function that checks the eligibility of and/or performs a 1-4 Pachner move upon the given ...">Triangulation&lt;3&gt;::oneFourMove()</a> and <a class="el" href="group__dim4.html#gaceb4bc27f38ebe29c0b1c97b54198905" title="Deprecated function that checks the eligibility of and/or performs a 1-5 Pachner move upon the given ...">Triangulation&lt;4&gt;::oneFiveMove()</a> maintain the old behaviour if you need it.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given <em>k</em>-face is a <em>k</em>-face of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the <em>k</em>-face about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">k</td><td>the dimension of the given face. This must be between 0 and (<em>dim</em>) inclusive. You can still perform a Pachner move about a 0-face <em>dim</em>-face, but these moves use specialised implementations (as opposed to this generic template implementation). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0839df9b50533553b1604fb41fab84d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0839df9b50533553b1604fb41fab84d6">&#9670;&nbsp;</a></span>pachner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int k&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="structregina_1_1detail_1_1PachnerHelper.html">regina::detail::PachnerHelper</a>&lt; dim, k &gt;::pachner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, k &gt; *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a (<em>dim</em> - <em>k</em> + 1)-(<em>k</em> + 1) move about the given face. </p>
<p>This routine contains the real implementation of <a class="el" href="group__detail.html#ga39dc5df8252f6e34ea45b19ca33c3964" title="Checks the eligibility of and/or performs a (dim + 1 - k)-(k + 1) Pachner move about the given k-face...">TriangulationBase::pachner&lt;k&gt;()</a>; see that routine for further details.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given <em>k</em>-face is a <em>k</em>-face of the given triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation upon which to perform the Pachner move. </td></tr>
    <tr><td class="paramname">f</td><td>the specific <em>k</em>-face about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if the move should be tested for eligibility. </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if the move should actually be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, this function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, this function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a id="ga4de5260704d60064eaacb40fe2f286bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4de5260704d60064eaacb40fe2f286bc">&#9670;&nbsp;</a></span>packet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::packet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gacb1a1ac23cabf7edbef79395a0e8af46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb1a1ac23cabf7edbef79395a0e8af46">&#9670;&nbsp;</a></span>propertyReader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::propertyReader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reader for the generic triangulation property with the given subtag name. </p>
<p>If <em>subTagName</em> refers to a property that is managed by the generic base class TriangulationBase&lt;dim&gt;, then this routine returns an appropriate element reader. Otherwise this routine returns <code>null</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the XML subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader if the corresponding triangulation property is managed by TriangulationBase&lt;dim&gt;, or <code>null</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga838e59de45da9b3f10ff3088bc127f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga838e59de45da9b3f10ff3088bc127f3f">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int codim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceStorage.html">regina::detail::FaceStorage</a>&lt; dim, codim &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FaceEmbedding.html">FaceEmbedding</a>&lt; dim, dim - codim &gt; &amp;&#160;</td>
          <td class="paramname"><em>emb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal routine to help build the skeleton of a triangulation. </p>
<p>This routine pushes the given object onto the end of the internal list of appearances of this face within top-dimensional simplices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">emb</td><td>the appearance to push onto the end of the internal list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab649c27ae3010716a1dd25a3288b46da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab649c27ae3010716a1dd25a3288b46da">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-1 &gt; *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the given face onto the end of the list of (<em>dim</em>-1)-faces of this boundary component. </p>
<p>This class does not take ownership of the given face.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the face to append to the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0119fa12357a0352b51c8de0de1340f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0119fa12357a0352b51c8de0de1340f9">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, dim-2 &gt; *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increments the number of (<em>dim</em>-2)-faces in this boundary component. </p>
<p>Since this boundary component class does not store any lower-dimensional faces, this routine does not store the given face. </p>

</div>
</div>
<a id="gae6ef18de0beda82356f7cdb98c7fb6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ef18de0beda82356f7cdb98c7fb6d5">&#9670;&nbsp;</a></span>push_back() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does nothing, since this boundary component does not store lower-dimensional faces. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the given face. This must be between 0 and <em>dim</em>-3 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga433519f91dc8bb5feab3fae9ba1d7f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga433519f91dc8bb5feab3fae9ba1d7f9c">&#9670;&nbsp;</a></span>push_back() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<div class="memtemplate">
template&lt;int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes the given face onto the end of the list of <em>subdim</em>-faces of this boundary component. </p>
<p>This class does not take ownership of the given face.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">subdim</td><td>the dimension of the face to append. This must be between 0 and <em>dim</em>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the face to append to the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef2a40f3357732361a596788206daccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2a40f3357732361a596788206daccf">&#9670;&nbsp;</a></span>random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::random </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>even</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a random isomorphism for the given number of simplices. </p>
<p>This isomorphism will reorder simplices 0 to <code>nSimplices-1</code> in a random fashion, and for each simplex a random permutation of its (<em>dim</em> + 1) vertices will be selected.</p>
<p>All possible isomorphisms for the given number of simplices are equally likely.</p>
<p>This routine is thread-safe, and uses <a class="el" href="classregina_1_1RandomEngine.html" title="Offers threadsafe access to Regina&#39;s global uniform random bit generator.">RandomEngine</a> for its random number generation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of simplices that the new isomorphism should operate upon. </td></tr>
    <tr><td class="paramname">even</td><td>if <code>true</code>, then every simplex will have its vertices permuted with an even permutation. This means that, if the random isomorphism is applied to an oriented triangulation, it will preserve the orientation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new random isomorphism. </dd></dl>

</div>
</div>
<a id="ga3f5583fe8731e5186eac30bb7dfeafa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f5583fe8731e5186eac30bb7dfeafa6">&#9670;&nbsp;</a></span>reflect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::reflect</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices reflect their orientation. </p>
<p>In particular, if this triangulation is oriented, then it will be converted into an isomorphic triangulation with the opposite orientation.</p>
<p>This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of every top-dimensional simplex. </p>

</div>
</div>
<a id="ga3e91a640743f9ce2710d17eda77d520a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e91a640743f9ce2710d17eda77d520a">&#9670;&nbsp;</a></span>removeAllSimplices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeAllSimplices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all simplices from the triangulation. </p>
<p>As a result, this triangulation will become empty.</p>
<p>All of the simplices that belong to this triangulation will be destroyed immediately. </p>

</div>
</div>
<a id="ga7b349c4e1fb4b27a9b20ed53b277a7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b349c4e1fb4b27a9b20ed53b277a7ba">&#9670;&nbsp;</a></span>removeSimplex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>simplex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given top-dimensional simplex from this triangulation. </p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex is a top-dimensional simplex in this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the simplex to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9f36b004ba6af3d6ce11bdb655650ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9f36b004ba6af3d6ce11bdb655650ec">&#9670;&nbsp;</a></span>removeSimplexAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::removeSimplexAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the top-dimensional simplex at the given index in this triangulation. </p>
<p>This is equivalent to calling <code>removeSimplex(simplex(index))</code>.</p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which top-dimensionalsimplex to remove; this must be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0fc09c9297c0471e6ffa647f7def8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0fc09c9297c0471e6ffa647f7def8c2">&#9670;&nbsp;</a></span>reorderAndRelabelFaces() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way. </p>
<p>This affects all faces of dimensions 0,...,(<em>dim</em>-2).</p>
<p>In this specialised class template, this function does nothing because faces of dimension 0,...,(<em>dim</em>-2) are not stored. </p>

</div>
</div>
<a id="gae95037dfb38a8f7488908cfa84649111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae95037dfb38a8f7488908cfa84649111">&#9670;&nbsp;</a></span>reorderAndRelabelFaces() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders all lower-dimensional faces of the given triangulation so that they appear in the same order as the corresponding faces of this boundary component, and relabels these faces so that their vertices are numbered in a corresponding way. </p>
<p>This affects all faces of dimensions 0,...,(<em>dim</em>-2).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This is a real boundary component. </dd>
<dd>
<em>tri</em> is a triangulation of this boundary component. </dd>
<dd>
For each <em>i</em>, the <em>i</em>th top-dimensional simplex of <em>tri</em> corresponds to the <em>i</em>th (<em>dim</em>-1)-face of this boundary component, and has its vertices 0,...,(<em>dim</em>-1) labelled in the same way.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a triangulation of this boundary component, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49c8335e8a11aa5f623daeedf8bc3472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c8335e8a11aa5f623daeedf8bc3472">&#9670;&nbsp;</a></span>reorderAndRelabelFaces() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tridimFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders and relabels all <em>subdim</em>-faces of the given triangulation so that they appear in the same order as the corresponding faces in this list, and so that their vertices are numbered in a corresponding way. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The <em>subdim</em>-faces of the given triangulation <em>tri</em> are in one-to-one correspondence with the <em>subdim</em>-faces in this list, though not necessarily in the same order. Moreover, for each <em>i</em> and <em>j</em>, this correspondence maps the <em>i</em>th <em>subdim</em>-face of <code>tri-&gt;simplex(j)</code> to the <em>i</em>th <em>subdim</em>-face of <code>tridimFaces[j]</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tridim</td><td>the dimension of the given triangulation. This must be strictly larger than <em>subdim</em>, but it need not be equal to <em>dim</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a <em>tridim</em>-dimensional triangulation, as described above. </td></tr>
    <tr><td class="paramname">tridimFaces</td><td>a list of <em>tridim</em>-faces that together contain all of the faces in this list, and that are in an <em>ordered</em> one-to-one correspondence with the top-dimensional simplices of <em>tri</em> as described in the precondition above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73becf4d57e83b9199775bc9b1378fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73becf4d57e83b9199775bc9b1378fae">&#9670;&nbsp;</a></span>reorderAndRelabelFaces() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1WeakFaceListSuite.html">regina::detail::WeakFaceListSuite</a>&lt; dim, subdim &gt;::reorderAndRelabelFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; tridim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, tridim &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>tridimFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders and relabels all faces of all dimensions 0,...,<em>subdim</em> of the given triangulation, so that for each <em>k</em>, the <em>k</em>-faces of the given triangulation appear in the same order as the corresponding <em>k</em>-faces in this suite, and have their vertices numbered in a corresponding way. </p>
<dl class="section pre"><dt>Precondition</dt><dd>For each dimension <em>k</em> = 0,...,<em>subdim</em>, the <em>k</em>-faces of the given triangulation <em>tri</em> are in one-to-one correspondence with the <em>k</em>-faces in this suite, though not necessarily in the same order. Moreover, for each <em>i</em> and <em>j</em>, this correspondence maps the <em>i</em>th <em>k</em>-face of <code>tri-&gt;simplex(j)</code> to the <em>i</em>th <em>k</em>-face of <code>tridimFaces[j]</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tridim</td><td>the dimension of the given triangulation. This must be strictly larger than <em>subdim</em>, but it need not be equal to <em>dim</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>a <em>tridim</em>-dimensional triangulation, as described above. </td></tr>
    <tr><td class="paramname">tridimFaces</td><td>a list of <em>tridim</em>-faces that together contain all of the faces in this suite, and that are in an <em>ordered</em> one-to-one correspondence with the top-dimensional simplices of <em>tri</em> as described in the precondition above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a8a26a3d5cd1642df574b639498cd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a8a26a3d5cd1642df574b639498cd88">&#9670;&nbsp;</a></span>ReorderIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::ReorderIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an uninitialised iterator. </p>

</div>
</div>
<a id="ga7ba549fd5891777b0147eec3e74733b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba549fd5891777b0147eec3e74733b0">&#9670;&nbsp;</a></span>ReorderIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::ReorderIterator </td>
          <td>(</td>
          <td class="paramtype">const ReorderIterator&lt; tridim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ga3c7924f66c204b8a751c87c3479b5dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c7924f66c204b8a751c87c3479b5dfa">&#9670;&nbsp;</a></span>ReorderIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<div class="memtemplate">
template&lt;int tridim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::ReorderIterator&lt; tridim &gt;::ReorderIterator </td>
          <td>(</td>
          <td class="paramtype">typename std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * &gt;::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; tridim, subdim &gt; **&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an iterator that points to the given face of this list, using the given map to convert faces of this list to faces of the other triangulation <em>tri</em>. </p>
<p>See the iterator class notes for details. </p>

</div>
</div>
<a id="ga4d39751508a86b39473b628f04fdbcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d39751508a86b39473b628f04fdbcc1">&#9670;&nbsp;</a></span>sameDegrees() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim &gt;::sameDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given triangulation have the same <em>k</em>-face degree sequences, for each facial dimension <em>k</em> &le; <em>subdim</em>. </p>
<p>For the purposes of this routine, degree sequences are considered to be unordered.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given triangulation are known to have the same number of <em>k</em>-faces as each other, for each facial dimension <em>k</em> &le; <em>subdim</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all degree sequences considered are equal. </dd></dl>

</div>
</div>
<a id="ga314fb6c464b9d2b0f1169233a75f5a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga314fb6c464b9d2b0f1169233a75f5a68">&#9670;&nbsp;</a></span>sameDegrees() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::sameDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">SimplexFaces</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the <em>subdim</em>-face degrees of this and the given simplex are identical, under the given relabelling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the simplex to compare against this. </td></tr>
    <tr><td class="paramname">p</td><td>a mapping from the vertices of this simplex to the vertices of <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if, for every <em>i</em>, <em>subdim</em>-face number <em>i</em> of this simplex has the same degree as its image in <em>other</em> under the relabelling <em>p</em>. </dd></dl>

</div>
</div>
<a id="gadc4c39e0a3b8437d2c3540b183de7b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc4c39e0a3b8437d2c3540b183de7b97">&#9670;&nbsp;</a></span>sameDegrees() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexFacesSuite.html">regina::detail::SimplexFacesSuite</a>&lt; dim &gt;::sameDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1SimplexFacesSuite.html">SimplexFacesSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the <em>k</em>-face degrees of this and the given simplex are identical, under the given relabelling, for all faces of all dimensions <em>k</em> &le; <em>subdim</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the simplex to compare against this. </td></tr>
    <tr><td class="paramname">p</td><td>a mapping from the vertices of this simplex to the vertices of <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if, for every <em>i</em> and every facial dimension <em>k</em> &le; <em>subdim</em>, <em>k</em>-face number <em>i</em> of this simplex has the same degree as its image in <em>other</em> under the relabelling <em>p</em>. </dd></dl>

</div>
</div>
<a id="ga493b5c6f975ab3ce7cb253532c365b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga493b5c6f975ab3ce7cb253532c365b21">&#9670;&nbsp;</a></span>sameFVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim &gt;::sameFVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given triangulation have the same number of <em>k</em>-faces, for each facial dimension <em>k</em> &le; <em>subdim</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the face counts considered are identical for both triangluations. </dd></dl>

</div>
</div>
<a id="ga6d949a6ec9b90b7c9fce5c9da6dc52d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d949a6ec9b90b7c9fce5c9da6dc52d6">&#9670;&nbsp;</a></span>setDescription()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::setDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the description associated with this simplex. </p>
<p>This may be any text whatsoever; typically it is intended to be human-readable. Descriptions do not need to be unique.</p>
<p>To remove an existing description, you can simply set the description to the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the new description to assign to this simplex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc12157b7e664b84894574e149ee1023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc12157b7e664b84894574e149ee1023">&#9670;&nbsp;</a></span>simpImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::simpImage </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex under this isomorphism. </p>
<dl class="section user"><dt>Python</dt><dd>This is not available for Python users. However, the read-only version of this routine is.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex; this must be between 0 and <code><a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the index of the destination simplex that the source simplex maps to. </dd></dl>

</div>
</div>
<a id="gac18646a12377b7965cbc58606082b659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac18646a12377b7965cbc58606082b659">&#9670;&nbsp;</a></span>simpImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::simpImage </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>sourceSimp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the image of the given source simplex under this isomorphism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceSimp</td><td>the index of the source simplex; this must be between 0 and <code><a class="el" href="group__detail.html#ga43c659599534e20778107158e2246958" title="Returns the number of simplices in the source triangulation associated with this isomorphism.">size()</a>-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the destination simplex that the source simplex maps to. </dd></dl>

</div>
</div>
<a id="ga4a2dd807132d852de6cecde560be685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a2dd807132d852de6cecde560be685a">&#9670;&nbsp;</a></span>simplex() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const char* <a class="el" href="structregina_1_1detail_1_1XMLTriangulationTags.html">regina::detail::XMLTriangulationTags</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The XML tag that stores a single top-dimensional simplex in a <em>dim</em>-dimensional triangulation. </p>

</div>
</div>
<a id="ga7f1ed30cfbd2385ce48046120c2ced19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f1ed30cfbd2385ce48046120c2ced19">&#9670;&nbsp;</a></span>simplex() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::simplex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex in which the underlying <em>subdim</em>-face of the triangulation is contained. </p>
<dl class="section return"><dt>Returns</dt><dd>the top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="gae2e269a7332e80aeec3603881fd175d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e269a7332e80aeec3603881fd175d3">&#9670;&nbsp;</a></span>simplex() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="ga5b240393651b978c8c842e14f175f500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b240393651b978c8c842e14f175f500">&#9670;&nbsp;</a></span>simplex() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in this component. </p>
<p>Note that the index within this component may not be the same as the index within the overall triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="group__detail.html#ga60e197585833b2a82f9e8ed66e0a5885" title="Returns the number of top-dimensional simplices in this component.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="ga7cdadce4ea703518064241597cf1514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cdadce4ea703518064241597cf1514b">&#9670;&nbsp;</a></span>simplex() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a id="ga62524114f62901a475255bda387be265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62524114f62901a475255bda387be265">&#9670;&nbsp;</a></span>SimplexBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new simplex with the given description and no facets joined to anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the description to give the new simplex. </td></tr>
    <tr><td class="paramname">tri</td><td>the triangulation to which the new simplex belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f6e247acf0c607c9a86722492ca5a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f6e247acf0c607c9a86722492ca5a1e">&#9670;&nbsp;</a></span>SimplexBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1SimplexBase.html">SimplexBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new simplex with no description and no facets joined to anything. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation to which the new simplex belongs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e725bd9bbbd6fd5d23d1d20e43f6e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e725bd9bbbd6fd5d23d1d20e43f6e43">&#9670;&nbsp;</a></span>simplices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const char* <a class="el" href="structregina_1_1detail_1_1XMLTriangulationTags.html">regina::detail::XMLTriangulationTags</a>&lt; dim &gt;::simplices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The XML tag that stores the set of all top-dimensional simplices for a <em>dim</em>-dimensional triangulation. </p>

</div>
</div>
<a id="gace3fe41e995104afc85e54c9f44f560a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3fe41e995104afc85e54c9f44f560a">&#9670;&nbsp;</a></span>simplices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::simplices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all top-dimensional simplices in this component. </p>
<p>The reference that is returned will remain valid only for as long as this component object exists. In particular, the reference will become invalid any time that the triangulation changes (since all component objects will be destroyed and others rebuilt in their place).</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="ga8322ef559fdee45b8905c8eef682ac77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8322ef559fdee45b8905c8eef682ac77">&#9670;&nbsp;</a></span>simplices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * &gt; &amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> all top-dimensional simplices in the triangulation. </p>
<p>The reference that is returned will remain valid for as long as the triangulation exists: even as simplices are added and/or removed, it will always reflect the simplices that are currently in the triangulation.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="gaad291d03ffaac87219b0be9a3b6d3cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad291d03ffaac87219b0be9a3b6d3cc8">&#9670;&nbsp;</a></span>simplicialSphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase</a>&lt; dim &gt;::simplicialSphere</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the standard (<em>dim</em>+2)-simplex triangulation of the <em>dim</em>-sphere as the boundary of a (<em>dim</em>+1)-simplex. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaf74cde5c3b790195df3e10e2e53e390b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf74cde5c3b790195df3e10e2e53e390b">&#9670;&nbsp;</a></span>simplifiedFundamentalGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplifiedFundamentalGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> *&#160;</td>
          <td class="paramname"><em>newGroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the triangulation that you have simplified the presentation of its fundamental group. </p>
<p>The old group presentation will be destroyed, and this triangulation will take ownership of the new (hopefully simpler) group that is passed.</p>
<p>This routine is useful for situations in which some external body (such as GAP) has simplified the group presentation better than Regina can.</p>
<p>Regina does <em>not</em> verify that the new group presentation is equivalent to the old, since this is - well, hard.</p>
<p>If the fundamental group has not yet been calculated for this triangulation, this routine will nevertheless take ownership of the new group, under the assumption that you have worked out the group through some other clever means without ever having needed to call <a class="el" href="group__detail.html#ga408718df2c6cc65f21adabc50850ec63" title="Returns the fundamental group of this triangulation.">fundamentalGroup()</a> at all.</p>
<p>Note that this routine will not fire a packet change event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newGroup</td><td>a new (and hopefully simpler) presentation of the fundamental group of this triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd8b50bc9d84a3d841b1bbb38f21769c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd8b50bc9d84a3d841b1bbb38f21769c">&#9670;&nbsp;</a></span>singleCone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool available&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleFromLowDim.html">regina::detail::ExampleFromLowDim</a>&lt; dim, available &gt;::singleCone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a single cone over the given (<em>dim-1</em>)-dimensional triangulation. </p>
<p>If the given triangulation represents the manifold <code>M</code>, then this returns a triangulation of the product <code>M x I</code> that has one real boundary component and one ideal boundary component. The triangulation of the real boundary component will be identical to the original (<em>dim-1</em>)-dimensional triangulation <em>base</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>If the given (<em>dim</em>-1)-dimensional triangulation has any boundary whatsoever (either real or ideal), then unless it is a (<em>dim</em>-1)-ball, you will obtain an invalid <em>dim</em>-manifold triangulation as a result.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga43861bd25d2417da9172b1f4c1310370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43861bd25d2417da9172b1f4c1310370">&#9670;&nbsp;</a></span>size() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr static const char* <a class="el" href="structregina_1_1detail_1_1XMLTriangulationTags.html">regina::detail::XMLTriangulationTags</a>&lt; dim &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The XML attribute that stores the number of top-dimensional simplices in a <em>dim</em>-dimensional triangulation. </p>

</div>
</div>
<a id="ga483ae78a8682ebace035a95c4e1eac12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga483ae78a8682ebace035a95c4e1eac12">&#9670;&nbsp;</a></span>size() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-1)-faces in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<p>If this is an ideal or invalid vertex boundary component, then this routine will return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-1)-faces in this boundary component. </dd></dl>

</div>
</div>
<a id="ga35950a8c9912f9a9317370b9c3614b7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35950a8c9912f9a9317370b9c3614b7e">&#9670;&nbsp;</a></span>size() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of (<em>dim</em>-1)-faces in this boundary component. </p>
<p>These are the top-dimensional faces for a real boundary component.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of (<em>dim</em>-1)-faces in this boundary component. </dd></dl>

</div>
</div>
<a id="ga60e197585833b2a82f9e8ed66e0a5885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e197585833b2a82f9e8ed66e0a5885">&#9670;&nbsp;</a></span>size() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of top-dimensional simplices in this component. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="ga05fd123494c0f9d15ffed9f226728b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05fd123494c0f9d15ffed9f226728b83">&#9670;&nbsp;</a></span>size() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of simplices whose facets are described by this facet pairing. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a id="ga43c659599534e20778107158e2246958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43c659599534e20778107158e2246958">&#9670;&nbsp;</a></span>size() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of simplices in the source triangulation associated with this isomorphism. </p>
<p>Note that this is always less than or equal to the number of simplices in the destination triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices in the source triangulation. </dd></dl>

</div>
</div>
<a id="ga3871caa1f02ccda957f22ebd9a646ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3871caa1f02ccda957f22ebd9a646ff5">&#9670;&nbsp;</a></span>size() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of top-dimensional simplices in the triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a id="gac44d1474b152e941ff3e57ca342095ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44d1474b152e941ff3e57ca342095ff">&#9670;&nbsp;</a></span>sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase</a>&lt; dim &gt;::sphere</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Closed Triangulations. </p>
<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-simplex triangulation of the <em>dim</em>-sphere.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gac808405b4900c8fdff2153d1e404f1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac808405b4900c8fdff2153d1e404f1bb">&#9670;&nbsp;</a></span>sphereBundle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase</a>&lt; dim &gt;::sphereBundle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-simplex triangulation of the product space <code>S^(<em>dim</em>-1) x S^1</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga4c57b6a7340d4f289b51469e62a8a66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c57b6a7340d4f289b51469e62a8a66c">&#9670;&nbsp;</a></span>splitIntoComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::splitIntoComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>componentParent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setLabels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits a disconnected triangulation into many smaller triangulations, one for each component. </p>
<p>The new component triangulations will be inserted as children of the given parent packet. The original triangulation (i.e., this triangulation) will be left unchanged.</p>
<p>If the given parent packet is <code>null</code>, the new component triangulations will be inserted as children of this triangulation.</p>
<p>By default, this routine will assign sensible packet labels to each of the new component triangulations. If these component triangulations are only temporary objects used as part of some larger algorithm, then labels are unnecessary - in this case you can pass <em>setLabels</em> as <code>false</code> to avoid the (small) overhead that these packet labels incur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentParent</td><td>the packet beneath which the new component triangulations will be inserted, or <code>null</code> if they should be inserted directly beneath this triangulation. </td></tr>
    <tr><td class="paramname">setLabels</td><td><code>true</code> if the new component triangulations should be assigned sensible packet labels, or <code>false</code> if they should be left without labels at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of new component triangulations constructed. </dd></dl>

</div>
</div>
<a id="ga15f7e12e1c4be36e550c0873d227cdca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15f7e12e1c4be36e550c0873d227cdca">&#9670;&nbsp;</a></span>startContentSubElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga2454f3da462ae0e806eefcdfbe75654f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2454f3da462ae0e806eefcdfbe75654f">&#9670;&nbsp;</a></span>startElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1XMLSimplexReader.html">regina::detail::XMLSimplexReader</a>&lt; dim &gt;::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga7fc09ae4b089c0e8e2642d11e4191aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fc09ae4b089c0e8e2642d11e4191aaf">&#9670;&nbsp;</a></span>startElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1XMLSimplicesReader.html">regina::detail::XMLSimplicesReader</a>&lt; dim &gt;::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__detail.html#gaad62f372e5d358a752bd3ed6d70d0447" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gaad62f372e5d358a752bd3ed6d70d0447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad62f372e5d358a752bd3ed6d70d0447">&#9670;&nbsp;</a></span>startSubElement() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * <a class="el" href="classregina_1_1detail_1_1XMLSimplicesReader.html">regina::detail::XMLSimplicesReader</a>&lt; dim &gt;::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gabe8b2a5ac795f6b22ad0eec7565adc83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe8b2a5ac795f6b22ad0eec7565adc83">&#9670;&nbsp;</a></span>startSubElement() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::AbelianGroupPropertyReader::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga543f461338d4187e278f74c8dc7e54f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga543f461338d4187e278f74c8dc7e54f3">&#9670;&nbsp;</a></span>startSubElement() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::GroupPresentationPropertyReader::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga0b2c7206559a6f253ba033c69afe2a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2c7206559a6f253ba033c69afe2a54">&#9670;&nbsp;</a></span>swapBaseProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::swapBaseProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all properties that are managed by this base class, including skeletal data, with the given triangulation. </p>
<p>Note that <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> never calls this routine itself. Typically <a class="el" href="group__detail.html#ga0b2c7206559a6f253ba033c69afe2a54" title="Swaps all properties that are managed by this base class, including skeletal data,...">swapBaseProperties()</a> is only ever called by Triangulation&lt;dim&gt;::swapAllProperties(), which in turn is called by <a class="el" href="group__detail.html#gad43e7587b785f281f5f5c553f263484e" title="Swaps the contents of this and the given triangulation.">swapContents()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose properties should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad43e7587b785f281f5f5c553f263484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad43e7587b785f281f5f5c553f263484e">&#9670;&nbsp;</a></span>swapContents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::swapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given triangulation. </p>
<p>All top-dimensional simplices that belong to this triangulation will be moved to <em>other</em>, and all top-dimensional simplices that belong to <em>other</em> will be moved to this triangulation. Likewise, all skeletal objects (such as lower-dimensional faces, components, and boundary components) and all cached properties (such as homology and fundamental group) will be swapped.</p>
<p>In particular, any pointers or references to Simplex&lt;dim&gt; and/or Face&lt;dim, subdim&gt; objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga013abf7fffeba839fb47a2dcfaee19f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga013abf7fffeba839fb47a2dcfaee19f5">&#9670;&nbsp;</a></span>swapFaces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim &gt;::swapFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all faces of dimension <em>subdim</em> and below with those of the given triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the face storage for the triangulation whose faces are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae29b538c61d91b627f9e29c589c041fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae29b538c61d91b627f9e29c589c041fd">&#9670;&nbsp;</a></span>TopologyLock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::TopologyLock::TopologyLock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new lock on the given triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation whose topological properties are to be locked. This may be <code>null</code> (in which case the lock has no effect). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6afb56a1370b063c12c4efe634eb771b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6afb56a1370b063c12c4efe634eb771b">&#9670;&nbsp;</a></span>toTextRep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::toTextRep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text-based representation of this facet pairing that can be used to reconstruct the facet pairing. </p>
<p>This reconstruction is done through routine <a class="el" href="group__detail.html#ga3241a34885f4b644773edccf65225ac4" title="Reconstructs a facet pairing from a text-based representation.">fromTextRep()</a>.</p>
<p>The text produced is not particularly readable; for a human-readable text representation, see routine <a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a> instead.</p>
<p>The string returned will contain no newlines.</p>
<dl class="section return"><dt>Returns</dt><dd>a text-based representation of this facet pairing. </dd></dl>

</div>
</div>
<a id="gaf5035b1f08320755fa39468231aaab0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5035b1f08320755fa39468231aaab0f">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this boundary component. </dd></dl>

</div>
</div>
<a id="ga9ac7fe03286ae8bd47dda1dee0a925ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ac7fe03286ae8bd47dda1dee0a925ab">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this boundary component belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this boundary component. </dd></dl>

</div>
</div>
<a id="ga4526d27d6771e5288209fac8caabd57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4526d27d6771e5288209fac8caabd57d">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this face belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this face. </dd></dl>

</div>
</div>
<a id="ga36f84802bd71d9affff8a90a6e8ea9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36f84802bd71d9affff8a90a6e8ea9f0">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this simplex belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this simplex. </dd></dl>

</div>
</div>
<a id="gaaa79cc9e7f5b4f6ea27045ebf3c8fabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa79cc9e7f5b4f6ea27045ebf3c8fabc">&#9670;&nbsp;</a></span>TriangulationBase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty triangulation. </p>

</div>
</div>
<a id="ga51f24cf3815b0d19d5afeae1860fcd0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51f24cf3815b0d19d5afeae1860fcd0f">&#9670;&nbsp;</a></span>TriangulationBase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation. </p>
<p>This will clone any computed properties (such as homology, fundamental group, and so on) of the given triangulation also. If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the triangulation to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa664ef0a04f31b2df1594f2a8dbb1322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa664ef0a04f31b2df1594f2a8dbb1322">&#9670;&nbsp;</a></span>TriangulationBase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties also. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the triangulation to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties of the given triangulation (such as homology, fundamental group, and so on), or <code>false</code> if the new triangulation should have all properties marked as unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaceae3ff4fb520f6df2d13966b5cfcc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceae3ff4fb520f6df2d13966b5cfcc22">&#9670;&nbsp;</a></span>twistedBallBundle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase</a>&lt; dim &gt;::twistedBallBundle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a triangulation of the twisted product space <code>B^(<em>dim</em>-1) x~ S^1</code>. </p>
<p>This will use one simplex in even dimensions, or two simplices in odd dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="gaf14d0b08a11aafcfe98af561437676f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf14d0b08a11aafcfe98af561437676f4">&#9670;&nbsp;</a></span>twistedSphereBundle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1ExampleBase.html">regina::detail::ExampleBase</a>&lt; dim &gt;::twistedSphereBundle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a two-simplex triangulation of the twisted product space <code>S^(<em>dim</em>-1) x~ S^1</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed triangulation, which must be destroyed by the caller of this routine. </dd></dl>

</div>
</div>
<a id="ga4d139902e93c8ddd7c17cd6f67729b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d139902e93c8ddd7c17cd6f67729b22">&#9670;&nbsp;</a></span>unjoin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::unjoin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myFacet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unglues the given facet of this simplex from whatever it is joined to. </p>
<p>As a result, the given facet of this simplex will become a boundary facet.</p>
<p>If there was an adjacent simplex to begin with, then this other simplex will be updated automatically (i.e., you only need to call <a class="el" href="group__detail.html#ga4d139902e93c8ddd7c17cd6f67729b22" title="Unglues the given facet of this simplex from whatever it is joined to.">unjoin()</a> from one side of the gluing).</p>
<p>This routine is safe to call even if the given facet is already a boundary facet (in which case it will do nothing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myFacet</td><td>the facet of this simplex whose gluing we will undo. This should be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplex that was originally glued to the given facet of this simplex, or 0 if this was already a boundary facet. </dd></dl>

</div>
</div>
<a id="ga8a8c5079eec12de43bd3fb8d0d7e3fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8c5079eec12de43bd3fb8d0d7e3fdd">&#9670;&nbsp;</a></span>vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::vertices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps vertices (0,...,<em>subdim</em>) of the underlying <em>subdim</em>-face of the triangulation to the corresponding vertex numbers of <a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a>. </p>
<p>If the link of the underlying <em>subdim</em>-face is orientable, then this permutation also maps (<em>subdim</em>+1, ..., <em>dim</em>) to the remaining vertex numbers of <a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a> in a manner that preserves orientation as you walk through the many different <a class="el" href="classregina_1_1FaceEmbedding.html" title="Details how a subdim-face of a dim-dimensional triangulation appears within each top-dimensional simp...">FaceEmbedding</a> objects for the same underlying <em>subdim</em>-face.</p>
<p>This routine returns the same permutation as <code><a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a>.faceMapping&lt;subdim&gt;(face())</code>. See <a class="el" href="group__detail.html#gab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">Simplex&lt;dim&gt;::faceMapping()</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd>a mapping from the vertices of the underlying <em>subdim</em>-face to the corresponding vertices of <a class="el" href="group__detail.html#ga7f1ed30cfbd2385ce48046120c2ced19" title="Returns the top-dimensional simplex in which the underlying subdim-face of the triangulation is conta...">simplex()</a>. </dd></dl>

</div>
</div>
<a id="ga792b2bf2791de7bcb02591f76b277a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga792b2bf2791de7bcb02591f76b277a0d">&#9670;&nbsp;</a></span>WeakFaceList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::<a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">WeakFaceList</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor that leaves the list of faces empty. </p>

</div>
</div>
<a id="gac869dd2ea2d4ca009f1e6474920fe65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac869dd2ea2d4ca009f1e6474920fe65b">&#9670;&nbsp;</a></span>writeDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subgraph</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>labels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the graph corresponding to this facet pairing in the Graphviz DOT language. </p>
<p>Every vertex of this graph represents a simplex, and every edge represents a pair of simplex facets that are joined together. Note that for a closed triangulation this graph will be entirely (<em>dim</em> + 1)-valent; for triangulations with boundary facets, some graph vertices will have degree <em>dim</em> or less.</p>
<p>The graph can either be written as a complete DOT graph, or as a clustered subgraph within some larger DOT graph (according to whether the argument <em>subgraph</em> is passed as <code>false</code> or <code>true</code>).</p>
<p>If a complete DOT graph is being written, the output may be used as a standalone DOT file ready for use with Graphviz.</p>
<p>If a subgraph is being written, the output will contain a single <code>subgraph</code> section that should be inserted into some larger DOT file. Note that the output generated by <a class="el" href="group__detail.html#ga7e368406092dd1c1c349dd07958f6145" title="Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet...">writeDotHeader()</a>, followed by one or more subgraphs and then a closing curly brace will suffice. The subgraph name will begin with the string <code>pairing_</code>.</p>
<p>The argument <em>prefix</em> will be prepended to the name of each graph vertex, and will also be used in the name of the graph or subgraph. Using unique prefixes becomes important if you are calling <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> several times to generate several subgraphs for use in a single DOT file. If the <em>prefix</em> argument is null or empty then a default prefix will be used.</p>
<p>Note that this routine generates undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">prefix</td><td>a string to prepend to the name of each graph vertex, and to include in the graph or subgraph name; see above for details. </td></tr>
    <tr><td class="paramname">subgraph</td><td><code>false</code> if a complete standalone DOT graph should be output, or <code>true</code> if a clustered subgraph should be output for use in some larger DOT file. </td></tr>
    <tr><td class="paramname">labels</td><td>indicates whether graph vertices will be labelled with the corresponding simplex numbers. This feature is currently experimental, and the default is <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="ga7e368406092dd1c1c349dd07958f6145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e368406092dd1c1c349dd07958f6145">&#9670;&nbsp;</a></span>writeDotHeader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeDotHeader </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>graphName</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes header information for a Graphviz DOT file that will describe the graphs for one or more facet pairings. </p>
<p>See the <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> documentation for further information on such graphs.</p>
<p>The output will be in the Graphviz DOT language, and will include appropriate display settings for graphs, edges and nodes. The opening brace for a <code>graph</code> section of the DOT file is included.</p>
<p>This routine may be used with <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> to generate a single DOT file containing the graphs for several different facet pairings. A complete DOT file can be produced by calling this routine, then calling <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in subgraph mode for each facet pairing, then outputting a final closing curly brace.</p>
<p>Note that if you require a DOT file containing the graph for only a single facet pairing, this routine is unnecessary; you may simply call <a class="el" href="group__detail.html#gac869dd2ea2d4ca009f1e6474920fe65b" title="Writes the graph corresponding to this facet pairing in the Graphviz DOT language.">writeDot()</a> in full graph mode instead.</p>
<p>This routine is suitable for generating undirected graphs, not directed graphs. The final DOT file should be used with either the <em>neato</em> or <em>fdp</em> programs shipped with Graphviz.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">graphName</td><td>the name of the graph in the DOT file. If this is null or empty then a default graph name will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="gaf56261b6f8f242d925a03de69db78f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf56261b6f8f242d925a03de69db78f35">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga114bc5936a4dc942edfd9b3e8c07df32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga114bc5936a4dc942edfd9b3e8c07df32">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, false &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2d045df7bc861b57e89444470e47cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2d045df7bc861b57e89444470e47cd4">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4ffac0e0ca2f4ffe3b61a54d6bce4bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ffac0e0ca2f4ffe3b61a54d6bce4bbd">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>The class Face&lt;dim, subdim&gt; may safely override this function, since the output routines cast down to Face&lt;dim, subdim&gt; before calling it.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12bb303f0c62cae604c2bfe2eadc602d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12bb303f0c62cae604c2bfe2eadc602d">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf98d5138a8528b99a8a77b4533784a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf98d5138a8528b99a8a77b4533784a4">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga68da49bd858b8b7f9016b7824bd7489f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68da49bd858b8b7f9016b7824bd7489f">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9df5a9c7bfb67c3dc8a0eb3dc4179c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9df5a9c7bfb67c3dc8a0eb3dc4179c9c">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, false &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1653572126e354f9e6f9202679742e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1653572126e354f9e6f9202679742e8">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7371c16f06d4776e54f2516be0d1595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7371c16f06d4776e54f2516be0d1595b">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html">regina::detail::FaceEmbeddingBase</a>&lt; dim, subdim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb461314ec9b661a4476b24d1f07c9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb461314ec9b661a4476b24d1f07c9d0">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceBase.html">regina::detail::FaceBase</a>&lt; dim, subdim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>The class Face&lt;dim, subdim&gt; may safely override this function, since the output routines cast down to Face&lt;dim, subdim&gt; before calling it.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e3a9b5851e0f984a28cc88fa64717c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e3a9b5851e0f984a28cc88fa64717c1">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a human-readable representation of this facet pairing to the given output stream. </p>
<p>The string returned will contain no newlines.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1fcd528876a8ef03ada27dc99004b871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fcd528876a8ef03ada27dc99004b871">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb07d86f5e49e7cf9effbcfa7645b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb07d86f5e49e7cf9effbcfa7645b7ce">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1d1a2ca27fd966c3c7403f0a1c6080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1d1a2ca27fd966c3c7403f0a1c6080d">&#9670;&nbsp;</a></span>writeXMLBaseProperties()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::writeXMLBaseProperties </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing properties of this triangulation. </p>
<p>This routine covers those properties that are managed by this base class <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html" title="Provides core functionality for dim-dimensional triangulations.">TriangulationBase</a> and that have already been computed for this triangulation.</p>
<p>This routine is typically called from within <a class="el" href="group__generic.html#ga959254d7310092ce115f5ff90529aceb" title="Writes a chunk of XML containing the data for this packet only.">Triangulation&lt;dim&gt;::writeXMLPacketData()</a>. The XML elements that it writes are child elements of the <code>packet</code> element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad90e2cc364bcba8f0aecb268523a708e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad90e2cc364bcba8f0aecb268523a708e">&#9670;&nbsp;</a></span>XMLSimplexReader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1XMLSimplexReader.html">regina::detail::XMLSimplexReader</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1XMLSimplexReader.html">XMLSimplexReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>whichSimplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new simplex element reader. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation <em>tri</em> already contains at least (<em>whichSimplex</em> + 1) top-dimensional simplices.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation containing the simplex being read. </td></tr>
    <tr><td class="paramname">whichSimplex</td><td>the index of the simplex being read within the triangulation <em>tri</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa07d1fe2808f661e90e0f4cc0e90df4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa07d1fe2808f661e90e0f4cc0e90df4c">&#9670;&nbsp;</a></span>XMLSimplicesReader()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1XMLSimplicesReader.html">regina::detail::XMLSimplicesReader</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1XMLSimplicesReader.html">XMLSimplicesReader</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new simplices element reader. </p>
<p>The given triangulation should be empty; its simplices will be created by this reader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the triangulation being read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f5c18a6fce0eefc6c22179b39dc18f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f5c18a6fce0eefc6c22179b39dc18f8">&#9670;&nbsp;</a></span>XMLTriangulationReaderBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">XMLTriangulationReaderBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new triangulation reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf807470f4260056753b5efbfacaa8e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf807470f4260056753b5efbfacaa8e7f">&#9670;&nbsp;</a></span>~BoundaryComponentStorage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex, bool canBuild_&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, <a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::~<a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">BoundaryComponentStorage</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys this object. </p>
<p>The cached boundary component triangulation will be destroyed also. </p>

</div>
</div>
<a id="gafdb4499d89fb9517b882720cf3b81a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdb4499d89fb9517b882720cf3b81a48">&#9670;&nbsp;</a></span>~FacetPairingBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">FacetPairingBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates any memory used by this structure. </p>

</div>
</div>
<a id="gabacfd5bb07ccd3a47d692b3d1f4b75b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabacfd5bb07ccd3a47d692b3d1f4b75b0">&#9670;&nbsp;</a></span>~IsomorphismBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">IsomorphismBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this isomorphism. </p>

</div>
</div>
<a id="gaefde423061c7aefa342235a791458765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefde423061c7aefa342235a791458765">&#9670;&nbsp;</a></span>~TopologyLock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::TopologyLock::~TopologyLock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes this lock on the associated triangulation. </p>

</div>
</div>
<a id="gace45d0a52d9a2a853f890d1006fedf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace45d0a52d9a2a853f890d1006fedf7c">&#9670;&nbsp;</a></span>~TriangulationBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::~<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this triangulation. </p>
<p>The simplices within this triangulation will also be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga695616fda7f4a0360ce6b94458a879c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga695616fda7f4a0360ce6b94458a879c8">&#9670;&nbsp;</a></span>allFaces <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, allFaces_ &gt;::allFaces = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>). </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<a id="gaa1362d526ead23fd9e3d1f8516c89ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1362d526ead23fd9e3d1f8516c89ac2">&#9670;&nbsp;</a></span>allFaces <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::allFaces = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether this boundary component class stores all lower-dimensional faces (<code>true</code>), or only faces of dimension <em>dim</em>-1 (<code>false</code>). </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<a id="gae2259be5e070ee6a88808f21026a8e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2259be5e070ee6a88808f21026a8e2e">&#9670;&nbsp;</a></span>allowVertex <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, allowVertex_ &gt;::allowVertex = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class. </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<a id="ga3a92943d330e4e11f8b012dc218e5be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a92943d330e4e11f8b012dc218e5be8">&#9670;&nbsp;</a></span>allowVertex <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceInterface.html">regina::detail::BoundaryComponentFaceInterface</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, false &gt;::allowVertex = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether ideal and/or invalid vertex boundary components are both possible and recognised by this boundary component class. </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<a id="ga7ba41612ae02ea47c1953758ec2e604d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ba41612ae02ea47c1953758ec2e604d">&#9670;&nbsp;</a></span>boundary_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex, bool canBuild_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim-1&gt;* <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, <a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::boundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A full triangulation of the boundary component. </p>
<p>This may be pre-computed when the triangulation skeleton is constructed, or it may be <code>null</code> in which case it will be built on demand. For ideal or invalid vertices, this is always <code>null</code> since the triangulation is cached by the vertex class instead. </p>

</div>
</div>
<a id="gaa6e46682d3ce5b05f7e693f863018f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6e46682d3ce5b05f7e693f863018f66">&#9670;&nbsp;</a></span>boundaryComponents_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::boundaryComponents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The components that form the boundary of the triangulation. </p>

</div>
</div>
<a id="ga743fcbbe87613ad86f844f5fbe07e2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga743fcbbe87613ad86f844f5fbe07e2e3">&#9670;&nbsp;</a></span>canBuild <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex, bool canBuild_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, <a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, canBuild_ &gt;::canBuild = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether this boundary component class supports triangulating boundary components. </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<a id="ga2f4309f2e7b617da85e6585e198dab58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f4309f2e7b617da85e6585e198dab58">&#9670;&nbsp;</a></span>canBuild <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool allFaces, bool allowVertex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentStorage.html">regina::detail::BoundaryComponentStorage</a>&lt; dim, <a class="el" href="group__detail.html#ga695616fda7f4a0360ce6b94458a879c8">allFaces</a>, <a class="el" href="group__detail.html#gae2259be5e070ee6a88808f21026a8e2e">allowVertex</a>, false &gt;::canBuild = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant indicating whether this boundary component class supports triangulating boundary components. </p>
<p>This is a compile-time constant only, with no linkage - any attempt to create a reference or pointer to it will give a linker error. </p>

</div>
</div>
<a id="ga4ea7ef789765f01c7b6268e5627bf242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ea7ef789765f01c7b6268e5627bf242">&#9670;&nbsp;</a></span>dim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings</a>&lt; dim_ &gt;::dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string that gives the dimension <em>dim</em> as a number. </p>
<p>An example for <em>dim</em> = 3 is "3". </p>

</div>
</div>
<a id="gaa177dda3276927267a3ae0130765a6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa177dda3276927267a3ae0130765a6f1">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant that gives the dimension of the triangulation. </p>

</div>
</div>
<a id="ga877171328c1fd9a7cf682fa82aa5d4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga877171328c1fd9a7cf682fa82aa5d4ab">&#9670;&nbsp;</a></span>edgeNumber <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 3, 1, true &gt;::edgeNumber[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table that maps vertices of a tetrahedron to edge numbers. </p>
<p>Edges in a tetrahedron are numbered 0,...,5. This table converts vertices to edge numbers; in particular, the edge joining vertices <em>i</em> and <em>j</em> of a tetrahedron is edge number <code>edgeNumber[i][j]</code>. Here <em>i</em> and <em>j</em> must be distinct, must be between 0 and 3 inclusive, and may be given in any order. The resulting edge number will be between 0 and 5 inclusive.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing <code>edgeNumber[i][j]</code> is equivalent to calling <code>faceNumber(p)</code>, where <em>p</em> is a permutation that maps 0,1 to <em>i</em>,<em>j</em> in some order. </dd></dl>

</div>
</div>
<a id="ga91840579e8e12130cd43671271bf87ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91840579e8e12130cd43671271bf87ed">&#9670;&nbsp;</a></span>edgeNumber <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 1, true &gt;::edgeNumber[5][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table that maps vertices of a pentachoron to edge numbers. </p>
<p>Edges in a pentachoron are numbered 0,...,9. This table converts vertices to edge numbers; in particular, the edge joining vertices <em>i</em> and <em>j</em> of a pentachoron is edge number <code>edgeNumber[i][j]</code>. Here <em>i</em> and <em>j</em> must be distinct, must be between 0 and 4 inclusive, and may be given in any order. The resulting edge number will be between 0 and 9 inclusive.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing <code>edgeNumber[i][j]</code> is equivalent to calling <code>faceNumber(p)</code>, where <em>p</em> is a permutation that maps 0,1 to <em>i</em>,<em>j</em> in some order. </dd></dl>

</div>
</div>
<a id="ga2fb616ff04b0862dbd9f98323b05275e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb616ff04b0862dbd9f98323b05275e">&#9670;&nbsp;</a></span>edgeVertex <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 1, true &gt;::edgeVertex[10][2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table that maps edges of a pentachoron to vertex numbers. </p>
<p>Edges in a pentachoron are numbered 0,...,9. This table converts edge numbers to vertices; in particular, edge <em>i</em> in a pentachoron joins vertices <code>edgeVertex[i][0]</code> and <code>edgeVertex[i][1]</code>. Here <em>i</em> must be between 0 and 9 inclusive; the resulting vertex numbers will be between 0 and 4 inclusive.</p>
<p>It is guaranteed that <code>edgeVertex[i][0]</code> will always be smaller than <code>edgeVertex[i][1]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing <code>edgeVertex[i][j]</code> is equivalent to calling <code>ordering(i)[j]</code>. </dd></dl>

</div>
</div>
<a id="ga1e898cc5186d8191017763dc299bc5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e898cc5186d8191017763dc299bc5b4">&#9670;&nbsp;</a></span>edgeVertex <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 3, 1, true &gt;::edgeVertex[6][2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table that maps edges of a tetrahedron to vertex numbers. </p>
<p>Edges in a tetrahedron are numbered 0,...,5. This table converts edge numbers to vertices; in particular, edge <em>i</em> in a tetrahedron joins vertices <code>edgeVertex[i][0]</code> and <code>edgeVertex[i][1]</code>. Here <em>i</em> must be bewteen 0 and 5 inclusive; the resulting vertex numbers will be between 0 and 3 inclusive.</p>
<p>It is guaranteed that <code>edgeVertex[i][0]</code> will always be smaller than <code>edgeVertex[i][1]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing <code>edgeVertex[i][j]</code> is equivalent to calling <code>ordering(i)[j]</code>. </dd></dl>

</div>
</div>
<a id="ga7790e75ecfe5dbc2767e5eb98b666ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7790e75ecfe5dbc2767e5eb98b666ba9">&#9670;&nbsp;</a></span>face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings</a>&lt; dim_ &gt;::face</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string that gives the name of a <em>dim</em>-face, all in lower case. </p>
<p>An example for <em>dim</em> = 3 is "tetrahedron". An example for <em>dim</em> = 7 is "7-face". </p>

</div>
</div>
<a id="ga7e35cef0bb3781117debcbe0e83ce03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e35cef0bb3781117debcbe0e83ce03d">&#9670;&nbsp;</a></span>Face</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings</a>&lt; dim_ &gt;::<a class="el" href="classregina_1_1Face.html">Face</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string that gives the name of a <em>dim</em>-face, with the first word capitalised. </p>
<p>An example for <em>dim</em> = 3 is "Tetrahedron". An example for <em>dim</em> = 7 is "7-face". </p>

</div>
</div>
<a id="gab1f62c40c2775c7d2d03412925c5a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1f62c40c2775c7d2d03412925c5a2bf">&#9670;&nbsp;</a></span>face_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;* <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::face_[<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The faces of the underlying triangulation that form the individual <em>subdim</em>-faces of this simplex. </p>

</div>
</div>
<a id="ga4f55617b786f4756eb088fc991536278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f55617b786f4756eb088fc991536278">&#9670;&nbsp;</a></span>faces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings</a>&lt; dim_ &gt;::faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string that gives the plural name of a <em>dim</em>-face, all in lower case. </p>
<p>An example for <em>dim</em> = 3 is "tetrahedra". An example for <em>dim</em> = 7 is "7-faces". </p>

</div>
</div>
<a id="gaac21414f54259a5efc3dc0b8a4350142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac21414f54259a5efc3dc0b8a4350142">&#9670;&nbsp;</a></span>Faces</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings</a>&lt; dim_ &gt;::Faces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string that gives the plural name of a <em>dim</em>-face, with the first word capitalised. </p>
<p>An example for <em>dim</em> = 3 is "Tetrahedra". An example for <em>dim</em> = 7 is "7-faces". </p>

</div>
</div>
<a id="ga7a9e624f86239df884711385ff208eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a9e624f86239df884711385ff208eb2">&#9670;&nbsp;</a></span>faces_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;*&gt; <a class="el" href="classregina_1_1detail_1_1WeakFaceList.html">regina::detail::WeakFaceList</a>&lt; dim, subdim &gt;::faces_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The list of faces. </p>

</div>
</div>
<a id="ga6f897c95d4c464b5c56ed5a370b1fd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f897c95d4c464b5c56ed5a370b1fd5f">&#9670;&nbsp;</a></span>facetPerm_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt;* <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::facetPerm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The permutation applied to the facets of each source simplex. </p>
<p>This array has size nSimplices_. </p>

</div>
</div>
<a id="ga0a4a6bcc51b669d96a730f2a16aa2728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a4a6bcc51b669d96a730f2a16aa2728">&#9670;&nbsp;</a></span>facets_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, dim-1&gt;*&gt; <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::facets_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of all (dim-1)-simplices in the boundary component. </p>

</div>
</div>
<a id="gad0b08af7c20829b137cd1840cc4f2022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0b08af7c20829b137cd1840cc4f2022">&#9670;&nbsp;</a></span>mapping_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::mapping_[<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each <em>subdim</em>-face of this simplex, maps vertices (0,1,...,<em>subdim</em>) of the underlying <em>subdim</em>-face of the triangulation to the corresponding vertices of this simplex, as described by faceMapping(). </p>

</div>
</div>
<a id="ga4cdd4377e3549620d4c90f967729df88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cdd4377e3549620d4c90f967729df88">&#9670;&nbsp;</a></span>nFaces <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim, bool lex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; dim, subdim, lex &gt;::nFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            FaceNumberingImpl&lt;dim - 1, subdim - 1, lex&gt;<a class="code" href="group__detail.html#ga4cdd4377e3549620d4c90f967729df88">::nFaces</a> +</div>
<div class="line">            FaceNumberingImpl&lt;dim - 1, subdim,</div>
<div class="line">                (dim &gt;= 2 * (subdim + 1))&gt;<a class="code" href="group__detail.html#ga4cdd4377e3549620d4c90f967729df88">::nFaces</a></div>
<div class="ttc" id="agroup__detail_html_ga4cdd4377e3549620d4c90f967729df88"><div class="ttname"><a href="group__detail.html#ga4cdd4377e3549620d4c90f967729df88">regina::detail::FaceNumberingImpl::nFaces</a></div><div class="ttdeci">static constexpr int nFaces</div><div class="ttdoc">The total number of subdim-dimensional faces in each dim-dimensional simplex.</div><div class="ttdef"><b>Definition:</b> facenumbering.h:212</div></div>
</div><!-- fragment -->
<p>The total number of <em>subdim</em>-dimensional faces in each <em>dim</em>-dimensional simplex. </p>

</div>
</div>
<a id="ga86d9ebb9486886520057d3a1314a2048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86d9ebb9486886520057d3a1314a2048">&#9670;&nbsp;</a></span>nFaces <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; dim, subdim, false &gt;::nFaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            FaceNumberingImpl&lt;dim, dim - subdim - 1, <span class="keyword">true</span>&gt;<a class="code" href="group__detail.html#ga86d9ebb9486886520057d3a1314a2048">::nFaces</a></div>
<div class="ttc" id="agroup__detail_html_ga86d9ebb9486886520057d3a1314a2048"><div class="ttname"><a href="group__detail.html#ga86d9ebb9486886520057d3a1314a2048">regina::detail::FaceNumberingImpl&lt; dim, subdim, false &gt;::nFaces</a></div><div class="ttdeci">static constexpr int nFaces</div><div class="ttdoc">The total number of subdim-dimensional faces in each dim-dimensional simplex.</div><div class="ttdef"><b>Definition:</b> facenumbering.h:405</div></div>
</div><!-- fragment -->
<p>The total number of <em>subdim</em>-dimensional faces in each <em>dim</em>-dimensional simplex. </p>

</div>
</div>
<a id="gabea9bb5ad05839b9754d37db00330ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabea9bb5ad05839b9754d37db00330ffc">&#9670;&nbsp;</a></span>nFaces <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; dim, 0, true &gt;::nFaces = dim + 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of vertices in each <em>dim</em>-dimensional simplex. </p>

</div>
</div>
<a id="ga72e9bde1d818124634239fa08b97ddcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e9bde1d818124634239fa08b97ddcb">&#9670;&nbsp;</a></span>nFaces <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 1, 0, true &gt;::nFaces = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of vertices in each edge. </p>

</div>
</div>
<a id="gabfcdb70e7b91bd5f9fb3397c909f7376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfcdb70e7b91bd5f9fb3397c909f7376">&#9670;&nbsp;</a></span>nFaces <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 2, 0, true &gt;::nFaces = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of vertices in each triangle. </p>

</div>
</div>
<a id="ga561d3baacf7d62429bfaf54c74ac5620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga561d3baacf7d62429bfaf54c74ac5620">&#9670;&nbsp;</a></span>nFaces <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 2, 1, false &gt;::nFaces = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in each triangle. </p>

</div>
</div>
<a id="ga6f9178658917428c841e5b7037bd6fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9178658917428c841e5b7037bd6fac">&#9670;&nbsp;</a></span>nFaces <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 3, 0, true &gt;::nFaces = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of vertices in each tetrahedron. </p>

</div>
</div>
<a id="ga6a16a5a64c9968e42e2fab8fa6a276da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a16a5a64c9968e42e2fab8fa6a276da">&#9670;&nbsp;</a></span>nFaces <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 3, 1, true &gt;::nFaces = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in each tetrahedron. </p>

</div>
</div>
<a id="ga951e2f7720dd304d302851530555cf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga951e2f7720dd304d302851530555cf55">&#9670;&nbsp;</a></span>nFaces <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 3, 2, false &gt;::nFaces = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of triangles in each tetrahedron. </p>

</div>
</div>
<a id="gadb57d403ea32c9b1c2b37cef6ac524a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb57d403ea32c9b1c2b37cef6ac524a4">&#9670;&nbsp;</a></span>nFaces <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 0, true &gt;::nFaces = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of vertices in each pentachoron. </p>

</div>
</div>
<a id="ga42109270ca84f6b0c758857778ca0d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42109270ca84f6b0c758857778ca0d75">&#9670;&nbsp;</a></span>nFaces <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 1, true &gt;::nFaces = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of edges in each pentachoron. </p>

</div>
</div>
<a id="ga953ee94de3460062fe72c90ca5d46b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga953ee94de3460062fe72c90ca5d46b43">&#9670;&nbsp;</a></span>nFaces <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 2, false &gt;::nFaces = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of triangles in each pentachoron. </p>

</div>
</div>
<a id="gaffab7483c82d7fdbda006de9a4511a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffab7483c82d7fdbda006de9a4511a37">&#9670;&nbsp;</a></span>nFaces <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 3, false &gt;::nFaces = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The total number of tetrahedra in each pentachoron. </p>

</div>
</div>
<a id="ga5239cb90bcbf7e12bbebc2f731645e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5239cb90bcbf7e12bbebc2f731645e60">&#9670;&nbsp;</a></span>nRidges_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1BoundaryComponentFaceStorage.html">regina::detail::BoundaryComponentFaceStorage</a>&lt; dim, false &gt;::nRidges_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of (dim-2)-faces in the boundary component. </p>

</div>
</div>
<a id="ga85e2edc9a84b4f7bb1afc4636f86222b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e2edc9a84b4f7bb1afc4636f86222b">&#9670;&nbsp;</a></span>nSimplices_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::nSimplices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of simplices in the source triangulation. </p>

</div>
</div>
<a id="gaa836bb693c00ec5ceed9f9fa8b1404e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa836bb693c00ec5ceed9f9fa8b1404e1">&#9670;&nbsp;</a></span>orientable_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1BoundaryComponentBase.html">regina::detail::BoundaryComponentBase</a>&lt; dim &gt;::orientable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this boundary component orientable? </p>

</div>
</div>
<a id="gaee05ce55cfad3b49aae171e5baa4a5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee05ce55cfad3b49aae171e5baa4a5e0">&#9670;&nbsp;</a></span>pairs_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::pairs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The other facet to which each simplex facet is paired. </p>
<p>If a simplex facet is left unmatched, the corresponding element of this array will be boundary (as returned by <a class="el" href="group__triangulation.html#gaa8f49fbc941f1150c7109c7b2aedfe08" title="Determines if this specifier represents the overall boundary.">FacetSpec&lt;dim&gt;::isBoundary()</a>). If the destination for a particular facet has not yet been decided, the facet will be paired to itself. </p>

</div>
</div>
<a id="gaec8b9b5acd02cbd669cdfdd5d3bb0631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8b9b5acd02cbd669cdfdd5d3bb0631">&#9670;&nbsp;</a></span>simpImage_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1detail_1_1IsomorphismBase.html">regina::detail::IsomorphismBase</a>&lt; dim &gt;::simpImage_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the simplex of the destination triangulation that each simplex of the source triangulation maps to. </p>
<p>This array has size nSimplices_. </p>

</div>
</div>
<a id="ga183b7a36759cba046d255dc8e3ba055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga183b7a36759cba046d255dc8e3ba055a">&#9670;&nbsp;</a></span>simplex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings</a>&lt; dim_ &gt;::simplex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string that gives the name of a <em>dim</em>-simplex, all in lower case. </p>
<p>An example for <em>dim</em> = 3 is "tetrahedron". An example for <em>dim</em> = 7 is "7-simplex". </p>

</div>
</div>
<a id="ga3ed2ac79d147176672e6cdc9e09267c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ed2ac79d147176672e6cdc9e09267c6">&#9670;&nbsp;</a></span>Simplex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="structregina_1_1detail_1_1Strings.html">regina::detail::Strings</a>&lt; dim_ &gt;::<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A string that gives the name of a <em>dim</em>-simplex, with the first word capitalised. </p>
<p>An example for <em>dim</em> = 3 is "Tetrahedron". An example for <em>dim</em> = 7 is "7-simplex". </p>

</div>
</div>
<a id="ga1739e33bdbb5c52cb77de81ec93c1ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1739e33bdbb5c52cb77de81ec93c1ec8">&#9670;&nbsp;</a></span>simplices_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::simplices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The top-dimensional simplices that form the triangulation. </p>

</div>
</div>
<a id="ga663cb963d4d177f69ec39c7f7409d278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga663cb963d4d177f69ec39c7f7409d278">&#9670;&nbsp;</a></span>size_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1FacetPairingBase.html">regina::detail::FacetPairingBase</a>&lt; dim &gt;::size_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of simplices under consideration. </p>

</div>
</div>
<a id="ga100785957f37cd392acc3ab420d44928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga100785957f37cd392acc3ab420d44928">&#9670;&nbsp;</a></span>topologyLock_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::topologyLock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If non-zero, this will cause Triangulation&lt;dim&gt;::clearAllProperties() to preserve any computed properties that related to the manifold (as opposed to the specific triangulation). </p>
<p>This allows you to avoid recomputing expensive invariants when the underlying manifold is retriangulated.</p>
<p>This property should be managed by creating and destroying <a class="el" href="classregina_1_1detail_1_1TriangulationBase_1_1TopologyLock.html" title="Creates a temporary lock on the topological properties of the given triangulation.">TopologyLock</a> objects. The precise value of topologyLock_ indicates the number of <a class="el" href="classregina_1_1detail_1_1TriangulationBase_1_1TopologyLock.html" title="Creates a temporary lock on the topological properties of the given triangulation.">TopologyLock</a> objects that currently exist for this triangulation. </p>

</div>
</div>
<a id="gaa698ed74854bbf07083babe002b9ef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa698ed74854bbf07083babe002b9ef2d">&#9670;&nbsp;</a></span>tri_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1XMLTriangulationReaderBase.html">regina::detail::XMLTriangulationReaderBase</a>&lt; dim &gt;::tri_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation currently being read. </p>

</div>
</div>
<a id="gac3ccaec69e1f90488bf9049359619987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3ccaec69e1f90488bf9049359619987">&#9670;&nbsp;</a></span>triangleNumber</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 2, false &gt;::triangleNumber[5][5][5]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table that maps vertices of a pentachoron to triangle numbers. </p>
<p>Triangles in a pentachoron are numbered 0,...,9. This table converts vertices to triangle numbers; in particular, the triangle spanned by vertices <em>i</em>, <em>j</em> and <em>k</em> of a pentachoron is triangle number <code>triangleNumber[i][j][k]</code>. Here <em>i</em>, <em>j</em> and <em>k</em> must be distinct, must be between 0 and 4 inclusive, and may be given in any order. The resulting triangle number will be between 0 and 9 inclusive.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing <code>triangleNumber[i][j][k]</code> is equivalent to calling <code>faceNumber(p)</code>, where <em>p</em> is a permutation that maps 0,1,2 to <em>i</em>,<em>j</em>,<em>k</em> in some order. </dd></dl>

</div>
</div>
<a id="ga1f560f0f9b54225b09656f55759c19b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f560f0f9b54225b09656f55759c19b8">&#9670;&nbsp;</a></span>triangleVertex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classregina_1_1detail_1_1FaceNumberingImpl.html">regina::detail::FaceNumberingImpl</a>&lt; 4, 2, false &gt;::triangleVertex[10][3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A table that maps triangles of a pentachoron to vertex numbers. </p>
<p>Triangles in a pentachoron are numbered 0,...,9. This table converts triangle numbers to vertices; in particular, triangle <em>i</em> in a pentachoron is spanned by vertices <code>triangleVertex[i][0]</code>, <code>triangleVertex[i][1]</code> and <code>triangleVertex[i][2]</code>. Here <em>i</em> must be between 0 and 9 inclusive; the resulting vertex numbers will be between 0 and 4 inclusive.</p>
<p>It is guaranteed that <code>triangleVertex[i][0]</code> will always be smaller than <code>triangleVertex[i][1]</code>, which in turn will always be smaller than <code>triangleVertex[i][2]</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing <code>triangleVertex[i][j]</code> is equivalent to calling <code>ordering(i)[j]</code>. </dd></dl>

</div>
</div>
<a id="gaafd43bf111d0354a3e490a44e651cff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafd43bf111d0354a3e490a44e651cff8">&#9670;&nbsp;</a></span>valid_ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1ComponentBase.html">regina::detail::ComponentBase</a>&lt; dim &gt;::valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this component valid? See <a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">Triangulation&lt;dim&gt;::isValid()</a> for details on what this means. </p>

</div>
</div>
<a id="ga106dc9d8ffc9e2bd1dd35ad35d52773c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga106dc9d8ffc9e2bd1dd35ad35d52773c">&#9670;&nbsp;</a></span>valid_ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; dim &gt;::valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this triangulation valid? See <a class="el" href="group__detail.html#gab6cf08805f1b496f644e75c1a0b34dde" title="Determines if this triangulation is valid.">isValid()</a> for details on what this means. </p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="ga4ac4dded60d8f6ec4e40d49ca37e9057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ac4dded60d8f6ec4e40d49ca37e9057">&#9670;&nbsp;</a></span>Triangulation&lt; dim &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow access to private members. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
