<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::GroupExpression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1GroupExpression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::GroupExpression Class Reference<div class="ingroups"><a class="el" href="group__algebra.html">Algebraic Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents an expression involving generators from a group presentation or a free group.  
 <a href="classregina_1_1GroupExpression.html#details">More...</a></p>

<p><code>#include &lt;algebra/grouppresentation.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::GroupExpression:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1GroupExpression.png" usemap="#regina::GroupExpression_map" alt=""/>
  <map id="regina::GroupExpression_map" name="regina::GroupExpression_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; GroupExpression &gt;" shape="rect" coords="0,56,248,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; GroupExpression, false &gt;" shape="rect" coords="0,0,248,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc1d5b73995d9fb27c1b73edaac73c08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#acc1d5b73995d9fb27c1b73edaac73c08">GroupExpression</a> ()</td></tr>
<tr class="memdesc:acc1d5b73995d9fb27c1b73edaac73c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The terms that make up this expression.  <a href="#acc1d5b73995d9fb27c1b73edaac73c08">More...</a><br/></td></tr>
<tr class="separator:acc1d5b73995d9fb27c1b73edaac73c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1ef15ecb594dd2f4476ff01fcb3279"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a1d1ef15ecb594dd2f4476ff01fcb3279">GroupExpression</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a1d1ef15ecb594dd2f4476ff01fcb3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new expression that is a clone of the given expression.  <a href="#a1d1ef15ecb594dd2f4476ff01fcb3279">More...</a><br/></td></tr>
<tr class="separator:a1d1ef15ecb594dd2f4476ff01fcb3279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291e0dae5c33b29993d9952ac7199fa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a291e0dae5c33b29993d9952ac7199fa3">GroupExpression</a> (const std::string &amp;input, bool *valid=NULL)</td></tr>
<tr class="memdesc:a291e0dae5c33b29993d9952ac7199fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to interpret the given input string as a word in a group.  <a href="#a291e0dae5c33b29993d9952ac7199fa3">More...</a><br/></td></tr>
<tr class="separator:a291e0dae5c33b29993d9952ac7199fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3cd2751f1338ff162806d290861dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a2c3cd2751f1338ff162806d290861dff">operator=</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a2c3cd2751f1338ff162806d290861dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this expression a clone of the given expression.  <a href="#a2c3cd2751f1338ff162806d290861dff">More...</a><br/></td></tr>
<tr class="separator:a2c3cd2751f1338ff162806d290861dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8aace9edb5adaaca2f9f16a8746d62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#aca8aace9edb5adaaca2f9f16a8746d62">operator==</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;comp) const </td></tr>
<tr class="memdesc:aca8aace9edb5adaaca2f9f16a8746d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#aca8aace9edb5adaaca2f9f16a8746d62">More...</a><br/></td></tr>
<tr class="separator:aca8aace9edb5adaaca2f9f16a8746d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00ebcf5c646c289453a73d109e50004"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#ac00ebcf5c646c289453a73d109e50004">operator!=</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;comp) const </td></tr>
<tr class="memdesc:ac00ebcf5c646c289453a73d109e50004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator.  <a href="#ac00ebcf5c646c289453a73d109e50004">More...</a><br/></td></tr>
<tr class="separator:ac00ebcf5c646c289453a73d109e50004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7107330382d76de56540ef1e5ec986e"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#ab7107330382d76de56540ef1e5ec986e">terms</a> ()</td></tr>
<tr class="memdesc:ab7107330382d76de56540ef1e5ec986e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the list of terms in this expression.  <a href="#ab7107330382d76de56540ef1e5ec986e">More...</a><br/></td></tr>
<tr class="separator:ab7107330382d76de56540ef1e5ec986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfdcf967a4154993232f79f58d22670"><td class="memItemLeft" align="right" valign="top">const std::list<br class="typebreak"/>
&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a1dfdcf967a4154993232f79f58d22670">terms</a> () const </td></tr>
<tr class="memdesc:a1dfdcf967a4154993232f79f58d22670"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the list of terms in this expression.  <a href="#a1dfdcf967a4154993232f79f58d22670">More...</a><br/></td></tr>
<tr class="separator:a1dfdcf967a4154993232f79f58d22670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa07c2b3a1a0f49b5a07fa968ce6543"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#acfa07c2b3a1a0f49b5a07fa968ce6543">countTerms</a> () const </td></tr>
<tr class="memdesc:acfa07c2b3a1a0f49b5a07fa968ce6543"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of terms in this expression.  <a href="#acfa07c2b3a1a0f49b5a07fa968ce6543">More...</a><br/></td></tr>
<tr class="separator:acfa07c2b3a1a0f49b5a07fa968ce6543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9755f4027e8b14da1d72cf5c7fe92163"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a9755f4027e8b14da1d72cf5c7fe92163">wordLength</a> () const </td></tr>
<tr class="memdesc:a9755f4027e8b14da1d72cf5c7fe92163"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the length of the word, i.e.  <a href="#a9755f4027e8b14da1d72cf5c7fe92163">More...</a><br/></td></tr>
<tr class="separator:a9755f4027e8b14da1d72cf5c7fe92163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92232d4003a424a25d6b056e826d8622"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a92232d4003a424a25d6b056e826d8622">isTrivial</a> () const </td></tr>
<tr class="memdesc:a92232d4003a424a25d6b056e826d8622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this is the trivial (unit) word.  <a href="#a92232d4003a424a25d6b056e826d8622">More...</a><br/></td></tr>
<tr class="separator:a92232d4003a424a25d6b056e826d8622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4e343e87b3c1b157a97292651e1d25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#aad4e343e87b3c1b157a97292651e1d25">erase</a> ()</td></tr>
<tr class="memdesc:aad4e343e87b3c1b157a97292651e1d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all terms from this this word.  <a href="#aad4e343e87b3c1b157a97292651e1d25">More...</a><br/></td></tr>
<tr class="separator:aad4e343e87b3c1b157a97292651e1d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5eaab7ecde7ceff9428853e17106fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#ae5eaab7ecde7ceff9428853e17106fe9">term</a> (size_t index)</td></tr>
<tr class="memdesc:ae5eaab7ecde7ceff9428853e17106fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the term at the given index in this expression.  <a href="#ae5eaab7ecde7ceff9428853e17106fe9">More...</a><br/></td></tr>
<tr class="separator:ae5eaab7ecde7ceff9428853e17106fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cd067b31b5105b22c0878fed21f3e6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a85cd067b31b5105b22c0878fed21f3e6">term</a> (size_t index) const </td></tr>
<tr class="memdesc:a85cd067b31b5105b22c0878fed21f3e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the term at the given index in this expression.  <a href="#a85cd067b31b5105b22c0878fed21f3e6">More...</a><br/></td></tr>
<tr class="separator:a85cd067b31b5105b22c0878fed21f3e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9506bbfbe8067915154f5e188d76ef65"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a9506bbfbe8067915154f5e188d76ef65">generator</a> (size_t index) const </td></tr>
<tr class="memdesc:a9506bbfbe8067915154f5e188d76ef65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the generator corresonding to the term at the given index in this expression.  <a href="#a9506bbfbe8067915154f5e188d76ef65">More...</a><br/></td></tr>
<tr class="separator:a9506bbfbe8067915154f5e188d76ef65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b048bfaa82e79dc71824bd7be9ca0d2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a7b048bfaa82e79dc71824bd7be9ca0d2">exponent</a> (size_t index) const </td></tr>
<tr class="memdesc:a7b048bfaa82e79dc71824bd7be9ca0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the exponent corresonding to the term at the given index in this expression.  <a href="#a7b048bfaa82e79dc71824bd7be9ca0d2">More...</a><br/></td></tr>
<tr class="separator:a7b048bfaa82e79dc71824bd7be9ca0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a2753d395ab5cb3089cb09ec637d86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a29a2753d395ab5cb3089cb09ec637d86">addTermFirst</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;<a class="el" href="classregina_1_1GroupExpression.html#ae5eaab7ecde7ceff9428853e17106fe9">term</a>)</td></tr>
<tr class="memdesc:a29a2753d395ab5cb3089cb09ec637d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the beginning of this expression.  <a href="#a29a2753d395ab5cb3089cb09ec637d86">More...</a><br/></td></tr>
<tr class="separator:a29a2753d395ab5cb3089cb09ec637d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe441455a1744f9b5a02cc0fa20bfcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#adfe441455a1744f9b5a02cc0fa20bfcf">addTermFirst</a> (unsigned long <a class="el" href="classregina_1_1GroupExpression.html#a9506bbfbe8067915154f5e188d76ef65">generator</a>, long <a class="el" href="classregina_1_1GroupExpression.html#a7b048bfaa82e79dc71824bd7be9ca0d2">exponent</a>)</td></tr>
<tr class="memdesc:adfe441455a1744f9b5a02cc0fa20bfcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the beginning of this expression.  <a href="#adfe441455a1744f9b5a02cc0fa20bfcf">More...</a><br/></td></tr>
<tr class="separator:adfe441455a1744f9b5a02cc0fa20bfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372453b28e949d4ddacd682fb655cbda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a372453b28e949d4ddacd682fb655cbda">addTermLast</a> (const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;<a class="el" href="classregina_1_1GroupExpression.html#ae5eaab7ecde7ceff9428853e17106fe9">term</a>)</td></tr>
<tr class="memdesc:a372453b28e949d4ddacd682fb655cbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the end of this expression.  <a href="#a372453b28e949d4ddacd682fb655cbda">More...</a><br/></td></tr>
<tr class="separator:a372453b28e949d4ddacd682fb655cbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539c39976a30b6836a750ffb57fd4d90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a539c39976a30b6836a750ffb57fd4d90">addTermLast</a> (unsigned long <a class="el" href="classregina_1_1GroupExpression.html#a9506bbfbe8067915154f5e188d76ef65">generator</a>, long <a class="el" href="classregina_1_1GroupExpression.html#a7b048bfaa82e79dc71824bd7be9ca0d2">exponent</a>)</td></tr>
<tr class="memdesc:a539c39976a30b6836a750ffb57fd4d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given term to the end of this expression.  <a href="#a539c39976a30b6836a750ffb57fd4d90">More...</a><br/></td></tr>
<tr class="separator:a539c39976a30b6836a750ffb57fd4d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9d2537788e2b9ca4019a9ed62bf695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#ade9d2537788e2b9ca4019a9ed62bf695">addTermsFirst</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;word)</td></tr>
<tr class="memdesc:ade9d2537788e2b9ca4019a9ed62bf695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the left by the given word.  <a href="#ade9d2537788e2b9ca4019a9ed62bf695">More...</a><br/></td></tr>
<tr class="separator:ade9d2537788e2b9ca4019a9ed62bf695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8411bb87da43d3b5e4d2d7573b1600a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#aa8411bb87da43d3b5e4d2d7573b1600a">addTermsLast</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;word)</td></tr>
<tr class="memdesc:aa8411bb87da43d3b5e4d2d7573b1600a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the right by the given word.  <a href="#aa8411bb87da43d3b5e4d2d7573b1600a">More...</a><br/></td></tr>
<tr class="separator:aa8411bb87da43d3b5e4d2d7573b1600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e06fa7de1208569484895d832274a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#afe1e06fa7de1208569484895d832274a">addStringFirst</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:afe1e06fa7de1208569484895d832274a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the left by the word respresented by the given string.  <a href="#afe1e06fa7de1208569484895d832274a">More...</a><br/></td></tr>
<tr class="separator:afe1e06fa7de1208569484895d832274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe11d45edbdfe2ed3915a2fd2203560d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#afe11d45edbdfe2ed3915a2fd2203560d">addStringLast</a> (const std::string &amp;input)</td></tr>
<tr class="memdesc:afe11d45edbdfe2ed3915a2fd2203560d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this expression on the right by the word respresented by the given string.  <a href="#afe11d45edbdfe2ed3915a2fd2203560d">More...</a><br/></td></tr>
<tr class="separator:afe11d45edbdfe2ed3915a2fd2203560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688406ed1ec6e9f3dfd4f31a220729c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a688406ed1ec6e9f3dfd4f31a220729c4">cycleRight</a> ()</td></tr>
<tr class="memdesc:a688406ed1ec6e9f3dfd4f31a220729c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles this word by moving the leftmost term around to the rightmost.  <a href="#a688406ed1ec6e9f3dfd4f31a220729c4">More...</a><br/></td></tr>
<tr class="separator:a688406ed1ec6e9f3dfd4f31a220729c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30471b33e30035e299ebfae316519d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a30471b33e30035e299ebfae316519d0c">cycleLeft</a> ()</td></tr>
<tr class="memdesc:a30471b33e30035e299ebfae316519d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cycles this word by moving the rightmost term around to the leftmost.  <a href="#a30471b33e30035e299ebfae316519d0c">More...</a><br/></td></tr>
<tr class="separator:a30471b33e30035e299ebfae316519d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e212a2a87e1ac6c738aa422764b3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a49e212a2a87e1ac6c738aa422764b3b7">inverse</a> () const </td></tr>
<tr class="memdesc:a49e212a2a87e1ac6c738aa422764b3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is the inverse of this expression.  <a href="#a49e212a2a87e1ac6c738aa422764b3b7">More...</a><br/></td></tr>
<tr class="separator:a49e212a2a87e1ac6c738aa422764b3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e65aaa150201d3df9fd6199d136d63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a7e65aaa150201d3df9fd6199d136d63e">invert</a> ()</td></tr>
<tr class="memdesc:a7e65aaa150201d3df9fd6199d136d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts this expression.  <a href="#a7e65aaa150201d3df9fd6199d136d63e">More...</a><br/></td></tr>
<tr class="separator:a7e65aaa150201d3df9fd6199d136d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d79606e759a9fcb4fd0656c85fddbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a02d79606e759a9fcb4fd0656c85fddbb">power</a> (long <a class="el" href="classregina_1_1GroupExpression.html#a7b048bfaa82e79dc71824bd7be9ca0d2">exponent</a>) const </td></tr>
<tr class="memdesc:a02d79606e759a9fcb4fd0656c85fddbb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is this expression raised to the given power.  <a href="#a02d79606e759a9fcb4fd0656c85fddbb">More...</a><br/></td></tr>
<tr class="separator:a02d79606e759a9fcb4fd0656c85fddbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77e1f2423da57b6bd93984762691bf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#ae77e1f2423da57b6bd93984762691bf2">simplify</a> (bool cyclic=false)</td></tr>
<tr class="memdesc:ae77e1f2423da57b6bd93984762691bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplifies this expression.  <a href="#ae77e1f2423da57b6bd93984762691bf2">More...</a><br/></td></tr>
<tr class="separator:ae77e1f2423da57b6bd93984762691bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc5f90b79dc0a50956c1737ac350c0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a5dc5f90b79dc0a50956c1737ac350c0b">substitute</a> (unsigned long <a class="el" href="classregina_1_1GroupExpression.html#a9506bbfbe8067915154f5e188d76ef65">generator</a>, const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;expansion, bool cyclic=false)</td></tr>
<tr class="memdesc:a5dc5f90b79dc0a50956c1737ac350c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces every occurrence of the given generator with the given substite expression.  <a href="#a5dc5f90b79dc0a50956c1737ac350c0b">More...</a><br/></td></tr>
<tr class="separator:a5dc5f90b79dc0a50956c1737ac350c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb857be545baea7461d1fa85d66b1d7c"><td class="memItemLeft" align="right" valign="top">std::list&lt; std::map&lt; unsigned <br class="typebreak"/>
long, <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#adb857be545baea7461d1fa85d66b1d7c">relabellingsThisToOther</a> (const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;other, bool cyclic=false) const </td></tr>
<tr class="memdesc:adb857be545baea7461d1fa85d66b1d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not one can relabel the generators in this word to obtain the given other word.  <a href="#adb857be545baea7461d1fa85d66b1d7c">More...</a><br/></td></tr>
<tr class="separator:adb857be545baea7461d1fa85d66b1d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2a4dd9297165fdd22e4c0808f4feb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#aa5f2a4dd9297165fdd22e4c0808f4feb">writeXMLData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:aa5f2a4dd9297165fdd22e4c0808f4feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this expression.  <a href="#aa5f2a4dd9297165fdd22e4c0808f4feb">More...</a><br/></td></tr>
<tr class="separator:aa5f2a4dd9297165fdd22e4c0808f4feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7982637cca598530d44860ec8910ec1e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a7982637cca598530d44860ec8910ec1e">toTeX</a> () const </td></tr>
<tr class="memdesc:a7982637cca598530d44860ec8910ec1e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this expression.  <a href="#a7982637cca598530d44860ec8910ec1e">More...</a><br/></td></tr>
<tr class="separator:a7982637cca598530d44860ec8910ec1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c921e277741966233921b16add0eff7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a4c921e277741966233921b16add0eff7">writeTeX</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a4c921e277741966233921b16add0eff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a TeX represesentation of this expression to the given output stream.  <a href="#a4c921e277741966233921b16add0eff7">More...</a><br/></td></tr>
<tr class="separator:a4c921e277741966233921b16add0eff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503a5bd133e62363cc396066f164baf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a503a5bd133e62363cc396066f164baf9">writeText</a> (std::ostream &amp;out, bool shortword=false, bool <a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a>=false) const </td></tr>
<tr class="memdesc:a503a5bd133e62363cc396066f164baf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a text representation of this expression to the given output stream, using either numbered generators or alphabetic generators.  <a href="#a503a5bd133e62363cc396066f164baf9">More...</a><br/></td></tr>
<tr class="separator:a503a5bd133e62363cc396066f164baf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd34230a09df04eaa577d2c4acec41b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1GroupExpression.html#a9fd34230a09df04eaa577d2c4acec41b">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a9fd34230a09df04eaa577d2c4acec41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a9fd34230a09df04eaa577d2c4acec41b">More...</a><br/></td></tr>
<tr class="separator:a9fd34230a09df04eaa577d2c4acec41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#afb6c9df60a4ebe89115cd80eb683cf58">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afb6c9df60a4ebe89115cd80eb683cf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="#afb6c9df60a4ebe89115cd80eb683cf58">More...</a><br/></td></tr>
<tr class="separator:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an expression involving generators from a group presentation or a free group. </p>
<p>An expression is represented as word, i.e, a sequence of powers of generators all of which are multiplied in order. Each power of a generator corresponds to an individual <a class="el" href="structregina_1_1GroupExpressionTerm.html" title="Represents a power of a generator in a group presentation.">GroupExpressionTerm</a>.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> contains the three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acc1d5b73995d9fb27c1b73edaac73c08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The terms that make up this expression. </p>
<p>Creates a new expression with no terms. </p>

</div>
</div>
<a class="anchor" id="a1d1ef15ecb594dd2f4476ff01fcb3279"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new expression that is a clone of the given expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the expression to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a291e0dae5c33b29993d9952ac7199fa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::GroupExpression::GroupExpression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>valid</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to interpret the given input string as a word in a group. </p>
<p>Regina can recognise strings in the following four basic forms:</p>
<ul>
<li><code>a^7b^-2</code> </li>
<li><code>aaaaaaaBB</code> </li>
<li><code>a^7B^2</code> </li>
<li><code>g0^7g1^-2</code> </li>
</ul>
<p>The string may contain whitespace, which will simply be ignored.</p>
<p>The argument <em>valid</em> may be <code>null</code>, but if it is non-null then the boolean it points to will be used for error reporting. This routine sets valid to <code>true</code> if the string was successfully interpreted, or <code>false</code> if the algorithm failed to interpret the string.</p>
<p>Regardless of whether <em>valid</em> is <code>null</code>, if the string could not be interpreted then this expression will be initialised to the trivial word.</p>
<dl class="section user"><dt>Python:</dt><dd>The second argument <em>valid</em> is not present, and will be assumed to be <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the input string that is to be interpreted. </td></tr>
    <tr><td class="paramname">valid</td><td>used for error reporting as described above, or <code>null</code> if no error reporting is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="afe1e06fa7de1208569484895d832274a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::addStringFirst </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the left by the word respresented by the given string. </p>
<p>See the string-based constructor <a class="el" href="classregina_1_1GroupExpression.html#a291e0dae5c33b29993d9952ac7199fa3" title="Attempts to interpret the given input string as a word in a group.">GroupExpression(const std::string&amp;, bool*)</a> for further information on how this string should be formatted.</p>
<p>If the given string cannot be interpreted as a word in a group, then this expression will be left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a string representation of the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given string could interpreted (and therefore the multiplication was completed successfully), or <code>false</code> if the given string could not be interpreted (in which case this expression will be left untouched). </dd></dl>

</div>
</div>
<a class="anchor" id="afe11d45edbdfe2ed3915a2fd2203560d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::addStringLast </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the right by the word respresented by the given string. </p>
<p>See the string-based constructor <a class="el" href="classregina_1_1GroupExpression.html#a291e0dae5c33b29993d9952ac7199fa3" title="Attempts to interpret the given input string as a word in a group.">GroupExpression(const std::string&amp;, bool*)</a> for further information on how this string should be formatted.</p>
<p>If the given string cannot be interpreted as a word in a group, then this expression will be left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a string representation of the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given string could interpreted (and therefore the multiplication was completed successfully), or <code>false</code> if the given string could not be interpreted (in which case this expression will be left untouched). </dd></dl>

</div>
</div>
<a class="anchor" id="a29a2753d395ab5cb3089cb09ec637d86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the beginning of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfe441455a1744f9b5a02cc0fa20bfcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermFirst </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the beginning of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the number of the generator corresponding to the new term. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent to which the given generator is raised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a372453b28e949d4ddacd682fb655cbda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermLast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the end of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a539c39976a30b6836a750ffb57fd4d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermLast </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given term to the end of this expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the number of the generator corresponding to the new term. </td></tr>
    <tr><td class="paramname">exponent</td><td>the exponent to which the given generator is raised. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade9d2537788e2b9ca4019a9ed62bf695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermsFirst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the left by the given word. </p>
<p>This expression will be modified directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8411bb87da43d3b5e4d2d7573b1600a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::addTermsLast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies this expression on the right by the given word. </p>
<p>This expression will be modified directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the word to multiply with this expression. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfa07c2b3a1a0f49b5a07fa968ce6543"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupExpression::countTerms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of terms in this expression. </p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> contains three terms. See also <a class="el" href="classregina_1_1GroupExpression.html#a9755f4027e8b14da1d72cf5c7fe92163" title="Returns the length of the word, i.e.">wordLength()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of terms. </dd></dl>

</div>
</div>
<a class="anchor" id="a30471b33e30035e299ebfae316519d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::cycleLeft </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycles this word by moving the rightmost term around to the leftmost. </p>
<p>All other terms shift one step to the right.</p>
<p>If the word is of the form <code>g_i1^j1 g_i2^j2 ... g_in^jn</code>, this converts it into the word <code>g_in^jn g_i1^j1 g_i1^j1 ... g_in-1^jn-1</code>. </p>

</div>
</div>
<a class="anchor" id="a688406ed1ec6e9f3dfd4f31a220729c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::cycleRight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cycles this word by moving the leftmost term around to the rightmost. </p>
<p>All other terms shift one step to the left.</p>
<p>If the word is of the form <code>g_i1^j1 g_i2^j2 ... g_in^jn</code>, this converts it into the word <code>g_i2^j2 ... g_in^jn g_i1^j1</code>. </p>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aad4e343e87b3c1b157a97292651e1d25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::erase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases all terms from this this word. </p>
<p>This effectively turns this word into the identity element. </p>

</div>
</div>
<a class="anchor" id="a7b048bfaa82e79dc71824bd7be9ca0d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::GroupExpression::exponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the exponent corresonding to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="classregina_1_1GroupExpression.html#acfa07c2b3a1a0f49b5a07fa968ce6543" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested exponent. </dd></dl>

</div>
</div>
<a class="anchor" id="a9506bbfbe8067915154f5e188d76ef65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::GroupExpression::generator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the generator corresonding to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="classregina_1_1GroupExpression.html#acfa07c2b3a1a0f49b5a07fa968ce6543" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the requested generator. </dd></dl>

</div>
</div>
<a class="anchor" id="a49e212a2a87e1ac6c738aa422764b3b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>* regina::GroupExpression::inverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is the inverse of this expression. </p>
<p>The terms will be reversed and the exponents negated.</p>
<dl class="section return"><dt>Returns</dt><dd>the inverse of this expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e65aaa150201d3df9fd6199d136d63e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts this expression. </p>
<p>Does not allocate or deallocate anything. </p>

</div>
</div>
<a class="anchor" id="a92232d4003a424a25d6b056e826d8622"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::isTrivial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this is the trivial (unit) word. </p>
<p>No attempt is made to remove redundant terms (so the word <code>g g^-1</code> will be treated as non-trivial).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is the trivial word. </dd></dl>

</div>
</div>
<a class="anchor" id="ac00ebcf5c646c289453a73d109e50004"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator. </p>
<p>Checks to see whether or not these two words represent different literal strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the expression to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given string literal are not identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3cd2751f1338ff162806d290861dff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp; regina::GroupExpression::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this expression a clone of the given expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the expression to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aca8aace9edb5adaaca2f9f16a8746d62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Checks to see whether or not these two words represent the same literal string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>the expression to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given string literal are identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a02d79606e759a9fcb4fd0656c85fddbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a>* regina::GroupExpression::power </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>exponent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created expression that is this expression raised to the given power. </p>
<p>Note that the given exponent may be positive, zero or negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exponent</td><td>the power to which this expression should be raised. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this expression raised to the given power. </dd></dl>

</div>
</div>
<a class="anchor" id="adb857be545baea7461d1fa85d66b1d7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; std::map&lt; unsigned long, <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &gt; regina::GroupExpression::relabellingsThisToOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cyclic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not one can relabel the generators in this word to obtain the given other word. </p>
<p>If so, returns a non-empty list of all such relabellings. If not, returns an empty list.</p>
<p>Relabellings are partially-defined permutations on the generator set, also allowing for possible inversions if cyclic is <code>true</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Change this to use less heavyweight types and less deep copying.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>cyclic</em> is <code>true</code>, then both this word and <em>other</em> have been cyclically reduced.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the word to compare against this. </td></tr>
    <tr><td class="paramname">cyclic</td><td>if <code>false</code> we get a list of exact relabellings from this word to <em>other</em>. If <code>true</code>, it can be up to cyclic permutation and inversion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of permutations, implemented as maps from generator indices of this word to generator indices of <em>other</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae77e1f2423da57b6bd93984762691bf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::simplify </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cyclic</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplifies this expression. </p>
<p>Adjacent powers of the same generator will be combined, and terms with an exponent of zero will be removed. Note that it is <em>not</em> assumed that the underlying group is abelian.</p>
<p>You may declare that the expression is cyclic, in which case it is assumed that terms may be moved from the back to the front and vice versa. Thus expression <code>g1 g2 g1 g2 g1</code> simplifies to <code>g1^2 g2 g1 g2</code> if it is cyclic, but does not simplify at all if it is not cyclic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cyclic</td><td><code>true</code> if and only if the expression may be assumed to be cyclic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this expression was changed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc5f90b79dc0a50956c1737ac350c0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::GroupExpression::substitute </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> &amp;&#160;</td>
          <td class="paramname"><em>expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cyclic</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces every occurrence of the given generator with the given substite expression. </p>
<p>If the given generator was found, the expression will be simplified once the substitution is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">generator</td><td>the generator to be replaced. </td></tr>
    <tr><td class="paramname">expansion</td><td>the substitute expression that will replace every occurrence of the given generator. </td></tr>
    <tr><td class="paramname">cyclic</td><td><code>true</code> if and only if the expression may be assumed to be cyclic; see <a class="el" href="classregina_1_1GroupExpression.html#ae77e1f2423da57b6bd93984762691bf2" title="Simplifies this expression.">simplify()</a> for further details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if any substitutions were made. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5eaab7ecde7ceff9428853e17106fe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a>&amp; regina::GroupExpression::term </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="classregina_1_1GroupExpression.html#acfa07c2b3a1a0f49b5a07fa968ce6543" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested term. </dd></dl>

</div>
</div>
<a class="anchor" id="a85cd067b31b5105b22c0878fed21f3e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a>&amp; regina::GroupExpression::term </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the term at the given index in this expression. </p>
<p>Index 0 represents the first term, index 1 represents the second term and so on.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>O(n)</em> where <em>n</em> is the number of terms in this expression.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present; only the non-const version of this routine is available.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the term to return; this must be between 0 and <a class="el" href="classregina_1_1GroupExpression.html#acfa07c2b3a1a0f49b5a07fa968ce6543" title="Returns the number of terms in this expression.">countTerms()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested term. </dd></dl>

</div>
</div>
<a class="anchor" id="ab7107330382d76de56540ef1e5ec986e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp; regina::GroupExpression::terms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the list of terms in this expression. </p>
<p>These are the actual terms stored internally; any modifications made to this list will show up in the expression itself.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> has list consisting of three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present; only the const version of this routine is available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of terms. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dfdcf967a4154993232f79f58d22670"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::list&lt; <a class="el" href="structregina_1_1GroupExpressionTerm.html">GroupExpressionTerm</a> &gt; &amp; regina::GroupExpression::terms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a constant reference to the list of terms in this expression. </p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> has list consisting of three terms <code>g1^2</code>, <code>g3^-1</code> and <code>g6^1</code> in that order.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list of copied <a class="el" href="structregina_1_1GroupExpressionTerm.html" title="Represents a power of a generator in a group presentation.">GroupExpressionTerm</a> objects. In particular, modifying this list or the terms within it will not modify the group expression from which they came.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of terms. </dd></dl>

</div>
</div>
<a class="anchor" id="a7982637cca598530d44860ec8910ec1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::GroupExpression::toTeX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a TeX representation of this expression. </p>
<p>See <a class="el" href="classregina_1_1GroupExpression.html#a4c921e277741966233921b16add0eff7" title="Writes a TeX represesentation of this expression to the given output stream.">writeTeX()</a> for details on how this is formed.</p>
<dl class="section return"><dt>Returns</dt><dd>a TeX representation of this expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a9755f4027e8b14da1d72cf5c7fe92163"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::GroupExpression::wordLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the length of the word, i.e. </p>
<p>the number of letters with exponent +1 or -1 for which this word is expressable as a product.</p>
<p>For instance, the expression <code>g1^2 g3^-1 g6</code> is a word of length four. See also <a class="el" href="classregina_1_1GroupExpression.html#acfa07c2b3a1a0f49b5a07fa968ce6543" title="Returns the number of terms in this expression.">countTerms()</a>.</p>
<p>No attempt is made to remove redundant terms (so the word <code>g g^-1</code> will count as length two).</p>
<dl class="section return"><dt>Returns</dt><dd>the length of the word. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c921e277741966233921b16add0eff7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeTeX </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a TeX represesentation of this expression to the given output stream. </p>
<p>The text representation will be of the form <code>g_2^4 g_{13}^{-5} g_4</code>.</p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a503a5bd133e62363cc396066f164baf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeText </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortword</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a text representation of this expression to the given output stream, using either numbered generators or alphabetic generators. </p>
<p>The text representation will be of the form <code>g2^4 g13^-5 g4</code>. If the <em>shortword</em> flag is <code>true</code>, it will assume your word is in an alphabet of no more than 26 letters, and will write the word using lower-case ASCII, i.e., <code>c^4 n^-5 e</code>. If the <em>utf8</em> flag is <code>true</code>, all exponents will be written using superscript characters encoded in UTF-8.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>shortword</em> is <code>true</code>, the number of generators in the corresponding group must be 26 or fewer.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">shortword</td><td>indicates whether to use numbered or alphabetic generators, as described above. </td></tr>
    <tr><td class="paramname">utf8</td><td><code>true</code> if exponents should be written using unicode superscript characters, or <code>false</code> if they should be written using a caret (^) symbol. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb6c9df60a4ebe89115cd80eb683cf58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1GroupExpression.html">GroupExpression</a> , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fd34230a09df04eaa577d2c4acec41b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>The text representation will be of the form <code>g2^4 g13^-5 g4</code>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5f2a4dd9297165fdd22e4c0808f4feb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::GroupExpression::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this expression. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>algebra/<a class="el" href="grouppresentation_8h.html">grouppresentation.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
