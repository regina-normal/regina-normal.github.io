<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::LPInitialTableaux&lt; LPConstraint &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1LPInitialTableaux-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::LPInitialTableaux&lt; LPConstraint &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__enumerate.html">Vertex Enumeration</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation, in sparse form.  
 <a href="classregina_1_1LPInitialTableaux.html#details">More...</a></p>

<p><code>#include &lt;enumerate/treelp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abe983e975f8883df9f512622f43ccaf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#abe983e975f8883df9f512622f43ccaf3">LPInitialTableaux</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *<a class="el" href="classregina_1_1LPInitialTableaux.html#aa3c878d36aceccf7a104e7b72b7f9a99">tri</a>, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1LPInitialTableaux.html#a15c66a19d6a2037cef94b004ecbde3df">coords</a>, bool enumeration)</td></tr>
<tr class="memdesc:abe983e975f8883df9f512622f43ccaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construts this adjusted sparse matrix of matching equations.  <a href="#abe983e975f8883df9f512622f43ccaf3">More...</a><br /></td></tr>
<tr class="separator:abe983e975f8883df9f512622f43ccaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9e1d9717a1363524eb40fd75f81f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a6d9e1d9717a1363524eb40fd75f81f23">~LPInitialTableaux</a> ()</td></tr>
<tr class="memdesc:a6d9e1d9717a1363524eb40fd75f81f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this matrix.  <a href="#a6d9e1d9717a1363524eb40fd75f81f23">More...</a><br /></td></tr>
<tr class="separator:a6d9e1d9717a1363524eb40fd75f81f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c878d36aceccf7a104e7b72b7f9a99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#aa3c878d36aceccf7a104e7b72b7f9a99">tri</a> () const</td></tr>
<tr class="memdesc:aa3c878d36aceccf7a104e7b72b7f9a99"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the underlying 3-manifold triangulation from which the matching equations were derived.  <a href="#aa3c878d36aceccf7a104e7b72b7f9a99">More...</a><br /></td></tr>
<tr class="separator:aa3c878d36aceccf7a104e7b72b7f9a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c66a19d6a2037cef94b004ecbde3df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a15c66a19d6a2037cef94b004ecbde3df">coords</a> () const</td></tr>
<tr class="memdesc:a15c66a19d6a2037cef94b004ecbde3df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system that is used for the matrix of matching equations.  <a href="#a15c66a19d6a2037cef94b004ecbde3df">More...</a><br /></td></tr>
<tr class="separator:a15c66a19d6a2037cef94b004ecbde3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bc3370dbf2b873b65d37e4d0cb2ccf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a15bc3370dbf2b873b65d37e4d0cb2ccf">rank</a> () const</td></tr>
<tr class="memdesc:a15bc3370dbf2b873b65d37e4d0cb2ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of this matrix.  <a href="#a15bc3370dbf2b873b65d37e4d0cb2ccf">More...</a><br /></td></tr>
<tr class="separator:a15bc3370dbf2b873b65d37e4d0cb2ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55f15c0bf782905c9749f3e0a4c7767"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#ac55f15c0bf782905c9749f3e0a4c7767">columns</a> () const</td></tr>
<tr class="memdesc:ac55f15c0bf782905c9749f3e0a4c7767"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix.  <a href="#ac55f15c0bf782905c9749f3e0a4c7767">More...</a><br /></td></tr>
<tr class="separator:ac55f15c0bf782905c9749f3e0a4c7767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad311a7137ce157d3aacce9f0d7158eff"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#ad311a7137ce157d3aacce9f0d7158eff">coordinateColumns</a> () const</td></tr>
<tr class="memdesc:ad311a7137ce157d3aacce9f0d7158eff"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns that correspond to normal coordinates or angle structure coordinates.  <a href="#ad311a7137ce157d3aacce9f0d7158eff">More...</a><br /></td></tr>
<tr class="separator:ad311a7137ce157d3aacce9f0d7158eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93944a288a1ad231acb0adda4532ce4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#aa93944a288a1ad231acb0adda4532ce4">constraintsBroken</a> () const</td></tr>
<tr class="memdesc:aa93944a288a1ad231acb0adda4532ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully.  <a href="#aa93944a288a1ad231acb0adda4532ce4">More...</a><br /></td></tr>
<tr class="separator:aa93944a288a1ad231acb0adda4532ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e37e376183084bd90d4d4f19466015"><td class="memItemLeft" align="right" valign="top">const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a16e37e376183084bd90d4d4f19466015">columnPerm</a> () const</td></tr>
<tr class="memdesc:a16e37e376183084bd90d4d4f19466015"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutation that describes how the columns of the matching equation matrix were reordered.  <a href="#a16e37e376183084bd90d4d4f19466015">More...</a><br /></td></tr>
<tr class="separator:a16e37e376183084bd90d4d4f19466015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351acbaa960c9dc0bb6c58cd947a544d"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a351acbaa960c9dc0bb6c58cd947a544d"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a351acbaa960c9dc0bb6c58cd947a544d">multColByRow</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow, unsigned thisCol) const</td></tr>
<tr class="memdesc:a351acbaa960c9dc0bb6c58cd947a544d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix.  <a href="#a351acbaa960c9dc0bb6c58cd947a544d">More...</a><br /></td></tr>
<tr class="separator:a351acbaa960c9dc0bb6c58cd947a544d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ddc39309b9839190b5be4ec894fcc1"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:a87ddc39309b9839190b5be4ec894fcc1"><td class="memTemplItemLeft" align="right" valign="top">IntType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#a87ddc39309b9839190b5be4ec894fcc1">multColByRowOct</a> (const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m, unsigned mRow, unsigned thisCol) const</td></tr>
<tr class="memdesc:a87ddc39309b9839190b5be4ec894fcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="classregina_1_1LPInitialTableaux.html#a351acbaa960c9dc0bb6c58cd947a544d" title="Computes the inner product of (i) the given row of the given matrix with (ii) the given column of thi...">multColByRow()</a> that takes into account any adjustments to the tableaux that are required when this is a quadrilateral column being used to represent an octagon type.  <a href="#a87ddc39309b9839190b5be4ec894fcc1">More...</a><br /></td></tr>
<tr class="separator:a87ddc39309b9839190b5be4ec894fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16772af7dc89a65a3547bab10c4e6b1"><td class="memTemplParams" colspan="2">template&lt;typename IntType &gt; </td></tr>
<tr class="memitem:aa16772af7dc89a65a3547bab10c4e6b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1LPInitialTableaux.html#aa16772af7dc89a65a3547bab10c4e6b1">fillInitialTableaux</a> (<a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;m) const</td></tr>
<tr class="memdesc:aa16772af7dc89a65a3547bab10c4e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given matrix with the contents of this matrix.  <a href="#aa16772af7dc89a65a3547bab10c4e6b1">More...</a><br /></td></tr>
<tr class="separator:aa16772af7dc89a65a3547bab10c4e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dda040b565a8e653b81d2d150909426"><td class="memItemLeft" align="right" valign="top"><a id="a9dda040b565a8e653b81d2d150909426"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LPInitialTableaux</b> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;)=delete</td></tr>
<tr class="separator:a9dda040b565a8e653b81d2d150909426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81951ea4aeaf1b5e83e01c3cd84d53aa"><td class="memItemLeft" align="right" valign="top"><a id="a81951ea4aeaf1b5e83e01c3cd84d53aa"></a>
<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> &amp;)=delete</td></tr>
<tr class="separator:a81951ea4aeaf1b5e83e01c3cd84d53aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class LPConstraint&gt;<br />
class regina::LPInitialTableaux&lt; LPConstraint &gt;</h3>

<p>Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation, in sparse form. </p>
<p>Typically these will be the normal surface matching equations in some coordinate system, or the angle structure equations.</p>
<p>This class forms part of the tree traversal algorithms for enumerating and locating normal surfaces, as described in "A tree traversal algorithm
for decision problems in knot theory and 3-manifold topology", Burton and Ozlen, Algorithmica 65:4 (2013), pp. 772-801, and "A fast branching algorithm for unknot recognition with
experimental polynomial-time behaviour", Burton and Ozlen, arXiv:1211.1079. It is also used for locating a single strict angle structure, and for enumerating all taut angle structures.</p>
<p>The adjustments (which are all carried out in the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> class constructor) are as follows:</p>
<ul>
<li>the rows of the matching equation matrix have been reordered so that the first <a class="el" href="classregina_1_1LPInitialTableaux.html#a15bc3370dbf2b873b65d37e4d0cb2ccf" title="Returns the rank of this matrix.">rank()</a> rows are full rank;</li>
<li>the columns of the matching equation matrix have been reordered according to the permutation returned by <a class="el" href="classregina_1_1LPInitialTableaux.html#a16e37e376183084bd90d4d4f19466015" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">columnPerm()</a>. This is a heuristic reordering designed to improve the performance of the tree traversal algorithm; see <a class="el" href="classregina_1_1LPInitialTableaux.html#a16e37e376183084bd90d4d4f19466015" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">columnPerm()</a> for a list of constraints that such a reordering must satisfy.</li>
</ul>
<p>There is also optional support for adding extra linear constraints (such as a constraint on Euler characteristic for normal surfaces). These extra constraints are supplied by the template parameter <em>LPConstraint</em>, and will generate LPConstraint::nConstraints additional rows and columns (used by the additional variables that evaluate the corresponding linear functions). If there are no additional constraints, simply use the template parameter <a class="el" href="classregina_1_1LPConstraintNone.html" title="A do-nothing class that imposes no additional linear constraints on the tableaux of normal surface or...">LPConstraintNone</a>.</p>
<p>In some cases, it may be impossible to add the extra linear constraints that you would like (for instance, the constraints might require some preconditions on the underlying triangulation that are not met). If this is a possibility in your setting, you should call <a class="el" href="classregina_1_1LPInitialTableaux.html#aa93944a288a1ad231acb0adda4532ce4" title="Indicates whether or not the extra constraints from the template parameter LPConstraints were added s...">constraintsBroken()</a> to test this as soon as the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> has been constructed. Even if the constraints could not be added correctly, the tableaux will be left in a consistent state (the constraints will just be treated as zero functions instead).</p>
<p>This class is optimised for working with <em>columns</em> of the matrix (in particular, multiplying columns of this matrix by rows of some other matrix).</p>
<p>This class can only work in quadrilateral normal coordinates (NS_QUAD), standard normal coordinates (NS_STANDARD), or angle structure coordinates (NS_ANGLE). No other coordinate systems are supported.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation of this class relies on the fact that the sum of <em>absolute values</em> of all coefficients in each column is at most four (not counting the rows for any optional extra constraints). If you are extending this class to work with more general matching equation matrices, you may need to change the implementation accordingly.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The template parameter LPConstraint must be one of the subclasses of <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a>. See the <a class="el" href="classregina_1_1LPConstraintBase.html" title="A base class for additional linear constraints that we can add to the tableaux of normal surface or a...">LPConstraintBase</a> class notes for further details.</dd></dl>
<dl class="section user"><dt>Headers</dt><dd>Parts of this template class are implemented in a separate header (treelp-impl.h), which is not included automatically by this file. Most end users should not need this extra header, since Regina's calculation engine already includes explicit instantiations for common combinations of template arguments.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The API for this class has not yet been finalised. This means that the class interface may change in new versions of Regina, without maintaining backward compatibility. If you use this class directly in your own code, please watch the detailed changelogs upon new releases to see if you need to make changes to your code.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abe983e975f8883df9f512622f43ccaf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe983e975f8883df9f512622f43ccaf3">&#9670;&nbsp;</a></span>LPInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enumeration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construts this adjusted sparse matrix of matching equations. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given triangulation is non-empty.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri</td><td>the underlying 3-manifold triangulation. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to use for the matrix of matching equations; this must be one of NS_QUAD, NS_STANDARD, or NS_ANGLE. </td></tr>
    <tr><td class="paramname">enumeration</td><td><code>true</code> if we should optimise the tableaux for a full enumeration of vertex surfaces or taut angle structures, or <code>false</code> if we should optimise the tableaux for an existence test (such as searching for a non-trivial normal disc or sphere, or a strict angle structure). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d9e1d9717a1363524eb40fd75f81f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9e1d9717a1363524eb40fd75f81f23">&#9670;&nbsp;</a></span>~LPInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::~<a class="el" href="classregina_1_1LPInitialTableaux.html">LPInitialTableaux</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a16e37e376183084bd90d4d4f19466015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e37e376183084bd90d4d4f19466015">&#9670;&nbsp;</a></span>columnPerm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int * <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::columnPerm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the permutation that describes how the columns of the matching equation matrix were reordered. </p>
<p>This permutation maps column numbers in this adjusted matching equation matrix to column numbers in the original (unmodified) matching equation matrix that was originally derived from the triangulation.</p>
<p>The permutation is returned as an array of <a class="el" href="classregina_1_1LPInitialTableaux.html#ac55f15c0bf782905c9749f3e0a4c7767" title="Returns the number of columns in this matrix.">columns()</a> integers, such that column <em>i</em> of this adjusted matrix corresponds to column <code><a class="el" href="classregina_1_1LPInitialTableaux.html#a16e37e376183084bd90d4d4f19466015" title="Returns the permutation that describes how the columns of the matching equation matrix were reordered...">columnPerm()</a>[i]</code> of the original matrix.</p>
<p>If you are imposing additional constraints through the template parameter LPConstraint, then the corresponding extra variables will be included in the permutation; however, these are never moved and will always remain the rightmost variables in this system (i.e., the columns of highest index).</p>
<p>As well as the requirement that this is a genuine permutation of 0,...,<a class="el" href="classregina_1_1LPInitialTableaux.html#ac55f15c0bf782905c9749f3e0a4c7767" title="Returns the number of columns in this matrix.">columns()</a>-1, this array will also adhere to the following constraints. In the following discussion, <em>n</em> refers to the number of tetrahedra in the underlying triangulation.</p>
<ul>
<li>The quadrilateral coordinate columns must appear as the first 3<em>n</em> columns of the adjusted matrix. In particular, when working in the 7<em>n</em>-dimensional standard normal coordinate system, the remaining 4<em>n</em> triangle coordinate columns must appear last.</li>
<li>The quadrilateral coordinate columns must be grouped by tetrahedron and ordered by quadrilateral type. In other words, for each <em>i</em> = 0,...,<em>n-1</em>, there will be some tetrahedron <em>j</em> for which the three columns 3<em>i</em>, 3<em>i</em>+1 and 3<em>i</em>+2 refer to the quadrilaterals in tetrahedron <em>j</em> of types 0, 1 and 2 respectively. Phrased loosely, we are allowed to reorder the tetrahedra, but not the quadrilateral coordinates within each tetrahedron.</li>
<li>The triangle coordinate columns (if we are working in standard normal coordinates) must likewise be grouped by tetrahedron, and these tetrahedra must appear in the same order as for the quadrilateral types. In other words, for each <em>i</em> = 0,...,<em>n-1</em>, the quadrilateral columns 3<em>i</em>, 3<em>i</em>+1 and 3<em>i</em>+2 and the triangle columns 3<em>n</em>+4<em>i</em>, 3<em>n</em>+4<em>i</em>+1, 3<em>n</em>+4<em>i</em>+2 and 3<em>n</em>+4<em>i</em>+3 all refer to the same tetrahedron.</li>
<li>For angle structure coordinates, the constraints are analogous to those for quadrilateral coordinates: the angle coordinates must be grouped by tetrahedron and ordered by angle type, and the final scaling coordinate must remain last.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>details of the permutation describing how columns were reordered. </dd></dl>

</div>
</div>
<a id="ac55f15c0bf782905c9749f3e0a4c7767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55f15c0bf782905c9749f3e0a4c7767">&#9670;&nbsp;</a></span>columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::columns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns in this matrix. </p>
<p>Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the number of columns will be larger than in the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of columns. </dd></dl>

</div>
</div>
<a id="aa93944a288a1ad231acb0adda4532ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93944a288a1ad231acb0adda4532ce4">&#9670;&nbsp;</a></span>constraintsBroken()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::constraintsBroken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether or not the extra constraints from the template parameter <em>LPConstraints</em> were added successfully. </p>
<p>This query function is important because some constraints require additional preconditions on the underlying triangulation, and cannot be added if these preconditions are not satisfied.</p>
<p>Even if the extra constraints were not added successfully, this tableaux will be left in a consistent state (the extra constraints will be treated as zero functions). See the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> class notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the constraints were <em>not</em> added successfully, or <code>false</code> if the constraints were added successfully. </dd></dl>

</div>
</div>
<a id="ad311a7137ce157d3aacce9f0d7158eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad311a7137ce157d3aacce9f0d7158eff">&#9670;&nbsp;</a></span>coordinateColumns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::coordinateColumns </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of columns that correspond to normal coordinates or angle structure coordinates. </p>
<p>This is precisely the number of columns in the original matrix of matching equations.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of normal or angle structure coordinate columns. </dd></dl>

</div>
</div>
<a id="a15c66a19d6a2037cef94b004ecbde3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c66a19d6a2037cef94b004ecbde3df">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system that is used for the matrix of matching equations. </p>
<p>This will be the same coordinate system that was passed to the <a class="el" href="classregina_1_1LPInitialTableaux.html" title="Stores an adjusted matrix of homogeneous linear matching equations based on a given triangulation,...">LPInitialTableaux</a> constructor; in particular, it will always be one of NS_QUAD, NS_STANDARD, or NS_ANGLE.</p>
<dl class="section return"><dt>Returns</dt><dd>the coordinate system. </dd></dl>

</div>
</div>
<a id="aa16772af7dc89a65a3547bab10c4e6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16772af7dc89a65a3547bab10c4e6b1">&#9670;&nbsp;</a></span>fillInitialTableaux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::fillInitialTableaux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given matrix with the contents of this matrix. </p>
<p>This effectively copies this sparse but highly specialised matrix representation into a dense but more flexible matrix representation.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix has already been initialised to size <a class="el" href="classregina_1_1LPInitialTableaux.html#a15bc3370dbf2b873b65d37e4d0cb2ccf" title="Returns the rank of this matrix.">rank()</a> * <a class="el" href="classregina_1_1LPInitialTableaux.html#ac55f15c0bf782905c9749f3e0a4c7767" title="Returns the number of columns in this matrix.">columns()</a>, and all of its elements have already been set to zero. Note that this can all be arranged by calling the constructor <a class="el" href="classregina_1_1LPMatrix.html#acd286b6b0f9ea3176934d00b8c1cc0c8" title="Creates a fully initialised rows by cols matrix with all elements set to zero.">LPMatrix::LPMatrix(unsigned, unsigned)</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix to fill. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a351acbaa960c9dc0bb6c58cd947a544d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351acbaa960c9dc0bb6c58cd947a544d">&#9670;&nbsp;</a></span>multColByRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::multColByRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>thisCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix. </p>
<p>This routine is optimised to use the sparse representation of columns in this matrix.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix <em>m</em> has precisely <a class="el" href="classregina_1_1LPInitialTableaux.html#a15bc3370dbf2b873b65d37e4d0cb2ccf" title="Returns the rank of this matrix.">rank()</a> columns.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the inner product. </td></tr>
    <tr><td class="paramname">thisCol</td><td>the column of this matrix to use in the inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting inner product. </dd></dl>

</div>
</div>
<a id="a87ddc39309b9839190b5be4ec894fcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ddc39309b9839190b5be4ec894fcc1">&#9670;&nbsp;</a></span>multColByRowOct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<div class="memtemplate">
template&lt;typename IntType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntType <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::multColByRowOct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1LPMatrix.html">LPMatrix</a>&lt; IntType &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>mRow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>thisCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="classregina_1_1LPInitialTableaux.html#a351acbaa960c9dc0bb6c58cd947a544d" title="Computes the inner product of (i) the given row of the given matrix with (ii) the given column of thi...">multColByRow()</a> that takes into account any adjustments to the tableaux that are required when this is a quadrilateral column being used to represent an octagon type. </p>
<p>The <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class offers support for octagonal almost normal surfaces, in which exactly one tetrahedron is allowed to have exactly one octagon type. We represent such an octagon as a <em>pair</em> of incompatible quadrilaterals within the same tetrahedron. See the <a class="el" href="classregina_1_1LPData.html" title="Stores an intermediate tableaux for the dual simplex method, and contains all of the core machinery f...">LPData</a> class notes for details on how this works.</p>
<p>In some settings where we are using additional constraints through the template parameter LPConstraint, these extra constraints behave differently in the presence of octagons (i.e., the coefficient of the octagon type is not just the sum of coefficients of the two constituent quadrilateral types). This routine effectively allows us to adjust the tableaux accordingly.</p>
<p>Specifically: this routine computes the inner product of (i) the given row of the given matrix with (ii) the given column of this matrix. We assume that the given column of this matrix describes one of the two quadrilateral coordinates in some tetrahedron that together form an octagon type, and (via the helper routine LPConstraint::Coefficients::innerProductOct) we implicitly adjust the coefficients of our extra constraints accordingly.</p>
<p>This routine is optimised to use the sparse representation of columns in this matrix.</p>
<p>This routine is not used with angle structure coordinates.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given matrix <em>m</em> has precisely <a class="el" href="classregina_1_1LPInitialTableaux.html#a15bc3370dbf2b873b65d37e4d0cb2ccf" title="Returns the rank of this matrix.">rank()</a> columns.</dd>
<dd>
Column <em>thisCol</em> of this matrix describes one of the two quadrilateral coordinates that are being combined to form an octagon type within some tetrahedron.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix whose row we will use in the adjusted inner product. </td></tr>
    <tr><td class="paramname">mRow</td><td>the row of the matrix <em>m</em> to use in the adjusted inner product. </td></tr>
    <tr><td class="paramname">thisCol</td><td>the column of this matrix to use in the adjusted inner product. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting adjusted inner product. </dd></dl>

</div>
</div>
<a id="a15bc3370dbf2b873b65d37e4d0cb2ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bc3370dbf2b873b65d37e4d0cb2ccf">&#9670;&nbsp;</a></span>rank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the rank of this matrix. </p>
<p>Note that, if we are imposing extra constraints through the template parameter LPConstraint, then there will be extra variables to enforce these, and so the rank will be larger than the rank of the original matching equation matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix rank. </dd></dl>

</div>
</div>
<a id="aa3c878d36aceccf7a104e7b72b7f9a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c878d36aceccf7a104e7b72b7f9a99">&#9670;&nbsp;</a></span>tri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class LPConstraint &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1LPInitialTableaux.html">regina::LPInitialTableaux</a>&lt; LPConstraint &gt;::tri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the underlying 3-manifold triangulation from which the matching equations were derived. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>enumerate/<a class="el" href="treeconstraint_8h.html">treeconstraint.h</a></li>
<li>enumerate/<a class="el" href="treelp_8h.html">treelp.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
