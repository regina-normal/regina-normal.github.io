<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Treewidth</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Treewidth</div>  </div>
</div><!--header-->
<div class="contents">

<p>Treewidth and tree decompositions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeBag.html">regina::TreeBag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single bag in a tree decomposition.  <a href="classregina_1_1TreeBag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1TreeDecomposition.html">regina::TreeDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a tree decomposition of a graph.  <a href="classregina_1_1TreeDecomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1TreeDecomposition_1_1Graph.html">regina::TreeDecomposition::Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a graph, which may be directed or undirected.  <a href="structregina_1_1TreeDecomposition_1_1Graph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac5bb9725db7b18445ed440c84302590e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gac5bb9725db7b18445ed440c84302590e">regina::NTreeBag</a></td></tr>
<tr class="memdesc:gac5bb9725db7b18445ed440c84302590e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__treewidth.html#gac5bb9725db7b18445ed440c84302590e">More...</a><br /></td></tr>
<tr class="separator:gac5bb9725db7b18445ed440c84302590e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f4ba871638d41a90b5796bf5bd4e8f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga59f4ba871638d41a90b5796bf5bd4e8f">regina::NTreeDecomposition</a></td></tr>
<tr class="memdesc:ga59f4ba871638d41a90b5796bf5bd4e8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__treewidth.html#ga59f4ba871638d41a90b5796bf5bd4e8f">More...</a><br /></td></tr>
<tr class="separator:ga59f4ba871638d41a90b5796bf5bd4e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf0dd75ca695140e2bf801cbc355f036f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">regina::TreeDecompositionAlg</a> { <a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">regina::TD_UPPER</a> = 0x0001
, <a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fa04cee26abfb715aa4a16017e323e573a">regina::TD_UPPER_GREEDY_FILL_IN</a> = 0x0001
 }</td></tr>
<tr class="memdesc:gaf0dd75ca695140e2bf801cbc355f036f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which algorithm should be used to compute a tree decomposition of a graph.  <a href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">More...</a><br /></td></tr>
<tr class="separator:gaf0dd75ca695140e2bf801cbc355f036f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe2b2e10a78a855612c2f1322923a974"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gafe2b2e10a78a855612c2f1322923a974">regina::BagComparison</a> { <a class="el" href="group__treewidth.html#ggafe2b2e10a78a855612c2f1322923a974aaae6e6eeabe1420eb0312722700f59bf">regina::BAG_EQUAL</a> = 0
, <a class="el" href="group__treewidth.html#ggafe2b2e10a78a855612c2f1322923a974af039ad38888c18d408c61431297cd350">regina::BAG_SUBSET</a> = -1
, <a class="el" href="group__treewidth.html#ggafe2b2e10a78a855612c2f1322923a974a845759db3c4eda02b6e6ee80435ad826">regina::BAG_SUPERSET</a> = 1
, <a class="el" href="group__treewidth.html#ggafe2b2e10a78a855612c2f1322923a974ae7a7377de039a974440109caba6e08e0">regina::BAG_UNRELATED</a> = 2
 }</td></tr>
<tr class="memdesc:gafe2b2e10a78a855612c2f1322923a974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the relationship between two bags in a tree decomposition.  <a href="group__treewidth.html#gafe2b2e10a78a855612c2f1322923a974">More...</a><br /></td></tr>
<tr class="separator:gafe2b2e10a78a855612c2f1322923a974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daf523dd0128906f943bcf49bce128f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga3daf523dd0128906f943bcf49bce128f">regina::NiceType</a> { <a class="el" href="group__treewidth.html#gga3daf523dd0128906f943bcf49bce128fa877af37a377169a824081ca26f295b22">regina::NICE_INTRODUCE</a> = 1
, <a class="el" href="group__treewidth.html#gga3daf523dd0128906f943bcf49bce128fa9adebb3162ce3e14672020dfd878c54a">regina::NICE_FORGET</a> = 2
, <a class="el" href="group__treewidth.html#gga3daf523dd0128906f943bcf49bce128fad9d47d694bf02539399787a8fb05ceb5">regina::NICE_JOIN</a> = 3
 }</td></tr>
<tr class="memdesc:ga3daf523dd0128906f943bcf49bce128f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to indicate the type of each bag in a <em>nice</em> tree decomposition.  <a href="group__treewidth.html#ga3daf523dd0128906f943bcf49bce128f">More...</a><br /></td></tr>
<tr class="separator:ga3daf523dd0128906f943bcf49bce128f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6d126d47961a01b25c5063567fc560cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga6d126d47961a01b25c5063567fc560cd">regina::TreeBag::~TreeBag</a> ()</td></tr>
<tr class="memdesc:ga6d126d47961a01b25c5063567fc560cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this bag.  <a href="group__treewidth.html#ga6d126d47961a01b25c5063567fc560cd">More...</a><br /></td></tr>
<tr class="separator:ga6d126d47961a01b25c5063567fc560cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga970ec7f8f2ca47765839e29153de417a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga970ec7f8f2ca47765839e29153de417a">regina::TreeBag::size</a> () const</td></tr>
<tr class="memdesc:ga970ec7f8f2ca47765839e29153de417a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of graph nodes stored in this bag.  <a href="group__treewidth.html#ga970ec7f8f2ca47765839e29153de417a">More...</a><br /></td></tr>
<tr class="separator:ga970ec7f8f2ca47765839e29153de417a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a7560363edf8479b2352e2666e3e96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaa9a7560363edf8479b2352e2666e3e96">regina::TreeBag::element</a> (int which) const</td></tr>
<tr class="memdesc:gaa9a7560363edf8479b2352e2666e3e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to query the individual graph nodes stored in this bag.  <a href="group__treewidth.html#gaa9a7560363edf8479b2352e2666e3e96">More...</a><br /></td></tr>
<tr class="separator:gaa9a7560363edf8479b2352e2666e3e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458064980d5485ff0850ccd50508c4b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga458064980d5485ff0850ccd50508c4b3">regina::TreeBag::contains</a> (int <a class="el" href="group__treewidth.html#gaa9a7560363edf8479b2352e2666e3e96">element</a>) const</td></tr>
<tr class="memdesc:ga458064980d5485ff0850ccd50508c4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries whether a given graph node is contained in this bag.  <a href="group__treewidth.html#ga458064980d5485ff0850ccd50508c4b3">More...</a><br /></td></tr>
<tr class="separator:ga458064980d5485ff0850ccd50508c4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5afc22b667a5034890e5d2aada50662"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaa5afc22b667a5034890e5d2aada50662">regina::TreeBag::index</a> () const</td></tr>
<tr class="memdesc:gaa5afc22b667a5034890e5d2aada50662"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this bag within the full tree decomposition.  <a href="group__treewidth.html#gaa5afc22b667a5034890e5d2aada50662">More...</a><br /></td></tr>
<tr class="separator:gaa5afc22b667a5034890e5d2aada50662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe19029e72c0f70c17751aa01a7b6a0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f">regina::TreeBag::type</a> () const</td></tr>
<tr class="memdesc:gabe19029e72c0f70c17751aa01a7b6a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> auxiliary information associated with bags in special classes of tree decompositions.  <a href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f">More...</a><br /></td></tr>
<tr class="separator:gabe19029e72c0f70c17751aa01a7b6a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7c848030e790f33d5cbe6424829f5c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8">regina::TreeBag::subtype</a> () const</td></tr>
<tr class="memdesc:gad7c848030e790f33d5cbe6424829f5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a secondary level of auxiliary information associated with bags in special classes of tree decompositions.  <a href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8">More...</a><br /></td></tr>
<tr class="separator:gad7c848030e790f33d5cbe6424829f5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7a88463aed1bc0afd81a421e513020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__treewidth.html#gafe2b2e10a78a855612c2f1322923a974">BagComparison</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga0d7a88463aed1bc0afd81a421e513020">regina::TreeBag::compare</a> (const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga0d7a88463aed1bc0afd81a421e513020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if there is a subset/superset relationship between this and the given bag.  <a href="group__treewidth.html#ga0d7a88463aed1bc0afd81a421e513020">More...</a><br /></td></tr>
<tr class="separator:ga0d7a88463aed1bc0afd81a421e513020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db4d57e569e5abb95e4e5b3c8626909"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga1db4d57e569e5abb95e4e5b3c8626909">regina::TreeBag::next</a> () const</td></tr>
<tr class="memdesc:ga1db4d57e569e5abb95e4e5b3c8626909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a postfix iteration through all of the bags in a tree decomposition.  <a href="group__treewidth.html#ga1db4d57e569e5abb95e4e5b3c8626909">More...</a><br /></td></tr>
<tr class="separator:ga1db4d57e569e5abb95e4e5b3c8626909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96126a0728a24e10aedaedfc7dbee139"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga96126a0728a24e10aedaedfc7dbee139">regina::TreeBag::nextPrefix</a> () const</td></tr>
<tr class="memdesc:ga96126a0728a24e10aedaedfc7dbee139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a prefix iteration through all of the bags in a tree decomposition.  <a href="group__treewidth.html#ga96126a0728a24e10aedaedfc7dbee139">More...</a><br /></td></tr>
<tr class="separator:ga96126a0728a24e10aedaedfc7dbee139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae951594f3e97a43c6e5ea3e12003c031"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gae951594f3e97a43c6e5ea3e12003c031">regina::TreeBag::parent</a> () const</td></tr>
<tr class="memdesc:gae951594f3e97a43c6e5ea3e12003c031"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the parent of this bag in the underlying rooted tree.  <a href="group__treewidth.html#gae951594f3e97a43c6e5ea3e12003c031">More...</a><br /></td></tr>
<tr class="separator:gae951594f3e97a43c6e5ea3e12003c031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8994786f596eeef4e95042eade94455"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gac8994786f596eeef4e95042eade94455">regina::TreeBag::children</a> () const</td></tr>
<tr class="memdesc:gac8994786f596eeef4e95042eade94455"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first child of this bag in the underlying rooted tree.  <a href="group__treewidth.html#gac8994786f596eeef4e95042eade94455">More...</a><br /></td></tr>
<tr class="separator:gac8994786f596eeef4e95042eade94455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2faf1539eb264b3114a691a99a5fb76a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a">regina::TreeBag::sibling</a> () const</td></tr>
<tr class="memdesc:ga2faf1539eb264b3114a691a99a5fb76a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next sibling of this bag in the underlying rooted tree.  <a href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a">More...</a><br /></td></tr>
<tr class="separator:ga2faf1539eb264b3114a691a99a5fb76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1c2920caaeacfeefab808d6baf8a70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga7a1c2920caaeacfeefab808d6baf8a70">regina::TreeBag::isLeaf</a> () const</td></tr>
<tr class="memdesc:ga7a1c2920caaeacfeefab808d6baf8a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this is a leaf bag.  <a href="group__treewidth.html#ga7a1c2920caaeacfeefab808d6baf8a70">More...</a><br /></td></tr>
<tr class="separator:ga7a1c2920caaeacfeefab808d6baf8a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ca32e278b34d69d8728d8e9ba4766d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga0ca32e278b34d69d8728d8e9ba4766d2">regina::TreeBag::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga0ca32e278b34d69d8728d8e9ba4766d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__treewidth.html#ga0ca32e278b34d69d8728d8e9ba4766d2">More...</a><br /></td></tr>
<tr class="separator:ga0ca32e278b34d69d8728d8e9ba4766d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae74d8f9375ff5c3fed665641e3f0e8dd"><td class="memItemLeft" align="right" valign="top"><a id="gae74d8f9375ff5c3fed665641e3f0e8dd"></a>
<a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TreeBag::operator=</b> (const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> &amp;)=delete</td></tr>
<tr class="separator:gae74d8f9375ff5c3fed665641e3f0e8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef0570742d8672353e39a6eb61251cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaaef0570742d8672353e39a6eb61251cb">regina::TreeDecomposition::Graph::Graph</a> (int order)</td></tr>
<tr class="memdesc:gaaef0570742d8672353e39a6eb61251cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new graph with no arcs.  <a href="group__treewidth.html#gaaef0570742d8672353e39a6eb61251cb">More...</a><br /></td></tr>
<tr class="separator:gaaef0570742d8672353e39a6eb61251cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aa8769b04555e3e76baec4dc30fdba2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga3aa8769b04555e3e76baec4dc30fdba2">regina::TreeDecomposition::Graph::~Graph</a> ()</td></tr>
<tr class="memdesc:ga3aa8769b04555e3e76baec4dc30fdba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this graph.  <a href="group__treewidth.html#ga3aa8769b04555e3e76baec4dc30fdba2">More...</a><br /></td></tr>
<tr class="separator:ga3aa8769b04555e3e76baec4dc30fdba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae63a02768ed128bc52a90ca288fc1149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gae63a02768ed128bc52a90ca288fc1149">regina::TreeDecomposition::Graph::dump</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gae63a02768ed128bc52a90ca288fc1149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the adjacency matrix of this graph in a compact format to the given output stream.  <a href="group__treewidth.html#gae63a02768ed128bc52a90ca288fc1149">More...</a><br /></td></tr>
<tr class="separator:gae63a02768ed128bc52a90ca288fc1149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabedc8160c0376aec2c32c00f5185d191"><td class="memItemLeft" align="right" valign="top"><a id="gabedc8160c0376aec2c32c00f5185d191"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TreeDecomposition::Graph::Graph</b> (const <a class="el" href="structregina_1_1TreeDecomposition_1_1Graph.html">Graph</a> &amp;)=delete</td></tr>
<tr class="separator:gabedc8160c0376aec2c32c00f5185d191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19fcad2a9a3dd3a81991a5eaa73fe8a"><td class="memItemLeft" align="right" valign="top"><a id="gae19fcad2a9a3dd3a81991a5eaa73fe8a"></a>
<a class="el" href="structregina_1_1TreeDecomposition_1_1Graph.html">Graph</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TreeDecomposition::Graph::operator=</b> (const <a class="el" href="structregina_1_1TreeDecomposition_1_1Graph.html">Graph</a> &amp;)=delete</td></tr>
<tr class="separator:gae19fcad2a9a3dd3a81991a5eaa73fe8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga745ee1c4dc79074104a7a013756514a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga745ee1c4dc79074104a7a013756514a6">regina::TreeDecomposition::TreeDecomposition</a> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga745ee1c4dc79074104a7a013756514a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a new copy of the given tree decomposition.  <a href="group__treewidth.html#ga745ee1c4dc79074104a7a013756514a6">More...</a><br /></td></tr>
<tr class="separator:ga745ee1c4dc79074104a7a013756514a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9260954f8e9341c6a25f7610ab8863f8"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga9260954f8e9341c6a25f7610ab8863f8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga9260954f8e9341c6a25f7610ab8863f8">regina::TreeDecomposition::TreeDecomposition</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;triangulation, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:ga9260954f8e9341c6a25f7610ab8863f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the facet pairing graph of the given triangulation.  <a href="group__treewidth.html#ga9260954f8e9341c6a25f7610ab8863f8">More...</a><br /></td></tr>
<tr class="separator:ga9260954f8e9341c6a25f7610ab8863f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b22a38314cfa157c7df66ebcc084ffc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ga6b22a38314cfa157c7df66ebcc084ffc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga6b22a38314cfa157c7df66ebcc084ffc">regina::TreeDecomposition::TreeDecomposition</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;pairing, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:ga6b22a38314cfa157c7df66ebcc084ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the given facet pairing graph.  <a href="group__treewidth.html#ga6b22a38314cfa157c7df66ebcc084ffc">More...</a><br /></td></tr>
<tr class="separator:ga6b22a38314cfa157c7df66ebcc084ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab19321d5f8b29246685ea6b10b9c0298"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gab19321d5f8b29246685ea6b10b9c0298">regina::TreeDecomposition::TreeDecomposition</a> (const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;link, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:gab19321d5f8b29246685ea6b10b9c0298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of the planar multigraph corresponding to the given knot or link diagram.  <a href="group__treewidth.html#gab19321d5f8b29246685ea6b10b9c0298">More...</a><br /></td></tr>
<tr class="separator:gab19321d5f8b29246685ea6b10b9c0298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2479571bf607d3c08af59bfbae3f754d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2479571bf607d3c08af59bfbae3f754d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga2479571bf607d3c08af59bfbae3f754d">regina::TreeDecomposition::TreeDecomposition</a> (unsigned order, T const **const graph, <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a> alg=<a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a>)</td></tr>
<tr class="memdesc:ga2479571bf607d3c08af59bfbae3f754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition of an arbitrary graph.  <a href="group__treewidth.html#ga2479571bf607d3c08af59bfbae3f754d">More...</a><br /></td></tr>
<tr class="separator:ga2479571bf607d3c08af59bfbae3f754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbb52e2966ddb006c8f9964e009e2ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga7dbb52e2966ddb006c8f9964e009e2ee">regina::TreeDecomposition::~TreeDecomposition</a> ()</td></tr>
<tr class="memdesc:ga7dbb52e2966ddb006c8f9964e009e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this tree decomposition and all of its bags.  <a href="group__treewidth.html#ga7dbb52e2966ddb006c8f9964e009e2ee">More...</a><br /></td></tr>
<tr class="separator:ga7dbb52e2966ddb006c8f9964e009e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13250fbe35fec8ea038fbbcc628361c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga13250fbe35fec8ea038fbbcc628361c5">regina::TreeDecomposition::width</a> () const</td></tr>
<tr class="memdesc:ga13250fbe35fec8ea038fbbcc628361c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the width of this tree decomposition.  <a href="group__treewidth.html#ga13250fbe35fec8ea038fbbcc628361c5">More...</a><br /></td></tr>
<tr class="separator:ga13250fbe35fec8ea038fbbcc628361c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805e5fed5d765d73a06cf7bce26b256b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b">regina::TreeDecomposition::size</a> () const</td></tr>
<tr class="memdesc:ga805e5fed5d765d73a06cf7bce26b256b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bags in this tree decomposition.  <a href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b">More...</a><br /></td></tr>
<tr class="separator:ga805e5fed5d765d73a06cf7bce26b256b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">regina::TreeDecomposition::root</a> () const</td></tr>
<tr class="memdesc:ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bag at the root of the underlying tree.  <a href="group__treewidth.html#ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">More...</a><br /></td></tr>
<tr class="separator:ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0834587b768678b90ff8591725092ab1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga0834587b768678b90ff8591725092ab1">regina::TreeDecomposition::first</a> () const</td></tr>
<tr class="memdesc:ga0834587b768678b90ff8591725092ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a postfix iteration through all of the bags in the tree decomposition.  <a href="group__treewidth.html#ga0834587b768678b90ff8591725092ab1">More...</a><br /></td></tr>
<tr class="separator:ga0834587b768678b90ff8591725092ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c06b040c85b2bbda234ef7601bc6676"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga7c06b040c85b2bbda234ef7601bc6676">regina::TreeDecomposition::firstPrefix</a> () const</td></tr>
<tr class="memdesc:ga7c06b040c85b2bbda234ef7601bc6676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for a prefix iteration through all of the bags in the tree decomposition.  <a href="group__treewidth.html#ga7c06b040c85b2bbda234ef7601bc6676">More...</a><br /></td></tr>
<tr class="separator:ga7c06b040c85b2bbda234ef7601bc6676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga896b10ec6ce8f390e304b4c525925f54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga896b10ec6ce8f390e304b4c525925f54">regina::TreeDecomposition::bag</a> (int index) const</td></tr>
<tr class="memdesc:ga896b10ec6ce8f390e304b4c525925f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slow (linear-time) routine that returns the bag at the given index.  <a href="group__treewidth.html#ga896b10ec6ce8f390e304b4c525925f54">More...</a><br /></td></tr>
<tr class="separator:ga896b10ec6ce8f390e304b4c525925f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf631d4dcefa2e7f025c727ffa313a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gabaf631d4dcefa2e7f025c727ffa313a6">regina::TreeDecomposition::compress</a> ()</td></tr>
<tr class="memdesc:gabaf631d4dcefa2e7f025c727ffa313a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant bags from this tree decomposition.  <a href="group__treewidth.html#gabaf631d4dcefa2e7f025c727ffa313a6">More...</a><br /></td></tr>
<tr class="separator:gabaf631d4dcefa2e7f025c727ffa313a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0c14882c657a38208732e025be562bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc">regina::TreeDecomposition::makeNice</a> (int *heightHint=nullptr)</td></tr>
<tr class="memdesc:gae0c14882c657a38208732e025be562bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this into a nice tree decomposition.  <a href="group__treewidth.html#gae0c14882c657a38208732e025be562bc">More...</a><br /></td></tr>
<tr class="separator:gae0c14882c657a38208732e025be562bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aaa9c488e166bd52474a17abc374eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga8aaa9c488e166bd52474a17abc374eef">regina::TreeDecomposition::reroot</a> (<a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *newRoot)</td></tr>
<tr class="memdesc:ga8aaa9c488e166bd52474a17abc374eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses child-parent relationships so that the given bag becomes the root of the tree decomposition.  <a href="group__treewidth.html#ga8aaa9c488e166bd52474a17abc374eef">More...</a><br /></td></tr>
<tr class="separator:ga8aaa9c488e166bd52474a17abc374eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf484fcab0b6693f5ad95c367007685f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf484fcab0b6693f5ad95c367007685f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaf484fcab0b6693f5ad95c367007685f3">regina::TreeDecomposition::reroot</a> (const T *costSame, const T *costReverse, const T *costRoot=nullptr)</td></tr>
<tr class="memdesc:gaf484fcab0b6693f5ad95c367007685f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reroots the tree by reversing child-parent relationships, in a way that minimises a maximum estimated processing cost amongst all bags.  <a href="group__treewidth.html#gaf484fcab0b6693f5ad95c367007685f3">More...</a><br /></td></tr>
<tr class="separator:gaf484fcab0b6693f5ad95c367007685f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c2518695c74624d2e1a536ab88577e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga2c2518695c74624d2e1a536ab88577e6">regina::TreeDecomposition::writeDot</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga2c2518695c74624d2e1a536ab88577e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this tree decomposition in the Graphviz DOT language.  <a href="group__treewidth.html#ga2c2518695c74624d2e1a536ab88577e6">More...</a><br /></td></tr>
<tr class="separator:ga2c2518695c74624d2e1a536ab88577e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaf3e2c680f3e8dc9ad87a9b74c94b9b37">regina::TreeDecomposition::dot</a> () const</td></tr>
<tr class="memdesc:gaf3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of this tree decomposition.  <a href="group__treewidth.html#gaf3e2c680f3e8dc9ad87a9b74c94b9b37">More...</a><br /></td></tr>
<tr class="separator:gaf3e2c680f3e8dc9ad87a9b74c94b9b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2668cd1871a2d62c7dca27c8540fca91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga2668cd1871a2d62c7dca27c8540fca91">regina::TreeDecomposition::writePACE</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga2668cd1871a2d62c7dca27c8540fca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs this tree decomposition using the PACE text format.  <a href="group__treewidth.html#ga2668cd1871a2d62c7dca27c8540fca91">More...</a><br /></td></tr>
<tr class="separator:ga2668cd1871a2d62c7dca27c8540fca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dabce1a3f084a041e1dd15c9a5cdb61"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga0dabce1a3f084a041e1dd15c9a5cdb61">regina::TreeDecomposition::pace</a> () const</td></tr>
<tr class="memdesc:ga0dabce1a3f084a041e1dd15c9a5cdb61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of this tree decomposition using the PACE text format.  <a href="group__treewidth.html#ga0dabce1a3f084a041e1dd15c9a5cdb61">More...</a><br /></td></tr>
<tr class="separator:ga0dabce1a3f084a041e1dd15c9a5cdb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d6d08edc8c5224ba9f0033d49bedce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaf5d6d08edc8c5224ba9f0033d49bedce">regina::TreeDecomposition::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gaf5d6d08edc8c5224ba9f0033d49bedce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__treewidth.html#gaf5d6d08edc8c5224ba9f0033d49bedce">More...</a><br /></td></tr>
<tr class="separator:gaf5d6d08edc8c5224ba9f0033d49bedce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2391ff92b92cd58806107fd640be74b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gad2391ff92b92cd58806107fd640be74b">regina::TreeDecomposition::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gad2391ff92b92cd58806107fd640be74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__treewidth.html#gad2391ff92b92cd58806107fd640be74b">More...</a><br /></td></tr>
<tr class="separator:gad2391ff92b92cd58806107fd640be74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa9effe91aa0076f60d92369d188280"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaeaa9effe91aa0076f60d92369d188280">regina::TreeDecomposition::fromPACE</a> (const std::string &amp;<a class="el" href="group__engine.html#ga2212a7a96adf2538ea875d49a98d99ad">str</a>)</td></tr>
<tr class="memdesc:gaeaa9effe91aa0076f60d92369d188280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition from a string using the PACE text format.  <a href="group__treewidth.html#gaeaa9effe91aa0076f60d92369d188280">More...</a><br /></td></tr>
<tr class="separator:gaeaa9effe91aa0076f60d92369d188280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d359314fe0cc858e479626c5956fa99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#ga4d359314fe0cc858e479626c5956fa99">regina::TreeDecomposition::fromPACE</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:ga4d359314fe0cc858e479626c5956fa99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a tree decomposition from an input stream using the PACE text format.  <a href="group__treewidth.html#ga4d359314fe0cc858e479626c5956fa99">More...</a><br /></td></tr>
<tr class="separator:ga4d359314fe0cc858e479626c5956fa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9511f6eac30596d16296772524a142f6"><td class="memItemLeft" align="right" valign="top"><a id="ga9511f6eac30596d16296772524a142f6"></a>
<a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TreeDecomposition::operator=</b> (const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;)=delete</td></tr>
<tr class="separator:ga9511f6eac30596d16296772524a142f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadddf1b64c3ce7b422e649cdf1ddfa5a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gadddf1b64c3ce7b422e649cdf1ddfa5a3">regina::TreeDecomposition::Graph::order_</a></td></tr>
<tr class="memdesc:gadddf1b64c3ce7b422e649cdf1ddfa5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of nodes in the graph.  <a href="group__treewidth.html#gadddf1b64c3ce7b422e649cdf1ddfa5a3">More...</a><br /></td></tr>
<tr class="separator:gadddf1b64c3ce7b422e649cdf1ddfa5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec64db419e799b5d885fc899e90cbe7b"><td class="memItemLeft" align="right" valign="top">bool **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__treewidth.html#gaec64db419e799b5d885fc899e90cbe7b">regina::TreeDecomposition::Graph::adj_</a></td></tr>
<tr class="memdesc:gaec64db419e799b5d885fc899e90cbe7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The adjacency matrix for the graph.  <a href="group__treewidth.html#gaec64db419e799b5d885fc899e90cbe7b">More...</a><br /></td></tr>
<tr class="separator:gaec64db419e799b5d885fc899e90cbe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga173284637f80b092ec5b5eb73626d476"><td class="memItemLeft" align="right" valign="top"><a id="ga173284637f80b092ec5b5eb73626d476"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::TreeBag::TreeDecomposition</b></td></tr>
<tr class="separator:ga173284637f80b092ec5b5eb73626d476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Treewidth and tree decompositions. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gac5bb9725db7b18445ed440c84302590e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5bb9725db7b18445ed440c84302590e">&#9670;&nbsp;</a></span>NTreeBag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> <a class="el" href="group__treewidth.html#gac5bb9725db7b18445ed440c84302590e">regina::NTreeBag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000173">Deprecated:</a></b></dt><dd>The class NTreeBag has now been renamed to <a class="el" href="classregina_1_1TreeBag.html" title="Represents a single bag in a tree decomposition.">TreeBag</a>. </dd></dl>

</div>
</div>
<a id="ga59f4ba871638d41a90b5796bf5bd4e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f4ba871638d41a90b5796bf5bd4e8f">&#9670;&nbsp;</a></span>NTreeDecomposition</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> <a class="el" href="group__treewidth.html#ga59f4ba871638d41a90b5796bf5bd4e8f">regina::NTreeDecomposition</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000174">Deprecated:</a></b></dt><dd>The class NTreeDecomposition has now been renamed to <a class="el" href="classregina_1_1TreeDecomposition.html" title="Represents a tree decomposition of a graph.">TreeDecomposition</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gafe2b2e10a78a855612c2f1322923a974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe2b2e10a78a855612c2f1322923a974">&#9670;&nbsp;</a></span>BagComparison</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__treewidth.html#gafe2b2e10a78a855612c2f1322923a974">regina::BagComparison</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the relationship between two bags in a tree decomposition. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggafe2b2e10a78a855612c2f1322923a974aaae6e6eeabe1420eb0312722700f59bf"></a>BAG_EQUAL&#160;</td><td class="fielddoc"><p>Indicates that the two bags have identical contents. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe2b2e10a78a855612c2f1322923a974af039ad38888c18d408c61431297cd350"></a>BAG_SUBSET&#160;</td><td class="fielddoc"><p>Indicates that the first bag is a strict subset of the second. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe2b2e10a78a855612c2f1322923a974a845759db3c4eda02b6e6ee80435ad826"></a>BAG_SUPERSET&#160;</td><td class="fielddoc"><p>Indicates that the first bag is a strict superset of the second. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggafe2b2e10a78a855612c2f1322923a974ae7a7377de039a974440109caba6e08e0"></a>BAG_UNRELATED&#160;</td><td class="fielddoc"><p>Indicates that neither bag is a subset of the other. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3daf523dd0128906f943bcf49bce128f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daf523dd0128906f943bcf49bce128f">&#9670;&nbsp;</a></span>NiceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__treewidth.html#ga3daf523dd0128906f943bcf49bce128f">regina::NiceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to indicate the type of each bag in a <em>nice</em> tree decomposition. </p>
<p>A nice tree decomposition is produced by calling <a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a>. As a result:</p>
<ul>
<li>every bag will be either an <em>introduce</em> bag, a <em>forget</em> bag, or a <em>join</em> bag, as defined below;</li>
<li>the root bag will be a forget bag, and will be empty;</li>
<li>every leaf bag will be an introduce bag, containing precisely one node.</li>
</ul>
<p>See <a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for further details, including how <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">TreeBag::type()</a> and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> are defined for a nice tree decomposition. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3daf523dd0128906f943bcf49bce128fa877af37a377169a824081ca26f295b22"></a>NICE_INTRODUCE&#160;</td><td class="fielddoc"><p>Indicates an introduce bag. </p>
<p>An <em>introduce</em> bag has only one child bag. It contains all of the nodes in this child bag plus exactly one new node, and contains no other nodes besides these.</p>
<p>As a special case, a leaf bag (which has no child bags at all) is also considered to be an introduce bag. In this case, the leaf bag contains exactly one node. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3daf523dd0128906f943bcf49bce128fa9adebb3162ce3e14672020dfd878c54a"></a>NICE_FORGET&#160;</td><td class="fielddoc"><p>Indicates a forget bag. </p>
<p>A <em>forget</em> bag has only one child bag. It contains all of the nodes in this child bag except for exactly one missing node, and contains no other nodes besides these. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3daf523dd0128906f943bcf49bce128fad9d47d694bf02539399787a8fb05ceb5"></a>NICE_JOIN&#160;</td><td class="fielddoc"><p>Indicates a join bag. </p>
<p>A <em>join</em> bag has exactly two child bags, where the join bag and both of its child bags are all identical. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf0dd75ca695140e2bf801cbc355f036f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0dd75ca695140e2bf801cbc355f036f">&#9670;&nbsp;</a></span>TreeDecompositionAlg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">regina::TreeDecompositionAlg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which algorithm should be used to compute a tree decomposition of a graph. </p>
<p>Additional algorithms may be added to this list in future versions of Regina. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21"></a>TD_UPPER&#160;</td><td class="fielddoc"><p>Indicates that a fast upper bound algorithm should be used. </p>
<p>This does not promise to find a tree decomposition of smallest possible width (an NP-hard problem), but it does promise to run in small polynomial time.</p>
<p>This constant <em>TD_UPPER</em> indicates that the "most appropriate" upper bound algorithm should be used. This is a good choice for users who just want a good tree decomposition and want it quickly, without needing to know the details of how it was produced. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf0dd75ca695140e2bf801cbc355f036fa04cee26abfb715aa4a16017e323e573a"></a>TD_UPPER_GREEDY_FILL_IN&#160;</td><td class="fielddoc"><p>Indicates that the greedy fill-in heuristic should be used. </p>
<p>This does not promise to find a tree decomposition of smallest possible width (an NP-hard problem), but it does promise to run in small polynomial time.</p>
<p>The greedy fill-in heuristic has been found experimentally to perform well on general graphs (T. van Dijk, J.-P. van den Heuvel and W. Slob, "Computing treewidth with LibTW", www.treewidth.com, 2006). Experimentation within Regina also suggests that it performs well in the setting of face pairing graphs of 3-manifold triangulations. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga896b10ec6ce8f390e304b4c525925f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896b10ec6ce8f390e304b4c525925f54">&#9670;&nbsp;</a></span>bag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a>* regina::TreeDecomposition::bag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A slow (linear-time) routine that returns the bag at the given index. </p>
<p>Recall that the bags in a tree decomposition are numbered 0,1,...,<a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a>-1. This routine returns the bag with the given number.</p>
<p>This routine is linear-time, and so you should <em>not</em> use it to iterate through all bags. Instead, to iterate through all bags, use <a class="el" href="group__treewidth.html#ga0834587b768678b90ff8591725092ab1" title="Used for a postfix iteration through all of the bags in the tree decomposition.">TreeDecomposition::first()</a> and <a class="el" href="group__treewidth.html#ga1db4d57e569e5abb95e4e5b3c8626909" title="Used for a postfix iteration through all of the bags in a tree decomposition.">TreeBag::next()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine is <em>slow</em>, with a worst-case linear time. This is because the bags are not stored internally in an array, and so this routine must search the tree from the root downwards to find the bag that is being requested.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the number of a bag; this must be between 0 and <a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bag with the given number. </dd></dl>

</div>
</div>
<a id="gac8994786f596eeef4e95042eade94455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8994786f596eeef4e95042eade94455">&#9670;&nbsp;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeBag::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first child of this bag in the underlying rooted tree. </p>
<p>If a bag has no children, then <a class="el" href="group__treewidth.html#gac8994786f596eeef4e95042eade94455" title="Returns the first child of this bag in the underlying rooted tree.">children()</a> will be <code>null</code>. If a bag has many children, then these will be <code><a class="el" href="group__treewidth.html#gac8994786f596eeef4e95042eade94455" title="Returns the first child of this bag in the underlying rooted tree.">children()</a></code>, <code><a class="el" href="group__treewidth.html#gac8994786f596eeef4e95042eade94455" title="Returns the first child of this bag in the underlying rooted tree.">children()</a>-&gt;<a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a" title="Returns the next sibling of this bag in the underlying rooted tree.">sibling()</a></code>, <code><a class="el" href="group__treewidth.html#gac8994786f596eeef4e95042eade94455" title="Returns the first child of this bag in the underlying rooted tree.">children()</a>-&gt;<a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a" title="Returns the next sibling of this bag in the underlying rooted tree.">sibling()</a>-&gt;<a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a" title="Returns the next sibling of this bag in the underlying rooted tree.">sibling()</a></code>, and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>the first child of this bag, or <code>null</code> if this is a leaf bag (i.e., it has no children). </dd></dl>

</div>
</div>
<a id="ga0d7a88463aed1bc0afd81a421e513020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d7a88463aed1bc0afd81a421e513020">&#9670;&nbsp;</a></span>compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__treewidth.html#gafe2b2e10a78a855612c2f1322923a974">BagComparison</a> regina::TreeBag::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if there is a subset/superset relationship between this and the given bag. </p>
<p>Recall that, in a tree decomposition of a graph <em>G</em>, each bag is a set of nodes of <em>G</em>. This function will return one of the following constants:</p>
<ul>
<li>BAG_EQUAL if this and <em>rhs</em> are equal;</li>
<li>BAG_SUBSET if this bag is a strict subset of <em>rhs</em>;</li>
<li>BAG_SUPERSET if this bag is a strict superset of <em>rhs</em>;</li>
<li>BAG_UNRELATED if neither this nor <em>rhs</em> is a subset of the other.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the bag to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the relationship between the two bags, as outlined above. </dd></dl>

</div>
</div>
<a id="gabaf631d4dcefa2e7f025c727ffa313a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaf631d4dcefa2e7f025c727ffa313a6">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TreeDecomposition::compress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes redundant bags from this tree decomposition. </p>
<p>Specifically, this routine "compresses" the tree decomposition as follows: whenever two bags are adjacent in the underlying tree and one is a subset of the other, these bags will be merged.</p>
<p>Note that some <a class="el" href="classregina_1_1TreeBag.html" title="Represents a single bag in a tree decomposition.">TreeBag</a> objects may be destroyed (thereby invalidating pointers or references to them), and for those bags that are not destroyed, their indices (as returned by <a class="el" href="group__treewidth.html#gaa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>) may change.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the tree decomposition was changed. </dd></dl>

</div>
</div>
<a id="ga458064980d5485ff0850ccd50508c4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga458064980d5485ff0850ccd50508c4b3">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TreeBag::contains </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries whether a given graph node is contained in this bag. </p>
<p>Suppose this is a bag in a tree decomposition of some graph <em>G</em>, whose nodes are numbered 0,1,2,.... Then <code>contains(x)</code> queries whether the node numbered <em>x</em> is contained in this bag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>the number of some node in the graph <em>G</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given node is in this bag. </dd></dl>

</div>
</div>
<a id="gaf3e2c680f3e8dc9ad87a9b74c94b9b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3e2c680f3e8dc9ad87a9b74c94b9b37">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TreeDecomposition::dot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a Graphviz DOT representation of this tree decomposition. </p>
<p>This routine simply returns the output of <a class="el" href="group__treewidth.html#ga2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a> as a string, instead of dumping it to an output stream.</p>
<p>See the <a class="el" href="group__treewidth.html#ga2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="group__treewidth.html#ga2c2518695c74624d2e1a536ab88577e6" title="Outputs this tree decomposition in the Graphviz DOT language.">writeDot()</a>, as outlined above. </dd></dl>

</div>
</div>
<a id="gae63a02768ed128bc52a90ca288fc1149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae63a02768ed128bc52a90ca288fc1149">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::Graph::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the adjacency matrix of this graph in a compact format to the given output stream. </p>
<p>The output will be formatted as a matrix, and will be spread across multiple lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9a7560363edf8479b2352e2666e3e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9a7560363edf8479b2352e2666e3e96">&#9670;&nbsp;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeBag::element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to query the individual graph nodes stored in this bag. </p>
<p>Suppose this is a bag in a tree decomposition of some graph <em>G</em>, whose nodes are numbered 0,1,2,.... Then <code>element(i)</code> returns the number of the <em>i</em>th node stored in this bag.</p>
<p>Nodes are always stored in ascending order. This means that <code>element(0) &lt; element(1) &lt; element(2) &lt; ...</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which node should be returned; this must be between 0 and <a class="el" href="group__treewidth.html#ga970ec7f8f2ca47765839e29153de417a" title="Returns the number of graph nodes stored in this bag.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the corresponding node stored in this bag. </dd></dl>

</div>
</div>
<a id="ga0834587b768678b90ff8591725092ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0834587b768678b90ff8591725092ab1">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a>* regina::TreeDecomposition::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for a postfix iteration through all of the bags in the tree decomposition. </p>
<p>Amongst other things, a <em>postfix</em> iteration is one in which all of the children of any bag <em>b</em> will be processed before <em>b</em> itself.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full postfix iteration of bags as follows:</p>
<ul>
<li>the first bag in a postfix iteration is <code>d.first()</code>;</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.next()</code>;</li>
<li>the iteration terminates when <code>b.next()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<p>This postfix iteration is equivalent to iterating through bags numbered 0,1,2,...; that is, following the order of <a class="el" href="group__treewidth.html#gaa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">TreeBag::index()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the first bag in a postfix iteration of all bags, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="ga7c06b040c85b2bbda234ef7601bc6676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c06b040c85b2bbda234ef7601bc6676">&#9670;&nbsp;</a></span>firstPrefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::firstPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used for a prefix iteration through all of the bags in the tree decomposition. </p>
<p>Amongst other things, a <em>prefix</em> iteration is one in which each bag will be processed before any of its children.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full prefix iteration of bags as follows:</p>
<ul>
<li>the first bag in a prefix iteration is <code>d.firstPrefix()</code>;</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.nextPrefix()</code>;</li>
<li>the iteration terminates when <code>b.nextPrefix()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<p>Since the first bag in a prefix iteration must be the root bag, this function is identical to calling <a class="el" href="group__treewidth.html#ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac" title="Returns the bag at the root of the underlying tree.">root()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the first bag in a prefix iteration of all bags, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="gaeaa9effe91aa0076f60d92369d188280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa9effe91aa0076f60d92369d188280">&#9670;&nbsp;</a></span>fromPACE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>* regina::TreeDecomposition::fromPACE </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a tree decomposition from a string using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>In short, the format contains a number of lines of text:</p>
<ul>
<li>Any line beginning with <code>c</code> is considered a comment, and will be ignored.</li>
<li>The first non-comment line should be of the form <code>s&#160;td&#160;<em>num_bags</em>&#160;<em>max_bag_size</em>&#160;<em>num_vertices</em></code>.</li>
<li>The next <em>num_bags</em> non-comment lines should describe the contents of the bags. Each such line should be of the form <code>b&#160;<em>bag_number</em>&#160;<em>element</em>&#160;<em>element</em>&#160;...</code>. The bags are numbered 1,2,...,<em>num_bags</em>, and may appear in any order. Likewise, the vertices of the graph are numbered 1,2,...,<em>num_vertices</em>, and within each bag they may again appear in any order.</li>
<li>The remaining <em>num_bags</em> - 1 non-comment lines should indicate the connections between the bags in the tree decomposition. Each such line should be of the form <code><em>first_bag_index</em>&#160;<em>second_bag_index</em></code>, where <em>first_bag_index</em> is smaller than <em>second_bag_index</em>.</li>
</ul>
<p>Bags may be empty, but there must be at least one bag, and the connections between the bags must form a tree. This routine will choose the root of the tree arbitrarily.</p>
<p>An example of this text format is as follows:</p>
<pre class="fragment">c A tree decomposition with 4 bags and width 2
s td 4 3 5
b 1 1 2 3
b 2 2 3 4
b 3 3 4 5
b 4
1 2
2 3
2 4
</pre><p>This routine does some basic error checking as it reads the input, but this checking is not exhaustive; in particular, it does not verify that the connections between bags actually form a tree.</p>
<p>There are two variants of this routine. This variant contains a single string containing the entire text representation. The other variant takes an input stream, from which the text representation will be read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>a text representation of the tree decomposition using the PACE text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed tree decomposition, or <code>null</code> if the input was found to be invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="ga4d359314fe0cc858e479626c5956fa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d359314fe0cc858e479626c5956fa99">&#9670;&nbsp;</a></span>fromPACE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a>* regina::TreeDecomposition::fromPACE </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a tree decomposition from an input stream using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> .</p>
<p>See the constructor TreeDecomposition(const std::string&amp;) for a description of this text format.</p>
<p>There are two variants of this routine. The other variant contains a single string containing the entire text representation. This variant takes an input stream, from which the text representation will be read.</p>
<p>This routine assumes that it should exhaust the input stream (i.e., it should contain no additional text after this text representation).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>an input stream that provides a text representation of the tree decomposition using the PACE text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly constructed tree decomposition, or <code>null</code> if the input was found to be invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="gaaef0570742d8672353e39a6eb61251cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef0570742d8672353e39a6eb61251cb">&#9670;&nbsp;</a></span>Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new graph with no arcs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the number of nodes in the new graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5afc22b667a5034890e5d2aada50662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5afc22b667a5034890e5d2aada50662">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeBag::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this bag within the full tree decomposition. </p>
<p>Suppose the entire tree decomposition contains <em>n</em> bags. Then these bags are automatically numbered 0,1,...,<em>n</em>-1. This member function returns the number of this particular bag.</p>
<p>The numbering of bags follows a leaves-to-root, left-to-right scheme:</p>
<ul>
<li>for any non-root bag <em>b</em>, we have <code>b.index() &lt; b.parent()-&gt;<a class="el" href="group__treewidth.html#gaa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">index()</a></code>;</li>
<li>for any bag <em>b</em> with a next sibling, we have <code>b.index() &lt; b.sibling()-&gt;<a class="el" href="group__treewidth.html#gaa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">index()</a></code>;</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>the index of this bag within the full tree decomposition <em>d</em>; this will be between 0 and <code>d.size()-1</code> inclusive. </dd></dl>

</div>
</div>
<a id="ga7a1c2920caaeacfeefab808d6baf8a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1c2920caaeacfeefab808d6baf8a70">&#9670;&nbsp;</a></span>isLeaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::TreeBag::isLeaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this is a leaf bag. </p>
<p>A leaf bag is a bag with no children in the underlying tree.</p>
<p>This is equivalent to testing whether <a class="el" href="group__treewidth.html#gac8994786f596eeef4e95042eade94455" title="Returns the first child of this bag in the underlying rooted tree.">children()</a> is <code>null</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a leaf bag. </dd></dl>

</div>
</div>
<a id="gae0c14882c657a38208732e025be562bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0c14882c657a38208732e025be562bc">&#9670;&nbsp;</a></span>makeNice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::makeNice </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>heightHint</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this into a nice tree decomposition. </p>
<p>A <em>nice</em> tree decomposition is one in which every bag is one of the following types:</p>
<ul>
<li>an <em>introduce</em> bag, which has only one child bag, and which contains all of the nodes in this child bag plus exactly one new node (and nothing else);</li>
<li>a <em>forget</em> bag, which has only one child bag, and which contains all of the nodes in this child bag except for exactly one missing node (and nothing else);</li>
<li>a <em>join</em> bag, which has exactly two child bags, and where each child bag contains exactly the same nodes as the join bag itself.</li>
</ul>
<p>As a special case, each leaf bag (which has no child bags at all) is also considered to be an introduce bag, and will contain exactly one node.</p>
<p>This routine will also ensure that the root bag is a forget bag, containing no nodes at all.</p>
<p>This routine will set <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">TreeBag::type()</a> and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> for each bag as follows:</p>
<ul>
<li><a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">TreeBag::type()</a> will be one of the constants from the NiceType enumeration, indicating whether the bag is an introduce, forget or join bag.</li>
<li>For an introduce bag <em>b</em>, <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will indicate which "new" node was introduced. Specifically, the new node will be <code>b.element(b.subtype())</code>.</li>
<li>For a forget bag <em>b</em>, <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will indicate which "missing" node was forgotten. Specifically, the missing node will be <code>b.children()-&gt;element(b.subtype())</code>.</li>
<li>For a join bag, <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> will be undefined.</li>
</ul>
<p>If the underlying graph is empty, then this routine will produce a tree decomposition with no bags at all.</p>
<p>You may optionally pass an argument <em>heightHint</em>, which is an array indicating how close to the root of the tree you would like each node to be. At present, this only affects the final chain of forget bags leading up to the root bag - if <em>heightHint</em> is passed, then this chain will be ordered so that nodes with a larger <em>heightHint</em> will be forgotten closer to the root bag. These should be considered hints only, in that their effect on the final tree decomposition might change in future versions of Regina.</p>
<dl class="section warning"><dt>Warning</dt><dd>Note that <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">TreeBag::subtype()</a> is <em>not</em> the number of the new or missing node, but instead gives the <em>index</em> of the new or missing node within the relevant bag.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine calls <a class="el" href="group__treewidth.html#gabaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> automatically, and so there is no need to explicitly call <a class="el" href="group__treewidth.html#gabaf631d4dcefa2e7f025c727ffa313a6" title="Removes redundant bags from this tree decomposition.">compress()</a> before calling <a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">makeNice()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The <em>heightHint</em> argument is not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heightHint</td><td>an optional array where, for each node <em>i</em>, a higher value of <code>heightHint[i]</code> indicates that the node should be forgotten closer to the root bag. If this is non-null, then the size of this array should be the number of nodes in the underlying graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1db4d57e569e5abb95e4e5b3c8626909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1db4d57e569e5abb95e4e5b3c8626909">&#9670;&nbsp;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a>* regina::TreeBag::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for a postfix iteration through all of the bags in a tree decomposition. </p>
<p>Amongst other things, a <em>postfix</em> iteration is one in which all of the children of any bag <em>b</em> will be processed before <em>b</em> itself.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full postfix iteration of bags as follows:</p>
<ul>
<li>the first bag in a postfix iteration is <code>d.first()</code>;</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.next()</code>;</li>
<li>the iteration terminates when <code>b.next()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<p>The bags in a tree decomposition are indexed as 0,1,2,..., as described by the <a class="el" href="group__treewidth.html#gaa5afc22b667a5034890e5d2aada50662" title="Returns the index of this bag within the full tree decomposition.">index()</a> member function. This postfix iteration is equivalent to iterating through bags 0,1,2,... in order.</p>
<dl class="section return"><dt>Returns</dt><dd>the next bag after this in a postfix iteration of all bags, or <code>null</code> if this is the final bag in such an iteration (i.e., the root bag). </dd></dl>

</div>
</div>
<a id="ga96126a0728a24e10aedaedfc7dbee139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96126a0728a24e10aedaedfc7dbee139">&#9670;&nbsp;</a></span>nextPrefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a>* regina::TreeBag::nextPrefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for a prefix iteration through all of the bags in a tree decomposition. </p>
<p>Amongst other things, a <em>prefix</em> iteration is one in which each bag will be processed before any of its children.</p>
<p>If <em>d</em> is a non-empty tree decomposition, then you can complete a full prefix iteration of bags as follows:</p>
<ul>
<li>the first bag in a prefix iteration is <code>d.firstPrefix()</code> (or equivalently, <code>d.root()</code>);</li>
<li>the next bag after <em>b</em> in the iteration is <code>b.nextPrefix()</code>;</li>
<li>the iteration terminates when <code>b.nextPrefix()</code> is <code>null</code>.</li>
</ul>
<p>This iteration processes the children of each bag in order; that is, it processes each bag <em>b</em> before <code>b.sibling()</code> (if the latter exists).</p>
<dl class="section return"><dt>Returns</dt><dd>the next bag after this in a prefix iteration of all bags, or <code>null</code> if this is the final bag in such an iteration. </dd></dl>

</div>
</div>
<a id="ga0dabce1a3f084a041e1dd15c9a5cdb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dabce1a3f084a041e1dd15c9a5cdb61">&#9670;&nbsp;</a></span>pace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::TreeDecomposition::pace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a text representation of this tree decomposition using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="group__treewidth.html#gaeaa9effe91aa0076f60d92369d188280" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE(const std::string&amp;)</a>.</p>
<p>This routine simply returns the output of <a class="el" href="group__treewidth.html#ga2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> as a string, instead of writing it to an output stream.</p>
<p>See the <a class="el" href="group__treewidth.html#ga2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> notes for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the output of <a class="el" href="group__treewidth.html#ga2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a>, as outlined above.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="gae951594f3e97a43c6e5ea3e12003c031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae951594f3e97a43c6e5ea3e12003c031">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeBag::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the parent of this bag in the underlying rooted tree. </p>
<dl class="section return"><dt>Returns</dt><dd>the parent of this bag, or <code>null</code> if this bag is at the root of the tree. </dd></dl>

</div>
</div>
<a id="gaf484fcab0b6693f5ad95c367007685f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf484fcab0b6693f5ad95c367007685f3">&#9670;&nbsp;</a></span>reroot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::reroot </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>costSame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>costReverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>costRoot</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reroots the tree by reversing child-parent relationships, in a way that minimises a maximum estimated processing cost amongst all bags. </p>
<p>The user needs to supply three arrays, which are used to estimate the cost of hanging the tree from any possible root. This routine then identifies which root minimises this cost, and reroots the underlying tree from that bag.</p>
<p>The three arrays play the following roles. Let <em>b</em> be some bag at index <em>i</em> in the original tree decomposition, and let <em>p</em> be its parent bag.</p>
<ul>
<li><code>costSame[i]</code> indicates the cost of <em>preserving</em> the parent-child relationship between <em>b</em> and <em>p</em> (i.e., after rerooting, <em>p</em> is still the parent bag of <em>b</em>). If <em>b</em> is the root bag of the original tree decomposition then <code>costSame[i]</code> is ignored.</li>
<li><code>costReverse[i]</code> indicates the cost of <em>reversing</em> the parent-child relationship between <em>b</em> and <em>p</em> (i.e., after rerooting, <em>b</em> is now the parent bag of <em>p</em>). Again, if <em>b</em> is the root bag of the original tree decomposition then <code>costReverse[i]</code> is ignored.</li>
<li><code>costRoot[i]</code> is an additional cost that is incurred if and only if <em>b</em> becomes the new root bag. The argument <em>costRoot</em> may be <code>null</code>, in which case these additional costs are all assumed to be zero.</li>
</ul>
<p>It follows that, for each potential new root, there are <a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> costs to aggregate: this comes from <a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a>-1 costs from the arrays <em>costSame</em> and/or <em>costReverse</em> (one for each connection between bags in the underlying tree), and one cost from <em>costRoot</em>. These costs will be aggregated by taking the <em>maximum</em> over all individual costs. This means that you do not need to estimate running times and/or memory consumption accurately; instead you only need to find some heuristic that aims to be <em>monotonic</em> in time and/or memory.</p>
<p>So: in essence then, this routine minimises the maximum cost. In the case of a tie, it then minimises multiplicity; that is, it minimises the <em>number</em> of times that this maximum cost occurs over the individual <a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> costs that are being aggregated.</p>
<p>Note that the <em>costSame</em> and <em>costReverse</em> arrays are technically defined as a cost per arc, not a cost per bag. If you wish to estimate a cost per bag, the typical way of doing this would be:</p>
<ul>
<li><code>costSame[i]</code> estimates the processing cost at bag <em>i</em> if its relationship with its parent is preserved;</li>
<li><code>costReverse[i]</code> estimates the processing cost at the original <em>parent</em> of bag <em>i</em> if its relationship with bag <em>i</em> is reversed (i.e., it becomes a child of bag <em>i</em>);</li>
<li><code>costRoot[i]</code> estimates the processing cost at bag <em>i</em> if bag <em>i</em> becomes the root.</li>
</ul>
<p>This scheme ensures that, for any possible rerooting, each bag is costed exactly once amongst the three arrays.</p>
<p>After rerooting, all pointers to bags will remain valid, and the contents of the bags will not change. However:</p>
<ul>
<li>the bags will be reindexed, to reflect the changes in the leaves-to-root, left-to-right ordering;</li>
<li>all bag types will be reset to 0, since in general rerooting may break whatever properties the bag types and subtypes represent.</li>
</ul>
<p>If the given bag is already the root bag, then this routine does nothing (and in particular, types and subtypes are preserved).</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for common types.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type being used to estimate costs. It must be possible to assign 0 to a variable of type <em>T</em> using both constructors and the assignment operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">costSame</td><td>An array of <a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an estimated cost of preserving each child-parent connection; </td></tr>
    <tr><td class="paramname">costReverse</td><td>An array of <a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an estimated cost of reversing each child-parent connection; </td></tr>
    <tr><td class="paramname">costRoot</td><td>An array of <a class="el" href="group__treewidth.html#ga805e5fed5d765d73a06cf7bce26b256b" title="Returns the number of bags in this tree decomposition.">size()</a> elements giving an additional estimated cost for each bag being the new root. This array may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8aaa9c488e166bd52474a17abc374eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aaa9c488e166bd52474a17abc374eef">&#9670;&nbsp;</a></span>reroot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::reroot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> *&#160;</td>
          <td class="paramname"><em>newRoot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverses child-parent relationships so that the given bag becomes the root of the tree decomposition. </p>
<p>All pointers to bags will remain valid, and the contents of the bags will not change. However:</p>
<ul>
<li>the bags will be reindexed, to reflect the changes in the leaves-to-root, left-to-right ordering;</li>
<li>all bag types will be reset to 0, since in general rerooting may break whatever properties the bag types and subtypes represent.</li>
</ul>
<p>If the given bag is already the root bag, then this routine does nothing (and in particular, types and subtypes are preserved).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newRoot</td><td>the bag that should become the root of this tree decomposition. This must already be a bag of this tree decomposition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fde6d6bf4551e3d1a0b5b2f3cf7f0ac">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeDecomposition::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bag at the root of the underlying tree. </p>
<dl class="section return"><dt>Returns</dt><dd>the root bag, or <code>null</code> if there are no bags (which means the underlying graph <em>G</em> is empty). </dd></dl>

</div>
</div>
<a id="ga2faf1539eb264b3114a691a99a5fb76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2faf1539eb264b3114a691a99a5fb76a">&#9670;&nbsp;</a></span>sibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1TreeBag.html">TreeBag</a> * regina::TreeBag::sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the next sibling of this bag in the underlying rooted tree. </p>
<p>Specifically, if the parent of this bag has many children, then <a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a" title="Returns the next sibling of this bag in the underlying rooted tree.">sibling()</a> will return the next child after this.</p>
<p>More generally, all of the children of a bag <em>b</em> can be accessed as <code>b.children()</code>, <code>b.children()-&gt;<a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a" title="Returns the next sibling of this bag in the underlying rooted tree.">sibling()</a></code>, <code>b.children()-&gt;<a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a" title="Returns the next sibling of this bag in the underlying rooted tree.">sibling()</a>-&gt;<a class="el" href="group__treewidth.html#ga2faf1539eb264b3114a691a99a5fb76a" title="Returns the next sibling of this bag in the underlying rooted tree.">sibling()</a></code>, and so on.</p>
<dl class="section return"><dt>Returns</dt><dd>the next sibling of this bag, or <code>null</code> if either (i) this is the final child of the parent bag, or (ii) this is the root bag. </dd></dl>

</div>
</div>
<a id="ga970ec7f8f2ca47765839e29153de417a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga970ec7f8f2ca47765839e29153de417a">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeBag::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of graph nodes stored in this bag. </p>
<p>Suppose this is a bag in a tree decomposition of some graph <em>G</em>. Then each bag is a subset of the nodes of <em>G</em>, and this function simply returns the size of this subset.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of graph nodes in this bag. </dd></dl>

</div>
</div>
<a id="ga805e5fed5d765d73a06cf7bce26b256b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805e5fed5d765d73a06cf7bce26b256b">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeDecomposition::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of bags in this tree decomposition. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of bags. </dd></dl>

</div>
</div>
<a id="gad7c848030e790f33d5cbe6424829f5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7c848030e790f33d5cbe6424829f5c8">&#9670;&nbsp;</a></span>subtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeBag::subtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a secondary level of auxiliary information associated with bags in special classes of tree decompositions. </p>
<p>If the underlying tree decomposition is of a special type, then each bag may be adorned with some additional information indicating the particular role that the bag plays. This additional information can be accessed through the member functions <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a>.</p>
<ul>
<li>If there is no type and/or subtype information stored for this bag, then <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> will return zero, and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a> will be undefined.</li>
<li>If there is type and/or subtype information stored for this bag, then <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> will be non-zero, and the specific meaning of <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a> (and indeed whether it is even defined) will depend on the value of <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a>.</li>
</ul>
<p>At present, types and subtypes are only stored for <em>nice</em> tree decompositions. See <a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a> represent.</p>
<dl class="section return"><dt>Returns</dt><dd>additional information indicating the role that this bag plays in this tree decomposition, or undefined if no additional subtype information is stored for this bag. </dd></dl>

</div>
</div>
<a id="ga6b22a38314cfa157c7df66ebcc084ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b22a38314cfa157c7df66ebcc084ffc">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the given facet pairing graph. </p>
<p>The nodes of the graph will be numbered in the same way as the top-dimensional simplices of the given triangulation.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This constructor is only available in Python when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairing</td><td>the facet pairing graph that we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab19321d5f8b29246685ea6b10b9c0298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab19321d5f8b29246685ea6b10b9c0298">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Link.html">Link</a> &amp;&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the planar multigraph corresponding to the given knot or link diagram. </p>
<p>The nodes of the graph will be numbered in the same way as the crossings of the given knot / link.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the knot or link that we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga745ee1c4dc79074104a7a013756514a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga745ee1c4dc79074104a7a013756514a6">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1TreeDecomposition.html">TreeDecomposition</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a new copy of the given tree decomposition. </p>
<p>This will be a deep copy, in the sense that all of the bags of <em>cloneMe</em> will be cloned also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the tree decomposition to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9260954f8e9341c6a25f7610ab8863f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9260954f8e9341c6a25f7610ab8863f8">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of the facet pairing graph of the given triangulation. </p>
<p>The nodes of the graph will be numbered in the same way as the top-dimensional simplices of the given triangulation.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. However, typical end users should never need this extra header, since Regina's calculation engine already includes explicit instantiations for <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This constructor is only available in Python when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation whose facet pairing graph we are working with. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2479571bf607d3c08af59bfbae3f754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2479571bf607d3c08af59bfbae3f754d">&#9670;&nbsp;</a></span>TreeDecomposition() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::TreeDecomposition </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const **const&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__treewidth.html#gaf0dd75ca695140e2bf801cbc355f036f">TreeDecompositionAlg</a>&#160;</td>
          <td class="paramname"><em>alg</em> = <code><a class="el" href="group__treewidth.html#ggaf0dd75ca695140e2bf801cbc355f036fadf511af69b24e20d81a9ca350622ab21">TD_UPPER</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a tree decomposition of an arbitrary graph. </p>
<p>The graph may be directed or undirected.</p>
<p>The graph is specified by an adjacency matrix. The matrix may contain any data type (this is the template argument <em>T</em>). However, the contents of this matrix will be interpreted as booleans: an arc runs from node <em>i</em> to node <em>j</em> if and only if <em>graph</em>[i][j] is <code>true</code> when interpreted as a boolean.</p>
<dl class="section user"><dt>Headers</dt><dd>This routine is implemented in a separate header (treedecomposition-impl.h), which is not included automatically by this file. Regina's calculation engine already includes explicit instantiations for types <code>bool</code> and <code>int</code>, but for other types you will need to include treedecomposition-impl.h along with this header.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The argument <em>order</em> is not present (it will be deduced automatically from <em>graph</em>). The adjacency matrix should be given as a list of lists. There is no need to use the same data type <em>T</em> throughout: each element of the matrix will be individually interpreted as a boolean as described above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the number of nodes in the graph. </td></tr>
    <tr><td class="paramname">graph</td><td>the adjacency matrix of the graph. </td></tr>
    <tr><td class="paramname">alg</td><td>the algorithm that should be used to compute the tree decomposition; in particular, this specifies whether to use a slow exact algorithm or a fast greedy algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe19029e72c0f70c17751aa01a7b6a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe19029e72c0f70c17751aa01a7b6a0f">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeBag::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> auxiliary information associated with bags in special classes of tree decompositions. </p>
<p>If the underlying tree decomposition is of a special type, then each bag may be adorned with some additional information indicating the particular role that the bag plays. This additional information can be accessed through the member functions <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a>.</p>
<ul>
<li>If there is no type and/or subtype information stored for this bag, then <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> will return zero, and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a> will be undefined.</li>
<li>If there is type and/or subtype information stored for this bag, then the return value of <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> is guaranteed to be non-zero. The specific meaning of <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a> (and indeed whether it is even defined) will typically depend on the return value of <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a>.</li>
</ul>
<p>At present, types and subtypes are only stored for <em>nice</em> tree decompositions. See <a class="el" href="group__treewidth.html#gae0c14882c657a38208732e025be562bc" title="Converts this into a nice tree decomposition.">TreeDecomposition::makeNice()</a> for details on what <a class="el" href="group__treewidth.html#gabe19029e72c0f70c17751aa01a7b6a0f" title="Returns auxiliary information associated with bags in special classes of tree decompositions.">type()</a> and <a class="el" href="group__treewidth.html#gad7c848030e790f33d5cbe6424829f5c8" title="Returns a secondary level of auxiliary information associated with bags in special classes of tree de...">subtype()</a> represent.</p>
<dl class="section return"><dt>Returns</dt><dd>a non-zero value indicating the role that this bag plays in this tree decomposition, or zero if type and subtype information are not stored. </dd></dl>

</div>
</div>
<a id="ga13250fbe35fec8ea038fbbcc628361c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13250fbe35fec8ea038fbbcc628361c5">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeDecomposition::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the width of this tree decomposition. </p>
<p>This is one less than the size of the largest bag.</p>
<dl class="section return"><dt>Returns</dt><dd>the width of this tree decomposition. </dd></dl>

</div>
</div>
<a id="ga2c2518695c74624d2e1a536ab88577e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c2518695c74624d2e1a536ab88577e6">&#9670;&nbsp;</a></span>writeDot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeDot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this tree decomposition in the Graphviz DOT language. </p>
<p>This produces a standalone DOT file that can be run through Graphviz in order to visualise the tree decomposition.</p>
<p>This routine generates a directed graph (with arrows running from parent bags to their children). The nodes of this graph will be labelled in a way that indicates the tetrahedra contained in each bag. The resulting DOT file should be used with the <em>dot</em> program shipped with Graphviz.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="http://www.graphviz.org/">http://www.graphviz.org/</a> </dd></dl>

</div>
</div>
<a id="ga2668cd1871a2d62c7dca27c8540fca91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2668cd1871a2d62c7dca27c8540fca91">&#9670;&nbsp;</a></span>writePACE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writePACE </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs this tree decomposition using the PACE text format. </p>
<p>The text format is described in detail at <a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> , and is documented in detail by the routine <a class="el" href="group__treewidth.html#gaeaa9effe91aa0076f60d92369d188280" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE(const std::string&amp;)</a>.</p>
<p>If you write a tree decomposition using <a class="el" href="group__treewidth.html#ga0dabce1a3f084a041e1dd15c9a5cdb61" title="Returns a text representation of this tree decomposition using the PACE text format.">pace()</a> or <a class="el" href="group__treewidth.html#ga2668cd1871a2d62c7dca27c8540fca91" title="Outputs this tree decomposition using the PACE text format.">writePACE()</a> and then read it again using <a class="el" href="group__treewidth.html#gaeaa9effe91aa0076f60d92369d188280" title="Builds a tree decomposition from a string using the PACE text format.">fromPACE()</a>, you are <em>not</em> guaranteed to obtain an identical tree decomposition. This is because the PACE text format stores the connections between bags as an undirected, unrooted tree.</p>
<dl class="section user"><dt>Python</dt><dd>The <em>out</em> argument is not present; instead standard output is assumed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/">https://pacechallenge.wordpress.com/pace-2016/track-a-treewidth/</a> </dd></dl>

</div>
</div>
<a id="gad2391ff92b92cd58806107fd640be74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2391ff92b92cd58806107fd640be74b">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ca32e278b34d69d8728d8e9ba4766d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ca32e278b34d69d8728d8e9ba4766d2">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeBag::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf5d6d08edc8c5224ba9f0033d49bedce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d6d08edc8c5224ba9f0033d49bedce">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::TreeDecomposition::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3aa8769b04555e3e76baec4dc30fdba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aa8769b04555e3e76baec4dc30fdba2">&#9670;&nbsp;</a></span>~Graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::Graph::~Graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this graph. </p>

</div>
</div>
<a id="ga6d126d47961a01b25c5063567fc560cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d126d47961a01b25c5063567fc560cd">&#9670;&nbsp;</a></span>~TreeBag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeBag::~TreeBag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this bag. </p>

</div>
</div>
<a id="ga7dbb52e2966ddb006c8f9964e009e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dbb52e2966ddb006c8f9964e009e2ee">&#9670;&nbsp;</a></span>~TreeDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::TreeDecomposition::~TreeDecomposition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this tree decomposition and all of its bags. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaec64db419e799b5d885fc899e90cbe7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec64db419e799b5d885fc899e90cbe7b">&#9670;&nbsp;</a></span>adj_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool** regina::TreeDecomposition::Graph::adj_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The adjacency matrix for the graph. </p>
<p>Specifically, adj_[i][j] is <code>true</code> if and only if there is an arc from node <em>i</em> to node <em>j</em>. </p>

</div>
</div>
<a id="gadddf1b64c3ce7b422e649cdf1ddfa5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadddf1b64c3ce7b422e649cdf1ddfa5a3">&#9670;&nbsp;</a></span>order_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::TreeDecomposition::Graph::order_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of nodes in the graph. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
