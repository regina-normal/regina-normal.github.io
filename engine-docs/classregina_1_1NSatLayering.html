<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NSatLayering Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NSatLayering.html">NSatLayering</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NSatLayering-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NSatLayering Class Reference<div class="ingroups"><a class="el" href="group__subcomplex.html">Standard Triangulations and Subcomplexes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A degenerate saturated block that is a single tetrahedron wrapped around so that two opposite edges touch.  
 <a href="classregina_1_1NSatLayering.html#details">More...</a></p>

<p><code>#include &lt;subcomplex/nsatblocktypes.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NSatLayering:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NSatLayering.png" usemap="#regina::NSatLayering_map" alt=""/>
  <map id="regina::NSatLayering_map" name="regina::NSatLayering_map">
<area href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space." alt="regina::NSatBlock" shape="rect" coords="91,56,264,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NSatBlock &gt;" shape="rect" coords="0,0,173,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a300627ed97526997bab97f9a21ac3090"><td class="memItemLeft" align="right" valign="top">typedef std::set&lt; <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">TetList</a></td></tr>
<tr class="memdesc:a300627ed97526997bab97f9a21ac3090"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data structure used to store a list of tetrahedra that should not be examined by <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a>.  <a href="#a300627ed97526997bab97f9a21ac3090">More...</a><br/></td></tr>
<tr class="separator:a300627ed97526997bab97f9a21ac3090"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a21b86ea65ac094e0c5d0fe6e7a93fc10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#a21b86ea65ac094e0c5d0fe6e7a93fc10">NSatLayering</a> (const <a class="el" href="classregina_1_1NSatLayering.html">NSatLayering</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:a21b86ea65ac094e0c5d0fe6e7a93fc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a clone of the given block structure.  <a href="#a21b86ea65ac094e0c5d0fe6e7a93fc10">More...</a><br/></td></tr>
<tr class="separator:a21b86ea65ac094e0c5d0fe6e7a93fc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bd473e0ba73e3e2e7bbfb99102cc4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#ab4bd473e0ba73e3e2e7bbfb99102cc4b">overHorizontal</a> () const </td></tr>
<tr class="memdesc:ab4bd473e0ba73e3e2e7bbfb99102cc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this describe a layering over the horizontal edge of the boundary annulus, or a layering over the diagonal edge?  <a href="#ab4bd473e0ba73e3e2e7bbfb99102cc4b">More...</a><br/></td></tr>
<tr class="separator:ab4bd473e0ba73e3e2e7bbfb99102cc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c3cff7394b628481b97a693e683dcc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#ab8c3cff7394b628481b97a693e683dcc">clone</a> () const </td></tr>
<tr class="memdesc:ab8c3cff7394b628481b97a693e683dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure.  <a href="#ab8c3cff7394b628481b97a693e683dcc">More...</a><br/></td></tr>
<tr class="separator:ab8c3cff7394b628481b97a693e683dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3696140450369453ebaba0f46cdf9065"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#a3696140450369453ebaba0f46cdf9065">adjustSFS</a> (<a class="el" href="classregina_1_1NSFSpace.html">NSFSpace</a> &amp;sfs, bool reflect) const </td></tr>
<tr class="memdesc:a3696140450369453ebaba0f46cdf9065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the given Seifert fibred space to insert the contents of this saturated block.  <a href="#a3696140450369453ebaba0f46cdf9065">More...</a><br/></td></tr>
<tr class="separator:a3696140450369453ebaba0f46cdf9065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c77322a472722d9a722045ac30da04"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#aa6c77322a472722d9a722045ac30da04">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:aa6c77322a472722d9a722045ac30da04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#aa6c77322a472722d9a722045ac30da04">More...</a><br/></td></tr>
<tr class="separator:aa6c77322a472722d9a722045ac30da04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e680a4d5159230599728911f58f0603"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#a8e680a4d5159230599728911f58f0603">writeAbbr</a> (std::ostream &amp;out, bool tex=false) const </td></tr>
<tr class="memdesc:a8e680a4d5159230599728911f58f0603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an abbreviated name or symbol for this block to the given output stream.  <a href="#a8e680a4d5159230599728911f58f0603">More...</a><br/></td></tr>
<tr class="separator:a8e680a4d5159230599728911f58f0603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ddd0257b1b560599aaf83f940fef30"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30">nAnnuli</a> () const </td></tr>
<tr class="memdesc:a58ddd0257b1b560599aaf83f940fef30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of annuli on the boundary of this saturated block.  <a href="#a58ddd0257b1b560599aaf83f940fef30">More...</a><br/></td></tr>
<tr class="separator:a58ddd0257b1b560599aaf83f940fef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ab4d9bf4b1d57e4f58964d99368378"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a72ab4d9bf4b1d57e4f58964d99368378">annulus</a> (unsigned which) const </td></tr>
<tr class="memdesc:a72ab4d9bf4b1d57e4f58964d99368378"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested annulus on the boundary of this saturated block.  <a href="#a72ab4d9bf4b1d57e4f58964d99368378">More...</a><br/></td></tr>
<tr class="separator:a72ab4d9bf4b1d57e4f58964d99368378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c67d9bb1286b258cf837d0e463dfebe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a6c67d9bb1286b258cf837d0e463dfebe">twistedBoundary</a> () const </td></tr>
<tr class="memdesc:a6c67d9bb1286b258cf837d0e463dfebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a long Mobius strip?  <a href="#a6c67d9bb1286b258cf837d0e463dfebe">More...</a><br/></td></tr>
<tr class="separator:a6c67d9bb1286b258cf837d0e463dfebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1a892c758412c511e5f6fb62a68d18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#abc1a892c758412c511e5f6fb62a68d18">hasAdjacentBlock</a> (unsigned whichAnnulus) const </td></tr>
<tr class="memdesc:abc1a892c758412c511e5f6fb62a68d18"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there is another saturated block listed as being adjacent to the given boundary annulus of this block.  <a href="#abc1a892c758412c511e5f6fb62a68d18">More...</a><br/></td></tr>
<tr class="separator:abc1a892c758412c511e5f6fb62a68d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bf257ea9ace4c4ffdce2934efffd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a40bf257ea9ace4c4ffdce2934efffd59">adjacentBlock</a> (unsigned whichAnnulus) const </td></tr>
<tr class="memdesc:a40bf257ea9ace4c4ffdce2934efffd59"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated block listed as being adjacent to the given boundary annulus of this block.  <a href="#a40bf257ea9ace4c4ffdce2934efffd59">More...</a><br/></td></tr>
<tr class="separator:a40bf257ea9ace4c4ffdce2934efffd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655a1e640549f880b5181859ceb8a4ca"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a655a1e640549f880b5181859ceb8a4ca">adjacentAnnulus</a> (unsigned whichAnnulus) const </td></tr>
<tr class="memdesc:a655a1e640549f880b5181859ceb8a4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block.  <a href="#a655a1e640549f880b5181859ceb8a4ca">More...</a><br/></td></tr>
<tr class="separator:a655a1e640549f880b5181859ceb8a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de25a0279559a824baab7c5fb5c026b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a3de25a0279559a824baab7c5fb5c026b">adjacentReflected</a> (unsigned whichAnnulus) const </td></tr>
<tr class="memdesc:a3de25a0279559a824baab7c5fb5c026b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is reflected.  <a href="#a3de25a0279559a824baab7c5fb5c026b">More...</a><br/></td></tr>
<tr class="separator:a3de25a0279559a824baab7c5fb5c026b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ead9c02a126cc2d2e83f83bb432898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#ab2ead9c02a126cc2d2e83f83bb432898">adjacentBackwards</a> (unsigned whichAnnulus) const </td></tr>
<tr class="memdesc:ab2ead9c02a126cc2d2e83f83bb432898"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is backwards.  <a href="#ab2ead9c02a126cc2d2e83f83bb432898">More...</a><br/></td></tr>
<tr class="separator:ab2ead9c02a126cc2d2e83f83bb432898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faecdf3a0e5968c4a188cac242e894c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a1faecdf3a0e5968c4a188cac242e894c">setAdjacent</a> (unsigned whichAnnulus, <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *adjBlock, unsigned adjAnnulus, bool adjReflected, bool adjBackwards)</td></tr>
<tr class="memdesc:a1faecdf3a0e5968c4a188cac242e894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the given saturated block as being adjacent to the given boundary annulus of this block.  <a href="#a1faecdf3a0e5968c4a188cac242e894c">More...</a><br/></td></tr>
<tr class="separator:a1faecdf3a0e5968c4a188cac242e894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ab8e989478e358de2e0da7a65bd2f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a95ab8e989478e358de2e0da7a65bd2f6">transform</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *originalTri, const <a class="el" href="group__triangulation.html#gab61041f95f4c31c416b5731ed63c47a1">NIsomorphism</a> *iso, <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *newTri)</td></tr>
<tr class="memdesc:a95ab8e989478e358de2e0da7a65bd2f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the structure of this block according to the given isomorphism between triangulations.  <a href="#a95ab8e989478e358de2e0da7a65bd2f6">More...</a><br/></td></tr>
<tr class="separator:a95ab8e989478e358de2e0da7a65bd2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9363cbf843199d800945b92828731a4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a9363cbf843199d800945b92828731a4b">nextBoundaryAnnulus</a> (unsigned thisAnnulus, <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&amp;nextBlock, unsigned &amp;nextAnnulus, bool &amp;refVert, bool &amp;refHoriz, bool followPrev)</td></tr>
<tr class="memdesc:a9363cbf843199d800945b92828731a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region.  <a href="#a9363cbf843199d800945b92828731a4b">More...</a><br/></td></tr>
<tr class="separator:a9363cbf843199d800945b92828731a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90117269568f7c0739f9212a6f8010cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a90117269568f7c0739f9212a6f8010cb">abbr</a> (bool tex=false) const </td></tr>
<tr class="memdesc:a90117269568f7c0739f9212a6f8010cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an abbreviated name or symbol for this block.  <a href="#a90117269568f7c0739f9212a6f8010cb">More...</a><br/></td></tr>
<tr class="separator:a90117269568f7c0739f9212a6f8010cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137eb1ca1624edd4e27c6b6d258e06a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a137eb1ca1624edd4e27c6b6d258e06a9">getAbbr</a> (bool tex=false) const </td></tr>
<tr class="memdesc:a137eb1ca1624edd4e27c6b6d258e06a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns an abbreviated name or symbol for this block.  <a href="#a137eb1ca1624edd4e27c6b6d258e06a9">More...</a><br/></td></tr>
<tr class="separator:a137eb1ca1624edd4e27c6b6d258e06a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62343453151adb6b293985721c32a706"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a62343453151adb6b293985721c32a706">operator&lt;</a> (const <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> &amp;compare) const </td></tr>
<tr class="memdesc:a62343453151adb6b293985721c32a706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a consistent ordering of saturated blocks.  <a href="#a62343453151adb6b293985721c32a706">More...</a><br/></td></tr>
<tr class="separator:a62343453151adb6b293985721c32a706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6259e5bdd2c5991d38ad1a0cd47e20e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#ad6259e5bdd2c5991d38ad1a0cd47e20e">writeTextLong</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ad6259e5bdd2c5991d38ad1a0cd47e20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#ad6259e5bdd2c5991d38ad1a0cd47e20e">More...</a><br/></td></tr>
<tr class="separator:ad6259e5bdd2c5991d38ad1a0cd47e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ab182c97fe654b8929d1fe41dc564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#aea0ab182c97fe654b8929d1fe41dc564">toString</a> () const</td></tr>
<tr class="memdesc:aea0ab182c97fe654b8929d1fe41dc564"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for str().  <a href="#aea0ab182c97fe654b8929d1fe41dc564">More...</a><br/></td></tr>
<tr class="separator:aea0ab182c97fe654b8929d1fe41dc564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32f5abced4d1365c34980741b564765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#af32f5abced4d1365c34980741b564765">toStringLong</a> () const</td></tr>
<tr class="memdesc:af32f5abced4d1365c34980741b564765"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for detail().  <a href="#af32f5abced4d1365c34980741b564765">More...</a><br/></td></tr>
<tr class="separator:af32f5abced4d1365c34980741b564765"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a143b826f6eeae5cafccf8a8c4548cdbf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NSatLayering.html">NSatLayering</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#a143b826f6eeae5cafccf8a8c4548cdbf">isBlockLayering</a> (const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> &amp;<a class="el" href="classregina_1_1NSatBlock.html#a72ab4d9bf4b1d57e4f58964d99368378">annulus</a>, <a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:a143b826f6eeae5cafccf8a8c4548cdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is a boundary annulus for a block of this type (single layering).  <a href="#a143b826f6eeae5cafccf8a8c4548cdbf">More...</a><br/></td></tr>
<tr class="separator:a143b826f6eeae5cafccf8a8c4548cdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590980341e7509c2e2c51d5ddb2186a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5">isBlock</a> (const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> &amp;<a class="el" href="classregina_1_1NSatBlock.html#a72ab4d9bf4b1d57e4f58964d99368378">annulus</a>, <a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">TetList</a> &amp;avoidTets)</td></tr>
<tr class="memdesc:a590980341e7509c2e2c51d5ddb2186a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated block.  <a href="#a590980341e7509c2e2c51d5ddb2186a5">More...</a><br/></td></tr>
<tr class="separator:a590980341e7509c2e2c51d5ddb2186a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aacfaa40481b077a4d9f53a7725b10dd2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatLayering.html#aacfaa40481b077a4d9f53a7725b10dd2">NSatLayering</a> (bool <a class="el" href="classregina_1_1NSatLayering.html#ab4bd473e0ba73e3e2e7bbfb99102cc4b">overHorizontal</a>)</td></tr>
<tr class="memdesc:aacfaa40481b077a4d9f53a7725b10dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a partially initialised block.  <a href="#aacfaa40481b077a4d9f53a7725b10dd2">More...</a><br/></td></tr>
<tr class="separator:aacfaa40481b077a4d9f53a7725b10dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af37b676f75effac57705e0f04c668e8a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#af37b676f75effac57705e0f04c668e8a">isBad</a> (<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *t, const <a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">TetList</a> &amp;list)</td></tr>
<tr class="memdesc:af37b676f75effac57705e0f04c668e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <a href="#af37b676f75effac57705e0f04c668e8a">More...</a><br/></td></tr>
<tr class="separator:af37b676f75effac57705e0f04c668e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdddb9b97ccae5cf091dd653e4e2d40"><td class="memTemplParams" colspan="2">template&lt;class List &gt; </td></tr>
<tr class="memitem:a0bdddb9b97ccae5cf091dd653e4e2d40"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a0bdddb9b97ccae5cf091dd653e4e2d40">isBad</a> (<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *t, const List &amp;list)</td></tr>
<tr class="memdesc:a0bdddb9b97ccae5cf091dd653e4e2d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron is contained within the given list.  <a href="#a0bdddb9b97ccae5cf091dd653e4e2d40">More...</a><br/></td></tr>
<tr class="separator:a0bdddb9b97ccae5cf091dd653e4e2d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af8810fb7267883b1cf525ba8b42e5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#ae0af8810fb7267883b1cf525ba8b42e5">notUnique</a> (<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *test)</td></tr>
<tr class="memdesc:ae0af8810fb7267883b1cf525ba8b42e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null.  <a href="#ae0af8810fb7267883b1cf525ba8b42e5">More...</a><br/></td></tr>
<tr class="separator:ae0af8810fb7267883b1cf525ba8b42e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2204296e017e5c34cc5247bf77adf571"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a2204296e017e5c34cc5247bf77adf571">notUnique</a> (<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *test, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other1)</td></tr>
<tr class="memdesc:a2204296e017e5c34cc5247bf77adf571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#a2204296e017e5c34cc5247bf77adf571">More...</a><br/></td></tr>
<tr class="separator:a2204296e017e5c34cc5247bf77adf571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1492404ad824c98a1a0753b91738c22"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#aa1492404ad824c98a1a0753b91738c22">notUnique</a> (<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *test, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other1, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other2)</td></tr>
<tr class="memdesc:aa1492404ad824c98a1a0753b91738c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#aa1492404ad824c98a1a0753b91738c22">More...</a><br/></td></tr>
<tr class="separator:aa1492404ad824c98a1a0753b91738c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cebe258004ded49590e442a24494b39"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a1cebe258004ded49590e442a24494b39">notUnique</a> (<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *test, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other1, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other2, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other3)</td></tr>
<tr class="memdesc:a1cebe258004ded49590e442a24494b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#a1cebe258004ded49590e442a24494b39">More...</a><br/></td></tr>
<tr class="separator:a1cebe258004ded49590e442a24494b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26efbf040246e7f893d97dcf8ffe5552"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a26efbf040246e7f893d97dcf8ffe5552">notUnique</a> (<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *test, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other1, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other2, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other3, <a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *other4)</td></tr>
<tr class="memdesc:a26efbf040246e7f893d97dcf8ffe5552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given tetrahedron pointer is null or equal to another from the given list.  <a href="#a26efbf040246e7f893d97dcf8ffe5552">More...</a><br/></td></tr>
<tr class="separator:a26efbf040246e7f893d97dcf8ffe5552"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3cb89adfd408f36c1f66d0917a0209a8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a3cb89adfd408f36c1f66d0917a0209a8">nAnnuli_</a></td></tr>
<tr class="memdesc:a3cb89adfd408f36c1f66d0917a0209a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of boundary annuli.  <a href="#a3cb89adfd408f36c1f66d0917a0209a8">More...</a><br/></td></tr>
<tr class="separator:a3cb89adfd408f36c1f66d0917a0209a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbab86e68ab6baabd47bdb6d15ea35d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#abbab86e68ab6baabd47bdb6d15ea35d6">annulus_</a></td></tr>
<tr class="memdesc:abbab86e68ab6baabd47bdb6d15ea35d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Details of each boundary annulus, as seen from the inside of this saturated block.  <a href="#abbab86e68ab6baabd47bdb6d15ea35d6">More...</a><br/></td></tr>
<tr class="separator:abbab86e68ab6baabd47bdb6d15ea35d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff6daa91e1548fb3b213aa79a23a66b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#aeff6daa91e1548fb3b213aa79a23a66b">twistedBoundary_</a></td></tr>
<tr class="memdesc:aeff6daa91e1548fb3b213aa79a23a66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the ring of boundary annuli twisted to form a Mobius band?  <a href="#aeff6daa91e1548fb3b213aa79a23a66b">More...</a><br/></td></tr>
<tr class="separator:aeff6daa91e1548fb3b213aa79a23a66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bc8cb95ea7a91998f1b6792d806ee0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#aa9bc8cb95ea7a91998f1b6792d806ee0">adjBlock_</a></td></tr>
<tr class="memdesc:aa9bc8cb95ea7a91998f1b6792d806ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known.  <a href="#aa9bc8cb95ea7a91998f1b6792d806ee0">More...</a><br/></td></tr>
<tr class="separator:aa9bc8cb95ea7a91998f1b6792d806ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92c2f7f2b7ba8d9268aac4cd3566c29"><td class="memItemLeft" align="right" valign="top">unsigned *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#ae92c2f7f2b7ba8d9268aac4cd3566c29">adjAnnulus_</a></td></tr>
<tr class="memdesc:ae92c2f7f2b7ba8d9268aac4cd3566c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block.  <a href="#ae92c2f7f2b7ba8d9268aac4cd3566c29">More...</a><br/></td></tr>
<tr class="separator:ae92c2f7f2b7ba8d9268aac4cd3566c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfac9ff4a125c932d03b0b5e82a4b1a8"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#adfac9ff4a125c932d03b0b5e82a4b1a8">adjReflected_</a></td></tr>
<tr class="memdesc:adfac9ff4a125c932d03b0b5e82a4b1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is reflected (see the class notes above).  <a href="#adfac9ff4a125c932d03b0b5e82a4b1a8">More...</a><br/></td></tr>
<tr class="separator:adfac9ff4a125c932d03b0b5e82a4b1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339396db368c5ccab6d3a17fee822eb3"><td class="memItemLeft" align="right" valign="top">bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSatBlock.html#a339396db368c5ccab6d3a17fee822eb3">adjBackwards_</a></td></tr>
<tr class="memdesc:a339396db368c5ccab6d3a17fee822eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes whether the adjacency for each boundary annulus is backwards (see the class notes above).  <a href="#a339396db368c5ccab6d3a17fee822eb3">More...</a><br/></td></tr>
<tr class="separator:a339396db368c5ccab6d3a17fee822eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A degenerate saturated block that is a single tetrahedron wrapped around so that two opposite edges touch. </p>
<p>This forms a degenerate one-tetrahedron solid torus that is pinched along a single meridinal curve.</p>
<p>The four faces of this tetrahedron form two boundary annuli, and the tetrahedron is effectively layered onto each boundary annulus. See the <a class="el" href="classregina_1_1NLayering.html" title="Represents a layering of zero or more tetrahedra upon a torus boundary.">NLayering</a> class notes for more discussion on layerings in general.</p>
<p>Although this block is degenerate (the fibres are all pinched together where the opposite edges of the tetrahedron meet), it can be used without problems as long as the entire Seifert fibred space is not formed from degenerate blocks. In other words, using such blocks is fine as long as they eventually meet a real (non-degenerate) block, which will give room for the fibres to separate so that they are no longer pinched together.</p>
<p>The <a class="el" href="structregina_1_1NSatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">NSatAnnulus</a> class notes describe horizontal and diagonal edges of a saturated annulus. This block may be one of two types, according to how the tetrahedron is layered onto the boundary annuli. Either the tetrahedron can be layered over the horizontal edge of each annulus (with the fibres pinched together between the two diagonal edges), or the tetrahedron can be layered over the diagonal edge of each annulus (with the fibres pinched together between the two horizontal edges). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a300627ed97526997bab97f9a21ac3090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::set&lt;<a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a>*&gt; <a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">regina::NSatBlock::TetList</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The data structure used to store a list of tetrahedra that should not be examined by <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a21b86ea65ac094e0c5d0fe6e7a93fc10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSatLayering::NSatLayering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NSatLayering.html">NSatLayering</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a clone of the given block structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the block structure to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacfaa40481b077a4d9f53a7725b10dd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSatLayering::NSatLayering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overHorizontal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a partially initialised block. </p>
<p>The boundary annuli will remain uninitialised, and must be initialised before this block can be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overHorizontal</td><td><code>true</code> if this block describes a layering over the horizontal edge of the boundary annulus, or <code>false</code> if it describes a layering over the diagonal edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a90117269568f7c0739f9212a6f8010cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NSatBlock::abbr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an abbreviated name or symbol for this block. </p>
<p>This name will reflect the particular block type, but may not provide thorough details.</p>
<p>The name will be no more than a handful of characters long, and will not include a newline (or surrounding dollar signs in TeX mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tex</td><td><code>true</code> if the name should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an abbreviated name for this block. </dd></dl>

</div>
</div>
<a class="anchor" id="a655a1e640549f880b5181859ceb8a4ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NSatBlock::adjacentAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> which specific annulus of the adjacent block is listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding annulus number on the other block that is adjacent along this annulus. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2ead9c02a126cc2d2e83f83bb432898"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::adjacentBackwards </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is backwards. </p>
<p>See the class notes for a discussion of backwards adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is backwards, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="a40bf257ea9ace4c4ffdce2934efffd59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> * regina::NSatBlock::adjacentBlock </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the other block adjacent along this annulus, or 0 if there is no adjacent block listed. </dd></dl>

</div>
</div>
<a class="anchor" id="a3de25a0279559a824baab7c5fb5c026b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::adjacentReflected </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether the adjacency along the given boundary annulus of this block is reflected. </p>
<p>See the class notes for a discussion of reflected adjacencies.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given annulus of this block actually has an adjacent block listed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the corresponding adjacency is reflected, or <code>false</code> if it is not. </dd></dl>

</div>
</div>
<a class="anchor" id="a3696140450369453ebaba0f46cdf9065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NSatLayering::adjustSFS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSFSpace.html">NSFSpace</a> &amp;&#160;</td>
          <td class="paramname"><em>sfs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the given Seifert fibred space to insert the contents of this saturated block. </p>
<p>In particular, the space should be adjusted as though an ordinary solid torus (base orbifold a disc, no twists or exceptional fibres) had been replaced by this block. This description does not make sense for blocks with twisted boundary; the twisted case is discussed below.</p>
<p>If the argument <em>reflect</em> is <code>true</code>, it should be assumed that this saturated block is being reflected before being inserted into the larger Seifert fibred space. That is, any twists or exceptional fibres should be negated before being added.</p>
<p>Regarding the signs of exceptional fibres: Consider a saturated block containing a solid torus whose meridinal curve runs <em>p</em> times horizontally around the boundary in order through annuli 0,1,... and follows the fibres <em>q</em> times from bottom to top (as depicted in the diagram in the <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a> class notes). Then this saturated block adds a positive (<em>p</em>, <em>q</em>) fibre to the underlying Seifert fibred space.</p>
<p>If the ring of saturated annuli bounding this block is twisted then the situation becomes more complex. It can be proven that such a block must contain a twisted reflector boundary in the base orbifold (use Z_2 homology with fibre-reversing paths to show that the base orbifold must contain another twisted boundary component, and then recall that real boundaries are not allowed inside blocks).</p>
<p>In this twisted boundary case, it should be assumed that the twisted reflector boundary is already stored in the given Seifert fibred space. This routine should make any further changes that are required (there may well be none). That is, the space should be adjusted as though a trivial Seifert fibred space over the annulus with one twisted reflector boundary (and one twisted puncture corresponding to the block boundary) had been replaced by this block. In particular, this routine should <em>not</em> add the reflector boundary itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sfs</td><td>the Seifert fibred space to adjust. </td></tr>
    <tr><td class="paramname">reflect</td><td><code>true</code> if this block is to be reflected, or <code>false</code> if it should be inserted directly. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1NSatBlock.html#a70ca5e069943ae58a2fb2652d8522cf9">regina::NSatBlock</a>.</p>

</div>
</div>
<a class="anchor" id="a72ab4d9bf4b1d57e4f58964d99368378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> &amp; regina::NSatBlock::annulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the requested annulus on the boundary of this saturated block. </p>
<p>Annuli are numbered from 0 to <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 as described in the class notes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>indicates which boundary annulus is requested; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the requested boundary annulus. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8c3cff7394b628481b97a693e683dcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> * regina::NSatLayering::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created clone of this saturated block structure. </p>
<p>A clone of the correct subclass of <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a> will be returned. For this reason, each subclass of <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a> must implement this routine.</p>
<dl class="section return"><dt>Returns</dt><dd>a new clone of this block. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NSatBlock.html#acef3c84f8329e56298de608ec00e109d">regina::NSatBlock</a>.</p>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a137eb1ca1624edd4e27c6b6d258e06a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NSatBlock::getAbbr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns an abbreviated name or symbol for this block. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000330">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NSatBlock.html#a90117269568f7c0739f9212a6f8010cb" title="Returns an abbreviated name or symbol for this block.">abbr()</a>. See the <a class="el" href="classregina_1_1NSatBlock.html#a90117269568f7c0739f9212a6f8010cb" title="Returns an abbreviated name or symbol for this block.">abbr()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="abc1a892c758412c511e5f6fb62a68d18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::hasAdjacentBlock </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether there is another saturated block listed as being adjacent to the given boundary annulus of this block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block should be examined; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given boundary annulus has an adjacent block listed, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af37b676f75effac57705e0f04c668e8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::NSatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bdddb9b97ccae5cf091dd653e4e2d40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class List &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool regina::NSatBlock::isBad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const List &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron is contained within the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. It is a generic routine for working with arbitrary list types.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Forward iterators of type <code>List::const_iterator</code> that span the given list can be obtained by calling <code>list.begin()</code> and <code>list.end()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron to search for. </td></tr>
    <tr><td class="paramname">list</td><td>the list in which to search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given tetrahedron was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a590980341e7509c2e2c51d5ddb2186a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a>* regina::NSatBlock::isBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated block. </p>
<p>The annulus should be represented from the inside of the proposed saturated block.</p>
<p>Only certain types of saturated block are recognised by this routine. More exotic saturated blocks will not be identified, and this routine will return <code>null</code> in such cases.</p>
<p>The given list of tetrahedra will not be examined by this routine. That is, only saturated blocks that do not contain any of these tetrahedra will be considered. As a consequence, if the given annulus uses any of these tetrahedra then <code>null</code> will be returned.</p>
<p>If a block is found on the other hand, all of the tetrahedra within this block will be added to the given list.</p>
<p>In the event that a block is found, it is guaranteed that the given annulus will be listed as annulus number 0 in the block structure, without any horizontal or vertical reflection.</p>
<dl class="section user"><dt>Python:</dt><dd>The second argument <em>avoidTets</em> is not present. An empty list will be passed instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a143b826f6eeae5cafccf8a8c4548cdbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NSatLayering.html">NSatLayering</a>* regina::NSatLayering::isBlockLayering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a> &amp;&#160;</td>
          <td class="paramname"><em>annulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSatBlock.html#a300627ed97526997bab97f9a21ac3090">TetList</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidTets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given annulus is a boundary annulus for a block of this type (single layering). </p>
<p>This routine is a specific case of <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">NSatBlock::isBlock()</a>; see that routine for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">annulus</td><td>the proposed boundary annulus that should form part of the new saturated block. </td></tr>
    <tr><td class="paramname">avoidTets</td><td>the list of tetrahedra that should not be considered, and to which any new tetrahedra will be added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the saturated block if one was found, or <code>null</code> if none was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a58ddd0257b1b560599aaf83f940fef30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NSatBlock::nAnnuli </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of annuli on the boundary of this saturated block. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary annuli. </dd></dl>

</div>
</div>
<a class="anchor" id="a9363cbf843199d800945b92828731a4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatBlock::nextBoundaryAnnulus </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>thisAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&amp;&#160;</td>
          <td class="paramname"><em>nextBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>nextAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>refVert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>refHoriz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>followPrev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next (or previous) boundary annulus around from this, treating all adjacent blocks as part of a single large saturated region. </p>
<p>Suppose that all saturated blocks are merged together according to adjacent boundary annuli, forming larger saturated structures. The remaining annuli that do not have adjacent blocks will group together to form several large boundary rings. Note that each boundary ring might involve annuli from several different blocks, and might or might not have a twist (thus forming a large Klein bottle instead of a large torus).</p>
<p>This routine is used to trace around such a boundary ring. It is assumed that annulus <em>thisAnnulus</em> of this block forms part of a boundary ring (i.e., it has no adjacent block). This routine will then return the next/previous annulus around from this in the large boundary ring. Here "next" means in the direction following from the second triangle of this annulus, and "previous" means in the direction following from the first triangle; the boolean argument <em>followPrev</em> controls which we will be used. This next/previous annulus might belong to another block, or it might even be this original annulus again.</p>
<p>The next/previous annulus itself is not returned, but rather a reference as to how it appears within its enclosing saturated block. Specifically, a block and corresponding annulus number will be returned in the arguments <em>nextBlock</em> and <em>nextAnnulus</em> respectively.</p>
<p>It is possible that the next/previous annulus as it appears within the returned block is oriented differently from how it appears within this large boundary ring. For this reason, two booleans are returned also. The argument <em>refVert</em> will describe whether the annulus is reflected vertically as it appears within the large boundary ring (i.e., the first and second triangles remain the same but the fibre direction is reversed). Similarly, the argument <em>refHoriz</em> will describe whether the annulus is reflected horizontally as it appears within the large boundary ring (i.e., first and second triangles are switched but the fibre direction is unchanged).</p>
<p>It is possible that both a horizontal and vertical reflection take place. Note that any kind of reflection will also affect the locations of the 0/1/2 markings as described in the <a class="el" href="structregina_1_1NSatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">NSatAnnulus</a> class notes.</p>
<p>Finally, note that if the large boundary ring is twisted (i.e., it forms a Klein bottle), then following the entire boundary ring around using this routine will bring you back to the starting annulus but with the <em>refVert</em> flag set.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Annulus <em>thisAnnulus</em> of this block has no block adjacent to it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If you wish to trace around an entire boundary ring, you will need to adjust the argument <em>followPrev</em> according to whether or not the current annulus is reflected horizontally (since, under a horizontal reflection, "next" becomes "previous" and vice versa).</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>This routine only takes two arguments (<em>thisAnnulus</em> and <em>followPrev</em>). The return value is a tuple of four values: the block returned in <em>nextBlock</em>, the integer returned in <em>nextAnnulus</em>, the boolean returned in <em>refVert</em>, and the boolean returned in <em>refHoriz</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thisAnnulus</td><td>describes which original boundary annulus of this block to examine; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">nextBlock</td><td>a reference used to return the block containing the next boundary annulus around from <em>thisAnnulus</em>. </td></tr>
    <tr><td class="paramname">nextAnnulus</td><td>a reference used to return the specific annulus number within <em>nextBlock</em> of the next annulus around; this will be between 0 and <em>nextBlock-&gt;<a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1</em> inclusive, and the corresponding annulus will have no block adjacent to it. </td></tr>
    <tr><td class="paramname">refVert</td><td>a reference used to return <code>true</code> if the next annulus around is vertically reflected, or <code>false</code> if not; see above for details. </td></tr>
    <tr><td class="paramname">refHoriz</td><td>a reference used to return <code>true</code> if the next annulus around is horizontally reflected, or <code>false</code> if not; see above for details. </td></tr>
    <tr><td class="paramname">followPrev</td><td><code>true</code> if we should find the previous boundary annulus, or <code>false</code> if we should find the next boundary annulus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0af8810fb7267883b1cf525ba8b42e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>test</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<p>The name <a class="el" href="classregina_1_1NSatBlock.html#ae0af8810fb7267883b1cf525ba8b42e5" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> may seem strang for what is essentially a nullity test; in fact this routine is offered as a degenerate case of other variants of <a class="el" href="classregina_1_1NSatBlock.html#ae0af8810fb7267883b1cf525ba8b42e5" title="Determines whether the given tetrahedron pointer is null.">notUnique()</a> that take more tetrahedra as arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2204296e017e5c34cc5247bf77adf571"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1492404ad824c98a1a0753b91738c22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em> or <em>other2</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cebe258004ded49590e442a24494b39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em> or <em>other3</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a26efbf040246e7f893d97dcf8ffe5552"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::notUnique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>test</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__triangulation.html#gaf2e0276b88d8f978f7d318e27b933ff9">NTetrahedron</a> *&#160;</td>
          <td class="paramname"><em>other4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given tetrahedron pointer is null or equal to another from the given list. </p>
<p>This is intended as a helper routine for <a class="el" href="classregina_1_1NSatBlock.html#a590980341e7509c2e2c51d5ddb2186a5" title="Determines whether the given annulus is in fact a boundary annulus for a recognised type of saturated...">isBlock()</a> and related routines. Despite its trivial implementation, it is provided to make long blocks of code easier to read and distinguish by functionality.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">test</td><td>the tetrahedron pointer to test. </td></tr>
    <tr><td class="paramname">other1</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other2</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other3</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
    <tr><td class="paramname">other4</td><td>another tetrahedron that will be compared with <em>test</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>test</em> is null or equal to <em>other1</em>, <em>other2</em>, <em>other3</em> or <em>other4</em>, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a62343453151adb6b293985721c32a706"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements a consistent ordering of saturated blocks. </p>
<p>This ordering is purely aesthetic on the part of the author, and is subject to change in future versions of Regina.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the saturated block with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this block comes before the given block according to the ordering of saturated blocks, or <code>false</code> if either the blocks are identical or this block comes after the given block. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4bd473e0ba73e3e2e7bbfb99102cc4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatLayering::overHorizontal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this describe a layering over the horizontal edge of the boundary annulus, or a layering over the diagonal edge? </p>
<p>See the <a class="el" href="structregina_1_1NSatAnnulus.html" title="Represents an annulus formed from a pair of triangles in a Seifert fibred space.">NSatAnnulus</a> class notes for definitions of horizontal and diagonal in this context. </p>

</div>
</div>
<a class="anchor" id="a1faecdf3a0e5968c4a188cac242e894c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatBlock::setAdjacent </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>whichAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> *&#160;</td>
          <td class="paramname"><em>adjBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>adjAnnulus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjReflected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>adjBackwards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists the given saturated block as being adjacent to the given boundary annulus of this block. </p>
<p>Both block structures (this and the given block) will be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whichAnnulus</td><td>indicates which boundary annulus of this block has the new adjacency; this must be between 0 and <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">adjBlock</td><td>the other saturated block that is adjacent to this. </td></tr>
    <tr><td class="paramname">adjAnnulus</td><td>indicates which boundary annulus of the adjacent block meets the given boundary annulus of this block; this must be between 0 and adjBlock-&gt;<a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">adjReflected</td><td>indicates whether the new adjacency is reflected (see the class notes for details). </td></tr>
    <tr><td class="paramname">adjBackwards</td><td>indicates whether the new adjacency is backwards (see the class notes for details). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aea0ab182c97fe654b8929d1fe41dc564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> , false  &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for str(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000253">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type str() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="af32f5abced4d1365c34980741b564765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> , false  &gt;::toStringLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for detail(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000254">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type detail() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a long text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a95ab8e989478e358de2e0da7a65bd2f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NSatBlock::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>originalTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__triangulation.html#gab61041f95f4c31c416b5731ed63c47a1">NIsomorphism</a> *&#160;</td>
          <td class="paramname"><em>iso</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>newTri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjusts the structure of this block according to the given isomorphism between triangulations. </p>
<p>Any triangulation-specific information will be transformed accordingly (for instance, the routine <a class="el" href="structregina_1_1NSatAnnulus.html#a631b29a8e19c9c901b81bfc99662abca" title="Adjusts this annulus representation according to the given isomorphism between triangulations.">NSatAnnulus::transform()</a> will be called for each boundary annulus).</p>
<p>Information regarding adjacent blocks will <em>not</em> be changed. Only structural information for this particular block will be updated.</p>
<p>The given isomorphism must describe a mapping from <em>originalTri</em> to <em>newTri</em>, and this block must currently refer to tetrahedra in <em>originalTri</em>. After this routine is called the block will instead refer to the corresponding tetrahedra in <em>newTri</em> (with changes in vertex/face numbering also accounted for).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This block currently refers to tetrahedra in <em>originalTri</em>, and <em>iso</em> describes a mapping from <em>originalTri</em> to <em>newTri</em>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any subclasses of <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a> that store additional triangulation-specific information will need to override this routine. When doing so, be sure to call <a class="el" href="classregina_1_1NSatBlock.html#a95ab8e989478e358de2e0da7a65bd2f6" title="Adjusts the structure of this block according to the given isomorphism between triangulations.">NSatBlock::transform()</a> so that the generic changes defined here will still take place.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">originalTri</td><td>the triangulation currently used by this saturated block. </td></tr>
    <tr><td class="paramname">iso</td><td>the mapping from <em>originalTri</em> to <em>newTri</em>. </td></tr>
    <tr><td class="paramname">newTri</td><td>the triangulation to be used by the updated block structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSatLST.html#aabe739825f2cc7029ce3242ad1304819">regina::NSatLST</a>.</p>

</div>
</div>
<a class="anchor" id="a6c67d9bb1286b258cf837d0e463dfebe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::twistedBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a long Mobius strip? </p>
<p>Recall from the class notes that the twist occurs between boundary annuli <a class="el" href="classregina_1_1NSatBlock.html#a58ddd0257b1b560599aaf83f940fef30" title="Returns the number of annuli on the boundary of this saturated block.">nAnnuli()</a>-1 and 0.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the ring of boundary annuli is twisted, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e680a4d5159230599728911f58f0603"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatLayering::writeAbbr </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tex</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an abbreviated name or symbol for this block to the given output stream. </p>
<p>This name should reflect the particular block type, but need not provide thorough details.</p>
<p>The output should be no more than a handful of characters long, and no newline should be written. In TeX mode, no leading or trailing dollar signs should be written.</p>
<dl class="section user"><dt>Python:</dt><dd>The parameter <em>out</em> does not exist; standard output will be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">tex</td><td><code>true</code> if the output should be formatted for TeX, or <code>false</code> if it should be in plain text format. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1NSatBlock.html#acd62b6809915e181af60b96f263957a2">regina::NSatBlock</a>.</p>

</div>
</div>
<a class="anchor" id="ad6259e5bdd2c5991d38ad1a0cd47e20e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatBlock::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1NSatBlock.html" title="Represents a saturated block in a Seifert fibred space.">NSatBlock</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6c77322a472722d9a722045ac30da04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSatLayering::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be implemented by subclasses.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1NSatBlock.html#a0556e17eefa9026f6229e8ede3cf8b23">regina::NSatBlock</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae92c2f7f2b7ba8d9268aac4cd3566c29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned* regina::NSatBlock::adjAnnulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes which specific annulus of the adjacent saturated block is joined to each boundary annulus of this block. </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a class="anchor" id="a339396db368c5ccab6d3a17fee822eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::NSatBlock::adjBackwards_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is backwards (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a class="anchor" id="aa9bc8cb95ea7a91998f1b6792d806ee0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NSatBlock.html">NSatBlock</a>** regina::NSatBlock::adjBlock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The saturated block joined to each boundary annulus; this may be null if there is no adjacency or if this information is not known. </p>

</div>
</div>
<a class="anchor" id="adfac9ff4a125c932d03b0b5e82a4b1a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool* regina::NSatBlock::adjReflected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Describes whether the adjacency for each boundary annulus is reflected (see the class notes above). </p>
<p>Values may be undefined if the corresponding entries in the <em>adjBlock</em> array is null. </p>

</div>
</div>
<a class="anchor" id="abbab86e68ab6baabd47bdb6d15ea35d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NSatAnnulus.html">NSatAnnulus</a>* regina::NSatBlock::annulus_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Details of each boundary annulus, as seen from the inside of this saturated block. </p>

</div>
</div>
<a class="anchor" id="a3cb89adfd408f36c1f66d0917a0209a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NSatBlock::nAnnuli_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of boundary annuli. </p>

</div>
</div>
<a class="anchor" id="aeff6daa91e1548fb3b213aa79a23a66b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NSatBlock::twistedBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the ring of boundary annuli twisted to form a Mobius band? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>subcomplex/<a class="el" href="nsatblocktypes_8h.html">nsatblocktypes.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
