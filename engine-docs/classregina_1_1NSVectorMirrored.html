<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::NSVectorMirrored Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NSVectorMirrored.html">NSVectorMirrored</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NSVectorMirrored-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NSVectorMirrored Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calculations.  
 <a href="classregina_1_1NSVectorMirrored.html#details">More...</a></p>

<p><code>#include &lt;surfaces/nsvectormirrored.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NSVectorMirrored:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NSVectorMirrored.png" usemap="#regina::NSVectorMirrored_map" alt=""/>
  <map id="regina::NSVectorMirrored_map" name="regina::NSVectorMirrored_map">
<area href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold." alt="regina::NormalSurfaceVector" shape="rect" coords="209,0,408,24"/>
<area href="classregina_1_1NSVectorOrientedQuad.html" title="A normal surface vector using transversely oriented quadrilateral coordinates." alt="regina::NSVectorOrientedQuad" shape="rect" coords="0,112,199,136"/>
<area href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates." alt="regina::NSVectorQuad" shape="rect" coords="209,112,408,136"/>
<area href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates." alt="regina::NSVectorQuadOct" shape="rect" coords="418,112,617,136"/>
<area href="classregina_1_1NSVectorQuadClosed.html" title="The vector for a normal surface in an ideal triangulation, expressed using quad coordinates and enume..." alt="regina::NSVectorQuadClosed" shape="rect" coords="209,168,408,192"/>
<area href="classregina_1_1NSVectorQuadOctClosed.html" title="The vector for an almost normal surface in an ideal triangulation, expressed using quad-oct coordinat..." alt="regina::NSVectorQuadOctClosed" shape="rect" coords="418,168,617,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7fb0d76340736f73191d953e5f1f7147"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a7fb0d76340736f73191d953e5f1f7147">NSVectorMirrored</a> (size_t length)</td></tr>
<tr class="memdesc:a7fb0d76340736f73191d953e5f1f7147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="#a7fb0d76340736f73191d953e5f1f7147">More...</a><br /></td></tr>
<tr class="separator:a7fb0d76340736f73191d953e5f1f7147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced4af37a677777be8d7c2712100161d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#aced4af37a677777be8d7c2712100161d">NSVectorMirrored</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:aced4af37a677777be8d7c2712100161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="#aced4af37a677777be8d7c2712100161d">More...</a><br /></td></tr>
<tr class="separator:aced4af37a677777be8d7c2712100161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1bb4b4fe448098099f7a51f50bc7ba"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a5b1bb4b4fe448098099f7a51f50bc7ba">~NSVectorMirrored</a> ()</td></tr>
<tr class="memdesc:a5b1bb4b4fe448098099f7a51f50bc7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this vector and its mirror if appropriate.  <a href="#a5b1bb4b4fe448098099f7a51f50bc7ba">More...</a><br /></td></tr>
<tr class="separator:a5b1bb4b4fe448098099f7a51f50bc7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dea78dbce6ae26d8f33fe26b568aba3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a8dea78dbce6ae26d8f33fe26b568aba3">makeMirror</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:a8dea78dbce6ae26d8f33fe26b568aba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mirror vector corresponding to this vector.  <a href="#a8dea78dbce6ae26d8f33fe26b568aba3">More...</a><br /></td></tr>
<tr class="separator:a8dea78dbce6ae26d8f33fe26b568aba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f01421c3a687edc63fada1808c063f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a09f01421c3a687edc63fada1808c063f">setElement</a> (size_t index, const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;value) override</td></tr>
<tr class="memdesc:a09f01421c3a687edc63fada1808c063f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given normal coordinate to the given value.  <a href="#a09f01421c3a687edc63fada1808c063f">More...</a><br /></td></tr>
<tr class="separator:a09f01421c3a687edc63fada1808c063f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654e738a0d9768a39697c79c8b2e74b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a654e738a0d9768a39697c79c8b2e74b7">operator+=</a> (const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;other) override</td></tr>
<tr class="memdesc:a654e738a0d9768a39697c79c8b2e74b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="#a654e738a0d9768a39697c79c8b2e74b7">More...</a><br /></td></tr>
<tr class="separator:a654e738a0d9768a39697c79c8b2e74b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7607f80141d61419e9fc05bb2c266c97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a7607f80141d61419e9fc05bb2c266c97">scaleDown</a> () override</td></tr>
<tr class="memdesc:a7607f80141d61419e9fc05bb2c266c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="#a7607f80141d61419e9fc05bb2c266c97">More...</a><br /></td></tr>
<tr class="separator:a7607f80141d61419e9fc05bb2c266c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4904b81d01adbe8050c30feb4d0dcee9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a4904b81d01adbe8050c30feb4d0dcee9">triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:a4904b81d01adbe8050c30feb4d0dcee9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="#a4904b81d01adbe8050c30feb4d0dcee9">More...</a><br /></td></tr>
<tr class="separator:a4904b81d01adbe8050c30feb4d0dcee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2015a06ce4d730919cf5ac29a17936e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a2015a06ce4d730919cf5ac29a17936e2">orientedTriangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:a2015a06ce4d730919cf5ac29a17936e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="#a2015a06ce4d730919cf5ac29a17936e2">More...</a><br /></td></tr>
<tr class="separator:a2015a06ce4d730919cf5ac29a17936e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7212bf949dd892cacfaed8de64115b7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a7212bf949dd892cacfaed8de64115b7a">quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:a7212bf949dd892cacfaed8de64115b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="#a7212bf949dd892cacfaed8de64115b7a">More...</a><br /></td></tr>
<tr class="separator:a7212bf949dd892cacfaed8de64115b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5318a2c38f37d22b56a05a31bec63592"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a5318a2c38f37d22b56a05a31bec63592">orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:a5318a2c38f37d22b56a05a31bec63592"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="#a5318a2c38f37d22b56a05a31bec63592">More...</a><br /></td></tr>
<tr class="separator:a5318a2c38f37d22b56a05a31bec63592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f510cc1f1fd40f2152803491a3cbf7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a79f510cc1f1fd40f2152803491a3cbf7">octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:a79f510cc1f1fd40f2152803491a3cbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="#a79f510cc1f1fd40f2152803491a3cbf7">More...</a><br /></td></tr>
<tr class="separator:a79f510cc1f1fd40f2152803491a3cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1074733d1aaa6de9ff8cd8b39ffaba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#aef1074733d1aaa6de9ff8cd8b39ffaba">edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:aef1074733d1aaa6de9ff8cd8b39ffaba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="#aef1074733d1aaa6de9ff8cd8b39ffaba">More...</a><br /></td></tr>
<tr class="separator:aef1074733d1aaa6de9ff8cd8b39ffaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef4cdd091a72db9f5a7bbd37c0c1735"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#acef4cdd091a72db9f5a7bbd37c0c1735">arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:acef4cdd091a72db9f5a7bbd37c0c1735"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="#acef4cdd091a72db9f5a7bbd37c0c1735">More...</a><br /></td></tr>
<tr class="separator:acef4cdd091a72db9f5a7bbd37c0c1735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64145ed248bd3b24af3d65a7500aadb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#af64145ed248bd3b24af3d65a7500aadb">coords</a> () const</td></tr>
<tr class="memdesc:af64145ed248bd3b24af3d65a7500aadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the underlying vector of coordinates.  <a href="#af64145ed248bd3b24af3d65a7500aadb">More...</a><br /></td></tr>
<tr class="separator:af64145ed248bd3b24af3d65a7500aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a919f098d3c43f1e68a5dc3ba9c9da227">clone</a> () const =0</td></tr>
<tr class="memdesc:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="#a919f098d3c43f1e68a5dc3ba9c9da227">More...</a><br /></td></tr>
<tr class="separator:a919f098d3c43f1e68a5dc3ba9c9da227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85">size</a> () const</td></tr>
<tr class="memdesc:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector.  <a href="#a680b7b7ac5f45b6404644ee9fb1afb85">More...</a><br /></td></tr>
<tr class="separator:a680b7b7ac5f45b6404644ee9fb1afb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238f18a8ba972f206f34a0302dc863cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a238f18a8ba972f206f34a0302dc863cf">operator []</a> (size_t index) const</td></tr>
<tr class="memdesc:a238f18a8ba972f206f34a0302dc863cf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector.  <a href="#a238f18a8ba972f206f34a0302dc863cf">More...</a><br /></td></tr>
<tr class="separator:a238f18a8ba972f206f34a0302dc863cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b5594a67c7a695ab21adaa862a8d38"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a44b5594a67c7a695ab21adaa862a8d38">allowsAlmostNormal</a> () const =0</td></tr>
<tr class="memdesc:a44b5594a67c7a695ab21adaa862a8d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="#a44b5594a67c7a695ab21adaa862a8d38">More...</a><br /></td></tr>
<tr class="separator:a44b5594a67c7a695ab21adaa862a8d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07d54c737adf4198657a237f31d8851"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ab07d54c737adf4198657a237f31d8851">allowsSpun</a> () const =0</td></tr>
<tr class="memdesc:ab07d54c737adf4198657a237f31d8851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles.  <a href="#ab07d54c737adf4198657a237f31d8851">More...</a><br /></td></tr>
<tr class="separator:ab07d54c737adf4198657a237f31d8851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a8c2541a7dcdecfafd908ad50d98cd9d1">allowsOriented</a> () const =0</td></tr>
<tr class="memdesc:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces.  <a href="#a8c2541a7dcdecfafd908ad50d98cd9d1">More...</a><br /></td></tr>
<tr class="separator:a8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a207ab6ce67f8c4f322f64fd0494e3a88">hasMultipleOctDiscs</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface has more than one octagonal disc.  <a href="#a207ab6ce67f8c4f322f64fd0494e3a88">More...</a><br /></td></tr>
<tr class="separator:a207ab6ce67f8c4f322f64fd0494e3a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ace3f3ccef51ec75544ee6cc6875a6cda">isCompact</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is compact (has finitely many discs).  <a href="#ace3f3ccef51ec75544ee6cc6875a6cda">More...</a><br /></td></tr>
<tr class="separator:ace3f3ccef51ec75544ee6cc6875a6cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf49b14b890535f0deee9d8db62dc4c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aecf49b14b890535f0deee9d8db62dc4c">isVertexLinking</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:aecf49b14b890535f0deee9d8db62dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is vertex linking.  <a href="#aecf49b14b890535f0deee9d8db62dc4c">More...</a><br /></td></tr>
<tr class="separator:aecf49b14b890535f0deee9d8db62dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f860e909873a8ab2449f36c7d3cfb3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a48f860e909873a8ab2449f36c7d3cfb3">isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a48f860e909873a8ab2449f36c7d3cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="#a48f860e909873a8ab2449f36c7d3cfb3">More...</a><br /></td></tr>
<tr class="separator:a48f860e909873a8ab2449f36c7d3cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07535a32a2da710490b864bb23f93ea1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a07535a32a2da710490b864bb23f93ea1">isThinEdgeLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a07535a32a2da710490b864bb23f93ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the thin link of a single edge.  <a href="#a07535a32a2da710490b864bb23f93ea1">More...</a><br /></td></tr>
<tr class="separator:a07535a32a2da710490b864bb23f93ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4da454072e9b44e9ccbf23523006dae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#ae4da454072e9b44e9ccbf23523006dae">isSplitting</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ae4da454072e9b44e9ccbf23523006dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a splitting surface in the given triangulation.  <a href="#ae4da454072e9b44e9ccbf23523006dae">More...</a><br /></td></tr>
<tr class="separator:ae4da454072e9b44e9ccbf23523006dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f211dde81cc1505e475d48da6f1aafa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a7f211dde81cc1505e475d48da6f1aafa">isCentral</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:a7f211dde81cc1505e475d48da6f1aafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a central surface in the given triangulation.  <a href="#a7f211dde81cc1505e475d48da6f1aafa">More...</a><br /></td></tr>
<tr class="separator:a7f211dde81cc1505e475d48da6f1aafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7c70b9f732f6867adf218250d66271df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html#a7c70b9f732f6867adf218250d66271df">makeMirror</a> (const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;original, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang)</td></tr>
<tr class="memdesc:a7c70b9f732f6867adf218250d66271df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mirror vector corresponding to the given vector.  <a href="#a7c70b9f732f6867adf218250d66271df">More...</a><br /></td></tr>
<tr class="separator:a7c70b9f732f6867adf218250d66271df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2208bc38293ec2a64359c2f582868a2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#a2208bc38293ec2a64359c2f582868a2f">makeZeroVector</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:a2208bc38293ec2a64359c2f582868a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.  <a href="#a2208bc38293ec2a64359c2f582868a2f">More...</a><br /></td></tr>
<tr class="separator:a2208bc38293ec2a64359c2f582868a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda04c126a8ff0c247429cf4acabdc60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#afda04c126a8ff0c247429cf4acabdc60">makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:afda04c126a8ff0c247429cf4acabdc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal surface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.  <a href="#afda04c126a8ff0c247429cf4acabdc60">More...</a><br /></td></tr>
<tr class="separator:afda04c126a8ff0c247429cf4acabdc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0abea602d297abf6cc61d1281169a4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aa0abea602d297abf6cc61d1281169a4e">makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:aa0abea602d297abf6cc61d1281169a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal surfaces be embedded.  <a href="#aa0abea602d297abf6cc61d1281169a4e">More...</a><br /></td></tr>
<tr class="separator:aa0abea602d297abf6cc61d1281169a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aed283d890443594e39ba1ea13c81046d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Ray.html">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html#aed283d890443594e39ba1ea13c81046d">coords_</a></td></tr>
<tr class="memdesc:aed283d890443594e39ba1ea13c81046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw vector of normal coordinates.  <a href="#aed283d890443594e39ba1ea13c81046d">More...</a><br /></td></tr>
<tr class="separator:aed283d890443594e39ba1ea13c81046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calculations. </p>
<p>When it is difficult to convert from the native coordinate system to standard tri-quad-oct coordinates, use this as a base class. The conversion of the entire vector will be done once only, and future coordinate lookups will be performed through the pre-converted mirror vector.</p>
<p>Subclasses need not implement any of the coordinate lookup routines. The default implementation will be to pass the lookup to the mirror. If any particular lookup can be done more efficiently in the native coordinate system, the corresponding routine should be overridden.</p>
<p>Subclasses must however implement two variants of <a class="el" href="classregina_1_1NSVectorMirrored.html#a8dea78dbce6ae26d8f33fe26b568aba3" title="Creates a new mirror vector corresponding to this vector.">makeMirror()</a>:</p>
<ul>
<li>a static function NormalSurfaceVector* <a class="el" href="classregina_1_1NSVectorMirrored.html#a7c70b9f732f6867adf218250d66271df" title="Creates a new mirror vector corresponding to the given vector.">makeMirror(const Ray&amp;, const Triangulation&lt;3&gt;*)</a>, which builds the mirror vector from the native vector;</li>
<li>a virtual function NormalSurfaceVector* <a class="el" href="classregina_1_1NSVectorMirrored.html#a8dea78dbce6ae26d8f33fe26b568aba3" title="Creates a new mirror vector corresponding to this vector.">makeMirror(const Triangulation&lt;3&gt;*) const</a>, which simply calls the static function described above.</li>
</ul>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7fb0d76340736f73191d953e5f1f7147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb0d76340736f73191d953e5f1f7147">&#9670;&nbsp;</a></span>NSVectorMirrored() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorMirrored::NSVectorMirrored </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced4af37a677777be8d7c2712100161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced4af37a677777be8d7c2712100161d">&#9670;&nbsp;</a></span>NSVectorMirrored() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorMirrored::NSVectorMirrored </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b1bb4b4fe448098099f7a51f50bc7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1bb4b4fe448098099f7a51f50bc7ba">&#9670;&nbsp;</a></span>~NSVectorMirrored()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorMirrored::~NSVectorMirrored </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this vector and its mirror if appropriate. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a44b5594a67c7a695ab21adaa862a8d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b5594a67c7a695ab21adaa862a8d38">&#9670;&nbsp;</a></span>allowsAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> octagonal discs.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="a8c2541a7dcdecfafd908ad50d98cd9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2541a7dcdecfafd908ad50d98cd9d1">&#9670;&nbsp;</a></span>allowsOriented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported. </dd></dl>

</div>
</div>
<a id="ab07d54c737adf4198657a237f31d8851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07d54c737adf4198657a237f31d8851">&#9670;&nbsp;</a></span>allowsSpun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> infinitely many triangles.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun-normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="acef4cdd091a72db9f5a7bbd37c0c1735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef4cdd091a72db9f5a7bbd37c0c1735">&#9670;&nbsp;</a></span>arcs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#ad3e760f7358e5ab934afca94fcd57138">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a919f098d3c43f1e68a5dc3ba9c9da227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919f098d3c43f1e68a5dc3ba9c9da227">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> as this vector. </p>

</div>
</div>
<a id="af64145ed248bd3b24af3d65a7500aadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64145ed248bd3b24af3d65a7500aadb">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalSurfaceVector::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the underlying vector of coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector of coordinates. </dd></dl>

</div>
</div>
<a id="aef1074733d1aaa6de9ff8cd8b39ffaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1074733d1aaa6de9ff8cd8b39ffaba">&#9670;&nbsp;</a></span>edgeWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#ab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#a5bc14138b82130ad79e60d8585aea3c5">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a207ab6ce67f8c4f322f64fd0494e3a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a207ab6ce67f8c4f322f64fd0494e3a88">&#9670;&nbsp;</a></span>hasMultipleOctDiscs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::hasMultipleOctDiscs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface has more than one octagonal disc. </p>
<p>It may be assumed that at most one octagonal disc <em>type</em> exists in this surface. This routine will return <code>true</code> if an octagonal type does exist and its coordinate is greater than one.</p>
<p>The default implementation for this routine simply calculates all the octagonal coordinates and returns as soon as a positive or negative result can be established. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<p>If a subclass does not allow for almost normal surfaces, this routine will never be called and thus does not need to be overwritten.</p>
<dl class="section pre"><dt>Precondition</dt><dd>At most one octagonal disc <em>type</em> exists in this surface. </dd>
<dd>
This normal surface vector is using a coordinate system that allows for almost normal surfaces.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is an octagonal disc type present and its coordinate is greater than one. </dd></dl>

</div>
</div>
<a id="a7f211dde81cc1505e475d48da6f1aafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f211dde81cc1505e475d48da6f1aafa">&#9670;&nbsp;</a></span>isCentral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::isCentral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a central surface in the given triangulation. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If the surface is central, the number of tetrahedra it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that the surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a id="ace3f3ccef51ec75544ee6cc6875a6cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3f3ccef51ec75544ee6cc6875a6cda">&#9670;&nbsp;</a></span>isCompact()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is compact (has finitely many discs). </p>
<p>The default implementation for this routine simply runs through every disc type until a disc type with infinite disc count is found or all disc types have been examined. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is compact. </dd></dl>

</div>
</div>
<a id="ae4da454072e9b44e9ccbf23523006dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da454072e9b44e9ccbf23523006dae">&#9670;&nbsp;</a></span>isSplitting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isSplitting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a splitting surface in the given triangulation. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is a splitting surface. </dd></dl>

</div>
</div>
<a id="a07535a32a2da710490b864bb23f93ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07535a32a2da710490b864bb23f93ea1">&#9670;&nbsp;</a></span>isThinEdgeLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*&gt; regina::NormalSurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the thin link of a single edge. </p>
<p>If there are two different edges <em>e1</em> and <em>e2</em> for which the surface could be expressed as the thin link of either <em>e1</em> or <em>e2</em>, the pair (<em>e1</em>,<em>e2</em>) will be returned. If the surface is the thin link of only one edge <em>e</em>, the pair (<em>e</em>,0) will be returned. If the surface is not the thin link of any edges, the pair (0,0) will be returned.</p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by this surface, as described above. </dd></dl>

</div>
</div>
<a id="a48f860e909873a8ab2449f36c7d3cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f860e909873a8ab2449f36c7d3cfb3">&#9670;&nbsp;</a></span>isVertexLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt;3&gt;* regina::NormalSurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#a98d612c1b934bd3d64908cbc42e4e81e">regina::NSVectorOrientedQuad</a>, <a class="el" href="classregina_1_1NSVectorQuadOct.html#a34afa9a4f7444f2b985adb80aaf2054f">regina::NSVectorQuadOct</a>, and <a class="el" href="classregina_1_1NSVectorQuad.html#af5b5ea3db1bb195bb2ac85d61c478c6a">regina::NSVectorQuad</a>.</p>

</div>
</div>
<a id="aecf49b14b890535f0deee9d8db62dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf49b14b890535f0deee9d8db62dc4c">&#9670;&nbsp;</a></span>isVertexLinking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>The default implementation for this routine simply runs through every non-triangular disc type ensuring that each has no corresponding discs. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is vertex linking. </dd></dl>

</div>
</div>
<a id="aa0abea602d297abf6cc61d1281169a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0abea602d297abf6cc61d1281169a4e">&#9670;&nbsp;</a></span>makeEmbeddedConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>* regina::NormalSurfaceVector::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal surfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a id="afda04c126a8ff0c247429cf4acabdc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda04c126a8ff0c247429cf4acabdc60">&#9670;&nbsp;</a></span>makeMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalSurfaceVector::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of normal surface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </p>
<p>See <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">regina::makeMatchingEquations()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations. </dd></dl>

</div>
</div>
<a id="a8dea78dbce6ae26d8f33fe26b568aba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dea78dbce6ae26d8f33fe26b568aba3">&#9670;&nbsp;</a></span>makeMirror() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NSVectorMirrored::makeMirror </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mirror vector corresponding to this vector. </p>
<p>This function must return a newly created vector that describes this normal surface in the corresponding "standard" coordinate system (i.e., <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>, or <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>, and so on.)</p>
<p>Typically subclasses should implement this function by calling the corresponding static <a class="el" href="classregina_1_1NSVectorMirrored.html#a8dea78dbce6ae26d8f33fe26b568aba3" title="Creates a new mirror vector corresponding to this vector.">makeMirror()</a> function, which does the real work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created vector that describes the same normal surface in a "standard" coordinate system, as described above. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#a5002d5519d11bae7249c551df2500f29">regina::NSVectorOrientedQuad</a>, <a class="el" href="classregina_1_1NSVectorQuadOct.html#a48fe8698ec9e687c84764347bbff2774">regina::NSVectorQuadOct</a>, and <a class="el" href="classregina_1_1NSVectorQuad.html#aeb7de0ac36839c7c0d76c273e01e89a2">regina::NSVectorQuad</a>.</p>

</div>
</div>
<a id="a7c70b9f732f6867adf218250d66271df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c70b9f732f6867adf218250d66271df">&#9670;&nbsp;</a></span>makeMirror() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NSVectorMirrored::makeMirror </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mirror vector corresponding to the given vector. </p>
<p>This function should be implemented by each subclass of <a class="el" href="classregina_1_1NSVectorMirrored.html" title="A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calcu...">NSVectorMirrored</a>.</p>
<p>This function must return a newly created vector that describes the given normal surface in a different coordinate system:</p>
<ul>
<li>The given vector must be in the coordinate system described by the subclass in which this function is implemented.</li>
<li>The return vector must be in the corresponding "standard" coordinate system (i.e., <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>, or <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>, and so on.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>a vector in the coordinate system corresponding to the subclass in which this function is implemented. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which the corresponding normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created vector that describes the same normal surface in a "standard" coordinate system, as described above. </dd></dl>

</div>
</div>
<a id="a2208bc38293ec2a64359c2f582868a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2208bc38293ec2a64359c2f582868a2f">&#9670;&nbsp;</a></span>makeZeroVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurfaceVector::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </p>
<p>All elements of the new vector will be initialised to zero.</p>
<p>See <a class="el" href="group__hypersurface.html#ga062b6a0fcecd8d05a2193bb98feb8b29" title="Returns a new normal hypersurface vector of the appropriate length for the given triangulation and th...">regina::makeZeroVector()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a id="a79f510cc1f1fd40f2152803491a3cbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f510cc1f1fd40f2152803491a3cbf7">&#9670;&nbsp;</a></span>octs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#abae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#ab042b630da0605dfc10845cb4eab2955">regina::NormalSurfaceVector</a>.</p>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#a3bd54cb95a976b0a3139f54b0296fa40">regina::NSVectorOrientedQuad</a>, and <a class="el" href="classregina_1_1NSVectorQuad.html#aa12eb25640ae314520cdb1499d23b9e2">regina::NSVectorQuad</a>.</p>

</div>
</div>
<a id="a238f18a8ba972f206f34a0302dc863cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238f18a8ba972f206f34a0302dc863cf">&#9670;&nbsp;</a></span>operator []()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp; regina::NormalSurfaceVector::operator [] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to retrieve; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinate at the given index. </dd></dl>

</div>
</div>
<a id="a654e738a0d9768a39697c79c8b2e74b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654e738a0d9768a39697c79c8b2e74b7">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSVectorMirrored::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p>This behaves correctly in the case where <em>other</em> is <em>this</em>.</p>
<p>The default implementation simply adds the coordinates of the underlying vectors. Subclasses should reimplement this if they carry any additional information that also needs adjusting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector represent normal surfaces in the same triangulation, and use the same normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NormalSurfaceVector.html#a87bf86f895cf3f97281cf98c6e9ac8ef">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a5318a2c38f37d22b56a05a31bec63592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5318a2c38f37d22b56a05a31bec63592">&#9670;&nbsp;</a></span>orientedQuads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a1782b65da2df0fe8921002d28139938e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">NormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NormalSurfaceVector.html#ad6d15dfef9d0dca32bc66c8ac506d196">regina::NormalSurfaceVector</a>.</p>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#aa1e3f2307548c014fb23b2a511632a1d">regina::NSVectorOrientedQuad</a>.</p>

</div>
</div>
<a id="a2015a06ce4d730919cf5ac29a17936e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2015a06ce4d730919cf5ac29a17936e2">&#9670;&nbsp;</a></span>orientedTriangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a778a22958ed66c5118c06e8fc861b5b7" title="Returns the number of oriented triangular discs of the given type in this normal surface.">NormalSurface::orientedTriangles()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NormalSurfaceVector.html#a2ce2cc2fbd8b46b97d8ea787535282d0">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a7212bf949dd892cacfaed8de64115b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7212bf949dd892cacfaed8de64115b7a">&#9670;&nbsp;</a></span>quads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#a570ee5188151835875872bb11c5849da">regina::NormalSurfaceVector</a>.</p>

<p>Reimplemented in <a class="el" href="classregina_1_1NSVectorOrientedQuad.html#ab05acfe295661b31d74571b224b58712">regina::NSVectorOrientedQuad</a>.</p>

</div>
</div>
<a id="a7607f80141d61419e9fc05bb2c266c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7607f80141d61419e9fc05bb2c266c97">&#9670;&nbsp;</a></span>scaleDown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSVectorMirrored::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p>The default implementation simply scales down the underlying vector. Subclasses should reimplement this if they carry any additional information that also needs adjusting. </p>

<p>Reimplemented from <a class="el" href="classregina_1_1NormalSurfaceVector.html#a19f95b5cc7d6e00e85cd78283227fb17">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a09f01421c3a687edc63fada1808c063f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f01421c3a687edc63fada1808c063f">&#9670;&nbsp;</a></span>setElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSVectorMirrored::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given normal coordinate to the given value. </p>
<p>The default implementation simply sets the coordinate in the underlying vector. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to set; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaceVector.html#a680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the given coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NormalSurfaceVector.html#a24c548a7bcd676dceef9b01ec96ab8da">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="a680b7b7ac5f45b6404644ee9fb1afb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680b7b7ac5f45b6404644ee9fb1afb85">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurfaceVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="a4904b81d01adbe8050c30feb4d0dcee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4904b81d01adbe8050c30feb4d0dcee9">&#9670;&nbsp;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NormalSurfaceVector.html#a3ea2312f446f4f7b1c3066925d7f1e2c">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aed283d890443594e39ba1ea13c81046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed283d890443594e39ba1ea13c81046d">&#9670;&nbsp;</a></span>coords_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Ray.html">Ray</a> regina::NormalSurfaceVector::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw vector of normal coordinates. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surfaces/<a class="el" href="nsvectormirrored_8h.html">nsvectormirrored.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
