<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NormalHypersurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1NormalHypersurface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NormalHypersurface Class Reference<div class="ingroups"><a class="el" href="group__hypersurface.html">Normal Hypersurfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a single normal hypersurface in a 4-manifold triangulation.  
 <a href="classregina_1_1NormalHypersurface.html#details">More...</a></p>

<p><code>#include &lt;hypersurface/normalhypersurface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalHypersurface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalHypersurface.png" usemap="#regina::NormalHypersurface_map" alt=""/>
  <map id="regina::NormalHypersurface_map" name="regina::NormalHypersurface_map">
<area href="structregina_1_1ShortOutput.html" alt="regina::ShortOutput&lt; NormalHypersurface &gt;" shape="rect" coords="0,56,269,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NormalHypersurface, false &gt;" shape="rect" coords="0,0,269,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a79ea52ceb2420115302f014a1fb621e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a79ea52ceb2420115302f014a1fb621e8">NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *<a class="el" href="classregina_1_1NormalHypersurface.html#a9e23f53ec15e353b8b892d850ed36c3f">triangulation</a>, <a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *vector)</td></tr>
<tr class="memdesc:a79ea52ceb2420115302f014a1fb621e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal hypersurface inside the given triangulation with the given coordinate vector.  <a href="#a79ea52ceb2420115302f014a1fb621e8">More...</a><br/></td></tr>
<tr class="separator:a79ea52ceb2420115302f014a1fb621e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1687ff1ed99e7a17c2b72e1fa9281f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#abf1687ff1ed99e7a17c2b72e1fa9281f">NormalHypersurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *triang, <a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a> coordSystem, List allCoords)</td></tr>
<tr class="memdesc:abf1687ff1ed99e7a17c2b72e1fa9281f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that creates a new normal hypersurface inside the given triangulation with the given coordinate vector.  <a href="#abf1687ff1ed99e7a17c2b72e1fa9281f">More...</a><br/></td></tr>
<tr class="separator:abf1687ff1ed99e7a17c2b72e1fa9281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30dbb81eda08334962f4e5328dded7f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ab30dbb81eda08334962f4e5328dded7f">~NormalHypersurface</a> ()</td></tr>
<tr class="memdesc:ab30dbb81eda08334962f4e5328dded7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this normal hypersurface.  <a href="#ab30dbb81eda08334962f4e5328dded7f">More...</a><br/></td></tr>
<tr class="separator:ab30dbb81eda08334962f4e5328dded7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133c05eeccbe50ae6becf76a80369a56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a133c05eeccbe50ae6becf76a80369a56">clone</a> () const </td></tr>
<tr class="memdesc:a133c05eeccbe50ae6becf76a80369a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this normal hypersurface.  <a href="#a133c05eeccbe50ae6becf76a80369a56">More...</a><br/></td></tr>
<tr class="separator:a133c05eeccbe50ae6becf76a80369a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8a167b23449c050a2c6b614dc78f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#abe8a167b23449c050a2c6b614dc78f0a">doubleHypersurface</a> () const </td></tr>
<tr class="memdesc:abe8a167b23449c050a2c6b614dc78f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated hypersurface that is the double of this hypersurface.  <a href="#abe8a167b23449c050a2c6b614dc78f0a">More...</a><br/></td></tr>
<tr class="separator:abe8a167b23449c050a2c6b614dc78f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbd571a5d52247e208cf9d9e2531be2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#adcbd571a5d52247e208cf9d9e2531be2">tetrahedra</a> (size_t pentIndex, int vertex) const </td></tr>
<tr class="memdesc:adcbd571a5d52247e208cf9d9e2531be2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface.  <a href="#adcbd571a5d52247e208cf9d9e2531be2">More...</a><br/></td></tr>
<tr class="separator:adcbd571a5d52247e208cf9d9e2531be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9450093fdbebb0af483928612dd51ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a9450093fdbebb0af483928612dd51ffd">prisms</a> (size_t pentIndex, int prismType) const </td></tr>
<tr class="memdesc:a9450093fdbebb0af483928612dd51ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface.  <a href="#a9450093fdbebb0af483928612dd51ffd">More...</a><br/></td></tr>
<tr class="separator:a9450093fdbebb0af483928612dd51ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08611a59e2dfbb07c7a7e1570111d59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ab08611a59e2dfbb07c7a7e1570111d59">edgeWeight</a> (size_t edgeIndex) const </td></tr>
<tr class="memdesc:ab08611a59e2dfbb07c7a7e1570111d59"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge.  <a href="#ab08611a59e2dfbb07c7a7e1570111d59">More...</a><br/></td></tr>
<tr class="separator:ab08611a59e2dfbb07c7a7e1570111d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6073b6437475b7d550e96a5528972a51"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a6073b6437475b7d550e96a5528972a51">countCoords</a> () const </td></tr>
<tr class="memdesc:a6073b6437475b7d550e96a5528972a51"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used.  <a href="#a6073b6437475b7d550e96a5528972a51">More...</a><br/></td></tr>
<tr class="separator:a6073b6437475b7d550e96a5528972a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e23f53ec15e353b8b892d850ed36c3f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a9e23f53ec15e353b8b892d850ed36c3f">triangulation</a> () const </td></tr>
<tr class="memdesc:a9e23f53ec15e353b8b892d850ed36c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal hypersurface resides.  <a href="#a9e23f53ec15e353b8b892d850ed36c3f">More...</a><br/></td></tr>
<tr class="separator:a9e23f53ec15e353b8b892d850ed36c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959f27f04a90d27ee39c3579cabfa8f6"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a959f27f04a90d27ee39c3579cabfa8f6">name</a> () const </td></tr>
<tr class="memdesc:a959f27f04a90d27ee39c3579cabfa8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal hypersurface.  <a href="#a959f27f04a90d27ee39c3579cabfa8f6">More...</a><br/></td></tr>
<tr class="separator:a959f27f04a90d27ee39c3579cabfa8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdf3ef9c9407d10c5eabc69671207f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a1cdf3ef9c9407d10c5eabc69671207f5">setName</a> (const std::string &amp;<a class="el" href="classregina_1_1NormalHypersurface.html#a959f27f04a90d27ee39c3579cabfa8f6">name</a>)</td></tr>
<tr class="memdesc:a1cdf3ef9c9407d10c5eabc69671207f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name associated with this normal hypersurface.  <a href="#a1cdf3ef9c9407d10c5eabc69671207f5">More...</a><br/></td></tr>
<tr class="separator:a1cdf3ef9c9407d10c5eabc69671207f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc3d8f75f4625081ce3dbc8209391be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a1dc3d8f75f4625081ce3dbc8209391be">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a1dc3d8f75f4625081ce3dbc8209391be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this hypersurface to the given output stream, using standard tetrahedron-prism coordinates.  <a href="#a1dc3d8f75f4625081ce3dbc8209391be">More...</a><br/></td></tr>
<tr class="separator:a1dc3d8f75f4625081ce3dbc8209391be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ef0471a970cf0b156a3fc09c79f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ac71ef0471a970cf0b156a3fc09c79f92">writeRawVector</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ac71ef0471a970cf0b156a3fc09c79f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the underlying coordinate vector to the given output stream in text format.  <a href="#ac71ef0471a970cf0b156a3fc09c79f92">More...</a><br/></td></tr>
<tr class="separator:ac71ef0471a970cf0b156a3fc09c79f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591bfa15ad5f836d400820760bcb3ee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a591bfa15ad5f836d400820760bcb3ee3">writeXMLData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a591bfa15ad5f836d400820760bcb3ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this normal hypersurface and all of its properties.  <a href="#a591bfa15ad5f836d400820760bcb3ee3">More...</a><br/></td></tr>
<tr class="separator:a591bfa15ad5f836d400820760bcb3ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f51e9730d5ae8e6bd2416fb1541137"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ab2f51e9730d5ae8e6bd2416fb1541137">isEmpty</a> () const </td></tr>
<tr class="memdesc:ab2f51e9730d5ae8e6bd2416fb1541137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal hypersurface is empty (has no pieces whatsoever).  <a href="#ab2f51e9730d5ae8e6bd2416fb1541137">More...</a><br/></td></tr>
<tr class="separator:ab2f51e9730d5ae8e6bd2416fb1541137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31cb134130c8b49682e1662c0f04b87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#aa31cb134130c8b49682e1662c0f04b87">isCompact</a> () const </td></tr>
<tr class="memdesc:aa31cb134130c8b49682e1662c0f04b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal hypersurface is compact (has finitely many pieces).  <a href="#aa31cb134130c8b49682e1662c0f04b87">More...</a><br/></td></tr>
<tr class="separator:aa31cb134130c8b49682e1662c0f04b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf82d56fa4664bfa57431b561a8a0f61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#adf82d56fa4664bfa57431b561a8a0f61">isOrientable</a> () const </td></tr>
<tr class="memdesc:adf82d56fa4664bfa57431b561a8a0f61"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is orientable.  <a href="#adf82d56fa4664bfa57431b561a8a0f61">More...</a><br/></td></tr>
<tr class="separator:adf82d56fa4664bfa57431b561a8a0f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace91fbc98f72751654bed04f5acbd4d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ace91fbc98f72751654bed04f5acbd4d0">isTwoSided</a> () const </td></tr>
<tr class="memdesc:ace91fbc98f72751654bed04f5acbd4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is two-sided.  <a href="#ace91fbc98f72751654bed04f5acbd4d0">More...</a><br/></td></tr>
<tr class="separator:ace91fbc98f72751654bed04f5acbd4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98a9e8296714200473ba1921bc70f9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ad98a9e8296714200473ba1921bc70f9c">isConnected</a> () const </td></tr>
<tr class="memdesc:ad98a9e8296714200473ba1921bc70f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is connected.  <a href="#ad98a9e8296714200473ba1921bc70f9c">More...</a><br/></td></tr>
<tr class="separator:ad98a9e8296714200473ba1921bc70f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeca4877a312dac782f75c127c892ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a5eeca4877a312dac782f75c127c892ae">hasRealBoundary</a> () const </td></tr>
<tr class="memdesc:a5eeca4877a312dac782f75c127c892ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this hypersurface has any real boundary, that is, whether it meets any boundary tetrahedra of the triangulation.  <a href="#a5eeca4877a312dac782f75c127c892ae">More...</a><br/></td></tr>
<tr class="separator:a5eeca4877a312dac782f75c127c892ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af418723f8caf31cc2333363f8cced589"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#af418723f8caf31cc2333363f8cced589">isVertexLinking</a> () const </td></tr>
<tr class="memdesc:af418723f8caf31cc2333363f8cced589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this hypersurface is vertex linking.  <a href="#af418723f8caf31cc2333363f8cced589">More...</a><br/></td></tr>
<tr class="separator:af418723f8caf31cc2333363f8cced589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910fe74f39ed1f6c24d1eeff56b0baaf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a910fe74f39ed1f6c24d1eeff56b0baaf">isVertexLink</a> () const </td></tr>
<tr class="memdesc:a910fe74f39ed1f6c24d1eeff56b0baaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this hypersurface is the link of a single vertex.  <a href="#a910fe74f39ed1f6c24d1eeff56b0baaf">More...</a><br/></td></tr>
<tr class="separator:a910fe74f39ed1f6c24d1eeff56b0baaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c06c031fa186cf75bf11fa3bf6b6cd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a9c06c031fa186cf75bf11fa3bf6b6cd2">isThinEdgeLink</a> () const </td></tr>
<tr class="memdesc:a9c06c031fa186cf75bf11fa3bf6b6cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this hypersurface is the thin link of a single edge.  <a href="#a9c06c031fa186cf75bf11fa3bf6b6cd2">More...</a><br/></td></tr>
<tr class="separator:a9c06c031fa186cf75bf11fa3bf6b6cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0fb96835908932faca1b9eac7b9183"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a3b0fb96835908932faca1b9eac7b9183">homology</a> () const </td></tr>
<tr class="memdesc:a3b0fb96835908932faca1b9eac7b9183"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this hypersurface.  <a href="#a3b0fb96835908932faca1b9eac7b9183">More...</a><br/></td></tr>
<tr class="separator:a3b0fb96835908932faca1b9eac7b9183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785bfc77ede71fb6248070abf8d3ba19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a785bfc77ede71fb6248070abf8d3ba19">triangulate</a> () const </td></tr>
<tr class="memdesc:a785bfc77ede71fb6248070abf8d3ba19"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 3-manifold triangulation describing this normal hypersurface.  <a href="#a785bfc77ede71fb6248070abf8d3ba19">More...</a><br/></td></tr>
<tr class="separator:a785bfc77ede71fb6248070abf8d3ba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ceea193dfde1f66b6141865eb15a98e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a3ceea193dfde1f66b6141865eb15a98e">sameSurface</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;other) const </td></tr>
<tr class="memdesc:a3ceea193dfde1f66b6141865eb15a98e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given hypersurface in fact represent the same normal hypersurface.  <a href="#a3ceea193dfde1f66b6141865eb15a98e">More...</a><br/></td></tr>
<tr class="separator:a3ceea193dfde1f66b6141865eb15a98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46acfaf0e7e81bc771204c851d6cac59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a46acfaf0e7e81bc771204c851d6cac59">embedded</a> () const </td></tr>
<tr class="memdesc:a46acfaf0e7e81bc771204c851d6cac59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this hypersurface is embedded.  <a href="#a46acfaf0e7e81bc771204c851d6cac59">More...</a><br/></td></tr>
<tr class="separator:a46acfaf0e7e81bc771204c851d6cac59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026ef8f07fe21429abaa2648338470ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a026ef8f07fe21429abaa2648338470ad">locallyCompatible</a> (const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;other) const </td></tr>
<tr class="memdesc:a026ef8f07fe21429abaa2648338470ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given hypersurface are locally compatible.  <a href="#a026ef8f07fe21429abaa2648338470ad">More...</a><br/></td></tr>
<tr class="separator:a026ef8f07fe21429abaa2648338470ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab6995bc125395f2fdfd6222593cde2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a8ab6995bc125395f2fdfd6222593cde2">rawVector</a> () const </td></tr>
<tr class="memdesc:a8ab6995bc125395f2fdfd6222593cde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the raw vector that sits beneath this normal hypersurface.  <a href="#a8ab6995bc125395f2fdfd6222593cde2">More...</a><br/></td></tr>
<tr class="separator:a8ab6995bc125395f2fdfd6222593cde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1ShortOutput.html#afb6c9df60a4ebe89115cd80eb683cf58">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:afb6c9df60a4ebe89115cd80eb683cf58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default implementation for detailed output.  <a href="#afb6c9df60a4ebe89115cd80eb683cf58">More...</a><br/></td></tr>
<tr class="separator:afb6c9df60a4ebe89115cd80eb683cf58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a689410e3a01a1ccec8d37a29554f33af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a689410e3a01a1ccec8d37a29554f33af">calculateRealBoundary</a> () const </td></tr>
<tr class="memdesc:a689410e3a01a1ccec8d37a29554f33af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates whether this hypersurface has any real boundary and stores the result as a property.  <a href="#a689410e3a01a1ccec8d37a29554f33af">More...</a><br/></td></tr>
<tr class="separator:a689410e3a01a1ccec8d37a29554f33af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd6652d6fa0078a8fdd19025c57bf63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a7dd6652d6fa0078a8fdd19025c57bf63">calculateFromTriangulation</a> () const </td></tr>
<tr class="memdesc:a7dd6652d6fa0078a8fdd19025c57bf63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and store all properties that we derive from the 3-manifold triangulation of this hypersurface.  <a href="#a7dd6652d6fa0078a8fdd19025c57bf63">More...</a><br/></td></tr>
<tr class="separator:a7dd6652d6fa0078a8fdd19025c57bf63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a01107fe9e58d09cc33d78ad93514050a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a01107fe9e58d09cc33d78ad93514050a">vector_</a></td></tr>
<tr class="memdesc:a01107fe9e58d09cc33d78ad93514050a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the coordinates of the normal hypersurface in whichever space is appropriate.  <a href="#a01107fe9e58d09cc33d78ad93514050a">More...</a><br/></td></tr>
<tr class="separator:a01107fe9e58d09cc33d78ad93514050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5966bebd6637e22c5fb8653591de238c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a5966bebd6637e22c5fb8653591de238c">triangulation_</a></td></tr>
<tr class="memdesc:a5966bebd6637e22c5fb8653591de238c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which this normal hypersurface resides.  <a href="#a5966bebd6637e22c5fb8653591de238c">More...</a><br/></td></tr>
<tr class="separator:a5966bebd6637e22c5fb8653591de238c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935b0370203eda2d9b07e3c751d81e76"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a935b0370203eda2d9b07e3c751d81e76">name_</a></td></tr>
<tr class="memdesc:a935b0370203eda2d9b07e3c751d81e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional name associated with this hypersurface.  <a href="#a935b0370203eda2d9b07e3c751d81e76">More...</a><br/></td></tr>
<tr class="separator:a935b0370203eda2d9b07e3c751d81e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad153c38c524603a35d400fb88f291662"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ad153c38c524603a35d400fb88f291662">orientable_</a></td></tr>
<tr class="memdesc:ad153c38c524603a35d400fb88f291662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface orientable?  <a href="#ad153c38c524603a35d400fb88f291662">More...</a><br/></td></tr>
<tr class="separator:ad153c38c524603a35d400fb88f291662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029a5069b2bfc0c1f9ac64ee9510d995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a029a5069b2bfc0c1f9ac64ee9510d995">twoSided_</a></td></tr>
<tr class="memdesc:a029a5069b2bfc0c1f9ac64ee9510d995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface two-sided?  <a href="#a029a5069b2bfc0c1f9ac64ee9510d995">More...</a><br/></td></tr>
<tr class="separator:a029a5069b2bfc0c1f9ac64ee9510d995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12d8548519c825d124d291c1e46db93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#ad12d8548519c825d124d291c1e46db93">connected_</a></td></tr>
<tr class="memdesc:ad12d8548519c825d124d291c1e46db93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface connected?  <a href="#ad12d8548519c825d124d291c1e46db93">More...</a><br/></td></tr>
<tr class="separator:ad12d8548519c825d124d291c1e46db93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf48595823bea5cd7e1c2bd2bf3e0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a4bf48595823bea5cd7e1c2bd2bf3e0a1">realBoundary_</a></td></tr>
<tr class="memdesc:a4bf48595823bea5cd7e1c2bd2bf3e0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this hypersurface have real boundary (i.e.  <a href="#a4bf48595823bea5cd7e1c2bd2bf3e0a1">More...</a><br/></td></tr>
<tr class="separator:a4bf48595823bea5cd7e1c2bd2bf3e0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6f5cb305ce9f0254556667efdb9461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#a3e6f5cb305ce9f0254556667efdb9461">compact_</a></td></tr>
<tr class="memdesc:a3e6f5cb305ce9f0254556667efdb9461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this hypersurface compact (i.e., does it only contain finitely many pieces)?  <a href="#a3e6f5cb305ce9f0254556667efdb9461">More...</a><br/></td></tr>
<tr class="separator:a3e6f5cb305ce9f0254556667efdb9461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf666c3a10d4f971c9e01457a0f2cd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, <br class="typebreak"/>
<a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalHypersurface.html#abf666c3a10d4f971c9e01457a0f2cd60">H1_</a></td></tr>
<tr class="memdesc:abf666c3a10d4f971c9e01457a0f2cd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">First homology group of the hypersurface.  <a href="#abf666c3a10d4f971c9e01457a0f2cd60">More...</a><br/></td></tr>
<tr class="separator:abf666c3a10d4f971c9e01457a0f2cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aad51ed54e8b4d8d41dfdfa82496be1ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad51ed54e8b4d8d41dfdfa82496be1ee"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLNormalHypersurfaceReader</b></td></tr>
<tr class="separator:aad51ed54e8b4d8d41dfdfa82496be1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a single normal hypersurface in a 4-manifold triangulation. </p>
<p>Once the underlying triangulation changes, this normal hypersurface object is no longer valid.</p>
<p>The information provided by the various query methods is independent of the underlying coordinate system being used. See the <a class="el" href="classregina_1_1NormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurfaceVector</a> class notes for details of what to do when introducing a new coordinate system.</p>
<p>Note that non-compact surfaces (surfaces with infinitely many pieces, are allowed; in these cases, the corresponding coordinate lookup routines will return <a class="el" href="classregina_1_1IntegerBase.html#ac071d748e8a784b5a425b01292aaa76a" title="Globally available infinity.">LargeInteger::infinity</a> where appropriate. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a79ea52ceb2420115302f014a1fb621e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a> *&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new normal hypersurface inside the given triangulation with the given coordinate vector. </p>
<p>This normal hypersurface will claim ownership of the given vector (i.e., you should not change or delete the vector yourself afterwards).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector represents a normal hypersurface inside the given triangulation. </dd>
<dd>
The given coordinate vector cannot be the null pointer.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">vector</td><td>a vector containing the coordinates of the normal hypersurface in whichever space is appropriate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf1687ff1ed99e7a17c2b72e1fa9281f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::NormalHypersurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#ga57526727019e919f8b9c3858318d2350">HyperCoords</a>&#160;</td>
          <td class="paramname"><em>coordSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&#160;</td>
          <td class="paramname"><em>allCoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that creates a new normal hypersurface inside the given triangulation with the given coordinate vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate system is one in which Regina is able to enumerate and store normal hypersurfaces (not a system like <a class="el" href="group__hypersurface.html#gga57526727019e919f8b9c3858318d2350a20231b069d7350f6da4840f48163efe1" title="Represents edge weight coordinates for normal hypersurfaces.">regina::HS_EDGE_WEIGHT</a>, which is for viewing purposes only). </dd>
<dd>
The given coordinate vector represents a normal hypersurface inside the given triangulation (in particular, it satisfies the relevant system of matching equations). This will not be checked, and things <em>will</em> go wrong if you break it.</dd></dl>
<dl class="section user"><dt>C++:</dt><dd>Not available; this routine is for Python only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface resides. </td></tr>
    <tr><td class="paramname">coordSystem</td><td>the coordinate system used by this normal hypersurface. </td></tr>
    <tr><td class="paramname">allCoords</td><td>the corresponding vector of normal coordinates, expressed as a Python list. The list elements will be converted internally to LargeInteger objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab30dbb81eda08334962f4e5328dded7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalHypersurface::~NormalHypersurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this normal hypersurface. </p>
<p>The underlying vector of coordinates will also be deallocated. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7dd6652d6fa0078a8fdd19025c57bf63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::calculateFromTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate and store all properties that we derive from the 3-manifold triangulation of this hypersurface. </p>

</div>
</div>
<a class="anchor" id="a689410e3a01a1ccec8d37a29554f33af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::calculateRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates whether this hypersurface has any real boundary and stores the result as a property. </p>

</div>
</div>
<a class="anchor" id="a133c05eeccbe50ae6becf76a80369a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>* regina::NormalHypersurface::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this normal hypersurface. </p>
<p>The name of the normal hypersurface will <em>not</em> be copied to the clone; instead the clone will have an empty name.</p>
<dl class="section return"><dt>Returns</dt><dd>a clone of this normal hypersurface. </dd></dl>

</div>
</div>
<a class="anchor" id="a6073b6437475b7d550e96a5528972a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalHypersurface::countCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> , supportsUtf8 &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="abe8a167b23449c050a2c6b614dc78f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a>* regina::NormalHypersurface::doubleHypersurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated hypersurface that is the double of this hypersurface. </p>
<dl class="section return"><dt>Returns</dt><dd>the double of this normal hypersurface. </dd></dl>

</div>
</div>
<a class="anchor" id="ab08611a59e2dfbb07c7a7e1570111d59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurface::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;4&gt;::countEdges()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal hypersurface crosses the given edge. </dd></dl>

</div>
</div>
<a class="anchor" id="a46acfaf0e7e81bc771204c851d6cac59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::embedded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this hypersurface is embedded. </p>
<p>This is true if and only if the surface contains no conflicting prism types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface is embedded. </dd></dl>

</div>
</div>
<a class="anchor" id="a5eeca4877a312dac782f75c127c892ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::hasRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this hypersurface has any real boundary, that is, whether it meets any boundary tetrahedra of the triangulation. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface has real boundary. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b0fb96835908932faca1b9eac7b9183"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp; regina::NormalHypersurface::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the first homology group of this hypersurface. </p>
<p>There is an important caveat regarding invalid 4-manifold triangulations. If the underlying triangulation has edge links that are not spheres, then it is possible that this normal hypersurface is not a compact 3-manifold. In such a case, this routine will compute homology in the same way as <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abe5cba1c19ba697c73c7ee7d2d0bca20" title="Returns the first homology group for this triangulation.">Triangulation&lt;3&gt;::homology()</a> - that is, by effectively truncating ideal points of the hypersurface (which may arise where the hypersurface meets an invalid edge).</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group. </dd></dl>

</div>
</div>
<a class="anchor" id="aa31cb134130c8b49682e1662c0f04b87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isCompact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal hypersurface is compact (has finitely many pieces). </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this normal hypersurface is compact. </dd></dl>

</div>
</div>
<a class="anchor" id="ad98a9e8296714200473ba1921bc70f9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is connected. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is connected, or <code>false</code> if this hypersurface is disconnected. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2f51e9730d5ae8e6bd2416fb1541137"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this normal hypersurface is empty (has no pieces whatsoever). </p>

</div>
</div>
<a class="anchor" id="adf82d56fa4664bfa57431b561a8a0f61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is orientable. </p>
<p>· This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is orientable, or <code>false</code> if this hypersurface is non-orientable. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c06c031fa186cf75bf11fa3bf6b6cd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; * regina::NormalHypersurface::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this hypersurface is the thin link of a single edge. </p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the edge linked by this hypersurface, or 0 if this hypersurface is not a thin edge link. </dd></dl>

</div>
</div>
<a class="anchor" id="ace91fbc98f72751654bed04f5acbd4d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isTwoSided </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this hypersurface is two-sided. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal pieces, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this hypersurface is two-sided, or <code>false</code> if this hypersurface is one-sided. </dd></dl>

</div>
</div>
<a class="anchor" id="a910fe74f39ed1f6c24d1eeff56b0baaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 4 &gt; * regina::NormalHypersurface::isVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this hypersurface is the link of a single vertex. </p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this hypersurface, or 0 if this hypersurface is not the link of a single vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="af418723f8caf31cc2333363f8cced589"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::isVertexLinking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this hypersurface is vertex linking. </p>
<p>A <em>vertex linking</em> hypersurface contains only tetrahedra.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this hypersurface is vertex linking. </dd></dl>

</div>
</div>
<a class="anchor" id="a026ef8f07fe21429abaa2648338470ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::locallyCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given hypersurface are locally compatible. </p>
<p>Local compatibility means that, within each individual pentachoron of the triangulation, it is possible to arrange the normal discs of both hypersurfaces so that none intersect.</p>
<p>This is a local constraint, not a global constraint. That is, we do not insist that we can avoid intersections within all pentachora <em>simultaneously</em>.</p>
<p>Local compatibility can be formulated in terms of normal piece types. Two normal hypersurfaces are locally compatible if and only if they together use at most two prism piece types per pentachoron; moreover, if there <em>are</em> two prism piece types within a single pentachoron then these prism types are non-intersecting.</p>
<p>If one of the two hypersurfaces breaks the local compatibility constraints on its own (for instance, it contains two conflicting prism types within the same pentachoron), then this routine will return <code>false</code> regardless of what the other hypersurface contains.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal hypersurface live within the same 4-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other hypersurface to test for local compatibility with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two hypersurfaces are locally compatible, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a class="anchor" id="a959f27f04a90d27ee39c3579cabfa8f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NormalHypersurface::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal hypersurface. </p>
<p>Names are optional and need not be unique. The default name for a hypersurface is the empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of associated with this hypersurface. </dd></dl>

</div>
</div>
<a class="anchor" id="a9450093fdbebb0af483928612dd51ffd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurface::prisms </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prismType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface. </p>
<p>A prism piece type is identified by specifying a pentachoron and an edge of that pentachoron; prisms of this type will then separate edge <em>i</em> of the pentachoron from triangle <em>i</em> of the pentachoron.</p>
<p>If you are using a coordinate system that adorns pieces with additional information (such as orientation), this routine returns the <em>total</em> number of prisms in the given pentachoron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested prisms reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">prismType</td><td>specifies the edge of the given pentachoron that this prism separates from the opposite triangle; this should be between 0 and 9 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prism pieces of the given type. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab6995bc125395f2fdfd6222593cde2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalHypersurface::rawVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the raw vector that sits beneath this normal hypersurface. </p>
<p>Generally users should not need this function. However, it is provided here in case the need should arise (e.g., for reasons of efficiency).</p>
<dl class="section warning"><dt>Warning</dt><dd>An <a class="el" href="classregina_1_1NormalHypersurface.html" title="Represents a single normal hypersurface in a 4-manifold triangulation.">NormalHypersurface</a> does not know what underlying coordinate system its raw vector uses. Unless you already know the coordinate system in advance (i.e., you created the hypersurface yourself), it is best to keep to the coordinate-system-agnostic access functions such as <a class="el" href="classregina_1_1NormalHypersurfaceVector.html#abcecbbd6ed6b1c905604345e755e9a23" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">NormalHypersurfaceVector::tetrahedra()</a> and <a class="el" href="classregina_1_1NormalHypersurfaceVector.html#a0d96a0eb204333f4deff8f7cacefdb00" title="Returns the number of prism pieces of the given type in this normal hypersurface.">NormalHypersurfaceVector::prisms()</a>.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying raw vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ceea193dfde1f66b6141865eb15a98e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalHypersurface::sameSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given hypersurface in fact represent the same normal hypersurface. </p>
<p>Specifically, this routine examines (or computes) the number of normal pieces of each type, and returns <code>true</code> if and only if these counts are the same for both hypersurfaces.</p>
<p>It does not matter what coordinate systems the two hypersurfaces use. In particular, it does not matter if this and the given hypersurface use different coordinate systems.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal hypersurface live within the same 4-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the hypersurface to be compared with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both hypersurfaces represent the same normal hypersurface, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cdf3ef9c9407d10c5eabc69671207f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name associated with this normal hypersurface. </p>
<p>Names are optional and need not be unique. The default name for a hypersurface is the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the new name to associate with this hypersurface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> , supportsUtf8 &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="adcbd571a5d52247e208cf9d9e2531be2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalHypersurface::tetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface. </p>
<p>A tetrahedron piece type is identified by specifying a pentachoron and a vertex of that pentachoron that the tetrahedron surrounds.</p>
<p>If you are using a coordinate system that adorns pieces with additional information (such as orientation), this routine returns the <em>total</em> number of tetrahedra in the given pentachoron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested pieces reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;4&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given pentachoron around which the requested pieces lie; this should be between 0 and 4 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedron pieces of the given type. </dd></dl>

</div>
</div>
<a class="anchor" id="a785bfc77ede71fb6248070abf8d3ba19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalHypersurface::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a 3-manifold triangulation describing this normal hypersurface. </p>
<p>The triangulation will be simplified via <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#ad63140ff3ab1dd53acd661a6c8cde47e" title="Attempts to simplify the triangulation using fast and greedy heuristics.">Triangulation&lt;3&gt;::intelligentSimplify()</a>, which means that the tetrahedra of the final triangulation are not likely to correspond to any particular tetrahedron/prism pieces of this normal hypersurface.</p>
<p>The 3-manifold triangulation will be newly allocated, and destroying it is the responsibility of the caller of this routine.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd><em>Bug:</em> Check for absurdly large numbers of pieces and return 0 accordingly.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal hypersurface is compact and embedded.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a triangulation of this normal hypersurface. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e23f53ec15e353b8b892d850ed36c3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; * regina::NormalHypersurface::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal hypersurface resides. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> , supportsUtf8 &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac71ef0471a970cf0b156a3fc09c79f92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeRawVector </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the underlying coordinate vector to the given output stream in text format. </p>
<p>No indication will be given as to which coordinate system is being used or what each coordinate means. No newline will be written.</p>
<dl class="section user"><dt>Python:</dt><dd>The paramater <em>out</em> does not exist, and is taken to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb6c9df60a4ebe89115cd80eb683cf58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structregina_1_1ShortOutput.html">regina::ShortOutput</a>&lt; <a class="el" href="classregina_1_1NormalHypersurface.html">NormalHypersurface</a> , false  &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default implementation for detailed output. </p>
<p>This routine simply calls <em>T::writeTextShort()</em> and appends a final newline.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1dc3d8f75f4625081ce3dbc8209391be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this hypersurface to the given output stream, using standard tetrahedron-prism coordinates. </p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a591bfa15ad5f836d400820760bcb3ee3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalHypersurface::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this normal hypersurface and all of its properties. </p>
<p>This routine will be called from within <a class="el" href="classregina_1_1NormalHypersurfaces.html#a6977ddff2a3f50ab5a9f2cb1d5fb51f1" title="Writes a chunk of XML containing the data for this packet only.">NormalHypersurfaces::writeXMLPacketData()</a>.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3e6f5cb305ce9f0254556667efdb9461"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::compact_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface compact (i.e., does it only contain finitely many pieces)? </p>

</div>
</div>
<a class="anchor" id="ad12d8548519c825d124d291c1e46db93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::connected_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface connected? </p>

</div>
</div>
<a class="anchor" id="abf666c3a10d4f971c9e01457a0f2cd60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>, <a class="el" href="classregina_1_1StoreManagedPtr.html">StoreManagedPtr</a>&gt; regina::NormalHypersurface::H1_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First homology group of the hypersurface. </p>

</div>
</div>
<a class="anchor" id="a935b0370203eda2d9b07e3c751d81e76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NormalHypersurface::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional name associated with this hypersurface. </p>

</div>
</div>
<a class="anchor" id="ad153c38c524603a35d400fb88f291662"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::orientable_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface orientable? </p>

</div>
</div>
<a class="anchor" id="a4bf48595823bea5cd7e1c2bd2bf3e0a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::realBoundary_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this hypersurface have real boundary (i.e. </p>
<p>does it meet any boundary facets)? </p>

</div>
</div>
<a class="anchor" id="a5966bebd6637e22c5fb8653591de238c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;4&gt;* regina::NormalHypersurface::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which this normal hypersurface resides. </p>

</div>
</div>
<a class="anchor" id="a029a5069b2bfc0c1f9ac64ee9510d995"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalHypersurface::twoSided_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this hypersurface two-sided? </p>

</div>
</div>
<a class="anchor" id="a01107fe9e58d09cc33d78ad93514050a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalHypersurfaceVector.html">NormalHypersurfaceVector</a>* regina::NormalHypersurface::vector_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the coordinates of the normal hypersurface in whichever space is appropriate. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hypersurface/<a class="el" href="normalhypersurface_8h.html">normalhypersurface.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
