<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::graph::AdjacentCrossingIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="namespaceregina_1_1graph.html">graph</a></li><li class="navelem"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classregina_1_1graph_1_1AdjacentCrossingIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::graph::AdjacentCrossingIterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Iterates through the two crossings adjacent to a given crossing of a knot or link via an outgoing arc.  
 <a href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#details">More...</a></p>

<p><code>#include &lt;link/graph.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3595b10d7b35bc8ef70df6de24717c3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a3595b10d7b35bc8ef70df6de24717c3e">AdjacentCrossingIterator</a> ()</td></tr>
<tr class="memdesc:a3595b10d7b35bc8ef70df6de24717c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a singular iterator.  <a href="#a3595b10d7b35bc8ef70df6de24717c3e">More...</a><br /></td></tr>
<tr class="separator:a3595b10d7b35bc8ef70df6de24717c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd08e5351a3532bd3585f899fdfd210"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a5dd08e5351a3532bd3585f899fdfd210">AdjacentCrossingIterator</a> (<a class="el" href="classregina_1_1Crossing.html">Crossing</a> *crossing, int strand=0)</td></tr>
<tr class="memdesc:a5dd08e5351a3532bd3585f899fdfd210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator that runs through the two crossings adjacent to the given crossing via an outgoing arc.  <a href="#a5dd08e5351a3532bd3585f899fdfd210">More...</a><br /></td></tr>
<tr class="separator:a5dd08e5351a3532bd3585f899fdfd210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f318929e6e2920bd4d01cb823b74b84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a6f318929e6e2920bd4d01cb823b74b84">AdjacentCrossingIterator</a> (const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:a6f318929e6e2920bd4d01cb823b74b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="#a6f318929e6e2920bd4d01cb823b74b84">More...</a><br /></td></tr>
<tr class="separator:a6f318929e6e2920bd4d01cb823b74b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8457836ec0d026ef912b302c28f4b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a5b8457836ec0d026ef912b302c28f4b0">operator++</a> ()</td></tr>
<tr class="memdesc:a5b8457836ec0d026ef912b302c28f4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="#a5b8457836ec0d026ef912b302c28f4b0">More...</a><br /></td></tr>
<tr class="separator:a5b8457836ec0d026ef912b302c28f4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494897e34e255adfde1b8dcdf3d6ef17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a494897e34e255adfde1b8dcdf3d6ef17">operator++</a> (int)</td></tr>
<tr class="memdesc:a494897e34e255adfde1b8dcdf3d6ef17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="#a494897e34e255adfde1b8dcdf3d6ef17">More...</a><br /></td></tr>
<tr class="separator:a494897e34e255adfde1b8dcdf3d6ef17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4a8513dbf89441c1672756c274e482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a4a4a8513dbf89441c1672756c274e482">operator *</a> () const</td></tr>
<tr class="memdesc:a4a4a8513dbf89441c1672756c274e482"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the adjacent crossing to which this iterator points.  <a href="#a4a4a8513dbf89441c1672756c274e482">More...</a><br /></td></tr>
<tr class="separator:a4a4a8513dbf89441c1672756c274e482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddbd2762e83508b32573a1c6f92a969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a2ddbd2762e83508b32573a1c6f92a969">operator=</a> (const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:a2ddbd2762e83508b32573a1c6f92a969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default assignment operator.  <a href="#a2ddbd2762e83508b32573a1c6f92a969">More...</a><br /></td></tr>
<tr class="separator:a2ddbd2762e83508b32573a1c6f92a969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af9b3954c28c1985ebdc17fefbfd02f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#a2af9b3954c28c1985ebdc17fefbfd02f">operator==</a> (const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a2af9b3954c28c1985ebdc17fefbfd02f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="#a2af9b3954c28c1985ebdc17fefbfd02f">More...</a><br /></td></tr>
<tr class="separator:a2af9b3954c28c1985ebdc17fefbfd02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade482bdfaa1a96da1beb7c38fbd1ab92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html#ade482bdfaa1a96da1beb7c38fbd1ab92">operator !=</a> (const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ade482bdfaa1a96da1beb7c38fbd1ab92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="#ade482bdfaa1a96da1beb7c38fbd1ab92">More...</a><br /></td></tr>
<tr class="separator:ade482bdfaa1a96da1beb7c38fbd1ab92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Iterates through the two crossings adjacent to a given crossing of a knot or link via an outgoing arc. </p>
<p>The order of iteration is as follows: first this will visit the crossing adjacent via the arc leaving the lower strand of the given crossing; then it will visit the crossing adjacent via the arc leaving the upper strand of the given crossing.</p>
<p>This class implements the Boost multipass input iterator concept, which is similar to the standard C++ forward iterator except that the <em>reference</em> type may be the same as <em>value_type</em> (and so, in particular, the dereference operator may return by value). This header also specialises std::iterator_traits for this iterator type. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3595b10d7b35bc8ef70df6de24717c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3595b10d7b35bc8ef70df6de24717c3e">&#9670;&nbsp;</a></span>AdjacentCrossingIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::graph::AdjacentCrossingIterator::AdjacentCrossingIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a singular iterator. </p>

</div>
</div>
<a id="a5dd08e5351a3532bd3585f899fdfd210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd08e5351a3532bd3585f899fdfd210">&#9670;&nbsp;</a></span>AdjacentCrossingIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::graph::AdjacentCrossingIterator::AdjacentCrossingIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> *&#160;</td>
          <td class="paramname"><em>crossing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strand</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator that runs through the two crossings adjacent to the given crossing via an outgoing arc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crossing</td><td>the crossing whose adjacent crossings we are iterating through. </td></tr>
    <tr><td class="paramname">strand</td><td>0 if we should begin at the crossing adjacent via the lower strand; 1 if we should begin at the crossing adjacent via the upper strand; or 2 if the iterator should be marked as past-the-end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f318929e6e2920bd4d01cb823b74b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f318929e6e2920bd4d01cb823b74b84">&#9670;&nbsp;</a></span>AdjacentCrossingIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::graph::AdjacentCrossingIterator::AdjacentCrossingIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade482bdfaa1a96da1beb7c38fbd1ab92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade482bdfaa1a96da1beb7c38fbd1ab92">&#9670;&nbsp;</a></span>operator !=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::graph::AdjacentCrossingIterator::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section note"><dt>Note</dt><dd>This only tests the "current strand" for each iterator, which identifies the adjacent crossings that they are pointing to. It does not compare the original "source" crossings that were passed to each constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="a4a4a8513dbf89441c1672756c274e482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4a8513dbf89441c1672756c274e482">&#9670;&nbsp;</a></span>operator *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Crossing.html">Crossing</a> * regina::graph::AdjacentCrossingIterator::operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the adjacent crossing to which this iterator points. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the adacent crossing to which this iterator points. </dd></dl>

</div>
</div>
<a id="a5b8457836ec0d026ef912b302c28f4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8457836ec0d026ef912b302c28f4b0">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp; regina::graph::AdjacentCrossingIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="a494897e34e255adfde1b8dcdf3d6ef17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494897e34e255adfde1b8dcdf3d6ef17">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> regina::graph::AdjacentCrossingIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="a2ddbd2762e83508b32573a1c6f92a969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ddbd2762e83508b32573a1c6f92a969">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a>&amp; regina::graph::AdjacentCrossingIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default assignment operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="a2af9b3954c28c1985ebdc17fefbfd02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af9b3954c28c1985ebdc17fefbfd02f">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::graph::AdjacentCrossingIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1graph_1_1AdjacentCrossingIterator.html">AdjacentCrossingIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section note"><dt>Note</dt><dd>This only tests the "current strand" for each iterator, which identifies the adjacent crossings that they are pointing to. It does not compare the original "source" crossings that were passed to each constructor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>link/<a class="el" href="link_2graph_8h.html">graph.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
