<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NNormalHypersurfaceVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html">NNormalHypersurfaceVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NNormalHypersurfaceVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NNormalHypersurfaceVector Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__hypersurface.html">Normal Hypersurfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stores the vector of a single normal hypersurface in a 4-manifold triangulation.  
 <a href="classregina_1_1NNormalHypersurfaceVector.html#details">More...</a></p>

<p><code>#include &lt;hypersurface/nnormalhypersurface.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NNormalHypersurfaceVector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NNormalHypersurfaceVector.png" usemap="#regina::NNormalHypersurfaceVector_map" alt=""/>
  <map id="regina::NNormalHypersurfaceVector_map" name="regina::NNormalHypersurfaceVector_map">
<area href="classregina_1_1NRay.html" title="A fast class for storing a ray rooted at the origin whose coordinates are rational." alt="regina::NRay" shape="rect" coords="140,56,410,80"/>
<area href="classregina_1_1NVector.html" alt="regina::NVector&lt; NLargeInteger &gt;" shape="rect" coords="140,0,410,24"/>
<area href="classregina_1_1NNormalHypersurfaceVectorMirrored.html" title="A normal hypersurface vector that is mirrored in another coordinate system to avoid frequent lengthy ..." alt="regina::NNormalHypersurfaceVectorMirrored" shape="rect" coords="0,168,270,192"/>
<area href="classregina_1_1NNormalHypersurfaceVectorStandard.html" title="A normal hypersurface vector using standard tetrahedron-prism coordinates." alt="regina::NNormalHypersurfaceVectorStandard" shape="rect" coords="280,168,550,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ace116ba5d5fa62cda107d7121902926f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#ace116ba5d5fa62cda107d7121902926f">NNormalHypersurfaceVector</a> (size_t length)</td></tr>
<tr class="memdesc:ace116ba5d5fa62cda107d7121902926f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="#ace116ba5d5fa62cda107d7121902926f">More...</a><br/></td></tr>
<tr class="separator:ace116ba5d5fa62cda107d7121902926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6a26f70976485dea23eb91abb90f76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#a7e6a26f70976485dea23eb91abb90f76">NNormalHypersurfaceVector</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:a7e6a26f70976485dea23eb91abb90f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="#a7e6a26f70976485dea23eb91abb90f76">More...</a><br/></td></tr>
<tr class="separator:a7e6a26f70976485dea23eb91abb90f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa626828b8b4acc504670fba4796cf9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#a2fa626828b8b4acc504670fba4796cf9">~NNormalHypersurfaceVector</a> ()</td></tr>
<tr class="memdesc:a2fa626828b8b4acc504670fba4796cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual destructor.  <a href="#a2fa626828b8b4acc504670fba4796cf9">More...</a><br/></td></tr>
<tr class="separator:a2fa626828b8b4acc504670fba4796cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85eda87be7ebec9a43f0266702b2a94d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html">NNormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#a85eda87be7ebec9a43f0266702b2a94d">clone</a> () const =0</td></tr>
<tr class="memdesc:a85eda87be7ebec9a43f0266702b2a94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="#a85eda87be7ebec9a43f0266702b2a94d">More...</a><br/></td></tr>
<tr class="separator:a85eda87be7ebec9a43f0266702b2a94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab944c1ef1989243c4e320b031d0b9736"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#ab944c1ef1989243c4e320b031d0b9736">isCompact</a> (const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triang) const </td></tr>
<tr class="memdesc:ab944c1ef1989243c4e320b031d0b9736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal hypersurface represented is compact (has finitely many pieces).  <a href="#ab944c1ef1989243c4e320b031d0b9736">More...</a><br/></td></tr>
<tr class="separator:ab944c1ef1989243c4e320b031d0b9736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeedf2edaf846c53a7bd0a594c86d3e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#abfeedf2edaf846c53a7bd0a594c86d3e">isVertexLinking</a> (const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triang) const </td></tr>
<tr class="memdesc:abfeedf2edaf846c53a7bd0a594c86d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal hypersurface represented is vertex linking.  <a href="#abfeedf2edaf846c53a7bd0a594c86d3e">More...</a><br/></td></tr>
<tr class="separator:abfeedf2edaf846c53a7bd0a594c86d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7724c2207add278809899d74b58a3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__hypersurface.html#ga415255b05200ca37045b8729c3d07de1">Dim4Vertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#a33a7724c2207add278809899d74b58a3">isVertexLink</a> (const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triang) const </td></tr>
<tr class="memdesc:a33a7724c2207add278809899d74b58a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal hypersurface represented is the link of a single vertex.  <a href="#a33a7724c2207add278809899d74b58a3">More...</a><br/></td></tr>
<tr class="separator:a33a7724c2207add278809899d74b58a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d987bc160d3d1afc17e3b5f3a55205f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__hypersurface.html#ga42dc463cfa0c6280b4ceceb9a2af9a3f">Dim4Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#a0d987bc160d3d1afc17e3b5f3a55205f">isThinEdgeLink</a> (const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triang) const </td></tr>
<tr class="memdesc:a0d987bc160d3d1afc17e3b5f3a55205f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal hypersurface represented is the thin link of a single edge.  <a href="#a0d987bc160d3d1afc17e3b5f3a55205f">More...</a><br/></td></tr>
<tr class="separator:a0d987bc160d3d1afc17e3b5f3a55205f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59d9a382197a39f5f1803b631e59045"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#af59d9a382197a39f5f1803b631e59045">tetrahedra</a> (size_t pentIndex, int vertex, const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triang) const =0</td></tr>
<tr class="memdesc:af59d9a382197a39f5f1803b631e59045"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface.  <a href="#af59d9a382197a39f5f1803b631e59045">More...</a><br/></td></tr>
<tr class="separator:af59d9a382197a39f5f1803b631e59045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcb7ba680a55ca489353beb385f0a30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#adbcb7ba680a55ca489353beb385f0a30">prisms</a> (size_t pentIndex, int prismType, const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triang) const =0</td></tr>
<tr class="memdesc:adbcb7ba680a55ca489353beb385f0a30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface.  <a href="#adbcb7ba680a55ca489353beb385f0a30">More...</a><br/></td></tr>
<tr class="separator:adbcb7ba680a55ca489353beb385f0a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6226a428edda2dac7cf3665a3e9e066"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#aa6226a428edda2dac7cf3665a3e9e066">edgeWeight</a> (size_t edgeIndex, const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triang) const =0</td></tr>
<tr class="memdesc:aa6226a428edda2dac7cf3665a3e9e066"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge.  <a href="#aa6226a428edda2dac7cf3665a3e9e066">More...</a><br/></td></tr>
<tr class="separator:aa6226a428edda2dac7cf3665a3e9e066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e1a1f744eba1ee66dfc0721ce41f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NRay.html#a17e1a1f744eba1ee66dfc0721ce41f74">scaleDown</a> ()</td></tr>
<tr class="memdesc:a17e1a1f744eba1ee66dfc0721ce41f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="#a17e1a1f744eba1ee66dfc0721ce41f74">More...</a><br/></td></tr>
<tr class="separator:a17e1a1f744eba1ee66dfc0721ce41f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88b4783f5822c9304eeae53dfb34ec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NRay.html#ab88b4783f5822c9304eeae53dfb34ec0">negate</a> ()</td></tr>
<tr class="memdesc:ab88b4783f5822c9304eeae53dfb34ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates every element of this vector.  <a href="#ab88b4783f5822c9304eeae53dfb34ec0">More...</a><br/></td></tr>
<tr class="separator:ab88b4783f5822c9304eeae53dfb34ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232f9c52eb61d3cbd6caea2b399e0529"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a232f9c52eb61d3cbd6caea2b399e0529">size</a> () const</td></tr>
<tr class="memdesc:a232f9c52eb61d3cbd6caea2b399e0529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the vector.  <a href="#a232f9c52eb61d3cbd6caea2b399e0529">More...</a><br/></td></tr>
<tr class="separator:a232f9c52eb61d3cbd6caea2b399e0529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09822e1b73fbef9edef6ab556c012b3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a09822e1b73fbef9edef6ab556c012b3a">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:a09822e1b73fbef9edef6ab556c012b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#a09822e1b73fbef9edef6ab556c012b3a">More...</a><br/></td></tr>
<tr class="separator:a09822e1b73fbef9edef6ab556c012b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8b2ea6c296c895d5278ed0baa9421a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a6a8b2ea6c296c895d5278ed0baa9421a">setElement</a> (size_t index, const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;value)</td></tr>
<tr class="memdesc:a6a8b2ea6c296c895d5278ed0baa9421a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element at the given index in the vector to the given value.  <a href="#a6a8b2ea6c296c895d5278ed0baa9421a">More...</a><br/></td></tr>
<tr class="separator:a6a8b2ea6c296c895d5278ed0baa9421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0101ec07a40d2e8d812b6c99c043a98b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a0101ec07a40d2e8d812b6c99c043a98b">operator==</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;compare) const</td></tr>
<tr class="memdesc:a0101ec07a40d2e8d812b6c99c043a98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vector is equal to the given vector.  <a href="#a0101ec07a40d2e8d812b6c99c043a98b">More...</a><br/></td></tr>
<tr class="separator:a0101ec07a40d2e8d812b6c99c043a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5df88b37f8de039ed2016f90a1c28f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#af5df88b37f8de039ed2016f90a1c28f4">operator+=</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:af5df88b37f8de039ed2016f90a1c28f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="#af5df88b37f8de039ed2016f90a1c28f4">More...</a><br/></td></tr>
<tr class="separator:af5df88b37f8de039ed2016f90a1c28f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15683c49d99a2e4a583621d587f0a0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#ad15683c49d99a2e4a583621d587f0a0a">operator-=</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:ad15683c49d99a2e4a583621d587f0a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given vector from this vector.  <a href="#ad15683c49d99a2e4a583621d587f0a0a">More...</a><br/></td></tr>
<tr class="separator:ad15683c49d99a2e4a583621d587f0a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb6fbe77e79f00a0136c2a204a0559a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a4fb6fbe77e79f00a0136c2a204a0559a">operator*=</a> (const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;factor)</td></tr>
<tr class="memdesc:a4fb6fbe77e79f00a0136c2a204a0559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this vector by the given scalar.  <a href="#a4fb6fbe77e79f00a0136c2a204a0559a">More...</a><br/></td></tr>
<tr class="separator:a4fb6fbe77e79f00a0136c2a204a0559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f2558cf3f297122a667ab5a2e81b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a83f2558cf3f297122a667ab5a2e81b61">operator*</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other) const</td></tr>
<tr class="memdesc:a83f2558cf3f297122a667ab5a2e81b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of this vector and the given vector.  <a href="#a83f2558cf3f297122a667ab5a2e81b61">More...</a><br/></td></tr>
<tr class="separator:a83f2558cf3f297122a667ab5a2e81b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d67741f77990e3141973436ef1d34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a49d67741f77990e3141973436ef1d34f">norm</a> () const</td></tr>
<tr class="memdesc:a49d67741f77990e3141973436ef1d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the norm of this vector.  <a href="#a49d67741f77990e3141973436ef1d34f">More...</a><br/></td></tr>
<tr class="separator:a49d67741f77990e3141973436ef1d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047575b4e446c804f5397c65f046e073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a047575b4e446c804f5397c65f046e073">elementSum</a> () const</td></tr>
<tr class="memdesc:a047575b4e446c804f5397c65f046e073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements of this vector.  <a href="#a047575b4e446c804f5397c65f046e073">More...</a><br/></td></tr>
<tr class="separator:a047575b4e446c804f5397c65f046e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67084429d7dc2f74ef4cf8ced9c0b22b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a67084429d7dc2f74ef4cf8ced9c0b22b">addCopies</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other, const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;multiple)</td></tr>
<tr class="memdesc:a67084429d7dc2f74ef4cf8ced9c0b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given multiple of the given vector to this vector.  <a href="#a67084429d7dc2f74ef4cf8ced9c0b22b">More...</a><br/></td></tr>
<tr class="separator:a67084429d7dc2f74ef4cf8ced9c0b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815a3224a9f83ddcd8b9856b3db50409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a815a3224a9f83ddcd8b9856b3db50409">subtractCopies</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other, const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;multiple)</td></tr>
<tr class="memdesc:a815a3224a9f83ddcd8b9856b3db50409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given multiple of the given vector to this vector.  <a href="#a815a3224a9f83ddcd8b9856b3db50409">More...</a><br/></td></tr>
<tr class="separator:a815a3224a9f83ddcd8b9856b3db50409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab2fcda3b8e6906258c2107133bfcaa0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html">NNormalHypersurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#ab2fcda3b8e6906258c2107133bfcaa0a">makeZeroVector</a> (const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triangulation)</td></tr>
<tr class="memdesc:ab2fcda3b8e6906258c2107133bfcaa0a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal hypersurface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a>.  <a href="#ab2fcda3b8e6906258c2107133bfcaa0a">More...</a><br/></td></tr>
<tr class="separator:ab2fcda3b8e6906258c2107133bfcaa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8dbe7ffe5280cf0fd48d8be33abd94"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#a1c8dbe7ffe5280cf0fd48d8be33abd94">makeMatchingEquations</a> (const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triangulation)</td></tr>
<tr class="memdesc:a1c8dbe7ffe5280cf0fd48d8be33abd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal hypersurface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a>.  <a href="#a1c8dbe7ffe5280cf0fd48d8be33abd94">More...</a><br/></td></tr>
<tr class="separator:a1c8dbe7ffe5280cf0fd48d8be33abd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97d09ff4d30a67c19a90da7c1fb0b6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NEnumConstraintList.html">NEnumConstraintList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#af97d09ff4d30a67c19a90da7c1fb0b6b">makeEmbeddedConstraints</a> (const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *triangulation)</td></tr>
<tr class="memdesc:af97d09ff4d30a67c19a90da7c1fb0b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal hypersurfaces be embedded.  <a href="#af97d09ff4d30a67c19a90da7c1fb0b6b">More...</a><br/></td></tr>
<tr class="separator:af97d09ff4d30a67c19a90da7c1fb0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga7bf8d50ab891667c80d04d5f50774ce5">zero</a></td></tr>
<tr class="memdesc:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero in the underlying number system.  <a href="#ga7bf8d50ab891667c80d04d5f50774ce5">More...</a><br/></td></tr>
<tr class="separator:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc1c84a78adf6df36ed538f45740bf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gabfc1c84a78adf6df36ed538f45740bf9">one</a></td></tr>
<tr class="memdesc:gabfc1c84a78adf6df36ed538f45740bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">One in the underlying number system.  <a href="#gabfc1c84a78adf6df36ed538f45740bf9">More...</a><br/></td></tr>
<tr class="separator:gabfc1c84a78adf6df36ed538f45740bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gafc8368c6a98e3b332af41d21dd7ac9a6">minusOne</a></td></tr>
<tr class="memdesc:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative one in the underlying number system.  <a href="#gafc8368c6a98e3b332af41d21dd7ac9a6">More...</a><br/></td></tr>
<tr class="separator:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abb95dfe16aba3835409b6fb0a33f3142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#abb95dfe16aba3835409b6fb0a33f3142">elements</a></td></tr>
<tr class="memdesc:abb95dfe16aba3835409b6fb0a33f3142"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal array containing all vector elements.  <a href="#abb95dfe16aba3835409b6fb0a33f3142">More...</a><br/></td></tr>
<tr class="separator:abb95dfe16aba3835409b6fb0a33f3142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ead92e64702378a2bb61e9a823248f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a13ead92e64702378a2bb61e9a823248f">end</a></td></tr>
<tr class="memdesc:a13ead92e64702378a2bb61e9a823248f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer just beyond the end of the internal array.  <a href="#a13ead92e64702378a2bb61e9a823248f">More...</a><br/></td></tr>
<tr class="separator:a13ead92e64702378a2bb61e9a823248f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stores the vector of a single normal hypersurface in a 4-manifold triangulation. </p>
<p>The different subclasses of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a> use different underlying coordinate systems for the normal solution space. However, the various coordinate retrieval routines will return values that are independent of the underlying coordinate system. Thus the coordinates of the normal hypersurface in any coordinate system can be determined without knowledge of the specific underlying coordinate system being used.</p>
<p>Note that if a mirrored vector class is being used (see <a class="el" href="classregina_1_1NNormalHypersurfaceVectorMirrored.html" title="A normal hypersurface vector that is mirrored in another coordinate system to avoid frequent lengthy ...">NNormalHypersurfaceVectorMirrored</a>), the vector <b>may not change</b> once the first coordinate lookup routine (such as <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#af59d9a382197a39f5f1803b631e59045" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">tetrahedra()</a> and the like) has been called. See <a class="el" href="classregina_1_1NNormalHypersurfaceVectorMirrored.html" title="A normal hypersurface vector that is mirrored in another coordinate system to avoid frequent lengthy ...">NNormalHypersurfaceVectorMirrored</a> for further explanation.</p>
<p>Note that non-compact hypersurfaces (surfaces with infinitely many pieces) are allowed; in these cases, the corresponding coordinate lookup routines should return <a class="el" href="classregina_1_1NIntegerBase.html#ad33acd312572b0f1d9fe4d6748d61a54" title="Globally available infinity.">NLargeInteger::infinity</a> where appropriate.</p>
<p>All subclasses of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a> <b>must</b> have the following properties:</p>
<ul>
<li>Normal hypersurfaces can be enumerated by intersecting the non-negative orthant of the underlying vector space with some linear subspace;</li>
</ul>
<ul>
<li>Multiplying a normal hypersurface by <em>k</em> corresponds to multiplying the underlying vector by <em>k</em> for any non-negative integer <em>k</em>.</li>
</ul>
<p><b>When deriving classes from <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a>:</b> </p>
<ul>
<li>
A new value must be added to the HyperCoords enum in <a class="el" href="hypercoords_8h.html" title="Defines constants for normal hypersurface coordinate systems.">hypercoords.h</a> to represent the new coordinate system. </li>
<li>
The file hscoordregistry-impl.h must be updated to reflect the new coordinate system (the file itself contains instructions on how to do this). </li>
<li>
A corresponding specialisation of HyperInfo&lt;&gt; must be defined, typically in the same header as the new vector subclass. </li>
<li>
The macro REGINA_NORMAL_HYPERSURFACE_FLAVOUR must be added to the beginning of the new vector subclass. This will declare and define various constants, typedefs and virtual functions (see the REGINA_NORMAL_HYPERSURFACE_FLAVOUR macro documentation for details). </li>
<li>
Constructors <code>class(size_t length)</code> and <code>class(const NVector&lt;NLargeInteger&gt;&amp; cloneMe)</code> must be declared and implemented; these will usually just call the corresponding superclass constructors. </li>
<li>
All abstract functions must be implemented, except for those already provided by REGINA_NORMAL_HYPERSURFACE_FLAVOUR. Note that coordinate functions such as <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#af59d9a382197a39f5f1803b631e59045" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">tetrahedra()</a> must return the <em>total</em> number of pieces of the requested type; if your new coordinate system adorns pieces with extra information (such as orientation) then your implementation must compute the appropriate sum. </li>
<li>
Static public functions <code>void <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#ab2fcda3b8e6906258c2107133bfcaa0a" title="Returns a new normal hypersurface vector of the appropriate length for the given triangulation and fo...">makeZeroVector(const Dim4Triangulation*)</a></code>, <code>NMatrixInt* <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#a1c8dbe7ffe5280cf0fd48d8be33abd94" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the coo...">makeMatchingEquations(const Dim4Triangulation*)</a></code> and <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html#af97d09ff4d30a67c19a90da7c1fb0b6b" title="Creates a new set of validity constraints representing the condition that normal hypersurfaces be emb...">makeEmbeddedConstraints(const Dim4Triangulation*)</a> must be declared and implemented. </li>
</ul>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ace116ba5d5fa62cda107d7121902926f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NNormalHypersurfaceVector::NNormalHypersurfaceVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e6a26f70976485dea23eb91abb90f76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NNormalHypersurfaceVector::NNormalHypersurfaceVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2fa626828b8b4acc504670fba4796cf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NNormalHypersurfaceVector::~NNormalHypersurfaceVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A virtual destructor. </p>
<p>This is required because here we introduce virtual functions into the <a class="el" href="classregina_1_1NRay.html" title="A fast class for storing a ray rooted at the origin whose coordinates are rational.">NRay</a> hierarchy. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67084429d7dc2f74ef4cf8ced9c0b22b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::addCopies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>multiple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given multiple of the given vector to this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector a multiple of which will be added to this vector. </td></tr>
    <tr><td class="paramname">multiple</td><td>the multiple of <em>other</em> to be added to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85eda87be7ebec9a43f0266702b2a94d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html">NNormalHypersurfaceVector</a>* regina::NNormalHypersurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a> as this vector. </p>

</div>
</div>
<a class="anchor" id="aa6226a428edda2dac7cf3665a3e9e066"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalHypersurfaceVector::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal hypersurface crosses the given edge. </p>
<p>See <a class="el" href="classregina_1_1NNormalHypersurface.html#aab6ba9c7d8c70a69fda9e30e9f07d268" title="Returns the number of times this normal hypersurface crosses the given edge.">NNormalHypersurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Dim4Triangulation::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal hypersurface crosses the given edge. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NNormalHypersurfaceVectorMirrored.html#a3e6d53b15166a9436190b0573184fab2">regina::NNormalHypersurfaceVectorMirrored</a>, and <a class="el" href="classregina_1_1NNormalHypersurfaceVectorStandard.html#a552978310e51f0f56bafdec90b1e2d73">regina::NNormalHypersurfaceVectorStandard</a>.</p>

</div>
</div>
<a class="anchor" id="a047575b4e446c804f5397c65f046e073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::elementSum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of all elements of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the sum of the elements of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ab944c1ef1989243c4e320b031d0b9736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalHypersurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal hypersurface represented is compact (has finitely many pieces). </p>
<p>The default implementation for this routine simply runs through every piece type until a piece type with infinite piece count is found or all piece types have been examined. Subclasses of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal hypersurface represented is compact. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d987bc160d3d1afc17e3b5f3a55205f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__hypersurface.html#ga42dc463cfa0c6280b4ceceb9a2af9a3f">Dim4Edge</a>* regina::NNormalHypersurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal hypersurface represented is the thin link of a single edge. </p>
<p>The default implementation for this routine involves counting the number of pieces of every type. Subclasses of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge linked by this hypersurface, or 0 if this hypersurface is not a thin edge link. </dd></dl>

</div>
</div>
<a class="anchor" id="a33a7724c2207add278809899d74b58a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__hypersurface.html#ga415255b05200ca37045b8729c3d07de1">Dim4Vertex</a>* regina::NNormalHypersurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal hypersurface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of pieces of every type. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this hypersurface, or 0 if this hypersurface is not the link of a single vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="abfeedf2edaf846c53a7bd0a594c86d3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalHypersurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal hypersurface represented is vertex linking. </p>
<p>A <em>vertex linking</em> hypersurface contains only tetrahedra.</p>
<p>The default implementation for this routine simply runs through every non-tetrahedron piece type ensuring that each has no corresponding pieces. Subclasses of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal hypersurface represented is vertex linking. </dd></dl>

</div>
</div>
<a class="anchor" id="af97d09ff4d30a67c19a90da7c1fb0b6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NEnumConstraintList.html">NEnumConstraintList</a>* regina::NNormalHypersurfaceVector::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal hypersurfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c8dbe7ffe5280cf0fd48d8be33abd94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a>* regina::NNormalHypersurfaceVector::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of normal hypersurface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a>. </p>
<p>See <a class="el" href="group__hypersurface.html#ga839ed1e933b800f2622b465387a8b0e5" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2fcda3b8e6906258c2107133bfcaa0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html">NNormalHypersurfaceVector</a>* regina::NNormalHypersurfaceVector::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal hypersurface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NNormalHypersurfaceVector.html" title="Stores the vector of a single normal hypersurface in a 4-manifold triangulation.">NNormalHypersurfaceVector</a>. </p>
<p>All elements of the new vector will be initialised to zero.</p>
<p>See <a class="el" href="group__hypersurface.html#ga66a18b9cb44d07a7bcad57eb010e6952" title="Returns a new normal hypersurface vector of the appropriate length for the given triangulation and th...">makeZeroVector()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a class="anchor" id="ab88b4783f5822c9304eeae53dfb34ec0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NRay::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates every element of this vector. </p>
<p>This is an optimised implementation that overrides <a class="el" href="classregina_1_1NVector.html#af5da9fd836844c94e6aa6cea855ee174" title="Negates every element of this vector.">NVector&lt;NLargeInteger&gt;::negate()</a>. </p>

</div>
</div>
<a class="anchor" id="a49d67741f77990e3141973436ef1d34f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the norm of this vector. </p>
<p>This is the dot product of the vector with itself.</p>
<dl class="section return"><dt>Returns</dt><dd>the norm of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a83f2558cf3f297122a667ab5a2e81b61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product of this vector and the given vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector with which this will be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of this and the given vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb6fbe77e79f00a0136c2a204a0559a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this vector by the given scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>the scalar with which this will be multiplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5df88b37f8de039ed2016f90a1c28f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad15683c49d99a2e4a583621d587f0a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given vector from this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to subtract from this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0101ec07a40d2e8d812b6c99c043a98b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vector is equal to the given vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the vector with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the this and the given vector are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a09822e1b73fbef9edef6ab556c012b3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp; <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<p>A constant reference to the element is returned; the element may not be altered.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> is between 0 and size()-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the vector index to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector element at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="adbcb7ba680a55ca489353beb385f0a30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalHypersurfaceVector::prisms </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prismType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of prism pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="classregina_1_1NNormalHypersurface.html#a2d8f6def6c4b9e9c5c009c04b215b7f3" title="Returns the number of prism pieces of the given type in this normal hypersurface.">NNormalHypersurface::prisms()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested prism pieces reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">Dim4Triangulation::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">prismType</td><td>specifies the edge of the given pentachoron that this prism separates from the opposite triangle; this should be between 0 and 9 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of prism pieces of the given type. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NNormalHypersurfaceVectorMirrored.html#a863716b8676253db77fbeb3f851c74f9">regina::NNormalHypersurfaceVectorMirrored</a>, and <a class="el" href="classregina_1_1NNormalHypersurfaceVectorStandard.html#a6d9a240f49ae41387ca57fb6cd06c8a4">regina::NNormalHypersurfaceVectorStandard</a>.</p>

</div>
</div>
<a class="anchor" id="a17e1a1f744eba1ee66dfc0721ce41f74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NRay::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine thus reduces a ray to its smallest possible representation.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity. </p>

</div>
</div>
<a class="anchor" id="a6a8b2ea6c296c895d5278ed0baa9421a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the element at the given index in the vector to the given value. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> is between 0 and size()-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the vector index to examine. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector element at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a232f9c52eb61d3cbd6caea2b399e0529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector size. </dd></dl>

</div>
</div>
<a class="anchor" id="a815a3224a9f83ddcd8b9856b3db50409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::subtractCopies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>multiple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given multiple of the given vector to this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector a multiple of which will be subtracted from this vector. </td></tr>
    <tr><td class="paramname">multiple</td><td>the multiple of <em>other</em> to be subtracted from this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af59d9a382197a39f5f1803b631e59045"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalHypersurfaceVector::tetrahedra </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__dim4.html#gaa331d3dccc409c63af6aeffef9032bc7">Dim4Triangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedron pieces of the given type in this normal hypersurface. </p>
<p>See <a class="el" href="classregina_1_1NNormalHypersurface.html#aa1f4d18a828f4b651ab86e6679caf705" title="Returns the number of tetrahedron pieces of the given type in this normal hypersurface.">NNormalHypersurface::tetrahedra()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pentIndex</td><td>the index in the triangulation of the pentachoron in which the requested tetrahedron pieces reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">Dim4Triangulation::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given pentachoron around which the requested tetrahedron pieces lie; this should be between 0 and 4 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal hypersurface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedron pieces of the given type. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1NNormalHypersurfaceVectorMirrored.html#a88793dc31923fdf7a1206f251a3e9320">regina::NNormalHypersurfaceVectorMirrored</a>, and <a class="el" href="classregina_1_1NNormalHypersurfaceVectorStandard.html#ac09200d1ea976cb229104949b1c3fe4d">regina::NNormalHypersurfaceVectorStandard</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abb95dfe16aba3835409b6fb0a33f3142"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> * <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal array containing all vector elements. </p>

</div>
</div>
<a class="anchor" id="a13ead92e64702378a2bb61e9a823248f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> * <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer just beyond the end of the internal array. </p>
<p>The size of the vector can be computed as (end - elements). </p>

</div>
</div>
<a class="anchor" id="gafc8368c6a98e3b332af41d21dd7ac9a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::minusOne</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negative one in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="gabfc1c84a78adf6df36ed538f45740bf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::one</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="ga7bf8d50ab891667c80d04d5f50774ce5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::zero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hypersurface/<a class="el" href="nnormalhypersurface_8h.html">nnormalhypersurface.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
