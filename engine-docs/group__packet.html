<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Basic Packet Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Basic Packet Types</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> administration and some basic packet types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Container.html">regina::Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that simply contains other packets.  <a href="classregina_1_1Container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1PacketInfo.html">regina::PacketInfo&lt; packetType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular type of packet.  <a href="structregina_1_1PacketInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">regina::Packet::ChangeEventSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that facilitates firing packetToBeChanged() and packetWasChanged() events.  <a href="classregina_1_1Packet_1_1ChangeEventSpan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html">regina::Packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a packet of information that may be individually edited or operated upon.  <a href="classregina_1_1Packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ChildIterator.html">regina::ChildIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator for iterating through all immediate children of a given packet.  <a href="classregina_1_1ChildIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SubtreeIterator.html">regina::SubtreeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator for iterating through the entire packet subtree rooted at a given packet.  <a href="classregina_1_1SubtreeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight object that gives access to all immediate children of a given packet.  <a href="classregina_1_1PacketChildren.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight object that gives access to all strict descendants of a given packet.  <a href="classregina_1_1PacketDescendants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketShell.html">regina::PacketShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to the final remains of a packet that is in the process of being destroyed.  <a href="classregina_1_1PacketShell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html">regina::PacketListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that can be registered to listen for packet events.  <a href="classregina_1_1PacketListener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1ChildIterator_01_4.html">std::iterator_traits&lt; regina::ChildIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1SubtreeIterator_01_4.html">std::iterator_traits&lt; regina::SubtreeIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PDF.html">regina::PDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that can hold a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document.  <a href="classregina_1_1PDF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Script.html">regina::Script</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a Python script that can be run.  <a href="classregina_1_1Script.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Text.html">regina::Text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a text string.  <a href="classregina_1_1Text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLPacketReader.html">regina::XMLPacketReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads the data for an individual packet.  <a href="classregina_1_1XMLPacketReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLContainerReader.html">regina::XMLContainerReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single container.  <a href="classregina_1_1XMLContainerReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLPDFReader.html">regina::XMLPDFReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet.  <a href="classregina_1_1XMLPDFReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLScriptReader.html">regina::XMLScriptReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single script.  <a href="classregina_1_1XMLScriptReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTextReader.html">regina::XMLTextReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single text packet.  <a href="classregina_1_1XMLTextReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolutionTask.html">regina::XMLTreeResolutionTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An individual task for resolving dangling packet references after an XML data file has been read.  <a href="classregina_1_1XMLTreeResolutionTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html">regina::XMLTreeResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism to resolve dangling packet references after a complete packet tree has been read from an XML data file.  <a href="classregina_1_1XMLTreeResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaad9d413dab5c36f4a57d9ca811d24188"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaad9d413dab5c36f4a57d9ca811d24188">REGINA_PACKET</a>(class_,  id)</td></tr>
<tr class="memdesc:gaad9d413dab5c36f4a57d9ca811d24188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a subclass of Packet.  <a href="#gaad9d413dab5c36f4a57d9ca811d24188">More...</a><br /></td></tr>
<tr class="separator:gaad9d413dab5c36f4a57d9ca811d24188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b8ff3226c3356a8b73c5e46f64c268"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad7b8ff3226c3356a8b73c5e46f64c268">REGINA_PACKET_FROM</a>(class_,  helper)</td></tr>
<tr class="memdesc:gad7b8ff3226c3356a8b73c5e46f64c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative to REGINA_PACKET, for scenarios where the relevant PacketInfo specialisation is not visible.  <a href="#gad7b8ff3226c3356a8b73c5e46f64c268">More...</a><br /></td></tr>
<tr class="separator:gad7b8ff3226c3356a8b73c5e46f64c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4dc907cfee17707d1409b1b4e499247c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Container.html">Container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4dc907cfee17707d1409b1b4e499247c">regina::NContainer</a></td></tr>
<tr class="memdesc:ga4dc907cfee17707d1409b1b4e499247c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga4dc907cfee17707d1409b1b4e499247c">More...</a><br /></td></tr>
<tr class="separator:ga4dc907cfee17707d1409b1b4e499247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f47ede3cd04a3b515ae8e375497a987"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4f47ede3cd04a3b515ae8e375497a987">regina::NPacket</a></td></tr>
<tr class="memdesc:ga4f47ede3cd04a3b515ae8e375497a987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga4f47ede3cd04a3b515ae8e375497a987">More...</a><br /></td></tr>
<tr class="separator:ga4f47ede3cd04a3b515ae8e375497a987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58067e865d029237d3a1e0e8c39cf29f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga58067e865d029237d3a1e0e8c39cf29f">regina::NPacketListener</a></td></tr>
<tr class="memdesc:ga58067e865d029237d3a1e0e8c39cf29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga58067e865d029237d3a1e0e8c39cf29f">More...</a><br /></td></tr>
<tr class="separator:ga58067e865d029237d3a1e0e8c39cf29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9664a85a1d1ae1165ed9461e7df5704b"><td class="memItemLeft" align="right" valign="top"><a id="ga9664a85a1d1ae1165ed9461e7df5704b"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::difference_type</b></td></tr>
<tr class="separator:ga9664a85a1d1ae1165ed9461e7df5704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26340bf5ba05d0ce4b003c0ad20e3e2"><td class="memItemLeft" align="right" valign="top"><a id="gab26340bf5ba05d0ce4b003c0ad20e3e2"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::value_type</b></td></tr>
<tr class="separator:gab26340bf5ba05d0ce4b003c0ad20e3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6924e98617da13c933b796fa829c339"><td class="memItemLeft" align="right" valign="top"><a id="gad6924e98617da13c933b796fa829c339"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::pointer_type</b></td></tr>
<tr class="separator:gad6924e98617da13c933b796fa829c339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a9df945108d4d53a777d6c011037d7"><td class="memItemLeft" align="right" valign="top"><a id="ga00a9df945108d4d53a777d6c011037d7"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::reference_type</b></td></tr>
<tr class="separator:ga00a9df945108d4d53a777d6c011037d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad64b892b52e0b7c44762ba72173f9084"><td class="memItemLeft" align="right" valign="top"><a id="gad64b892b52e0b7c44762ba72173f9084"></a>
typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:gad64b892b52e0b7c44762ba72173f9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad698b8e3feb3660efb36ef0d137d2f13"><td class="memItemLeft" align="right" valign="top"><a id="gad698b8e3feb3660efb36ef0d137d2f13"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::difference_type</b></td></tr>
<tr class="separator:gad698b8e3feb3660efb36ef0d137d2f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0b76a2867102b58353a7a4ac8f817f"><td class="memItemLeft" align="right" valign="top"><a id="ga9f0b76a2867102b58353a7a4ac8f817f"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::value_type</b></td></tr>
<tr class="separator:ga9f0b76a2867102b58353a7a4ac8f817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a939ea8b7ac3b914b2364b5c701176"><td class="memItemLeft" align="right" valign="top"><a id="ga71a939ea8b7ac3b914b2364b5c701176"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::pointer_type</b></td></tr>
<tr class="separator:ga71a939ea8b7ac3b914b2364b5c701176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad477029282973ced54520f9ef77b5b42"><td class="memItemLeft" align="right" valign="top"><a id="gad477029282973ced54520f9ef77b5b42"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::reference_type</b></td></tr>
<tr class="separator:gad477029282973ced54520f9ef77b5b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58050469406661228f9d14e8345ffcc7"><td class="memItemLeft" align="right" valign="top"><a id="ga58050469406661228f9d14e8345ffcc7"></a>
typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:ga58050469406661228f9d14e8345ffcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4467bfb4bc172da71964a4b9967a04d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PDF.html">PDF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad4467bfb4bc172da71964a4b9967a04d">regina::NPDF</a></td></tr>
<tr class="memdesc:gad4467bfb4bc172da71964a4b9967a04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#gad4467bfb4bc172da71964a4b9967a04d">More...</a><br /></td></tr>
<tr class="separator:gad4467bfb4bc172da71964a4b9967a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80158507a6960da75b1f1c2c35d90148"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Script.html">Script</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga80158507a6960da75b1f1c2c35d90148">regina::NScript</a></td></tr>
<tr class="memdesc:ga80158507a6960da75b1f1c2c35d90148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga80158507a6960da75b1f1c2c35d90148">More...</a><br /></td></tr>
<tr class="separator:ga80158507a6960da75b1f1c2c35d90148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9581a76573ed62ddcd1623ae4963b72d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Text.html">Text</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9581a76573ed62ddcd1623ae4963b72d">regina::NText</a></td></tr>
<tr class="memdesc:ga9581a76573ed62ddcd1623ae4963b72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga9581a76573ed62ddcd1623ae4963b72d">More...</a><br /></td></tr>
<tr class="separator:ga9581a76573ed62ddcd1623ae4963b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga982f45957b093a38120119066dc4cfef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">regina::PacketType</a> { <br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefabc7680a0895a0d0540123f9e0596b38e">regina::PACKET_CONTAINER</a> = 1, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa54ede7ca089949c83b103489c1c3ad57">regina::PACKET_TEXT</a> = 2, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc">regina::PACKET_NORMALSURFACES</a> = 6, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa44f343e9e3b4baf3b53f8943a4503f6e">regina::PACKET_SCRIPT</a> = 7, 
<br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa958e5099e4f7506590d6b351a9a889cf">regina::PACKET_SURFACEFILTER</a> = 8, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9">regina::PACKET_ANGLESTRUCTURES</a> = 9, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa346e59a436dacb0d10922334f9e002e1">regina::PACKET_PDF</a> = 10, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e">regina::PACKET_NORMALHYPERSURFACES</a> = 13, 
<br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac0835064733eb9d41e9db904afde7240">regina::PACKET_SNAPPEATRIANGULATION</a> = 16, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefaa9042461f4df32b551cc9046f7d44f23">regina::PACKET_LINK</a> = 17, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815">regina::PACKET_TRIANGULATION2</a> = 15, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64">regina::PACKET_TRIANGULATION3</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff">regina::PACKET_TRIANGULATION4</a> = 11, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefad6af6b9c7e211662703204551c8f0a6c">regina::PACKET_TRIANGULATION5</a> = 105, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac241be6e856f68161d4e217b49260596">regina::PACKET_TRIANGULATION6</a> = 106, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefae75828b18b7041a6602a41f61e900c4b">regina::PACKET_TRIANGULATION7</a> = 107, 
<br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefadac8b650c87a395064f35d8dd7139174">regina::PACKET_TRIANGULATION8</a> = 108, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefaae3f65ac7e3e3b14c06e866e4732f04f">regina::PACKET_TRIANGULATION9</a> = 109, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa2e49b81db0006562994ba409db5fdbb2">regina::PACKET_TRIANGULATION10</a> = 110, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa8239b1c5322caeb818c5dd8f3fb78ae3">regina::PACKET_TRIANGULATION11</a> = 111, 
<br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa9abc4fbf3b98a845481d2d6a651c730f">regina::PACKET_TRIANGULATION12</a> = 112, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa2a134929dda394ce55b128b661f68a9a">regina::PACKET_TRIANGULATION13</a> = 113, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa7984ac7306b6a4301565b5d154daddb0">regina::PACKET_TRIANGULATION14</a> = 114, 
<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa0e5a2698ebebf778b6bc6209778cc3a3">regina::PACKET_TRIANGULATION15</a> = 115
<br />
 }</td></tr>
<tr class="memdesc:ga982f45957b093a38120119066dc4cfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the different types of packet that are available in Regina.  <a href="group__packet.html#ga982f45957b093a38120119066dc4cfef">More...</a><br /></td></tr>
<tr class="separator:ga982f45957b093a38120119066dc4cfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6f48a115e3ad5912a038c8d00900eae1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6f48a115e3ad5912a038c8d00900eae1">regina::Packet::xmlReader</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga6f48a115e3ad5912a038c8d00900eae1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created XML element reader that will read the contents of a single XML packet element.  <a href="#ga6f48a115e3ad5912a038c8d00900eae1">More...</a><br /></td></tr>
<tr class="separator:ga6f48a115e3ad5912a038c8d00900eae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5646f70dfe6c538387ebc2148fc69dd8"><td class="memItemLeft" align="right" valign="top"><a id="ga5646f70dfe6c538387ebc2148fc69dd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::Packet</b> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;)=delete</td></tr>
<tr class="separator:ga5646f70dfe6c538387ebc2148fc69dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62521bbc99fbaf225e511b1d4d20282d"><td class="memItemLeft" align="right" valign="top"><a id="ga62521bbc99fbaf225e511b1d4d20282d"></a>
<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::operator=</b> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;)=delete</td></tr>
<tr class="separator:ga62521bbc99fbaf225e511b1d4d20282d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089c4f6e4b1989fe9c89653091e6321e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga089c4f6e4b1989fe9c89653091e6321e">regina::Packet::ChangeEventSpan::ChangeEventSpan</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga089c4f6e4b1989fe9c89653091e6321e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new change event object for the given packet.  <a href="#ga089c4f6e4b1989fe9c89653091e6321e">More...</a><br /></td></tr>
<tr class="separator:ga089c4f6e4b1989fe9c89653091e6321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b86447dbb2a828673adb6b5c508d34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga90b86447dbb2a828673adb6b5c508d34">regina::Packet::ChangeEventSpan::~ChangeEventSpan</a> ()</td></tr>
<tr class="memdesc:ga90b86447dbb2a828673adb6b5c508d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this change event object.  <a href="#ga90b86447dbb2a828673adb6b5c508d34">More...</a><br /></td></tr>
<tr class="separator:ga90b86447dbb2a828673adb6b5c508d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e37bb3d9744c191ee2085fab3a04a54"><td class="memItemLeft" align="right" valign="top"><a id="ga7e37bb3d9744c191ee2085fab3a04a54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::ChangeEventSpan::ChangeEventSpan</b> (const <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">ChangeEventSpan</a> &amp;)=delete</td></tr>
<tr class="separator:ga7e37bb3d9744c191ee2085fab3a04a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf313fb80913a92793db6aab9be5560"><td class="memItemLeft" align="right" valign="top"><a id="gaecf313fb80913a92793db6aab9be5560"></a>
<a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">ChangeEventSpan</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::ChangeEventSpan::operator=</b> (const <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">ChangeEventSpan</a> &amp;)=delete</td></tr>
<tr class="separator:gaecf313fb80913a92793db6aab9be5560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4d2e82e583276a70128d952b46bd53"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const =0</td></tr>
<tr class="memdesc:gacd4d2e82e583276a70128d952b46bd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="#gacd4d2e82e583276a70128d952b46bd53">More...</a><br /></td></tr>
<tr class="separator:gacd4d2e82e583276a70128d952b46bd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">regina::Packet::writeXMLPacketTree</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the subtree with this packet as matriarch.  <a href="#ga690d1f04ae42ab3778726d37fbd0fe54">More...</a><br /></td></tr>
<tr class="separator:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7efec42b4c85d5590a07a0184bb3b0ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet::writeXMLPacketData</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga7efec42b4c85d5590a07a0184bb3b0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="#ga7efec42b4c85d5590a07a0184bb3b0ec">More...</a><br /></td></tr>
<tr class="separator:ga7efec42b4c85d5590a07a0184bb3b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54930e66829e2b832b2b8d5b6813e55d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet::writeTextShort</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga54930e66829e2b832b2b8d5b6813e55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#ga54930e66829e2b832b2b8d5b6813e55d">More...</a><br /></td></tr>
<tr class="separator:ga54930e66829e2b832b2b8d5b6813e55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">More...</a><br /></td></tr>
<tr class="separator:ga044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">regina::Packet::hasOwner</a> () const</td></tr>
<tr class="memdesc:gac85ba39c124eda4ce631b653d6bb0a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object.  <a href="#gac85ba39c124eda4ce631b653d6bb0a29">More...</a><br /></td></tr>
<tr class="separator:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964a605603a33a84e5004e9ebb0ac5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec">regina::open</a> (const char *filename)</td></tr>
<tr class="memdesc:ga964a605603a33a84e5004e9ebb0ac5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a Regina data file, and returns the corresponding packet tree.  <a href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec">More...</a><br /></td></tr>
<tr class="separator:ga964a605603a33a84e5004e9ebb0ac5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53c0b54eaa7f029e0b0a13bb3c02675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae53c0b54eaa7f029e0b0a13bb3c02675">regina::open</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:gae53c0b54eaa7f029e0b0a13bb3c02675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a Regina data file from the given input stream, and returns the corresponding packet tree.  <a href="group__packet.html#gae53c0b54eaa7f029e0b0a13bb3c02675">More...</a><br /></td></tr>
<tr class="separator:gae53c0b54eaa7f029e0b0a13bb3c02675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad369e1b9117672269c40c2e1dc75b2d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad369e1b9117672269c40c2e1dc75b2d9">regina::ChildIterator::ChildIterator</a> ()</td></tr>
<tr class="memdesc:gad369e1b9117672269c40c2e1dc75b2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a past-the-end iterator.  <a href="#gad369e1b9117672269c40c2e1dc75b2d9">More...</a><br /></td></tr>
<tr class="separator:gad369e1b9117672269c40c2e1dc75b2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25e416c2756416f8faff87583566422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab25e416c2756416f8faff87583566422">regina::ChildIterator::ChildIterator</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gab25e416c2756416f8faff87583566422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="#gab25e416c2756416f8faff87583566422">More...</a><br /></td></tr>
<tr class="separator:gab25e416c2756416f8faff87583566422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075232d3523eb9c5974eaf0ce2163489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga075232d3523eb9c5974eaf0ce2163489">regina::ChildIterator::ChildIterator</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *current)</td></tr>
<tr class="memdesc:ga075232d3523eb9c5974eaf0ce2163489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the given child packet.  <a href="#ga075232d3523eb9c5974eaf0ce2163489">More...</a><br /></td></tr>
<tr class="separator:ga075232d3523eb9c5974eaf0ce2163489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345ff5809b12d36f7ce53d81ebfcc4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga345ff5809b12d36f7ce53d81ebfcc4bb">regina::ChildIterator::operator=</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga345ff5809b12d36f7ce53d81ebfcc4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="#ga345ff5809b12d36f7ce53d81ebfcc4bb">More...</a><br /></td></tr>
<tr class="separator:ga345ff5809b12d36f7ce53d81ebfcc4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a305d83c114887ce6c5bbce98aaaa64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8a305d83c114887ce6c5bbce98aaaa64">regina::ChildIterator::operator==</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga8a305d83c114887ce6c5bbce98aaaa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="#ga8a305d83c114887ce6c5bbce98aaaa64">More...</a><br /></td></tr>
<tr class="separator:ga8a305d83c114887ce6c5bbce98aaaa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ea9c9b9efbf3054e0517eae2648f30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga77ea9c9b9efbf3054e0517eae2648f30">regina::ChildIterator::operator !=</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga77ea9c9b9efbf3054e0517eae2648f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="#ga77ea9c9b9efbf3054e0517eae2648f30">More...</a><br /></td></tr>
<tr class="separator:ga77ea9c9b9efbf3054e0517eae2648f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e515b2ba38eba36cf621598447bfad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6e515b2ba38eba36cf621598447bfad6">regina::ChildIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga6e515b2ba38eba36cf621598447bfad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="#ga6e515b2ba38eba36cf621598447bfad6">More...</a><br /></td></tr>
<tr class="separator:ga6e515b2ba38eba36cf621598447bfad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8d33346fee85e3a0ccb4fb8e94e437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafc8d33346fee85e3a0ccb4fb8e94e437">regina::ChildIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:gafc8d33346fee85e3a0ccb4fb8e94e437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="#gafc8d33346fee85e3a0ccb4fb8e94e437">More...</a><br /></td></tr>
<tr class="separator:gafc8d33346fee85e3a0ccb4fb8e94e437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1faa715461872fb5a6aacf1f80f2719"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad1faa715461872fb5a6aacf1f80f2719">regina::ChildIterator::operator *</a> () const</td></tr>
<tr class="memdesc:gad1faa715461872fb5a6aacf1f80f2719"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to.  <a href="#gad1faa715461872fb5a6aacf1f80f2719">More...</a><br /></td></tr>
<tr class="separator:gad1faa715461872fb5a6aacf1f80f2719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552be006cf9fe432a6a678aed7f4c6ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga552be006cf9fe432a6a678aed7f4c6ac">regina::SubtreeIterator::SubtreeIterator</a> ()</td></tr>
<tr class="memdesc:ga552be006cf9fe432a6a678aed7f4c6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a past-the-end iterator.  <a href="#ga552be006cf9fe432a6a678aed7f4c6ac">More...</a><br /></td></tr>
<tr class="separator:ga552be006cf9fe432a6a678aed7f4c6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf619ec7a62275a926a723c015a386420"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf619ec7a62275a926a723c015a386420">regina::SubtreeIterator::SubtreeIterator</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gaf619ec7a62275a926a723c015a386420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="#gaf619ec7a62275a926a723c015a386420">More...</a><br /></td></tr>
<tr class="separator:gaf619ec7a62275a926a723c015a386420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ee02a48a9c4be604e85e49da97ed6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad6ee02a48a9c4be604e85e49da97ed6b">regina::SubtreeIterator::SubtreeIterator</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *subtree)</td></tr>
<tr class="memdesc:gad6ee02a48a9c4be604e85e49da97ed6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the first packet within the given subtree.  <a href="#gad6ee02a48a9c4be604e85e49da97ed6b">More...</a><br /></td></tr>
<tr class="separator:gad6ee02a48a9c4be604e85e49da97ed6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ecbf7b86f80e45347fdbd67cd40884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf7ecbf7b86f80e45347fdbd67cd40884">regina::SubtreeIterator::SubtreeIterator</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *subtree, <a class="el" href="classregina_1_1Packet.html">Packet</a> *current)</td></tr>
<tr class="memdesc:gaf7ecbf7b86f80e45347fdbd67cd40884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the given packet within the given subtree.  <a href="#gaf7ecbf7b86f80e45347fdbd67cd40884">More...</a><br /></td></tr>
<tr class="separator:gaf7ecbf7b86f80e45347fdbd67cd40884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962997e07b8aa25d5b7a44ac4922d28e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga962997e07b8aa25d5b7a44ac4922d28e">regina::SubtreeIterator::operator=</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga962997e07b8aa25d5b7a44ac4922d28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="#ga962997e07b8aa25d5b7a44ac4922d28e">More...</a><br /></td></tr>
<tr class="separator:ga962997e07b8aa25d5b7a44ac4922d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa098cbbe41b9f6fba63297e915fa8992"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa098cbbe41b9f6fba63297e915fa8992">regina::SubtreeIterator::operator==</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gaa098cbbe41b9f6fba63297e915fa8992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="#gaa098cbbe41b9f6fba63297e915fa8992">More...</a><br /></td></tr>
<tr class="separator:gaa098cbbe41b9f6fba63297e915fa8992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46684c15cbbc4cea9146f584766a06d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga46684c15cbbc4cea9146f584766a06d0">regina::SubtreeIterator::operator !=</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga46684c15cbbc4cea9146f584766a06d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="#ga46684c15cbbc4cea9146f584766a06d0">More...</a><br /></td></tr>
<tr class="separator:ga46684c15cbbc4cea9146f584766a06d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130eb896f8e699b159d2c124d774f7b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga130eb896f8e699b159d2c124d774f7b1">regina::SubtreeIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga130eb896f8e699b159d2c124d774f7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="#ga130eb896f8e699b159d2c124d774f7b1">More...</a><br /></td></tr>
<tr class="separator:ga130eb896f8e699b159d2c124d774f7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1010344f9ccca0551bb80f0a5966cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad1010344f9ccca0551bb80f0a5966cf2">regina::SubtreeIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:gad1010344f9ccca0551bb80f0a5966cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="#gad1010344f9ccca0551bb80f0a5966cf2">More...</a><br /></td></tr>
<tr class="separator:gad1010344f9ccca0551bb80f0a5966cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e81ea61e149c4c919b2c9ced87e54c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga67e81ea61e149c4c919b2c9ced87e54c">regina::SubtreeIterator::operator *</a> () const</td></tr>
<tr class="memdesc:ga67e81ea61e149c4c919b2c9ced87e54c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to.  <a href="#ga67e81ea61e149c4c919b2c9ced87e54c">More...</a><br /></td></tr>
<tr class="separator:ga67e81ea61e149c4c919b2c9ced87e54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1deebd4b4c4c3b685b017386b4b6f8e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga1deebd4b4c4c3b685b017386b4b6f8e0">regina::PacketChildren::PacketChildren</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:ga1deebd4b4c4c3b685b017386b4b6f8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="#ga1deebd4b4c4c3b685b017386b4b6f8e0">More...</a><br /></td></tr>
<tr class="separator:ga1deebd4b4c4c3b685b017386b4b6f8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3bc3386708cc7a52859df12f0b34e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga1a3bc3386708cc7a52859df12f0b34e0">regina::PacketChildren::PacketChildren</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *parent)</td></tr>
<tr class="memdesc:ga1a3bc3386708cc7a52859df12f0b34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the immediate children of the given packet.  <a href="#ga1a3bc3386708cc7a52859df12f0b34e0">More...</a><br /></td></tr>
<tr class="separator:ga1a3bc3386708cc7a52859df12f0b34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef24629212c08d93d4171816488e597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4ef24629212c08d93d4171816488e597">regina::PacketChildren::operator=</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:ga4ef24629212c08d93d4171816488e597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="#ga4ef24629212c08d93d4171816488e597">More...</a><br /></td></tr>
<tr class="separator:ga4ef24629212c08d93d4171816488e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e5ca15289b85b0630d07ac1da20c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac7e5ca15289b85b0630d07ac1da20c84">regina::PacketChildren::begin</a> () const</td></tr>
<tr class="memdesc:gac7e5ca15289b85b0630d07ac1da20c84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of children.  <a href="#gac7e5ca15289b85b0630d07ac1da20c84">More...</a><br /></td></tr>
<tr class="separator:gac7e5ca15289b85b0630d07ac1da20c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f68310c44da3f5f260b04a49694ea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga09f68310c44da3f5f260b04a49694ea2">regina::PacketChildren::end</a> () const</td></tr>
<tr class="memdesc:ga09f68310c44da3f5f260b04a49694ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of children.  <a href="#ga09f68310c44da3f5f260b04a49694ea2">More...</a><br /></td></tr>
<tr class="separator:ga09f68310c44da3f5f260b04a49694ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbbafcb328346116b72f1cb2f41b02c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaecbbafcb328346116b72f1cb2f41b02c">regina::PacketDescendants::PacketDescendants</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;)=default</td></tr>
<tr class="memdesc:gaecbbafcb328346116b72f1cb2f41b02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="#gaecbbafcb328346116b72f1cb2f41b02c">More...</a><br /></td></tr>
<tr class="separator:gaecbbafcb328346116b72f1cb2f41b02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3349803a6192301ffccc708dcf7c8efa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga3349803a6192301ffccc708dcf7c8efa">regina::PacketDescendants::PacketDescendants</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *subtree)</td></tr>
<tr class="memdesc:ga3349803a6192301ffccc708dcf7c8efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the strict descendants of the given packet.  <a href="#ga3349803a6192301ffccc708dcf7c8efa">More...</a><br /></td></tr>
<tr class="separator:ga3349803a6192301ffccc708dcf7c8efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab143a69767e65df6b0e7fa4671b3d493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab143a69767e65df6b0e7fa4671b3d493">regina::PacketDescendants::operator=</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;)=default</td></tr>
<tr class="memdesc:gab143a69767e65df6b0e7fa4671b3d493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="#gab143a69767e65df6b0e7fa4671b3d493">More...</a><br /></td></tr>
<tr class="separator:gab143a69767e65df6b0e7fa4671b3d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24129e2bed4ad821ec55526ef68abfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae24129e2bed4ad821ec55526ef68abfc">regina::PacketDescendants::begin</a> () const</td></tr>
<tr class="memdesc:gae24129e2bed4ad821ec55526ef68abfc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of strict descendants.  <a href="#gae24129e2bed4ad821ec55526ef68abfc">More...</a><br /></td></tr>
<tr class="separator:gae24129e2bed4ad821ec55526ef68abfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56c66808490401dfc950ce16b268423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab56c66808490401dfc950ce16b268423">regina::PacketDescendants::end</a> () const</td></tr>
<tr class="memdesc:gab56c66808490401dfc950ce16b268423"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of strict descendants.  <a href="#gab56c66808490401dfc950ce16b268423">More...</a><br /></td></tr>
<tr class="separator:gab56c66808490401dfc950ce16b268423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126ffc7b34aca93a3edba924d0764aaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga126ffc7b34aca93a3edba924d0764aaa">regina::PacketShell::PacketShell</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga126ffc7b34aca93a3edba924d0764aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new shell referring to the given packet.  <a href="#ga126ffc7b34aca93a3edba924d0764aaa">More...</a><br /></td></tr>
<tr class="separator:ga126ffc7b34aca93a3edba924d0764aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4743ca941ad1c1c3849b72cb5d315ede"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4743ca941ad1c1c3849b72cb5d315ede">regina::PacketShell::PacketShell</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell)=default</td></tr>
<tr class="memdesc:ga4743ca941ad1c1c3849b72cb5d315ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given shell.  <a href="#ga4743ca941ad1c1c3849b72cb5d315ede">More...</a><br /></td></tr>
<tr class="separator:ga4743ca941ad1c1c3849b72cb5d315ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga515f5c71ddf046610d03714948264f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga515f5c71ddf046610d03714948264f4e">regina::PacketShell::operator=</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell)=default</td></tr>
<tr class="memdesc:ga515f5c71ddf046610d03714948264f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given shell.  <a href="#ga515f5c71ddf046610d03714948264f4e">More...</a><br /></td></tr>
<tr class="separator:ga515f5c71ddf046610d03714948264f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbe65ec69b04755609d8294977dd989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaacbe65ec69b04755609d8294977dd989">regina::PacketShell::operator==</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell) const</td></tr>
<tr class="memdesc:gaacbe65ec69b04755609d8294977dd989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this and the given shell refer to the same underlying packet.  <a href="#gaacbe65ec69b04755609d8294977dd989">More...</a><br /></td></tr>
<tr class="separator:gaacbe65ec69b04755609d8294977dd989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b87fb099d8e833d62f0d386695ac4ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4b87fb099d8e833d62f0d386695ac4ab">regina::PacketShell::operator==</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet) const</td></tr>
<tr class="memdesc:ga4b87fb099d8e833d62f0d386695ac4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this shell refers to the given packet.  <a href="#ga4b87fb099d8e833d62f0d386695ac4ab">More...</a><br /></td></tr>
<tr class="separator:ga4b87fb099d8e833d62f0d386695ac4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3fc4744147c49718c6ca407a5912041"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab3fc4744147c49718c6ca407a5912041">regina::PacketShell::operator !=</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell) const</td></tr>
<tr class="memdesc:gab3fc4744147c49718c6ca407a5912041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this and the given shell refer to different underlying packets.  <a href="#gab3fc4744147c49718c6ca407a5912041">More...</a><br /></td></tr>
<tr class="separator:gab3fc4744147c49718c6ca407a5912041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b7986ef3b2a1ae3709a38d85d49ce4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa7b7986ef3b2a1ae3709a38d85d49ce4">regina::PacketShell::operator !=</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet) const</td></tr>
<tr class="memdesc:gaa7b7986ef3b2a1ae3709a38d85d49ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this shell does not refer to the given packet.  <a href="#gaa7b7986ef3b2a1ae3709a38d85d49ce4">More...</a><br /></td></tr>
<tr class="separator:gaa7b7986ef3b2a1ae3709a38d85d49ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5970247173515dd6e4bc93dd956922aa"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga5970247173515dd6e4bc93dd956922aa">regina::PacketShell::label</a> () const</td></tr>
<tr class="memdesc:ga5970247173515dd6e4bc93dd956922aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="#ga5970247173515dd6e4bc93dd956922aa">More...</a><br /></td></tr>
<tr class="separator:ga5970247173515dd6e4bc93dd956922aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee053db30fd6227cd420a3a5d19266e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0ee053db30fd6227cd420a3a5d19266e">regina::PacketShell::humanLabel</a> () const</td></tr>
<tr class="memdesc:ga0ee053db30fd6227cd420a3a5d19266e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="#ga0ee053db30fd6227cd420a3a5d19266e">More...</a><br /></td></tr>
<tr class="separator:ga0ee053db30fd6227cd420a3a5d19266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4893445f043663e9a8595fc8bb0490a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa4893445f043663e9a8595fc8bb0490a">regina::PacketShell::hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:gaa4893445f043663e9a8595fc8bb0490a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="#gaa4893445f043663e9a8595fc8bb0490a">More...</a><br /></td></tr>
<tr class="separator:gaa4893445f043663e9a8595fc8bb0490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a2ab9c10c8a0d08b804a9bd02530e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab9a2ab9c10c8a0d08b804a9bd02530e5">regina::PacketShell::hasTags</a> () const</td></tr>
<tr class="memdesc:gab9a2ab9c10c8a0d08b804a9bd02530e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="#gab9a2ab9c10c8a0d08b804a9bd02530e5">More...</a><br /></td></tr>
<tr class="separator:gab9a2ab9c10c8a0d08b804a9bd02530e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fe568711de8246572dc6ec376361df"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga60fe568711de8246572dc6ec376361df">regina::PacketShell::tags</a> () const</td></tr>
<tr class="memdesc:ga60fe568711de8246572dc6ec376361df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="#ga60fe568711de8246572dc6ec376361df">More...</a><br /></td></tr>
<tr class="separator:ga60fe568711de8246572dc6ec376361df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826de400a7a8238d49c86e0413043738"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga826de400a7a8238d49c86e0413043738">regina::PacketShell::internalID</a> () const</td></tr>
<tr class="memdesc:ga826de400a7a8238d49c86e0413043738"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="#ga826de400a7a8238d49c86e0413043738">More...</a><br /></td></tr>
<tr class="separator:ga826de400a7a8238d49c86e0413043738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac717c06a744c38993b7d137c55e6de40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac717c06a744c38993b7d137c55e6de40">regina::operator==</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> shell)</td></tr>
<tr class="memdesc:gac717c06a744c38993b7d137c55e6de40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if the given shell refers to the given packet.  <a href="group__packet.html#gac717c06a744c38993b7d137c55e6de40">More...</a><br /></td></tr>
<tr class="separator:gac717c06a744c38993b7d137c55e6de40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c8541d8d491011256bb936079e77cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8c8541d8d491011256bb936079e77cc6">regina::operator !=</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> shell)</td></tr>
<tr class="memdesc:ga8c8541d8d491011256bb936079e77cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if the given shell does not refer to the given packet.  <a href="group__packet.html#ga8c8541d8d491011256bb936079e77cc6">More...</a><br /></td></tr>
<tr class="separator:ga8c8541d8d491011256bb936079e77cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23c67850c87e226f435b85a7b7ddd43"><td class="memItemLeft" align="right" valign="top"><a id="gaa23c67850c87e226f435b85a7b7ddd43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PacketListener::PacketListener</b> (const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;)=delete</td></tr>
<tr class="separator:gaa23c67850c87e226f435b85a7b7ddd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ada20d9f3cd4ebf4d08651ecc9b23c0"><td class="memItemLeft" align="right" valign="top"><a id="ga4ada20d9f3cd4ebf4d08651ecc9b23c0"></a>
<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PacketListener::operator=</b> (const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;)=delete</td></tr>
<tr class="separator:ga4ada20d9f3cd4ebf4d08651ecc9b23c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac869caf59c0e19e27006cb67d5742977"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac869caf59c0e19e27006cb67d5742977">regina::PacketListener::PacketListener</a> ()=default</td></tr>
<tr class="memdesc:gac869caf59c0e19e27006cb67d5742977"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor that does nothing.  <a href="#gac869caf59c0e19e27006cb67d5742977">More...</a><br /></td></tr>
<tr class="separator:gac869caf59c0e19e27006cb67d5742977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842932466a8cdb50c359c584dd8e93ca"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga842932466a8cdb50c359c584dd8e93ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca">regina::forPacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> packetType, FunctionObject &amp;&amp;func, typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga842932466a8cdb50c359c584dd8e93ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime.  <a href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca">More...</a><br /></td></tr>
<tr class="separator:ga842932466a8cdb50c359c584dd8e93ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__packet.html#gae6cfcd14a51ee6ad01fef5af95d05458">regina::forPacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> packetType, FunctionObject &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime.  <a href="group__packet.html#gae6cfcd14a51ee6ad01fef5af95d05458">More...</a><br /></td></tr>
<tr class="separator:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1bc5e3b33bf3a5ac165b99b9956b284e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga1bc5e3b33bf3a5ac165b99b9956b284e">regina::PACKET_TRIANGULATION</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64">PACKET_TRIANGULATION3</a></td></tr>
<tr class="memdesc:ga1bc5e3b33bf3a5ac165b99b9956b284e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_TRIANGULATION3.  <a href="group__packet.html#ga1bc5e3b33bf3a5ac165b99b9956b284e">More...</a><br /></td></tr>
<tr class="separator:ga1bc5e3b33bf3a5ac165b99b9956b284e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ee82ab98a53118996b1b0ef1be1c1a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga46ee82ab98a53118996b1b0ef1be1c1a">regina::PACKET_NORMALSURFACELIST</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc">PACKET_NORMALSURFACES</a></td></tr>
<tr class="memdesc:ga46ee82ab98a53118996b1b0ef1be1c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_NORMALSURFACES.  <a href="group__packet.html#ga46ee82ab98a53118996b1b0ef1be1c1a">More...</a><br /></td></tr>
<tr class="separator:ga46ee82ab98a53118996b1b0ef1be1c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455ca759888786ae6bf7be5fb0b65236"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga455ca759888786ae6bf7be5fb0b65236">regina::PACKET_ANGLESTRUCTURELIST</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9">PACKET_ANGLESTRUCTURES</a></td></tr>
<tr class="memdesc:ga455ca759888786ae6bf7be5fb0b65236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_ANGLESTRUCTURES.  <a href="group__packet.html#ga455ca759888786ae6bf7be5fb0b65236">More...</a><br /></td></tr>
<tr class="separator:ga455ca759888786ae6bf7be5fb0b65236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63030f7812e66bd10741a6186c542c96"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga63030f7812e66bd10741a6186c542c96">regina::PACKET_DIM4TRIANGULATION</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff">PACKET_TRIANGULATION4</a></td></tr>
<tr class="memdesc:ga63030f7812e66bd10741a6186c542c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_TRIANGULATION4.  <a href="group__packet.html#ga63030f7812e66bd10741a6186c542c96">More...</a><br /></td></tr>
<tr class="separator:ga63030f7812e66bd10741a6186c542c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5161f01c333fa03786d0bb40b6f68580"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga5161f01c333fa03786d0bb40b6f68580">regina::PACKET_NORMALHYPERSURFACELIST</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e">PACKET_NORMALHYPERSURFACES</a></td></tr>
<tr class="memdesc:ga5161f01c333fa03786d0bb40b6f68580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_NORMALHYPERSURFACES.  <a href="group__packet.html#ga5161f01c333fa03786d0bb40b6f68580">More...</a><br /></td></tr>
<tr class="separator:ga5161f01c333fa03786d0bb40b6f68580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f45d5e55b081a0ada789479ed34f6c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga05f45d5e55b081a0ada789479ed34f6c">regina::PACKET_DIM2TRIANGULATION</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815">PACKET_TRIANGULATION2</a></td></tr>
<tr class="memdesc:ga05f45d5e55b081a0ada789479ed34f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_TRIANGULATION2.  <a href="group__packet.html#ga05f45d5e55b081a0ada789479ed34f6c">More...</a><br /></td></tr>
<tr class="separator:ga05f45d5e55b081a0ada789479ed34f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:gae51cb555166657e5996a76768db998e3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae51cb555166657e5996a76768db998e3">regina::PacketListener::Packet</a></td></tr>
<tr class="memdesc:gae51cb555166657e5996a76768db998e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow packets to automatically deregister listeners as they are destroyed.  <a href="#gae51cb555166657e5996a76768db998e3">More...</a><br /></td></tr>
<tr class="separator:gae51cb555166657e5996a76768db998e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructors and Destructors</h2></td></tr>
<tr class="memitem:ga8bdfa10b9c80b9f36c54097a64977d4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">regina::Packet::Packet</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>=0)</td></tr>
<tr class="memdesc:ga8bdfa10b9c80b9f36c54097a64977d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that inserts the new packet into the overall tree structure.  <a href="#ga8bdfa10b9c80b9f36c54097a64977d4c">More...</a><br /></td></tr>
<tr class="separator:ga8bdfa10b9c80b9f36c54097a64977d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5fc332c4380895ff045b21025703b16"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad5fc332c4380895ff045b21025703b16">regina::Packet::~Packet</a> ()</td></tr>
<tr class="memdesc:gad5fc332c4380895ff045b21025703b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that also orphans this packet and destroys all of its descendants.  <a href="#gad5fc332c4380895ff045b21025703b16">More...</a><br /></td></tr>
<tr class="separator:gad5fc332c4380895ff045b21025703b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">regina::Packet::safeDelete</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either destroys or orphans the given packet, according to whether it has safe pointers that currently reference it.  <a href="#ga2fe7098f6a0b61e94e9e301e4c93a89e">More...</a><br /></td></tr>
<tr class="separator:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Packet Identification</h2></td></tr>
<tr class="memitem:ga11e183185ea0a33e67e2574fc93c7469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">regina::Packet::type</a> () const =0</td></tr>
<tr class="memdesc:ga11e183185ea0a33e67e2574fc93c7469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet.  <a href="#ga11e183185ea0a33e67e2574fc93c7469">More...</a><br /></td></tr>
<tr class="separator:ga11e183185ea0a33e67e2574fc93c7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787a09ec531988778fcfb0bc87effdd4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">regina::Packet::typeName</a> () const =0</td></tr>
<tr class="memdesc:ga787a09ec531988778fcfb0bc87effdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet.  <a href="#ga787a09ec531988778fcfb0bc87effdd4">More...</a><br /></td></tr>
<tr class="separator:ga787a09ec531988778fcfb0bc87effdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">regina::Packet::label</a> () const</td></tr>
<tr class="memdesc:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="#gafd05b16f0990a54ac7f95bc32cf1483e">More...</a><br /></td></tr>
<tr class="separator:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfaee615502b79cbeef31628a1186dc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">regina::Packet::humanLabel</a> () const</td></tr>
<tr class="memdesc:gadfaee615502b79cbeef31628a1186dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="#gadfaee615502b79cbeef31628a1186dc4">More...</a><br /></td></tr>
<tr class="separator:gadfaee615502b79cbeef31628a1186dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">regina::Packet::adornedLabel</a> (const std::string &amp;adornment) const</td></tr>
<tr class="memdesc:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string.  <a href="#gae1cd6eea63e8cd41d7517f86b8c7776d">More...</a><br /></td></tr>
<tr class="separator:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd869991cbf664891629f21a5432b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfd869991cbf664891629f21a5432b02">regina::Packet::setLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:gadfd869991cbf664891629f21a5432b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="#gadfd869991cbf664891629f21a5432b02">More...</a><br /></td></tr>
<tr class="separator:gadfd869991cbf664891629f21a5432b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f5775c175a56d06da14444b391ed3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">regina::Packet::fullName</a> () const</td></tr>
<tr class="memdesc:ga29f5775c175a56d06da14444b391ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet.  <a href="#ga29f5775c175a56d06da14444b391ed3a">More...</a><br /></td></tr>
<tr class="separator:ga29f5775c175a56d06da14444b391ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tags</h2></td></tr>
<tr class="memitem:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">regina::Packet::hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:gaf4315a8b8ebcf47e781c204927f8845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="#gaf4315a8b8ebcf47e781c204927f8845f">More...</a><br /></td></tr>
<tr class="separator:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4404beade84983a4f1c051cd64035ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">regina::Packet::hasTags</a> () const</td></tr>
<tr class="memdesc:ga4404beade84983a4f1c051cd64035ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="#ga4404beade84983a4f1c051cd64035ddf">More...</a><br /></td></tr>
<tr class="separator:ga4404beade84983a4f1c051cd64035ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">regina::Packet::addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="#ga982b9936f9e9dc11ce932d4e8c7402de">More...</a><br /></td></tr>
<tr class="separator:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">regina::Packet::removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="#gacb9880c0189b8f60827cd0ce9a2bb32c">More...</a><br /></td></tr>
<tr class="separator:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">regina::Packet::removeAllTags</a> ()</td></tr>
<tr class="memdesc:gaee2405989e058dbfddf7ae445d47ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="#gaee2405989e058dbfddf7ae445d47ddcf">More...</a><br /></td></tr>
<tr class="separator:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d41356ff086d078b04f34919aac26d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">regina::Packet::tags</a> () const</td></tr>
<tr class="memdesc:ga06d41356ff086d078b04f34919aac26d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="#ga06d41356ff086d078b04f34919aac26d">More...</a><br /></td></tr>
<tr class="separator:ga06d41356ff086d078b04f34919aac26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Event Handling</h2></td></tr>
<tr class="memitem:gaa504cfa813a3190c00337743915ffef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">regina::Packet::listen</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gaa504cfa813a3190c00337743915ffef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="#gaa504cfa813a3190c00337743915ffef5">More...</a><br /></td></tr>
<tr class="separator:gaa504cfa813a3190c00337743915ffef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">regina::Packet::isListening</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="#gacd2dc2dee3396afb9dbf07c38fe10d63">More...</a><br /></td></tr>
<tr class="separator:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71b40cd2416de174bba61db2ec92f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">regina::Packet::unlisten</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gae71b40cd2416de174bba61db2ec92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="#gae71b40cd2416de174bba61db2ec92f1d">More...</a><br /></td></tr>
<tr class="separator:gae71b40cd2416de174bba61db2ec92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tree Queries</h2></td></tr>
<tr class="memitem:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">regina::Packet::parent</a> () const</td></tr>
<tr class="memdesc:gab80d6d7bc86d4600980f0c9555bb6237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="#gab80d6d7bc86d4600980f0c9555bb6237">More...</a><br /></td></tr>
<tr class="separator:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">regina::Packet::firstChild</a> () const</td></tr>
<tr class="memdesc:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="#ga6eec5fa6ced4aa15edcef36d9d299a5d">More...</a><br /></td></tr>
<tr class="separator:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">regina::Packet::lastChild</a> () const</td></tr>
<tr class="memdesc:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="#ga0a6c8037ec9109e8bf422b3cade7676e">More...</a><br /></td></tr>
<tr class="separator:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">regina::Packet::nextSibling</a> () const</td></tr>
<tr class="memdesc:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="#ga7afd16bf0e5cf7a3efe8f5d0944fe165">More...</a><br /></td></tr>
<tr class="separator:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84decda10642eccee55a109e70e10076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga84decda10642eccee55a109e70e10076">regina::Packet::prevSibling</a> () const</td></tr>
<tr class="memdesc:ga84decda10642eccee55a109e70e10076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="#ga84decda10642eccee55a109e70e10076">More...</a><br /></td></tr>
<tr class="separator:ga84decda10642eccee55a109e70e10076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">regina::Packet::root</a> () const</td></tr>
<tr class="memdesc:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="#ga49a21b8f9147249e97d68ac6cdce0c20">More...</a><br /></td></tr>
<tr class="separator:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">regina::Packet::levelsDownTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="#ga8d80a76204afdb9ea31bfef77b137bf3">More...</a><br /></td></tr>
<tr class="separator:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">regina::Packet::levelsUpTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *ancestor) const</td></tr>
<tr class="memdesc:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="#gaf4ed7022c81276beb3ef81ca8db024fa">More...</a><br /></td></tr>
<tr class="separator:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">regina::Packet::isGrandparentOf</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="#ga8848bba753ebfb2ea9940391da9c2eb9">More...</a><br /></td></tr>
<tr class="separator:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">regina::Packet::countChildren</a> () const</td></tr>
<tr class="memdesc:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet.  <a href="#gae2df11b3b1cecdfbce1a4c53bd1a0395">More...</a><br /></td></tr>
<tr class="separator:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">regina::Packet::countDescendants</a> () const</td></tr>
<tr class="memdesc:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of strict descendants of this packet.  <a href="#ga33da88ebed1a4ceccdf70172eff4e3f1">More...</a><br /></td></tr>
<tr class="separator:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2519c2dac8e039b7acd5df8373c608d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">regina::Packet::totalTreeSize</a> () const</td></tr>
<tr class="memdesc:gae2519c2dac8e039b7acd5df8373c608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="#gae2519c2dac8e039b7acd5df8373c608d">More...</a><br /></td></tr>
<tr class="separator:gae2519c2dac8e039b7acd5df8373c608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tree Manipulation</h2></td></tr>
<tr class="memitem:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">regina::Packet::insertChildFirst</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gac389781f5c53a7d3aac3206d51ecfd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="#gac389781f5c53a7d3aac3206d51ecfd91">More...</a><br /></td></tr>
<tr class="separator:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">regina::Packet::insertChildLast</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gad3d02be74192f03b372a4195c9e5bc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="#gad3d02be74192f03b372a4195c9e5bc1f">More...</a><br /></td></tr>
<tr class="separator:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9556e8405ca88517ccd5549471fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">regina::Packet::insertChildAfter</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newChild, <a class="el" href="classregina_1_1Packet.html">Packet</a> *prevChild)</td></tr>
<tr class="memdesc:gad7f9556e8405ca88517ccd5549471fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="#gad7f9556e8405ca88517ccd5549471fea">More...</a><br /></td></tr>
<tr class="separator:gad7f9556e8405ca88517ccd5549471fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">regina::Packet::makeOrphan</a> ()</td></tr>
<tr class="memdesc:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree.  <a href="#gad9aa0488b40a1f3ec702838b2a2ceecc">More...</a><br /></td></tr>
<tr class="separator:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">regina::Packet::reparent</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent, bool first=false)</td></tr>
<tr class="memdesc:ga219920e1523d3edf2982da0a3ba1a33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="#ga219920e1523d3edf2982da0a3ba1a33d">More...</a><br /></td></tr>
<tr class="separator:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">regina::Packet::transferChildren</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent)</td></tr>
<tr class="memdesc:ga27ce736503ede9e8c57fb5d169e6414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="#ga27ce736503ede9e8c57fb5d169e6414f">More...</a><br /></td></tr>
<tr class="separator:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765186c1742fe402922433b77e5f439a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga765186c1742fe402922433b77e5f439a">regina::Packet::swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:ga765186c1742fe402922433b77e5f439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="#ga765186c1742fe402922433b77e5f439a">More...</a><br /></td></tr>
<tr class="separator:ga765186c1742fe402922433b77e5f439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">regina::Packet::moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="#gae02f6b3ad3a7816cde5d7df456763aaf">More...</a><br /></td></tr>
<tr class="separator:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adc13b6143cf994779796077aed731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga59adc13b6143cf994779796077aed731">regina::Packet::moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:ga59adc13b6143cf994779796077aed731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="#ga59adc13b6143cf994779796077aed731">More...</a><br /></td></tr>
<tr class="separator:ga59adc13b6143cf994779796077aed731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d7730c57940444bf7d3085459449e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">regina::Packet::moveToFirst</a> ()</td></tr>
<tr class="memdesc:gab4d7730c57940444bf7d3085459449e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="#gab4d7730c57940444bf7d3085459449e8">More...</a><br /></td></tr>
<tr class="separator:gab4d7730c57940444bf7d3085459449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">regina::Packet::moveToLast</a> ()</td></tr>
<tr class="memdesc:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="#ga7fcff38ccb62b62d28bed83d2a3a28d5">More...</a><br /></td></tr>
<tr class="separator:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91bc951714dc60db12810affb266b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">regina::Packet::sortChildren</a> ()</td></tr>
<tr class="memdesc:gaf91bc951714dc60db12810affb266b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="#gaf91bc951714dc60db12810affb266b8a">More...</a><br /></td></tr>
<tr class="separator:gaf91bc951714dc60db12810affb266b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Searching and Iterating</h2></td></tr>
<tr class="memitem:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">regina::Packet::begin</a> ()</td></tr>
<tr class="memdesc:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of packets in the subtree rooted at this packet.  <a href="#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">More...</a><br /></td></tr>
<tr class="separator:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941baf3f572331538ec82154fd3dc997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">regina::Packet::end</a> ()</td></tr>
<tr class="memdesc:ga941baf3f572331538ec82154fd3dc997"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of the range of packets in the subtree rooted at this packet.  <a href="#ga941baf3f572331538ec82154fd3dc997">More...</a><br /></td></tr>
<tr class="separator:ga941baf3f572331538ec82154fd3dc997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">regina::Packet::descendants</a> () const</td></tr>
<tr class="memdesc:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through all strict descendants of this packet in the packet tree.  <a href="#ga4cf495d57c19d371358ba5e9955a6dc5">More...</a><br /></td></tr>
<tr class="separator:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17dd27f603463f226e64ccb65211060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">regina::Packet::children</a> () const</td></tr>
<tr class="memdesc:gaf17dd27f603463f226e64ccb65211060"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through the immediate children of this packet.  <a href="#gaf17dd27f603463f226e64ccb65211060">More...</a><br /></td></tr>
<tr class="separator:gaf17dd27f603463f226e64ccb65211060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">regina::Packet::nextTreePacket</a> ()</td></tr>
<tr class="memdesc:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="#ga7bd2bc8fc84f44023a0a4b26ad839621">More...</a><br /></td></tr>
<tr class="separator:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">regina::Packet::nextTreePacket</a> () const</td></tr>
<tr class="memdesc:gaeaff341860febcb3daadd1b9b4216c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="#gaeaff341860febcb3daadd1b9b4216c3d">More...</a><br /></td></tr>
<tr class="separator:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e196f0f1c415b457df17f96d5b6518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">regina::Packet::firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga12e196f0f1c415b457df17f96d5b6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="#ga12e196f0f1c415b457df17f96d5b6518">More...</a><br /></td></tr>
<tr class="separator:ga12e196f0f1c415b457df17f96d5b6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">regina::Packet::firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="#ga9a8ec6e940be4cf49c3f19a563b9cb16">More...</a><br /></td></tr>
<tr class="separator:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">regina::Packet::nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="#ga6b3f24565a5053de126c8169d1a3ccdb">More...</a><br /></td></tr>
<tr class="separator:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74345507fd3326dc1b22a284b90da5d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">regina::Packet::nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga74345507fd3326dc1b22a284b90da5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="#ga74345507fd3326dc1b22a284b90da5d1">More...</a><br /></td></tr>
<tr class="separator:ga74345507fd3326dc1b22a284b90da5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">regina::Packet::findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="#ga6f7c7be06c9ed6d15f99787ea5d883b2">More...</a><br /></td></tr>
<tr class="separator:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7855ea352221d498d1ca38a34d85af5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">regina::Packet::findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>) const</td></tr>
<tr class="memdesc:gac7855ea352221d498d1ca38a34d85af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="#gac7855ea352221d498d1ca38a34d85af5">More...</a><br /></td></tr>
<tr class="separator:gac7855ea352221d498d1ca38a34d85af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Packet Dependencies</h2></td></tr>
<tr class="memitem:ga36260b904a2bf98d9484869267ddf7b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet::dependsOnParent</a> () const =0</td></tr>
<tr class="memdesc:ga36260b904a2bf98d9484869267ddf7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="#ga36260b904a2bf98d9484869267ddf7b5">More...</a><br /></td></tr>
<tr class="separator:ga36260b904a2bf98d9484869267ddf7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">regina::Packet::isPacketEditable</a> () const</td></tr>
<tr class="memdesc:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children.  <a href="#gaa03a6c9fb8c55dbed8a86f32b5975437">More...</a><br /></td></tr>
<tr class="separator:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Cloning</h2></td></tr>
<tr class="memitem:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">regina::Packet::clone</a> (bool cloneDescendants=false, bool <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>=true) const</td></tr>
<tr class="memdesc:ga73c411ef1237a06ad6b634d3db67f17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="#ga73c411ef1237a06ad6b634d3db67f17d">More...</a><br /></td></tr>
<tr class="separator:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
File I/O</h2></td></tr>
<tr class="memitem:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">regina::Packet::save</a> (const char *filename, bool compressed=true) const</td></tr>
<tr class="memdesc:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="#ga9e2f7f2c116c52b44aa9dcf092a87892">More...</a><br /></td></tr>
<tr class="separator:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">regina::Packet::save</a> (std::ostream &amp;s, bool compressed=true) const</td></tr>
<tr class="memdesc:ga898ec49e8d39c46cd965ad506493f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="#ga898ec49e8d39c46cd965ad506493f2cc">More...</a><br /></td></tr>
<tr class="separator:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">regina::Packet::writeXMLFile</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga0bf681a968d890cd848f1277ea22ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="#ga0bf681a968d890cd848f1277ea22ea0f">More...</a><br /></td></tr>
<tr class="separator:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">regina::Packet::internalID</a> () const</td></tr>
<tr class="memdesc:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="#ga0b6130ab1dda164f6c6a6158a854f79f">More...</a><br /></td></tr>
<tr class="separator:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructors and Destructors</h2></td></tr>
<tr class="memitem:gabd98cb9168c4333925f340e5f7310423"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gabd98cb9168c4333925f340e5f7310423">regina::PacketListener::~PacketListener</a> ()</td></tr>
<tr class="memdesc:gabd98cb9168c4333925f340e5f7310423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this listener.  <a href="#gabd98cb9168c4333925f340e5f7310423">More...</a><br /></td></tr>
<tr class="separator:gabd98cb9168c4333925f340e5f7310423"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Packet Listener Interface</h2></td></tr>
<tr class="memitem:ga88fd0a82cc44c243e1f3d4041b86792a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga88fd0a82cc44c243e1f3d4041b86792a">regina::PacketListener::unregisterFromAllPackets</a> ()</td></tr>
<tr class="memdesc:ga88fd0a82cc44c243e1f3d4041b86792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters this listener from any packets to which it is currently listening.  <a href="#ga88fd0a82cc44c243e1f3d4041b86792a">More...</a><br /></td></tr>
<tr class="separator:ga88fd0a82cc44c243e1f3d4041b86792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec00b1f4665c352ca6638819a7f7221"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacec00b1f4665c352ca6638819a7f7221">regina::PacketListener::packetToBeChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:gacec00b1f4665c352ca6638819a7f7221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the contents of the packet are to be changed.  <a href="#gacec00b1f4665c352ca6638819a7f7221">More...</a><br /></td></tr>
<tr class="separator:gacec00b1f4665c352ca6638819a7f7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113b2c051046b67870da4a4953422438"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga113b2c051046b67870da4a4953422438">regina::PacketListener::packetWasChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga113b2c051046b67870da4a4953422438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the contents of the packet have been changed.  <a href="#ga113b2c051046b67870da4a4953422438">More...</a><br /></td></tr>
<tr class="separator:ga113b2c051046b67870da4a4953422438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7756e8a51f95d68d84c9ea2e0a7838"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838">regina::PacketListener::packetToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:gaec7756e8a51f95d68d84c9ea2e0a7838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet label or tags are to be changed.  <a href="#gaec7756e8a51f95d68d84c9ea2e0a7838">More...</a><br /></td></tr>
<tr class="separator:gaec7756e8a51f95d68d84c9ea2e0a7838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6d39aabd829a9417637a0b71b39acb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb">regina::PacketListener::packetWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:gadf6d39aabd829a9417637a0b71b39acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the packet label or tags have been changed.  <a href="#gadf6d39aabd829a9417637a0b71b39acb">More...</a><br /></td></tr>
<tr class="separator:gadf6d39aabd829a9417637a0b71b39acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f626506f5c7f4dc12fb41acde2ab97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga85f626506f5c7f4dc12fb41acde2ab97">regina::PacketListener::packetToBeDestroyed</a> (<a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> packet)</td></tr>
<tr class="memdesc:ga85f626506f5c7f4dc12fb41acde2ab97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet is about to be destroyed.  <a href="#ga85f626506f5c7f4dc12fb41acde2ab97">More...</a><br /></td></tr>
<tr class="separator:ga85f626506f5c7f4dc12fb41acde2ab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db49c766578d5d0f3b13cf5a6244a43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0db49c766578d5d0f3b13cf5a6244a43">regina::PacketListener::childToBeAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ga0db49c766578d5d0f3b13cf5a6244a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be inserted directly beneath the packet.  <a href="#ga0db49c766578d5d0f3b13cf5a6244a43">More...</a><br /></td></tr>
<tr class="separator:ga0db49c766578d5d0f3b13cf5a6244a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffc274996ce2bfe35a85bc2cf7209ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadffc274996ce2bfe35a85bc2cf7209ee">regina::PacketListener::childWasAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gadffc274996ce2bfe35a85bc2cf7209ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been inserted directly beneath the packet.  <a href="#gadffc274996ce2bfe35a85bc2cf7209ee">More...</a><br /></td></tr>
<tr class="separator:gadffc274996ce2bfe35a85bc2cf7209ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9953ae63b9b29634faeb5f36ba34ab91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91">regina::PacketListener::childToBeRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ga9953ae63b9b29634faeb5f36ba34ab91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be removed from directly beneath the packet.  <a href="#ga9953ae63b9b29634faeb5f36ba34ab91">More...</a><br /></td></tr>
<tr class="separator:ga9953ae63b9b29634faeb5f36ba34ab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9528b072f69513fba62e382c9c2aed22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22">regina::PacketListener::childWasRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ga9528b072f69513fba62e382c9c2aed22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been removed from directly beneath the packet.  <a href="#ga9528b072f69513fba62e382c9c2aed22">More...</a><br /></td></tr>
<tr class="separator:ga9528b072f69513fba62e382c9c2aed22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ce7ca97f2e668c73975d5048bd40dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga43ce7ca97f2e668c73975d5048bd40dd">regina::PacketListener::childrenToBeReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga43ce7ca97f2e668c73975d5048bd40dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the child packets directly beneath the packet are to be reordered.  <a href="#ga43ce7ca97f2e668c73975d5048bd40dd">More...</a><br /></td></tr>
<tr class="separator:ga43ce7ca97f2e668c73975d5048bd40dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a277eb9f504bd705903df678f91c3a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6a277eb9f504bd705903df678f91c3a7">regina::PacketListener::childrenWereReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga6a277eb9f504bd705903df678f91c3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the child packets directly beneath the packet have been reordered.  <a href="#ga6a277eb9f504bd705903df678f91c3a7">More...</a><br /></td></tr>
<tr class="separator:ga6a277eb9f504bd705903df678f91c3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c075ad56fc5bd7cde9e971693f3867"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867">regina::PacketListener::childToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gaf0c075ad56fc5bd7cde9e971693f3867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before one of this packet's immediate children has its label or tags changed.  <a href="#gaf0c075ad56fc5bd7cde9e971693f3867">More...</a><br /></td></tr>
<tr class="separator:gaf0c075ad56fc5bd7cde9e971693f3867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad546812ede412a4c7583edf323d6a54a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad546812ede412a4c7583edf323d6a54a">regina::PacketListener::childWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gad546812ede412a4c7583edf323d6a54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after one of this packet's immediate children has its label or tags changed.  <a href="#gad546812ede412a4c7583edf323d6a54a">More...</a><br /></td></tr>
<tr class="separator:gad546812ede412a4c7583edf323d6a54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> administration and some basic packet types. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaad9d413dab5c36f4a57d9ca811d24188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad9d413dab5c36f4a57d9ca811d24188">&#9670;&nbsp;</a></span>REGINA_PACKET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_PACKET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>: \</div><div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> typeID = id; \</div><div class="line">        inline <span class="keyword">virtual</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> type()<span class="keyword"> const override </span>{ \</div><div class="line">            return id; \</div><div class="line">        } \</div><div class="line">        inline <span class="keyword">virtual</span> std::string typeName()<span class="keyword"> const override </span>{ \</div><div class="line">            return PacketInfo&lt;id&gt;::name(); \</div><div class="line">        }</div><div class="ttc" id="group__packet_html_ga982f45957b093a38120119066dc4cfef"><div class="ttname"><a href="group__packet.html#ga982f45957b093a38120119066dc4cfef">regina::PacketType</a></div><div class="ttdeci">PacketType</div><div class="ttdoc">Represents the different types of packet that are available in Regina.</div><div class="ttdef"><b>Definition:</b> packettype.h:57</div></div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a subclass of Packet. </p>
<p>Every subclass of Packet <em>must</em> include REGINA_PACKET at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>typeID</em> that is equal to the corresponding PacketType constant;</li>
<li>declarations and implementations of the virtual functions Packet::type() and Packet::typeName().</li>
</ul>
<p>The implementation of this macro relies on the helper class PacketInfo&lt;id&gt;. If the relevant specialisation of PacketInfo is not visible (as is the case, for instance, with templated packet classes such as Triangulation&lt;dim&gt;), then you may replace REGINA_PACKET with the macro REGINA_PACKET_FROM, which allows you to provide an alternative implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this descendant class of Packet. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding PacketType constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7b8ff3226c3356a8b73c5e46f64c268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b8ff3226c3356a8b73c5e46f64c268">&#9670;&nbsp;</a></span>REGINA_PACKET_FROM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_PACKET_FROM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">helper&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>: \</div><div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> typeID = helper::typeID; \</div><div class="line">        inline <span class="keyword">virtual</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> type()<span class="keyword"> const override </span>{ \</div><div class="line">            return helper::typeID; \</div><div class="line">        } \</div><div class="line">        inline <span class="keyword">virtual</span> std::string typeName()<span class="keyword"> const override </span>{ \</div><div class="line">            return helper::name(); \</div><div class="line">        }</div><div class="ttc" id="group__packet_html_ga982f45957b093a38120119066dc4cfef"><div class="ttname"><a href="group__packet.html#ga982f45957b093a38120119066dc4cfef">regina::PacketType</a></div><div class="ttdeci">PacketType</div><div class="ttdoc">Represents the different types of packet that are available in Regina.</div><div class="ttdef"><b>Definition:</b> packettype.h:57</div></div>
</div><!-- fragment -->
<p>An alternative to REGINA_PACKET, for scenarios where the relevant PacketInfo specialisation is not visible. </p>
<p>This is intended for use with template classes such as Triangulation&lt;dim&gt;, where the corresponding PacketInfo specialisations are defined in a separate header to avoid triggering unwanted instantiations of every possible Triangulation class.</p>
<p>Like REGINA_PACKET, this macro should be placed in the definition of the relevant subclass of Packet, and in return it provides the same constants, types and virtual functions that REGINA_PACKET does. However, unlike REGINA_PACKET, it does not rely on PacketInfo for its implementation. Instead it calls upon the given class <em>helper</em>, which must provide:</p>
<ul>
<li>a compile-time constant <em>typeID</em> which is equal to the PacketType constant corresponding to this packet class;</li>
<li>a static function name() that returns a string giving the human-readable name of this packet type.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this descendant class of Packet. </td></tr>
    <tr><td class="paramname">helper</td><td>the helper class that provides the implementation details, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4dc907cfee17707d1409b1b4e499247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dc907cfee17707d1409b1b4e499247c">&#9670;&nbsp;</a></span>NContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Container.html">Container</a> <a class="el" href="group__packet.html#ga4dc907cfee17707d1409b1b4e499247c">regina::NContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000086">Deprecated:</a></b></dt><dd>The class NContainer has now been renamed to <a class="el" href="classregina_1_1Container.html" title="A packet that simply contains other packets.">Container</a>. </dd></dl>

</div>
</div>
<a id="ga4f47ede3cd04a3b515ae8e375497a987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f47ede3cd04a3b515ae8e375497a987">&#9670;&nbsp;</a></span>NPacket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a> <a class="el" href="group__packet.html#ga4f47ede3cd04a3b515ae8e375497a987">regina::NPacket</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>The class NPacket has now been renamed to <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a>. </dd></dl>

</div>
</div>
<a id="ga58067e865d029237d3a1e0e8c39cf29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58067e865d029237d3a1e0e8c39cf29f">&#9670;&nbsp;</a></span>NPacketListener</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> <a class="el" href="group__packet.html#ga58067e865d029237d3a1e0e8c39cf29f">regina::NPacketListener</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000088">Deprecated:</a></b></dt><dd>The class NPacketListener has now been renamed to <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a>. </dd></dl>

</div>
</div>
<a id="gad4467bfb4bc172da71964a4b9967a04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4467bfb4bc172da71964a4b9967a04d">&#9670;&nbsp;</a></span>NPDF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PDF.html">PDF</a> <a class="el" href="group__packet.html#gad4467bfb4bc172da71964a4b9967a04d">regina::NPDF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>The class NPDF has now been renamed to <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a>. </dd></dl>

</div>
</div>
<a id="ga80158507a6960da75b1f1c2c35d90148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80158507a6960da75b1f1c2c35d90148">&#9670;&nbsp;</a></span>NScript</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Script.html">Script</a> <a class="el" href="group__packet.html#ga80158507a6960da75b1f1c2c35d90148">regina::NScript</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000096">Deprecated:</a></b></dt><dd>The class NScript has now been renamed to <a class="el" href="classregina_1_1Script.html" title="A packet representing a Python script that can be run.">Script</a>. </dd></dl>

</div>
</div>
<a id="ga9581a76573ed62ddcd1623ae4963b72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9581a76573ed62ddcd1623ae4963b72d">&#9670;&nbsp;</a></span>NText</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Text.html">Text</a> <a class="el" href="group__packet.html#ga9581a76573ed62ddcd1623ae4963b72d">regina::NText</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>The class NText has now been renamed to <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga982f45957b093a38120119066dc4cfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982f45957b093a38120119066dc4cfef">&#9670;&nbsp;</a></span>PacketType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">regina::PacketType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the different types of packet that are available in Regina. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own packet type, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefabc7680a0895a0d0540123f9e0596b38e"></a>PACKET_CONTAINER&#160;</td><td class="fielddoc"><p>Represents a container packet, of class <a class="el" href="classregina_1_1Container.html" title="A packet that simply contains other packets.">Container</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa54ede7ca089949c83b103489c1c3ad57"></a>PACKET_TEXT&#160;</td><td class="fielddoc"><p>Represents a text packet, of class <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc"></a>PACKET_NORMALSURFACES&#160;</td><td class="fielddoc"><p>Represents a normal surface list, of class <a class="el" href="classregina_1_1NormalSurfaces.html" title="A packet representing a collection of normal surfaces in a 3-manifold.">NormalSurfaces</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa44f343e9e3b4baf3b53f8943a4503f6e"></a>PACKET_SCRIPT&#160;</td><td class="fielddoc"><p>Represents a script packet, of class <a class="el" href="classregina_1_1Script.html" title="A packet representing a Python script that can be run.">Script</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa958e5099e4f7506590d6b351a9a889cf"></a>PACKET_SURFACEFILTER&#160;</td><td class="fielddoc"><p>Represents a normal surface filter, of class <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a> or one of its descendant classes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9"></a>PACKET_ANGLESTRUCTURES&#160;</td><td class="fielddoc"><p>Represents an angle structure list, of class <a class="el" href="classregina_1_1AngleStructures.html" title="A packet representing a collection of angle structures on a triangulation.">AngleStructures</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa346e59a436dacb0d10922334f9e002e1"></a>PACKET_PDF&#160;</td><td class="fielddoc"><p>Represents a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document, of class <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e"></a>PACKET_NORMALHYPERSURFACES&#160;</td><td class="fielddoc"><p>Represents a normal hypersurface list, of class <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefac0835064733eb9d41e9db904afde7240"></a>PACKET_SNAPPEATRIANGULATION&#160;</td><td class="fielddoc"><p>Represents a triangulation in the embedded SnapPea kernel, of class <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefaa9042461f4df32b551cc9046f7d44f23"></a>PACKET_LINK&#160;</td><td class="fielddoc"><p>Represents a knot or link in the 3-sphere, of class <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815"></a>PACKET_TRIANGULATION2&#160;</td><td class="fielddoc"><p>Represents a 2-dimensional triangulation, of class <a class="el" href="classregina_1_1Triangulation_3_012_01_4.html" title="Represents a 2-manifold triangulation.">Triangulation&lt;2&gt;</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64"></a>PACKET_TRIANGULATION3&#160;</td><td class="fielddoc"><p>Represents a 3-dimensional triangulation, of class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff"></a>PACKET_TRIANGULATION4&#160;</td><td class="fielddoc"><p>Represents a 4-dimensional triangulation, of class <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html" title="Represents a 4-dimensional triangulation, typically of a 4-manifold.">Triangulation&lt;4&gt;</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefad6af6b9c7e211662703204551c8f0a6c"></a>PACKET_TRIANGULATION5&#160;</td><td class="fielddoc"><p>Represents a 5-dimensional triangulation, of class Triangulation&lt;5&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefac241be6e856f68161d4e217b49260596"></a>PACKET_TRIANGULATION6&#160;</td><td class="fielddoc"><p>Represents a 6-dimensional triangulation, of class Triangulation&lt;6&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefae75828b18b7041a6602a41f61e900c4b"></a>PACKET_TRIANGULATION7&#160;</td><td class="fielddoc"><p>Represents a 7-dimensional triangulation, of class Triangulation&lt;7&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefadac8b650c87a395064f35d8dd7139174"></a>PACKET_TRIANGULATION8&#160;</td><td class="fielddoc"><p>Represents a 8-dimensional triangulation, of class Triangulation&lt;8&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefaae3f65ac7e3e3b14c06e866e4732f04f"></a>PACKET_TRIANGULATION9&#160;</td><td class="fielddoc"><p>Represents a 9-dimensional triangulation, of class Triangulation&lt;9&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa2e49b81db0006562994ba409db5fdbb2"></a>PACKET_TRIANGULATION10&#160;</td><td class="fielddoc"><p>Represents a 10-dimensional triangulation, of class Triangulation&lt;10&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa8239b1c5322caeb818c5dd8f3fb78ae3"></a>PACKET_TRIANGULATION11&#160;</td><td class="fielddoc"><p>Represents a 11-dimensional triangulation, of class Triangulation&lt;11&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa9abc4fbf3b98a845481d2d6a651c730f"></a>PACKET_TRIANGULATION12&#160;</td><td class="fielddoc"><p>Represents a 12-dimensional triangulation, of class Triangulation&lt;12&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa2a134929dda394ce55b128b661f68a9a"></a>PACKET_TRIANGULATION13&#160;</td><td class="fielddoc"><p>Represents a 13-dimensional triangulation, of class Triangulation&lt;13&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa7984ac7306b6a4301565b5d154daddb0"></a>PACKET_TRIANGULATION14&#160;</td><td class="fielddoc"><p>Represents a 14-dimensional triangulation, of class Triangulation&lt;14&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa0e5a2698ebebf778b6bc6209778cc3a3"></a>PACKET_TRIANGULATION15&#160;</td><td class="fielddoc"><p>Represents a 15-dimensional triangulation, of class Triangulation&lt;15&gt;. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga982b9936f9e9dc11ce932d4e8c7402de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982b9936f9e9dc11ce932d4e8c7402de">&#9670;&nbsp;</a></span>addTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::addTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tag is not the empty string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was successfully added, or <code>false</code> if the given tag was already present beforehand. </dd></dl>

</div>
</div>
<a id="gae1cd6eea63e8cd41d7517f86b8c7776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1cd6eea63e8cd41d7517f86b8c7776d">&#9670;&nbsp;</a></span>adornedLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::adornedLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adornment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string. </p>
<p>An adornment typically shows how a packet has been created and/or modified. For instance, the <em>adornment</em> argument might be "Filled", or "Summand #1".</p>
<p>The way in which the packet label is adorned depends upon the label itself (in particular, an empty packet label will be handled in a sensible way). The way in which the packet label is adorned is subject to change in future versions of Regina.</p>
<p>Note that, whilst this routine returns a modified version of the packet label, the label itself will not be permamently changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adornment</td><td>the string that will be used to adorn this packet label. The adornment should just be a piece of English, ideally beginning with an upper-case letter. It should not contain any surrounding punctuation such as brackets or a dash (this will be added automatically by this routine as required). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the packet label with the given adornment. </dd></dl>

</div>
</div>
<a id="gab7ab56cf7ba6ebdc6176b1b4bc2cb287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::Packet::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of packets in the subtree rooted at this packet. </p>
<p>Subtree iteration is depth-first, where a parent packet is always processed before its descendants. Therefore the iterator returned by <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> will always point to this packet itself.</p>
<p>The <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a> routines allow you to iterate through an entire packet subtree using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* subtree = ...;</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* p : *subtree) { ... }</div></div><!-- fragment --><p>In Python, each packet can be treated as an iterable object, again iterating through the corresponding subtree:</p>
<div class="fragment"><div class="line">subtree = ...</div><div class="line"><span class="keywordflow">for</span> p <span class="keywordflow">in</span> subtree:</div><div class="line">    ...</div></div><!-- fragment --><p>See also <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a> for iterating through just the strict descendants in the subtree (i.e., excluding this packet itself), and <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating just through the immediate children of this packet (not the full subtree).</p>
<dl class="section note"><dt>Note</dt><dd>This routine is non-const because <em>dereferencing</em> a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> returns a non-const packet pointer.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>As well as treating each packet as an iterable object, Regina supplies a member function <code>Packet.subtree()</code> which returns an iterable object. Iterating over a packet directly is exactly the same as iterating over <code>Packet.subtree()</code>; the latter is offered because it may be clearer for readers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this subtree. </dd></dl>

</div>
</div>
<a id="gac7e5ca15289b85b0630d07ac1da20c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7e5ca15289b85b0630d07ac1da20c84">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> regina::PacketChildren::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of children. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>__iter__()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning iterator. </dd></dl>

</div>
</div>
<a id="gae24129e2bed4ad821ec55526ef68abfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24129e2bed4ad821ec55526ef68abfc">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::PacketDescendants::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of strict descendants. </p>
<p>This will point to the first child packet (if one exists) of the packet whose descendants we are iterating over.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>__iter__()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning iterator. </dd></dl>

</div>
</div>
<a id="ga089c4f6e4b1989fe9c89653091e6321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga089c4f6e4b1989fe9c89653091e6321e">&#9670;&nbsp;</a></span>ChangeEventSpan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Packet::ChangeEventSpan::ChangeEventSpan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new change event object for the given packet. </p>
<p>If this is the only <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a> currently in existence for the given packet, this constructor will call <a class="el" href="group__packet.html#gacec00b1f4665c352ca6638819a7f7221" title="Called before the contents of the packet are to be changed.">PacketListener::packetToBeChanged()</a> for all registered listeners for the given packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet whose data is about to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad369e1b9117672269c40c2e1dc75b2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad369e1b9117672269c40c2e1dc75b2d9">&#9670;&nbsp;</a></span>ChildIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ChildIterator::ChildIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a past-the-end iterator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> is via <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>. </dd></dl>

</div>
</div>
<a id="gab25e416c2756416f8faff87583566422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25e416c2756416f8faff87583566422">&#9670;&nbsp;</a></span>ChildIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ChildIterator::ChildIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> is via <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>. </dd></dl>

</div>
</div>
<a id="ga075232d3523eb9c5974eaf0ce2163489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga075232d3523eb9c5974eaf0ce2163489">&#9670;&nbsp;</a></span>ChildIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ChildIterator::ChildIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the given child packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> is via <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>the child packet that the new iterator should point to, or 0 if the new iterator should be past-the-end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf17dd27f603463f226e64ccb65211060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf17dd27f603463f226e64ccb65211060">&#9670;&nbsp;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> regina::Packet::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through the immediate children of this packet. </p>
<p>This routine allows you to iterate through the immediate children of a given packet using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a> = ...;</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* child : <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>-&gt;<a class="code" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">children</a>()) { ... }</div></div><!-- fragment --><p>In Python, this routine returns an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div><div class="line"><span class="keywordflow">for</span> child <span class="keywordflow">in</span> parent.children():</div><div class="line">    ...</div></div><!-- fragment --><p>This function returns a lightweight object in the sense that it does not generate a full list of children in advance, but instead just returns a small iterator that visits each child as required. In particular, this routine has small constant time and memory.</p>
<p>See <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a>, as well as <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a>, for iterating through the subtree rooted at this packet (not just the immediate children).</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the children of this packet. </dd></dl>

</div>
</div>
<a id="ga43ce7ca97f2e668c73975d5048bd40dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43ce7ca97f2e668c73975d5048bd40dd">&#9670;&nbsp;</a></span>childrenToBeReordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childrenToBeReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the child packets directly beneath the packet are to be reordered. </p>
<p>Once the reordering is done, <a class="el" href="group__packet.html#ga6a277eb9f504bd705903df678f91c3a7" title="Called after the child packets directly beneath the packet have been reordered.">childrenWereReordered()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a277eb9f504bd705903df678f91c3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a277eb9f504bd705903df678f91c3a7">&#9670;&nbsp;</a></span>childrenWereReordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childrenWereReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the child packets directly beneath the packet have been reordered. </p>
<p>Before this reordering is done, <a class="el" href="group__packet.html#ga43ce7ca97f2e668c73975d5048bd40dd" title="Called before the child packets directly beneath the packet are to be reordered.">childrenToBeReordered()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0db49c766578d5d0f3b13cf5a6244a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db49c766578d5d0f3b13cf5a6244a43">&#9670;&nbsp;</a></span>childToBeAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childToBeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be inserted directly beneath the packet. </p>
<p>Once the child is inserted, <a class="el" href="group__packet.html#gadffc274996ce2bfe35a85bc2cf7209ee" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9953ae63b9b29634faeb5f36ba34ab91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9953ae63b9b29634faeb5f36ba34ab91">&#9670;&nbsp;</a></span>childToBeRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childToBeRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be removed from directly beneath the packet. </p>
<p>Once the child is removed, <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called also.</p>
<p>Be warned: we could already be inside either this packet's or the child packet's destructor:</p>
<ul>
<li>If this packet is being destroyed, then it will orphan all of its children, and then (unless they are being mananged by <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> safe pointers) it will delete these children also. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called <em>before</em> the child is destroyed. For both functions, <em>packet</em> will be passed as <code>null</code> (since the parent packet is already well into its destruction process).</li>
<li>If the child packet is being destroyed (but the parent is not), then it will be orphaned as part of its destructor. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called from within the child destructor, and <em>child</em> will be passed as <code>null</code> to both functions.</li>
</ul>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to, or <code>null</code> if this routine is being called from within this packet's destructor. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be removed, or <code>null</code> if this routine is being called from within the child's destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0c075ad56fc5bd7cde9e971693f3867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c075ad56fc5bd7cde9e971693f3867">&#9670;&nbsp;</a></span>childToBeRenamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before one of this packet's immediate children has its label or tags changed. </p>
<p>Before this change, <a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> </dd></dl>

</div>
</div>
<a id="gadffc274996ce2bfe35a85bc2cf7209ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadffc274996ce2bfe35a85bc2cf7209ee">&#9670;&nbsp;</a></span>childWasAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childWasAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been inserted directly beneath the packet. </p>
<p>Before this child is added, <a class="el" href="group__packet.html#ga0db49c766578d5d0f3b13cf5a6244a43" title="Called before a child packet is to be inserted directly beneath the packet.">childToBeAdded()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9528b072f69513fba62e382c9c2aed22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9528b072f69513fba62e382c9c2aed22">&#9670;&nbsp;</a></span>childWasRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childWasRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been removed from directly beneath the packet. </p>
<p>Before the child is removed, <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> will be called also.</p>
<p>Be warned: we could already be inside either this packet's or the child packet's destructor:</p>
<ul>
<li>If this packet is being destroyed, then it will orphan all of its children, and then (unless they are being mananged by <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> safe pointers) it will delete these children also. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called <em>before</em> the child is destroyed. For both functions, <em>packet</em> will be passed as <code>null</code> (since the parent packet is already well into its destruction process).</li>
<li>If the child packet is being destroyed (but the parent is not), then it will be orphaned as part of its destructor. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called from within the child destructor, and <em>child</em> will be passed as <code>null</code> to both functions.</li>
</ul>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to, or <code>null</code> if this routine is being called from within this packet's destructor. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was removed, or <code>null</code> if this routine is being called from within the child's destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad546812ede412a4c7583edf323d6a54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad546812ede412a4c7583edf323d6a54a">&#9670;&nbsp;</a></span>childWasRenamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after one of this packet's immediate children has its label or tags changed. </p>
<p>Before this change, <a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> </dd></dl>

</div>
</div>
<a id="ga73c411ef1237a06ad6b634d3db67f17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73c411ef1237a06ad6b634d3db67f17d">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneDescendants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet. </p>
<p>Note that any string tags associated with this packet will <em>not</em> be cloned.</p>
<p>If this packet has no parent in the tree structure, no clone will be created and 0 will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneDescendants</td><td><code>true</code> if the descendants of this packet should also be cloned and inserted as descendants of the new packet. If this is passed as <code>false</code> (the default), only this packet will be cloned. </td></tr>
    <tr><td class="paramname">end</td><td><code>true</code> if the new packet should be inserted at the end of the parent's list of children (the default), or <code>false</code> if the new packet should be inserted as the sibling immediately after this packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly inserted packet, or 0 if this packet has no parent. </dd></dl>

</div>
</div>
<a id="gae2df11b3b1cecdfbce1a4c53bd1a0395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2df11b3b1cecdfbce1a4c53bd1a0395">&#9670;&nbsp;</a></span>countChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet. </p>
<p>Grandchildren and so on are not counted.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of immediate children. </dd></dl>

</div>
</div>
<a id="ga33da88ebed1a4ceccdf70172eff4e3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33da88ebed1a4ceccdf70172eff4e3f1">&#9670;&nbsp;</a></span>countDescendants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of strict descendants of this packet. </p>
<p>This includes children, grandchildren and so on. This packet is not included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of strict descendants. </dd></dl>

</div>
</div>
<a id="ga36260b904a2bf98d9484869267ddf7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36260b904a2bf98d9484869267ddf7b5">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::Packet::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1Link.html#a34359ae0aeda30012164cd24256dd29d">regina::Link</a>, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a69a2d5c64038c031ca6626b4fbc80175">regina::SnapPeaTriangulation</a>, <a class="el" href="classregina_1_1NormalSurfaces.html#ad33634993b549ee12249b97a019fe002">regina::NormalSurfaces</a>, <a class="el" href="classregina_1_1Triangulation.html#a88d1148417898781dba0769484711989">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="classregina_1_1Triangulation.html#a88d1148417898781dba0769484711989">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a937b00d0472570d29436cacecbaf701a">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="classregina_1_1Script.html#a4f1e07ef835c561938bf2f36cb48e438">regina::Script</a>, <a class="el" href="classregina_1_1NormalHypersurfaces.html#a56057aabcc51c84ea924dd68f2e1326a">regina::NormalHypersurfaces</a>, <a class="el" href="classregina_1_1SurfaceFilter.html#a2cbf1c1dc39ca6a9792124e129ab54b4">regina::SurfaceFilter</a>, <a class="el" href="classregina_1_1PDF.html#a845af51beb787b3de5ef34912c438457">regina::PDF</a>, <a class="el" href="classregina_1_1AngleStructures.html#a7c5ac676fbceae4514b483fb661a11c9">regina::AngleStructures</a>, <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a52891e48cbed1c50e5960b9977e45b67">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="classregina_1_1Triangulation_3_012_01_4.html#a0a9012ef8d3274d1bbb4a5b57d7a43c0">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="classregina_1_1Text.html#a6e1640a424aa67f2ff1e406871fa63a6">regina::Text</a>, and <a class="el" href="classregina_1_1Container.html#a56c1588e7b5f30f8c5b70047c2b70fdc">regina::Container</a>.</p>

</div>
</div>
<a id="ga4cf495d57c19d371358ba5e9955a6dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cf495d57c19d371358ba5e9955a6dc5">&#9670;&nbsp;</a></span>descendants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> regina::Packet::descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through all strict descendants of this packet in the packet tree. </p>
<p>The order of iteration is exactly the same as when iterating over the full subtree rooted at this packet (as offered by <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">Packet::begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">Packet::end()</a>), except that the iteration <em>excludes</em> this packet itself. In particular, the iteration is depth-first, and each packet in the subtree is processed before its own descendants.</p>
<p>This routine allows you to iterate through all strict descendants of a given packet using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a> = ...;</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* desc : <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>-&gt;<a class="code" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">descendants</a>()) { ... }</div></div><!-- fragment --><p>In Python, this routine returns an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div><div class="line"><span class="keywordflow">for</span> desc <span class="keywordflow">in</span> parent.descendants():</div><div class="line">    ...</div></div><!-- fragment --><p>This function returns a lightweight object in the sense that it does not generate a full list of descendants in advance, but instead just returns a small iterator that visits each descendant as required. In particular, this routine has small constant time and memory.</p>
<p>See also <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a> for iterating through the entire subtree <em>including</em> this packet, and <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating over just this packet's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the strict descendants of this packet. </dd></dl>

</div>
</div>
<a id="ga941baf3f572331538ec82154fd3dc997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941baf3f572331538ec82154fd3dc997">&#9670;&nbsp;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::Packet::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of the range of packets in the subtree rooted at this packet. </p>
<p>In C++, the <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a> routines allow you to iterate through an entire packet subtree using C++11 range-based <code>for</code> loops. In Python, each packet can be treated as an iterable object.</p>
<p>See the <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Again, see the <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> documentation for the iterable objects that Regina provides for Python users.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this subtree. </dd></dl>

</div>
</div>
<a id="ga09f68310c44da3f5f260b04a49694ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09f68310c44da3f5f260b04a49694ea2">&#9670;&nbsp;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> regina::PacketChildren::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of children. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>__iter__()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the past-the-end iterator. </dd></dl>

</div>
</div>
<a id="gab56c66808490401dfc950ce16b268423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56c66808490401dfc950ce16b268423">&#9670;&nbsp;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::PacketDescendants::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of strict descendants. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>__iter__()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the past-the-end iterator. </dd></dl>

</div>
</div>
<a id="ga6f7c7be06c9ed6d15f99787ea5d883b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7c7be06c9ed6d15f99787ea5d883b2">&#9670;&nbsp;</a></span>findPacketLabel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a id="gac7855ea352221d498d1ca38a34d85af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7855ea352221d498d1ca38a34d85af5">&#9670;&nbsp;</a></span>findPacketLabel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a id="ga6eec5fa6ced4aa15edcef36d9d299a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eec5fa6ced4aa15edcef36d9d299a5d">&#9670;&nbsp;</a></span>firstChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::firstChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the first child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga12e196f0f1c415b457df17f96d5b6518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e196f0f1c415b457df17f96d5b6518">&#9670;&nbsp;</a></span>firstTreePacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a id="ga9a8ec6e940be4cf49c3f19a563b9cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8ec6e940be4cf49c3f19a563b9cb16">&#9670;&nbsp;</a></span>firstTreePacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a id="ga842932466a8cdb50c359c584dd8e93ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga842932466a8cdb50c359c584dd8e93ca">&#9670;&nbsp;</a></span>forPacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::ReturnType regina::forPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible packet types known to Regina.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new packet type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;PacketInfo&lt;t&gt;&gt;(...)</code> is defined for any valid PacketType enum value <em>t</em>. Then, when the user calls <code>forPacket(packetType, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;PacketInfo&lt;packetType&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>packetType</em> does not denote a valid packet type, then <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from Returns&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>the given packet type. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a PacketInfo&lt;packetType&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given packet type is not valid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given packet type is not valid. </dd></dl>

</div>
</div>
<a id="gae6cfcd14a51ee6ad01fef5af95d05458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6cfcd14a51ee6ad01fef5af95d05458">&#9670;&nbsp;</a></span>forPacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::Void regina::forPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible packet types known to Regina.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new packet type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;PacketInfo&lt;t&gt;&gt;(...)</code> is defined for any valid PacketType enum value <em>t</em>. Then, when the user calls <code>forPacket(packetType, func, ...)</code>, this routine will call <code>func.operator()&lt;PacketInfo&lt;packetType&gt;&gt;(...)</code> in turn. If <em>packetType</em> does not denote a valid packet type, then <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em> (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>the given packet type. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a PacketInfo&lt;packetType&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a id="ga29f5775c175a56d06da14444b391ed3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f5775c175a56d06da14444b391ed3a">&#9670;&nbsp;</a></span>fullName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::fullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet. </p>
<p>The string is of the form <em>label (packet-type)</em>.</p>
<p>The packet label will be adjusted for human-readable output according to the behaviour of <a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">humanLabel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the descriptive text string. </dd></dl>

</div>
</div>
<a id="gac85ba39c124eda4ce631b653d6bb0a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac85ba39c124eda4ce631b653d6bb0a29">&#9670;&nbsp;</a></span>hasOwner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object. </p>
<p>For packets, this returns <code>true</code> if and only if this packet has a parent in the packet tree (i.e., is not the root).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if some other object owns this object. </dd></dl>

</div>
</div>
<a id="gaf4315a8b8ebcf47e781c204927f8845f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4315a8b8ebcf47e781c204927f8845f">&#9670;&nbsp;</a></span>hasTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has the given associated tag. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaa4893445f043663e9a8595fc8bb0490a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4893445f043663e9a8595fc8bb0490a">&#9670;&nbsp;</a></span>hasTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has the given associated tag. </p>
<p>See <a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d" title="Returns the set of all tags associated with this packet.">Packet::tags()</a> for further details on packet tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4404beade84983a4f1c051cd64035ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4404beade84983a4f1c051cd64035ddf">&#9670;&nbsp;</a></span>hasTags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has any associated tags at all. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this packet has any tags, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab9a2ab9c10c8a0d08b804a9bd02530e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a2ab9c10c8a0d08b804a9bd02530e5">&#9670;&nbsp;</a></span>hasTags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::hasTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has any associated tags at all. </p>
<p>See <a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d" title="Returns the set of all tags associated with this packet.">Packet::tags()</a> for further details on packet tags.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this packet has any tags, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gadfaee615502b79cbeef31628a1186dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfaee615502b79cbeef31628a1186dc4">&#9670;&nbsp;</a></span>humanLabel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::humanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<p>In particular, if the packet has no label assigned then this routine will return "(no label)", not the empty string.</p>
<dl class="section warning"><dt>Warning</dt><dd>The method by which this routine adjusts packet labels is subject to change in future versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="ga0ee053db30fd6227cd420a3a5d19266e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee053db30fd6227cd420a3a5d19266e">&#9670;&nbsp;</a></span>humanLabel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::PacketShell::humanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<p>See <a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e" title="Returns the label associated with this individual packet.">Packet::label()</a> and <a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">Packet::humanLabel()</a> for further details on packet labels.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="gad7f9556e8405ca88517ccd5549471fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f9556e8405ca88517ccd5549471fea">&#9670;&nbsp;</a></span>insertChildAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>prevChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given packet as a child of this packet at the given location in this packet's child list. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>newChild</em> has no parent packet. </dd>
<dd>
Parameter <em>prevChild</em> is already a child of this packet. </dd>
<dd>
This packet is not a descendant of <em>newChild</em>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newChild</td><td>the child to insert. </td></tr>
    <tr><td class="paramname">prevChild</td><td>the preexisting child of this packet after which <em>newChild</em> will be inserted, or 0 if <em>newChild</em> is to be the first child of this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac389781f5c53a7d3aac3206d51ecfd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac389781f5c53a7d3aac3206d51ecfd91">&#9670;&nbsp;</a></span>insertChildFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given packet as the first child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3d02be74192f03b372a4195c9e5bc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3d02be74192f03b372a4195c9e5bc1f">&#9670;&nbsp;</a></span>insertChildLast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildLast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given packet as the last child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd4d2e82e583276a70128d952b46bd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd4d2e82e583276a70128d952b46bd53">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implemented in <a class="el" href="classregina_1_1Link.html#aa36d8a4b0c964cafb2cbac86b0d5e272">regina::Link</a>, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a9d64120795e92d1a7c18b0427180080a">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#aac5b4c8b62c4c1467bac25d2797629f7">regina::SnapPeaTriangulation</a>, <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#adf21fab69f6841399139254ccd73e99d">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="classregina_1_1NormalSurfaces.html#adc0ab53ae8085a452393a764bd8d5b27">regina::NormalSurfaces</a>, <a class="el" href="classregina_1_1SurfaceFilterProperties.html#a7ec5eeb4810c80741c71380d47315334">regina::SurfaceFilterProperties</a>, <a class="el" href="classregina_1_1NormalHypersurfaces.html#afbfc6c679ae7ab07f4cd4953ae5c4efe">regina::NormalHypersurfaces</a>, <a class="el" href="classregina_1_1Triangulation_3_012_01_4.html#a0798b7fb0e21aa00f335380406628a94">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="classregina_1_1Triangulation.html#af3ad2917495b976a4a449a1ecf72011a">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="classregina_1_1Triangulation.html#af3ad2917495b976a4a449a1ecf72011a">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="classregina_1_1SurfaceFilterCombination.html#a233c06d9abc90d0d78e7505e330ace46">regina::SurfaceFilterCombination</a>, <a class="el" href="classregina_1_1Script.html#ad5aa0da3c39b73fb341cd2cb3f59deb6">regina::Script</a>, <a class="el" href="classregina_1_1SurfaceFilter.html#acb8bd5f5aaa07c895c1ff7b457056c80">regina::SurfaceFilter</a>, <a class="el" href="classregina_1_1PDF.html#a814a47f567426f0def126844dcacb0bb">regina::PDF</a>, <a class="el" href="classregina_1_1AngleStructures.html#a045880691b243edd429661aa1d0fc859">regina::AngleStructures</a>, <a class="el" href="classregina_1_1Text.html#a4ee6af15b1de3e79e8fe259244f1315c">regina::Text</a>, and <a class="el" href="classregina_1_1Container.html#aaca88e2d9f18a028110e0eff651c41db">regina::Container</a>.</p>

</div>
</div>
<a id="ga0b6130ab1dda164f6c6a6158a854f79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6130ab1dda164f6c6a6158a854f79f">&#9670;&nbsp;</a></span>internalID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::internalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet. </p>
<p>The user has no control over this ID, and it is not human readable. It is guaranteed to remain fixed throughout the lifetime of the program for a given packet, and it is guaranteed not to clash with the ID of any other packet.</p>
<p>If you change the contents of a packet, its ID will not change.</p>
<p>If you clone a packet, the new clone will receive a different ID. If you save and then load a packet to/from file, the ID will change. These behaviours are necessary to ensure that IDs remain unique (since, for instance, you could load several copies of the same data file into memory simultaneously).</p>
<p>The ID is implemented as an encoding of the underlying C++ pointer. This encoding is subject to change in later versions of Regina.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this packet. </dd></dl>

</div>
</div>
<a id="ga826de400a7a8238d49c86e0413043738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga826de400a7a8238d49c86e0413043738">&#9670;&nbsp;</a></span>internalID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::PacketShell::internalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet. </p>
<p>The user has no control over this ID and it is not human readable, but it is guaranteed to be unique to this packet, and to remain fixed throughout the lifetime of the program for this packet.</p>
<p>See <a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this packet. </dd></dl>

</div>
</div>
<a id="ga8848bba753ebfb2ea9940391da9c2eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8848bba753ebfb2ea9940391da9c2eb9">&#9670;&nbsp;</a></span>isGrandparentOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isGrandparentOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this packet is equal to or an ancestor of the given packet in the tree structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the other packet whose relationships we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet is equal to or an ancestor of <code>descendant</code>. </dd></dl>

</div>
</div>
<a id="gacd2dc2dee3396afb9dbf07c38fe10d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd2dc2dee3396afb9dbf07c38fe10d63">&#9670;&nbsp;</a></span>isListening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isListening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given packet listener is currently listening for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener is currently registered with this packet, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaa03a6c9fb8c55dbed8a86f32b5975437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa03a6c9fb8c55dbed8a86f32b5975437">&#9670;&nbsp;</a></span>isPacketEditable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isPacketEditable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children. </p>
<p>Descendants further down the packet tree are not (and should not need to be) considered.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet may be edited. </dd></dl>

</div>
</div>
<a id="gafd05b16f0990a54ac7f95bc32cf1483e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd05b16f0990a54ac7f95bc32cf1483e">&#9670;&nbsp;</a></span>label() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::Packet::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet. </p>
<p>An example is <code>MyTriangulation</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="ga5970247173515dd6e4bc93dd956922aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5970247173515dd6e4bc93dd956922aa">&#9670;&nbsp;</a></span>label() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::PacketShell::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet. </p>
<p>See <a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e" title="Returns the label associated with this individual packet.">Packet::label()</a> and <a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">Packet::humanLabel()</a> for further details on packet labels.</p>
<p>The reference that is returned should be only used as a temporary, since the underlying packet (and therefore the string that is referenced) is in the process of being destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="ga0a6c8037ec9109e8bf422b3cade7676e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a6c8037ec9109e8bf422b3cade7676e">&#9670;&nbsp;</a></span>lastChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::lastChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the last child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the last child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga8d80a76204afdb9ea31bfef77b137bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d80a76204afdb9ea31bfef77b137bf3">&#9670;&nbsp;</a></span>levelsDownTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsDownTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given descendant in the tree structure. </p>
<p>If <code>descendant</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>descendant</code>, or can be obtained from <code>descendant</code> using only child-to-parent steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a id="gaf4ed7022c81276beb3ef81ca8db024fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4ed7022c81276beb3ef81ca8db024fa">&#9670;&nbsp;</a></span>levelsUpTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsUpTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given ancestor in the tree structure. </p>
<p>If <code>ancestor</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>ancestor</code>, or can be obtained from <code>ancestor</code> using only parent-to-child steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a id="gaa504cfa813a3190c00337743915ffef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa504cfa813a3190c00337743915ffef5">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the given packet listener to listen for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully registered, or <code>false</code> if the given listener was already registered beforehand. </dd></dl>

</div>
</div>
<a id="gad9aa0488b40a1f3ec702838b2a2ceecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9aa0488b40a1f3ec702838b2a2ceecc">&#9670;&nbsp;</a></span>makeOrphan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::makeOrphan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree. </p>
<p>The tree information for both this packet and its parent will be updated.</p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet has a parent. </dd>
<dd>
This packet does not depend on its parent; see <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>After <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> is called, this packet will become the root of a new packet tree that is owned by Python. In particular, if you call <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and then delete all Python references to this packet, the entire packet subtree will be automatically destroyed. </dd></dl>

</div>
</div>
<a id="ga59adc13b6143cf994779796077aed731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59adc13b6143cf994779796077aed731">&#9670;&nbsp;</a></span>moveDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveDown </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the end of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very end of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a id="gab4d7730c57940444bf7d3085459449e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4d7730c57940444bf7d3085459449e8">&#9670;&nbsp;</a></span>moveToFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet to be the first in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a id="ga7fcff38ccb62b62d28bed83d2a3a28d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcff38ccb62b62d28bed83d2a3a28d5">&#9670;&nbsp;</a></span>moveToLast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet to be the last in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a id="gae02f6b3ad3a7816cde5d7df456763aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02f6b3ad3a7816cde5d7df456763aaf">&#9670;&nbsp;</a></span>moveUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveUp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the beginning of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very beginning of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a id="ga7afd16bf0e5cf7a3efe8f5d0944fe165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7afd16bf0e5cf7a3efe8f5d0944fe165">&#9670;&nbsp;</a></span>nextSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::nextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the next sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that follows this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the next sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga7bd2bc8fc84f44023a0a4b26ad839621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd2bc8fc84f44023a0a4b26ad839621">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a id="gaeaff341860febcb3daadd1b9b4216c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaff341860febcb3daadd1b9b4216c3d">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a id="ga6b3f24565a5053de126c8169d1a3ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b3f24565a5053de126c8169d1a3ccdb">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a id="ga74345507fd3326dc1b22a284b90da5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74345507fd3326dc1b22a284b90da5d1">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a id="ga964a605603a33a84e5004e9ebb0ac5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964a605603a33a84e5004e9ebb0ac5ec">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a Regina data file, and returns the corresponding packet tree. </p>
<p>This uses Regina's native XML file format; it does not matter whether the XML file is compressed or uncompressed.</p>
<p>If the file could not be opened or the top-level packet in the tree could not be read, this routine will return 0. If some packet deeper within the tree could not be read then that particular packet (and its descendants, if any) will simply be ignored.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is not automatically imported into the global namespace when running regina-python, or when opening a Python console in the graphical user interface, or even when typing <code>from regina import *</code>. This is to avoid overriding Python's own built-in <a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec" title="Reads a Regina data file, and returns the corresponding packet tree.">open()</a> function. You can access Regina's <a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec" title="Reads a Regina data file, and returns the corresponding packet tree.">open()</a> function by calling <code><a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec" title="Reads a Regina data file, and returns the corresponding packet tree.">regina.open()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the pathname of the file to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet tree read from file, or 0 on error (as explained above). </dd></dl>

</div>
</div>
<a id="gae53c0b54eaa7f029e0b0a13bb3c02675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae53c0b54eaa7f029e0b0a13bb3c02675">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::open </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a Regina data file from the given input stream, and returns the corresponding packet tree. </p>
<p>This uses Regina's native XML file format; it does not matter whether the XML file is compressed or uncompressed.</p>
<p>If the stream could not be read or if the top-level packet in the tree could not be read, then this routine will return 0. If some packet deeper within the tree could not be read then that particular packet (and its descendants, if any) will simply be ignored.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given stream is open for reading.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet tree read from file, or 0 on error (as explained above). </dd></dl>

</div>
</div>
<a id="ga77ea9c9b9efbf3054e0517eae2648f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77ea9c9b9efbf3054e0517eae2648f30">&#9670;&nbsp;</a></span>operator !=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ChildIterator::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="ga46684c15cbbc4cea9146f584766a06d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46684c15cbbc4cea9146f584766a06d0">&#9670;&nbsp;</a></span>operator !=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SubtreeIterator::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the packets that each iterator is currently pointing to. It does not compare the roots of the subtrees themselves.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="gab3fc4744147c49718c6ca407a5912041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fc4744147c49718c6ca407a5912041">&#9670;&nbsp;</a></span>operator !=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this and the given shell refer to different underlying packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both shells refer to different packets. </dd></dl>

</div>
</div>
<a id="gaa7b7986ef3b2a1ae3709a38d85d49ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7b7986ef3b2a1ae3709a38d85d49ce4">&#9670;&nbsp;</a></span>operator !=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this shell does not refer to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the right); this reversed test is defined as a global function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this shell does not refer to the given packet. </dd></dl>

</div>
</div>
<a id="ga8c8541d8d491011256bb936079e77cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c8541d8d491011256bb936079e77cc6">&#9670;&nbsp;</a></span>operator !=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>shell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if the given shell does not refer to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the left); this reversed test is defined as a member function of <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
    <tr><td class="paramname">shell</td><td>the packet shell to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given shell does not refer to the given packet. </dd></dl>

</div>
</div>
<a id="gad1faa715461872fb5a6aacf1f80f2719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1faa715461872fb5a6aacf1f80f2719">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp; regina::ChildIterator::operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current child packet and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current packet. </dd></dl>

</div>
</div>
<a id="ga67e81ea61e149c4c919b2c9ced87e54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67e81ea61e149c4c919b2c9ced87e54c">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp; regina::SubtreeIterator::operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current packet. </dd></dl>

</div>
</div>
<a id="ga6e515b2ba38eba36cf621598447bfad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e515b2ba38eba36cf621598447bfad6">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp; regina::ChildIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current child packet and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="gafc8d33346fee85e3a0ccb4fb8e94e437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc8d33346fee85e3a0ccb4fb8e94e437">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> regina::ChildIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current child packet and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="ga130eb896f8e699b159d2c124d774f7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga130eb896f8e699b159d2c124d774f7b1">&#9670;&nbsp;</a></span>operator++() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp; regina::SubtreeIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="gad1010344f9ccca0551bb80f0a5966cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1010344f9ccca0551bb80f0a5966cf2">&#9670;&nbsp;</a></span>operator++() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::SubtreeIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="ga345ff5809b12d36f7ce53d81ebfcc4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345ff5809b12d36f7ce53d81ebfcc4bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&amp; regina::ChildIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>

</div>
</div>
<a id="ga962997e07b8aa25d5b7a44ac4922d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga962997e07b8aa25d5b7a44ac4922d28e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&amp; regina::SubtreeIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>

</div>
</div>
<a id="ga4ef24629212c08d93d4171816488e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ef24629212c08d93d4171816488e597">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&amp; regina::PacketChildren::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gab143a69767e65df6b0e7fa4671b3d493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab143a69767e65df6b0e7fa4671b3d493">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&amp; regina::PacketDescendants::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga515f5c71ddf046610d03714948264f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga515f5c71ddf046610d03714948264f4e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&amp; regina::PacketShell::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given shell. </p>
<p>Both shells will refer to the same underlying packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a305d83c114887ce6c5bbce98aaaa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a305d83c114887ce6c5bbce98aaaa64">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ChildIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<a id="gaa098cbbe41b9f6fba63297e915fa8992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa098cbbe41b9f6fba63297e915fa8992">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SubtreeIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the packets that each iterator is currently pointing to. It does not compare the roots of the subtrees themselves.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<a id="gaacbe65ec69b04755609d8294977dd989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacbe65ec69b04755609d8294977dd989">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this and the given shell refer to the same underlying packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both shells refer to the same packet. </dd></dl>

</div>
</div>
<a id="ga4b87fb099d8e833d62f0d386695ac4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b87fb099d8e833d62f0d386695ac4ab">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this shell refers to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the right); this reversed test is defined as a global function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this shell refers to the given packet. </dd></dl>

</div>
</div>
<a id="gac717c06a744c38993b7d137c55e6de40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac717c06a744c38993b7d137c55e6de40">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>shell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if the given shell refers to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the left); this reversed test is defined as a member function of <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
    <tr><td class="paramname">shell</td><td>the packet shell to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given shell refers to the given packet. </dd></dl>

</div>
</div>
<a id="ga8bdfa10b9c80b9f36c54097a64977d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bdfa10b9c80b9f36c54097a64977d4c">&#9670;&nbsp;</a></span>Packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that inserts the new packet into the overall tree structure. </p>
<p>The new packet will be inserted as the last child of the given parent, and will be initialised with no children of its own.</p>
<p>Note that <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> is an abstract class and cannot be instantiated directly.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which to insert this packet, or 0 if this packet is to be the matriarch of a new tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1deebd4b4c4c3b685b017386b4b6f8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1deebd4b4c4c3b685b017386b4b6f8e0">&#9670;&nbsp;</a></span>PacketChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketChildren::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga1a3bc3386708cc7a52859df12f0b34e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a3bc3386708cc7a52859df12f0b34e0">&#9670;&nbsp;</a></span>PacketChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketChildren::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the immediate children of the given packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the packet whose children we will iterate through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecbbafcb328346116b72f1cb2f41b02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecbbafcb328346116b72f1cb2f41b02c">&#9670;&nbsp;</a></span>PacketDescendants() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketDescendants::PacketDescendants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga3349803a6192301ffccc708dcf7c8efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3349803a6192301ffccc708dcf7c8efa">&#9670;&nbsp;</a></span>PacketDescendants() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketDescendants::PacketDescendants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>subtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the strict descendants of the given packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td>the packet whose strict descendants we will iterate through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac869caf59c0e19e27006cb67d5742977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac869caf59c0e19e27006cb67d5742977">&#9670;&nbsp;</a></span>PacketListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketListener::PacketListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default constructor that does nothing. </p>

</div>
</div>
<a id="ga126ffc7b34aca93a3edba924d0764aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga126ffc7b34aca93a3edba924d0764aaa">&#9670;&nbsp;</a></span>PacketShell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketShell::PacketShell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new shell referring to the given packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to refer to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4743ca941ad1c1c3849b72cb5d315ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4743ca941ad1c1c3849b72cb5d315ede">&#9670;&nbsp;</a></span>PacketShell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketShell::PacketShell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given shell. </p>
<p>Both shells will refer to the same underlying packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacec00b1f4665c352ca6638819a7f7221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacec00b1f4665c352ca6638819a7f7221">&#9670;&nbsp;</a></span>packetToBeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetToBeChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the contents of the packet are to be changed. </p>
<p>Once the contents are changed, <a class="el" href="group__packet.html#ga113b2c051046b67870da4a4953422438" title="Called after the contents of the packet have been changed.">packetWasChanged()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85f626506f5c7f4dc12fb41acde2ab97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85f626506f5c7f4dc12fb41acde2ab97">&#9670;&nbsp;</a></span>packetToBeDestroyed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetToBeDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet is about to be destroyed. </p>
<p>Note that there is no matching function called <em>after</em> the packet is destroyed, since the set of listeners will no longer be available at that stage.</p>
<p>When an entire packet subtree is to be destroyed, child packets will notify their listeners of the impending destruction before parent packets will.</p>
<p>Note that the packet will forcibly unregister this listener immediately <em>before</em> <a class="el" href="group__packet.html#ga85f626506f5c7f4dc12fb41acde2ab97" title="Called before the packet is about to be destroyed.">packetToBeDestroyed()</a> is called, to avoid any unpleasant consequences if this listener should also try to unregister itself. This means that, by the time this routine is called, this listener will no longer be registered with the packet in question (and any attempt to unregister it again will be harmless).</p>
<p>By the time this function is called, we are already inside the <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> destructor, and so most <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> member functions are no longer safe to call. Therefore the argument that is passed to this routine is a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>, which exposes only those member functions of <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> that are still safe to call at this time. Importantly, you can safely compare a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> against a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> pointer, in case you need to identify which particular packet is being destroyed.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>gives access to the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1Script.html#a7d97052be80a5b0e3ebb3ca104bf3edd">regina::Script</a>.</p>

</div>
</div>
<a id="gaec7756e8a51f95d68d84c9ea2e0a7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7756e8a51f95d68d84c9ea2e0a7838">&#9670;&nbsp;</a></span>packetToBeRenamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet label or tags are to be changed. </p>
<p>Once the label or tags are changed, <a class="el" href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> </dd></dl>

</div>
</div>
<a id="ga113b2c051046b67870da4a4953422438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga113b2c051046b67870da4a4953422438">&#9670;&nbsp;</a></span>packetWasChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetWasChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the contents of the packet have been changed. </p>
<p>Before the contents are changed, <a class="el" href="group__packet.html#gacec00b1f4665c352ca6638819a7f7221" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a44bfb39f2ed4cd387b2c20fcf62b5626">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="gadf6d39aabd829a9417637a0b71b39acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf6d39aabd829a9417637a0b71b39acb">&#9670;&nbsp;</a></span>packetWasRenamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the packet label or tags have been changed. </p>
<p>Before the label or tags are changed, <a class="el" href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gad546812ede412a4c7583edf323d6a54a" title="Called after one of this packet&#39;s immediate children has its label or tags changed.">childWasRenamed()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1Script.html#ad286098a247bcba4f440c5f42f4b6863">regina::Script</a>.</p>

</div>
</div>
<a id="gab80d6d7bc86d4600980f0c9555bb6237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab80d6d7bc86d4600980f0c9555bb6237">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the parent packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga84decda10642eccee55a109e70e10076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84decda10642eccee55a109e70e10076">&#9670;&nbsp;</a></span>prevSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::prevSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the previous sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that precedes this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the previous sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="gaee2405989e058dbfddf7ae445d47ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2405989e058dbfddf7ae445d47ddcf">&#9670;&nbsp;</a></span>removeAllTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::removeAllTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all associated tags from this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet. </p>

</div>
</div>
<a id="gacb9880c0189b8f60827cd0ce9a2bb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9880c0189b8f60827cd0ce9a2bb32c">&#9670;&nbsp;</a></span>removeTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::removeTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the association of the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was removed, or <code>false</code> if the given tag was not actually associated with this packet. </dd></dl>

</div>
</div>
<a id="ga219920e1523d3edf2982da0a3ba1a33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219920e1523d3edf2982da0a3ba1a33d">&#9670;&nbsp;</a></span>reparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::reparent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead. </p>
<p>This routine is essentially a combination of <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> followed by either <a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> or <a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>.</p>
<p>This routine takes small constant time. It is safe to use regardless of whether this packet has a parent or not.</p>
<p>If you wish to reparent <em>all</em> of the children of a given packet, see <a class="el" href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f" title="Cuts all of this packet&#39;s children out of the packet tree, and reinserts them as children of the give...">transferChildren()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend on its parent; see <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is much simpler than combinations of <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and <a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> / <a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>, since there are no unpleasant ownership issues to deal with. However, if this packet currently has no parent then the ownership issues are unavoidable; in this case <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> will do nothing, and one of the insertChild...() routines must be used instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent of this packet, i.e., the packet beneath which this packet will be inserted. </td></tr>
    <tr><td class="paramname">first</td><td><code>true</code> if this packet should be inserted as the first child of the given parent, or <code>false</code> (the default) if it should be inserted as the last child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49a21b8f9147249e97d68ac6cdce0c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a21b8f9147249e97d68ac6cdce0c20">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the root of the tree to which this packet belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the matriarch of the packet tree. </dd></dl>

</div>
</div>
<a id="ga2fe7098f6a0b61e94e9e301e4c93a89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe7098f6a0b61e94e9e301e4c93a89e">&#9670;&nbsp;</a></span>safeDelete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::Packet::safeDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Either destroys or orphans the given packet, according to whether it has safe pointers that currently reference it. </p>
<p>In this context, a "safe pointer" is either SafePtr&lt;Packet&gt; or a subclass; such pointers are (for instance) used to hold packets in regina's python bindings.</p>
<p>If there are no safe pointers currently pointing to <em>p</em>, then this routine simply deletes <em>p</em>. If there are one or more safe pointers currently pointing to <em>p</em>, then this routine orphans <em>p</em> in the packet tree and does nothing more; the safe pointers are left to manage the lifespan of <em>p</em> from here onwards.</p>
<p>C++ code should call <a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e" title="Either destroys or orphans the given packet, according to whether it has safe pointers that currently...">safeDelete()</a> instead of <code>delete</code> when it wishes to delete a packet, but there is a possibility that some external body (such as a python interpreter) still holds a reference to <em>p</em> and might still try to access it.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, since when called from python there will always be a safe pointer, and so this is equivalent to <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the packet to delete or orphan. It is safe to pass <code>null</code> (in which case this routine does nothing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e2f7f2c116c52b44aa9dcf092a87892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2f7f2c116c52b44aa9dcf092a87892">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format. </p>
<p>The XML file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>This is the preferred way of saving a Regina data file. Typically this will be called from the root of the packet tree, which will save the entire packet tree to file.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the pathname of the file to write to. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="ga898ec49e8d39c46cd965ad506493f2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898ec49e8d39c46cd965ad506493f2cc">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file. </p>
<p>The data file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the given output stream.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given stream is open for writing. </dd>
<dd>
The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the data was successfully written. </dd></dl>

</div>
</div>
<a id="gadfd869991cbf664891629f21a5432b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd869991cbf664891629f21a5432b02">&#9670;&nbsp;</a></span>setLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the label associated with this individual packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the new label to give this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf91bc951714dc60db12810affb266b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf91bc951714dc60db12810affb266b8a">&#9670;&nbsp;</a></span>sortChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::sortChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the immediate children of this packet according to their packet labels. </p>
<p>Note that this routine is not recursive (for instance, grandchildren will not be sorted within each child packet).</p>
<p>This routine takes quadratic time in the number of immediate children (and it's slow quadratic at that). </p>

</div>
</div>
<a id="ga552be006cf9fe432a6a678aed7f4c6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552be006cf9fe432a6a678aed7f4c6ac">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a past-the-end iterator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself. </dd></dl>

</div>
</div>
<a id="gaf619ec7a62275a926a723c015a386420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf619ec7a62275a926a723c015a386420">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself. </dd></dl>

</div>
</div>
<a id="gad6ee02a48a9c4be604e85e49da97ed6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6ee02a48a9c4be604e85e49da97ed6b">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>subtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the first packet within the given subtree. </p>
<p>Dereferencing this iterator will return <em>subtree</em> itself.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td>the packet subtree that we are iterating through. This does not need to be the root of the overall packet tree (i.e., <em>subtree</em> is allowed to have a non-null parent). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7ecbf7b86f80e45347fdbd67cd40884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7ecbf7b86f80e45347fdbd67cd40884">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the given packet within the given subtree. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td>the packet subtree that we are iterating through. This does not need to be the root of the overall packet tree (i.e., <em>subtree</em> is allowed to have a non-null parent). </td></tr>
    <tr><td class="paramname">current</td><td>the packet within the subtree that the new iterator should point to, or 0 if the new iterator should be past-the-end. If <em>current</em> is not null, then it must be equal to or a descendant of <em>subtree</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga765186c1742fe402922433b77e5f439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765186c1742fe402922433b77e5f439a">&#9670;&nbsp;</a></span>swapWithNextSibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::swapWithNextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps this packet with its next sibling in the sequence of children beneath their common parent packet. </p>
<p>Calling this routine is equivalent to calling <a class="el" href="group__packet.html#ga59adc13b6143cf994779796077aed731" title="Moves this packet the given number of steps towards the end of its sibling list.">moveDown()</a>.</p>
<p>This routine takes small constant time.</p>
<p>If this packet has no next sibling then this routine does nothing. </p>

</div>
</div>
<a id="ga06d41356ff086d078b04f34919aac26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d41356ff086d078b04f34919aac26d">&#9670;&nbsp;</a></span>tags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::Packet::tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set of all tags associated with this packet. </dd></dl>

</div>
</div>
<a id="ga60fe568711de8246572dc6ec376361df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60fe568711de8246572dc6ec376361df">&#9670;&nbsp;</a></span>tags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::PacketShell::tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet. </p>
<p>See <a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d" title="Returns the set of all tags associated with this packet.">Packet::tags()</a> for further details on packet tags.</p>
<p>The reference that is returned should be only used as a temporary, since the underlying packet (and therefore the set that is referenced) is in the process of being destroyed.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set of all tags associated with this packet. </dd></dl>

</div>
</div>
<a id="gae2519c2dac8e039b7acd5df8373c608d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2519c2dac8e039b7acd5df8373c608d">&#9670;&nbsp;</a></span>totalTreeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::totalTreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the total number of packets in the tree or subtree for which this packet is matriarch. </p>
<p>This packet is included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total tree or subtree size. </dd></dl>

</div>
</div>
<a id="ga27ce736503ede9e8c57fb5d169e6414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27ce736503ede9e8c57fb5d169e6414f">&#9670;&nbsp;</a></span>transferChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::transferChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead. </p>
<p>The children of this packet will be appended to the end of the new parent's child list, in the same order as they were previously.</p>
<p>This is equivalent to calling <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> on each child, but should be somewhat faster if there are many children to move.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None of the children of this packet depend on their current parent; see <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent beneath which the children will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11e183185ea0a33e67e2574fc93c7469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e183185ea0a33e67e2574fc93c7469">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::Packet::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet. </p>
<p>This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type ID. </dd></dl>

</div>
</div>
<a id="ga787a09ec531988778fcfb0bc87effdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga787a09ec531988778fcfb0bc87effdd4">&#9670;&nbsp;</a></span>typeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string regina::Packet::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet. </p>
<p>An example is <code>Triangulation3</code>. This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type name. </dd></dl>

</div>
</div>
<a id="gae71b40cd2416de174bba61db2ec92f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae71b40cd2416de174bba61db2ec92f1d">&#9670;&nbsp;</a></span>unlisten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::unlisten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters the given packet listener so that it no longer listens for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully unregistered, or <code>false</code> if the given listener was not registered in the first place. </dd></dl>

</div>
</div>
<a id="ga88fd0a82cc44c243e1f3d4041b86792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88fd0a82cc44c243e1f3d4041b86792a">&#9670;&nbsp;</a></span>unregisterFromAllPackets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::unregisterFromAllPackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters this listener from any packets to which it is currently listening. </p>

</div>
</div>
<a id="ga044a5c8d80d5aeb0e13a335bfc9b4ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1Link.html#a58309b754fc2392ea83ee63c77a961b8">regina::Link</a>, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#af07da75247cb831ad93b1b5cd865d598">regina::SnapPeaTriangulation</a>, <a class="el" href="classregina_1_1SurfaceFilterProperties.html#a7c50e18076483d95864ad345650d2888">regina::SurfaceFilterProperties</a>, <a class="el" href="classregina_1_1NormalSurfaces.html#ad07dcdec28b20348705f8cec15838957">regina::NormalSurfaces</a>, <a class="el" href="classregina_1_1Triangulation.html#ab333a00e997d1ce0b0fecdc8688d4578">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="classregina_1_1Triangulation.html#ab333a00e997d1ce0b0fecdc8688d4578">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="classregina_1_1SurfaceFilterCombination.html#a151cff12a4c85a04fd8e5d7f617a90f0">regina::SurfaceFilterCombination</a>, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a0e3c9276224681ca932912e989485266">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="classregina_1_1Script.html#acde4bee19f71a36759d51e1939a1a841">regina::Script</a>, <a class="el" href="classregina_1_1NormalHypersurfaces.html#a938dd8acfd2cdab2f6854305bbae4c97">regina::NormalHypersurfaces</a>, <a class="el" href="classregina_1_1AngleStructures.html#a12c0c8c9b7bb190f32e48573b4299de4">regina::AngleStructures</a>, <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a5c1649cc8c94d07193c81a55ffd76120">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="classregina_1_1Triangulation_3_012_01_4.html#a0f6866e00e66265effb4cdc4e9e4eda8">regina::Triangulation&lt; 2 &gt;</a>, and <a class="el" href="classregina_1_1Text.html#afe65a9b4b9fc9430a6b161bae995f024">regina::Text</a>.</p>

</div>
</div>
<a id="ga54930e66829e2b832b2b8d5b6813e55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54930e66829e2b832b2b8d5b6813e55d">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Packet::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classregina_1_1Link.html#a645147f6f603066ea0eb85a8d0978578">regina::Link</a>, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#a97281c7fda7388050d52d3450b83d195">regina::SnapPeaTriangulation</a>, <a class="el" href="classregina_1_1NormalSurfaces.html#a6801fb032b55c800bb82e89fce2bbe71">regina::NormalSurfaces</a>, <a class="el" href="classregina_1_1Triangulation.html#ac16b56b45355b0e5b78d64d0b4415dd5">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="classregina_1_1Triangulation.html#ac16b56b45355b0e5b78d64d0b4415dd5">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#af5d26032c0c2af5a7c9f931df93edaed">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="classregina_1_1Script.html#a161bba5734a7675ae64dee54b8fd07ef">regina::Script</a>, <a class="el" href="classregina_1_1NormalHypersurfaces.html#a3f0bf074f42a0da5e565bb79831d6d30">regina::NormalHypersurfaces</a>, <a class="el" href="classregina_1_1SurfaceFilter.html#af9ec7fe3b0c83880fc4d8bde58853cae">regina::SurfaceFilter</a>, <a class="el" href="classregina_1_1PDF.html#afbb9f8c4de7a10db3ad24d0adb463d2d">regina::PDF</a>, <a class="el" href="classregina_1_1AngleStructures.html#a125b651b08f8aa07d79f450a6f29ff7d">regina::AngleStructures</a>, <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a53da06903ab0b18888259626b947adcf">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="classregina_1_1Triangulation_3_012_01_4.html#a7c34d61039e1c28d575815f4b90c0daf">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="classregina_1_1Text.html#a0b5ade64bc08041b7bdf135ae6e65f16">regina::Text</a>, and <a class="el" href="classregina_1_1Container.html#a0ab175cd8a5430641393166c9d6ff0d8">regina::Container</a>.</p>

</div>
</div>
<a id="ga0bf681a968d890cd848f1277ea22ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf681a968d890cd848f1277ea22ea0f">&#9670;&nbsp;</a></span>writeXMLFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format. </p>
<p>Ths is similar to calling <a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a>, except that (i) the user has a more flexible choice of output stream, and (ii) the XML will always be written in plain text (i.e., it will not be compressed).</p>
<p>If you simply wish to save your data to a file on the filesystem, you should call <a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a> instead.</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the output stream.</p>
<p>The output from this routine cannot be used as a piece of an XML file; it must be the entire XML file. For a piece of an XML file, see routine <a class="el" href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54" title="Writes a chunk of XML containing the subtree with this packet as matriarch.">writeXMLPacketTree()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend upon its parent.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> is not present; instead the XML data is written to standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML data file should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7efec42b4c85d5590a07a0184bb3b0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7efec42b4c85d5590a07a0184bb3b0ec">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Packet::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classregina_1_1Link.html#a4df95452d2c6fdd8ec754c5adbaf9505">regina::Link</a>, <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a3951498021127cad3b20bb1e1c415809">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="classregina_1_1SnapPeaTriangulation.html#ac22f69e3264630bc043c69d97921a316">regina::SnapPeaTriangulation</a>, <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#af9229ac59708fe4332b37eae95760bd4">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="classregina_1_1NormalSurfaces.html#aa5539ec7f016ba2e9fca94f00971f4c3">regina::NormalSurfaces</a>, <a class="el" href="classregina_1_1NormalHypersurfaces.html#af3d6b7be21b48e6ed50652634a85fcac">regina::NormalHypersurfaces</a>, <a class="el" href="classregina_1_1Triangulation_3_012_01_4.html#acadc8156422f519fc0747dbf9afee9a1">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="classregina_1_1Triangulation.html#a959254d7310092ce115f5ff90529aceb">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="classregina_1_1Triangulation.html#a959254d7310092ce115f5ff90529aceb">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="classregina_1_1Script.html#ac09bcb96ff3f280e15400bda3afb2d45">regina::Script</a>, <a class="el" href="classregina_1_1SurfaceFilter.html#ae94055c65c176f663111268c8f8de9d4">regina::SurfaceFilter</a>, <a class="el" href="classregina_1_1PDF.html#aab128672dc3fe2d6aee4674c16cdb6a6">regina::PDF</a>, <a class="el" href="classregina_1_1AngleStructures.html#afe639ef03c5af712afaae0b602dab37f">regina::AngleStructures</a>, <a class="el" href="classregina_1_1Text.html#a081c43ec9110be27b224f430c4212861">regina::Text</a>, and <a class="el" href="classregina_1_1Container.html#a913d6a5436e25a67c22d751167966b6f">regina::Container</a>.</p>

</div>
</div>
<a id="ga690d1f04ae42ab3778726d37fbd0fe54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga690d1f04ae42ab3778726d37fbd0fe54">&#9670;&nbsp;</a></span>writeXMLPacketTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLPacketTree </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the subtree with this packet as matriarch. </p>
<p>This is the preferred way of writing a packet tree to file.</p>
<p>The output from this routine is only a piece of XML; it should not be used as a complete XML file. For a complete XML file, see routine <a class="el" href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f" title="Writes the subtree rooted at this packet to the given output stream in Regina&#39;s native XML file forma...">writeXMLFile()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f48a115e3ad5912a038c8d00900eae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f48a115e3ad5912a038c8d00900eae1">&#9670;&nbsp;</a></span>xmlReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a>* regina::Packet::xmlReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created XML element reader that will read the contents of a single XML packet element. </p>
<p>You may assume that the packet to be read is of the same type as the class in which you are implementing this routine.</p>
<p>The XML element reader should read exactly what <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec" title="Writes a chunk of XML containing the data for this packet only.">writeXMLPacketData()</a> writes, and vice versa.</p>
<p><em>parent</em> represents the packet which will become the new packet's parent in the tree structure, and may be assumed to have already been read from the file. This information is for reference only, and does not need to be used. The XML element reader can either insert or not insert the new packet beneath <em>parent</em> in the tree structure as it pleases. Note however that <em>parent</em> will be 0 if the new packet is to become a tree matriarch.</p>
<p>If the new packet needs to store pointers to other packets that might not have been read yet (such as a script packet that needs pointers to its variables), then it should queue a new <a class="el" href="classregina_1_1XMLTreeResolutionTask.html" title="An individual task for resolving dangling packet references after an XML data file has been read.">XMLTreeResolutionTask</a> to the given <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a>. After the complete data file has been read, <a class="el" href="classregina_1_1XMLTreeResolver.html#a6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">XMLTreeResolver::resolve()</a> will run all of its queued tasks, at which point the new packet can resolve any dangling references.</p>
<p>This routine is not actually provided for <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself, but must be declared and implemented for every packet subclass that will be instantiated.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the packet which will become the new packet's parent in the tree structure, or 0 if the new packet is to be tree matriarch. </td></tr>
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created XML element reader. </dd></dl>

</div>
</div>
<a id="ga90b86447dbb2a828673adb6b5c508d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90b86447dbb2a828673adb6b5c508d34">&#9670;&nbsp;</a></span>~ChangeEventSpan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Packet::ChangeEventSpan::~ChangeEventSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this change event object. </p>
<p>If this is the only <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a> currently in existence for the given packet, this destructor will call <a class="el" href="group__packet.html#ga113b2c051046b67870da4a4953422438" title="Called after the contents of the packet have been changed.">PacketListener::packetWasChanged()</a> for all registered listeners for the given packet. </p>

</div>
</div>
<a id="gad5fc332c4380895ff045b21025703b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5fc332c4380895ff045b21025703b16">&#9670;&nbsp;</a></span>~Packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::Packet::~Packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor that also orphans this packet and destroys all of its descendants. </p>
<p>This destructor calls <a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e" title="Either destroys or orphans the given packet, according to whether it has safe pointers that currently...">safeDelete()</a> on its descendants. Therefore, if any descendants have safe pointers that reference them, those descendants will remain orphaned but alive (and their lifespans will now be managed by <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> instead). See <a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e" title="Either destroys or orphans the given packet, according to whether it has safe pointers that currently...">safeDelete()</a> for details. </p>

</div>
</div>
<a id="gabd98cb9168c4333925f340e5f7310423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd98cb9168c4333925f340e5f7310423">&#9670;&nbsp;</a></span>~PacketListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::PacketListener::~PacketListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this listener. </p>
<p>This listener will be unregistered from any packets to which it is currently listening. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga455ca759888786ae6bf7be5fb0b65236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455ca759888786ae6bf7be5fb0b65236">&#9670;&nbsp;</a></span>PACKET_ANGLESTRUCTURELIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_ANGLESTRUCTURELIST = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9">PACKET_ANGLESTRUCTURES</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_ANGLESTRUCTURES. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000091">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_ANGLESTRUCTURES. </dd></dl>

</div>
</div>
<a id="ga05f45d5e55b081a0ada789479ed34f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05f45d5e55b081a0ada789479ed34f6c">&#9670;&nbsp;</a></span>PACKET_DIM2TRIANGULATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_DIM2TRIANGULATION = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815">PACKET_TRIANGULATION2</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_TRIANGULATION2. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000094">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_TRIANGULATION2. </dd></dl>

</div>
</div>
<a id="ga63030f7812e66bd10741a6186c542c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63030f7812e66bd10741a6186c542c96">&#9670;&nbsp;</a></span>PACKET_DIM4TRIANGULATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_DIM4TRIANGULATION = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff">PACKET_TRIANGULATION4</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_TRIANGULATION4. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_TRIANGULATION4. </dd></dl>

</div>
</div>
<a id="ga5161f01c333fa03786d0bb40b6f68580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5161f01c333fa03786d0bb40b6f68580">&#9670;&nbsp;</a></span>PACKET_NORMALHYPERSURFACELIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_NORMALHYPERSURFACELIST = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e">PACKET_NORMALHYPERSURFACES</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_NORMALHYPERSURFACES. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_NORMALHYPERSURFACES. </dd></dl>

</div>
</div>
<a id="ga46ee82ab98a53118996b1b0ef1be1c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46ee82ab98a53118996b1b0ef1be1c1a">&#9670;&nbsp;</a></span>PACKET_NORMALSURFACELIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_NORMALSURFACELIST = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc">PACKET_NORMALSURFACES</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_NORMALSURFACES. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000090">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_NORMALSURFACES. </dd></dl>

</div>
</div>
<a id="ga1bc5e3b33bf3a5ac165b99b9956b284e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc5e3b33bf3a5ac165b99b9956b284e">&#9670;&nbsp;</a></span>PACKET_TRIANGULATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_TRIANGULATION = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64">PACKET_TRIANGULATION3</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_TRIANGULATION3. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000089">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_TRIANGULATION3. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="gae51cb555166657e5996a76768db998e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51cb555166657e5996a76768db998e3">&#9670;&nbsp;</a></span>Packet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classregina_1_1Packet.html">Packet</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow packets to automatically deregister listeners as they are destroyed. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
