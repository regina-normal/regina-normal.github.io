<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Basic Packet Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Basic Packet Types</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> administration and some basic packet types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Container.html">regina::Container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that simply contains other packets.  <a href="classregina_1_1Container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1PacketInfo.html">regina::PacketInfo&lt; packetType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular type of packet.  <a href="structregina_1_1PacketInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html">regina::Packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a packet of information that may be individually edited or operated upon.  <a href="classregina_1_1Packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">regina::Packet::ChangeEventSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that facilitates firing packetToBeChanged() and packetWasChanged() events.  <a href="classregina_1_1Packet_1_1ChangeEventSpan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1ChildIterator.html">regina::ChildIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator for iterating through all immediate children of a given packet.  <a href="classregina_1_1ChildIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SubtreeIterator.html">regina::SubtreeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator for iterating through the entire packet subtree rooted at a given packet.  <a href="classregina_1_1SubtreeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketChildren.html">regina::PacketChildren</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight object that gives access to all immediate children of a given packet.  <a href="classregina_1_1PacketChildren.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketDescendants.html">regina::PacketDescendants</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A lightweight object that gives access to all strict descendants of a given packet.  <a href="classregina_1_1PacketDescendants.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketShell.html">regina::PacketShell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives access to the final remains of a packet that is in the process of being destroyed.  <a href="classregina_1_1PacketShell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PacketListener.html">regina::PacketListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object that can be registered to listen for packet events.  <a href="classregina_1_1PacketListener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1ChildIterator_01_4.html">std::iterator_traits&lt; regina::ChildIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1SubtreeIterator_01_4.html">std::iterator_traits&lt; regina::SubtreeIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1PDF.html">regina::PDF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that can hold a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document.  <a href="classregina_1_1PDF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Script.html">regina::Script</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a Python script that can be run.  <a href="classregina_1_1Script.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Text.html">regina::Text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a text string.  <a href="classregina_1_1Text.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLPacketReader.html">regina::XMLPacketReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads the data for an individual packet.  <a href="classregina_1_1XMLPacketReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLContainerReader.html">regina::XMLContainerReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single container.  <a href="classregina_1_1XMLContainerReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLPDFReader.html">regina::XMLPDFReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet.  <a href="classregina_1_1XMLPDFReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLScriptReader.html">regina::XMLScriptReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single script.  <a href="classregina_1_1XMLScriptReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTextReader.html">regina::XMLTextReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single text packet.  <a href="classregina_1_1XMLTextReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolutionTask.html">regina::XMLTreeResolutionTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An individual task for resolving dangling packet references after an XML data file has been read.  <a href="classregina_1_1XMLTreeResolutionTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLTreeResolver.html">regina::XMLTreeResolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a mechanism to resolve dangling packet references after a complete packet tree has been read from an XML data file.  <a href="classregina_1_1XMLTreeResolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaad9d413dab5c36f4a57d9ca811d24188"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaad9d413dab5c36f4a57d9ca811d24188">REGINA_PACKET</a>(class_,  id)</td></tr>
<tr class="memdesc:gaad9d413dab5c36f4a57d9ca811d24188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a subclass of Packet.  <a href="group__packet.html#gaad9d413dab5c36f4a57d9ca811d24188">More...</a><br /></td></tr>
<tr class="separator:gaad9d413dab5c36f4a57d9ca811d24188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b8ff3226c3356a8b73c5e46f64c268"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad7b8ff3226c3356a8b73c5e46f64c268">REGINA_PACKET_FROM</a>(class_,  helper)</td></tr>
<tr class="memdesc:gad7b8ff3226c3356a8b73c5e46f64c268"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternative to REGINA_PACKET, for scenarios where the relevant PacketInfo specialisation is not visible.  <a href="group__packet.html#gad7b8ff3226c3356a8b73c5e46f64c268">More...</a><br /></td></tr>
<tr class="separator:gad7b8ff3226c3356a8b73c5e46f64c268"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4dc907cfee17707d1409b1b4e499247c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Container.html">Container</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4dc907cfee17707d1409b1b4e499247c">regina::NContainer</a></td></tr>
<tr class="memdesc:ga4dc907cfee17707d1409b1b4e499247c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga4dc907cfee17707d1409b1b4e499247c">More...</a><br /></td></tr>
<tr class="separator:ga4dc907cfee17707d1409b1b4e499247c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f47ede3cd04a3b515ae8e375497a987"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4f47ede3cd04a3b515ae8e375497a987">regina::NPacket</a></td></tr>
<tr class="memdesc:ga4f47ede3cd04a3b515ae8e375497a987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga4f47ede3cd04a3b515ae8e375497a987">More...</a><br /></td></tr>
<tr class="separator:ga4f47ede3cd04a3b515ae8e375497a987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58067e865d029237d3a1e0e8c39cf29f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga58067e865d029237d3a1e0e8c39cf29f">regina::NPacketListener</a></td></tr>
<tr class="memdesc:ga58067e865d029237d3a1e0e8c39cf29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga58067e865d029237d3a1e0e8c39cf29f">More...</a><br /></td></tr>
<tr class="separator:ga58067e865d029237d3a1e0e8c39cf29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9664a85a1d1ae1165ed9461e7df5704b"><td class="memItemLeft" align="right" valign="top"><a id="ga9664a85a1d1ae1165ed9461e7df5704b"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::difference_type</b></td></tr>
<tr class="separator:ga9664a85a1d1ae1165ed9461e7df5704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26340bf5ba05d0ce4b003c0ad20e3e2"><td class="memItemLeft" align="right" valign="top"><a id="gab26340bf5ba05d0ce4b003c0ad20e3e2"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::value_type</b></td></tr>
<tr class="separator:gab26340bf5ba05d0ce4b003c0ad20e3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6924e98617da13c933b796fa829c339"><td class="memItemLeft" align="right" valign="top"><a id="gad6924e98617da13c933b796fa829c339"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::pointer_type</b></td></tr>
<tr class="separator:gad6924e98617da13c933b796fa829c339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a9df945108d4d53a777d6c011037d7"><td class="memItemLeft" align="right" valign="top"><a id="ga00a9df945108d4d53a777d6c011037d7"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::reference_type</b></td></tr>
<tr class="separator:ga00a9df945108d4d53a777d6c011037d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad64b892b52e0b7c44762ba72173f9084"><td class="memItemLeft" align="right" valign="top"><a id="gad64b892b52e0b7c44762ba72173f9084"></a>
typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::ChildIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:gad64b892b52e0b7c44762ba72173f9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad698b8e3feb3660efb36ef0d137d2f13"><td class="memItemLeft" align="right" valign="top"><a id="gad698b8e3feb3660efb36ef0d137d2f13"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::difference_type</b></td></tr>
<tr class="separator:gad698b8e3feb3660efb36ef0d137d2f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0b76a2867102b58353a7a4ac8f817f"><td class="memItemLeft" align="right" valign="top"><a id="ga9f0b76a2867102b58353a7a4ac8f817f"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::value_type</b></td></tr>
<tr class="separator:ga9f0b76a2867102b58353a7a4ac8f817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a939ea8b7ac3b914b2364b5c701176"><td class="memItemLeft" align="right" valign="top"><a id="ga71a939ea8b7ac3b914b2364b5c701176"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::pointer_type</b></td></tr>
<tr class="separator:ga71a939ea8b7ac3b914b2364b5c701176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad477029282973ced54520f9ef77b5b42"><td class="memItemLeft" align="right" valign="top"><a id="gad477029282973ced54520f9ef77b5b42"></a>
typedef <a class="el" href="classregina_1_1Packet.html">regina::Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::reference_type</b></td></tr>
<tr class="separator:gad477029282973ced54520f9ef77b5b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58050469406661228f9d14e8345ffcc7"><td class="memItemLeft" align="right" valign="top"><a id="ga58050469406661228f9d14e8345ffcc7"></a>
typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::SubtreeIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:ga58050469406661228f9d14e8345ffcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4467bfb4bc172da71964a4b9967a04d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1PDF.html">PDF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad4467bfb4bc172da71964a4b9967a04d">regina::NPDF</a></td></tr>
<tr class="memdesc:gad4467bfb4bc172da71964a4b9967a04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#gad4467bfb4bc172da71964a4b9967a04d">More...</a><br /></td></tr>
<tr class="separator:gad4467bfb4bc172da71964a4b9967a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80158507a6960da75b1f1c2c35d90148"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Script.html">Script</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga80158507a6960da75b1f1c2c35d90148">regina::NScript</a></td></tr>
<tr class="memdesc:ga80158507a6960da75b1f1c2c35d90148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga80158507a6960da75b1f1c2c35d90148">More...</a><br /></td></tr>
<tr class="separator:ga80158507a6960da75b1f1c2c35d90148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9581a76573ed62ddcd1623ae4963b72d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Text.html">Text</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9581a76573ed62ddcd1623ae4963b72d">regina::NText</a></td></tr>
<tr class="memdesc:ga9581a76573ed62ddcd1623ae4963b72d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__packet.html#ga9581a76573ed62ddcd1623ae4963b72d">More...</a><br /></td></tr>
<tr class="separator:ga9581a76573ed62ddcd1623ae4963b72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bcdb1301b1f56d445352a56fc9973fb"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::string, <a class="el" href="classregina_1_1Packet.html">Packet</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9bcdb1301b1f56d445352a56fc9973fb">regina::XMLTreeResolver::IDMap</a></td></tr>
<tr class="memdesc:ga9bcdb1301b1f56d445352a56fc9973fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that maps internal IDs from the data file to the corresponding packets.  <a href="group__packet.html#ga9bcdb1301b1f56d445352a56fc9973fb">More...</a><br /></td></tr>
<tr class="separator:ga9bcdb1301b1f56d445352a56fc9973fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga982f45957b093a38120119066dc4cfef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">regina::PacketType</a> { <br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefabc7680a0895a0d0540123f9e0596b38e">regina::PACKET_CONTAINER</a> = 1
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa54ede7ca089949c83b103489c1c3ad57">regina::PACKET_TEXT</a> = 2
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc">regina::PACKET_NORMALSURFACES</a> = 6
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa44f343e9e3b4baf3b53f8943a4503f6e">regina::PACKET_SCRIPT</a> = 7
, <br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa958e5099e4f7506590d6b351a9a889cf">regina::PACKET_SURFACEFILTER</a> = 8
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9">regina::PACKET_ANGLESTRUCTURES</a> = 9
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa346e59a436dacb0d10922334f9e002e1">regina::PACKET_PDF</a> = 10
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e">regina::PACKET_NORMALHYPERSURFACES</a> = 13
, <br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac0835064733eb9d41e9db904afde7240">regina::PACKET_SNAPPEATRIANGULATION</a> = 16
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefaa9042461f4df32b551cc9046f7d44f23">regina::PACKET_LINK</a> = 17
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815">regina::PACKET_TRIANGULATION2</a> = 15
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64">regina::PACKET_TRIANGULATION3</a> = 3
, <br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff">regina::PACKET_TRIANGULATION4</a> = 11
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefad6af6b9c7e211662703204551c8f0a6c">regina::PACKET_TRIANGULATION5</a> = 105
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac241be6e856f68161d4e217b49260596">regina::PACKET_TRIANGULATION6</a> = 106
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefae75828b18b7041a6602a41f61e900c4b">regina::PACKET_TRIANGULATION7</a> = 107
, <br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefadac8b650c87a395064f35d8dd7139174">regina::PACKET_TRIANGULATION8</a> = 108
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefaae3f65ac7e3e3b14c06e866e4732f04f">regina::PACKET_TRIANGULATION9</a> = 109
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa2e49b81db0006562994ba409db5fdbb2">regina::PACKET_TRIANGULATION10</a> = 110
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa8239b1c5322caeb818c5dd8f3fb78ae3">regina::PACKET_TRIANGULATION11</a> = 111
, <br />
&#160;&#160;<a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa9abc4fbf3b98a845481d2d6a651c730f">regina::PACKET_TRIANGULATION12</a> = 112
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa2a134929dda394ce55b128b661f68a9a">regina::PACKET_TRIANGULATION13</a> = 113
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa7984ac7306b6a4301565b5d154daddb0">regina::PACKET_TRIANGULATION14</a> = 114
, <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa0e5a2698ebebf778b6bc6209778cc3a3">regina::PACKET_TRIANGULATION15</a> = 115
<br />
 }</td></tr>
<tr class="memdesc:ga982f45957b093a38120119066dc4cfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the different types of packet that are available in Regina.  <a href="group__packet.html#ga982f45957b093a38120119066dc4cfef">More...</a><br /></td></tr>
<tr class="separator:ga982f45957b093a38120119066dc4cfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7c46c6bbb0cfe639525d1bf5700f2c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gabb7c46c6bbb0cfe639525d1bf5700f2c">regina::PDF::OwnershipPolicy</a> { <a class="el" href="group__packet.html#ggabb7c46c6bbb0cfe639525d1bf5700f2caaab665d8c167fe6d05be283e87199361">regina::PDF::OWN_MALLOC</a>
, <a class="el" href="group__packet.html#ggabb7c46c6bbb0cfe639525d1bf5700f2ca55bae618310250121649f4cf90ab4c8f">regina::PDF::OWN_NEW</a>
, <a class="el" href="group__packet.html#ggabb7c46c6bbb0cfe639525d1bf5700f2cad0a3996ebf3e955b1be0ebf0fff8e741">regina::PDF::DEEP_COPY</a>
 }</td></tr>
<tr class="memdesc:gabb7c46c6bbb0cfe639525d1bf5700f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes how a PDF packet should claim ownership of a block of binary data.  <a href="group__packet.html#gabb7c46c6bbb0cfe639525d1bf5700f2c">More...</a><br /></td></tr>
<tr class="separator:gabb7c46c6bbb0cfe639525d1bf5700f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga50387f979321ede9f79c1cd7fb15304a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga50387f979321ede9f79c1cd7fb15304a">regina::Container::Container</a> ()</td></tr>
<tr class="memdesc:ga50387f979321ede9f79c1cd7fb15304a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="group__packet.html#ga50387f979321ede9f79c1cd7fb15304a">More...</a><br /></td></tr>
<tr class="separator:ga50387f979321ede9f79c1cd7fb15304a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff5a19504faae584888652a659b45dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0ff5a19504faae584888652a659b45dc">regina::Container::Container</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:ga0ff5a19504faae584888652a659b45dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new container with the given packet label.  <a href="group__packet.html#ga0ff5a19504faae584888652a659b45dc">More...</a><br /></td></tr>
<tr class="separator:ga0ff5a19504faae584888652a659b45dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ab175cd8a5430641393166c9d6ff0d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0ab175cd8a5430641393166c9d6ff0d8">regina::Container::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga0ab175cd8a5430641393166c9d6ff0d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__packet.html#ga0ab175cd8a5430641393166c9d6ff0d8">More...</a><br /></td></tr>
<tr class="separator:ga0ab175cd8a5430641393166c9d6ff0d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaecfedb9a969d6d227f2f2e789e62473"><td class="memItemLeft" align="right" valign="top"><a id="gaaecfedb9a969d6d227f2f2e789e62473"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Container::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:gaaecfedb9a969d6d227f2f2e789e62473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56c1588e7b5f30f8c5b70047c2b70fdc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga56c1588e7b5f30f8c5b70047c2b70fdc">regina::Container::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga56c1588e7b5f30f8c5b70047c2b70fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__packet.html#ga56c1588e7b5f30f8c5b70047c2b70fdc">More...</a><br /></td></tr>
<tr class="separator:ga56c1588e7b5f30f8c5b70047c2b70fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca88e2d9f18a028110e0eff651c41db"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaaca88e2d9f18a028110e0eff651c41db">regina::Container::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:gaaca88e2d9f18a028110e0eff651c41db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__packet.html#gaaca88e2d9f18a028110e0eff651c41db">More...</a><br /></td></tr>
<tr class="separator:gaaca88e2d9f18a028110e0eff651c41db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913d6a5436e25a67c22d751167966b6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga913d6a5436e25a67c22d751167966b6f">regina::Container::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga913d6a5436e25a67c22d751167966b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__packet.html#ga913d6a5436e25a67c22d751167966b6f">More...</a><br /></td></tr>
<tr class="separator:ga913d6a5436e25a67c22d751167966b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga089c4f6e4b1989fe9c89653091e6321e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga089c4f6e4b1989fe9c89653091e6321e">regina::Packet::ChangeEventSpan::ChangeEventSpan</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga089c4f6e4b1989fe9c89653091e6321e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new change event object for the given packet.  <a href="group__packet.html#ga089c4f6e4b1989fe9c89653091e6321e">More...</a><br /></td></tr>
<tr class="separator:ga089c4f6e4b1989fe9c89653091e6321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b86447dbb2a828673adb6b5c508d34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga90b86447dbb2a828673adb6b5c508d34">regina::Packet::ChangeEventSpan::~ChangeEventSpan</a> ()</td></tr>
<tr class="memdesc:ga90b86447dbb2a828673adb6b5c508d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this change event object.  <a href="group__packet.html#ga90b86447dbb2a828673adb6b5c508d34">More...</a><br /></td></tr>
<tr class="separator:ga90b86447dbb2a828673adb6b5c508d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e37bb3d9744c191ee2085fab3a04a54"><td class="memItemLeft" align="right" valign="top"><a id="ga7e37bb3d9744c191ee2085fab3a04a54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::ChangeEventSpan::ChangeEventSpan</b> (const <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">ChangeEventSpan</a> &amp;)=delete</td></tr>
<tr class="separator:ga7e37bb3d9744c191ee2085fab3a04a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf313fb80913a92793db6aab9be5560"><td class="memItemLeft" align="right" valign="top"><a id="gaecf313fb80913a92793db6aab9be5560"></a>
<a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">ChangeEventSpan</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::ChangeEventSpan::operator=</b> (const <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html">ChangeEventSpan</a> &amp;)=delete</td></tr>
<tr class="separator:gaecf313fb80913a92793db6aab9be5560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga964a605603a33a84e5004e9ebb0ac5ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec">regina::open</a> (const char *filename)</td></tr>
<tr class="memdesc:ga964a605603a33a84e5004e9ebb0ac5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a Regina data file, and returns the corresponding packet tree.  <a href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec">More...</a><br /></td></tr>
<tr class="separator:ga964a605603a33a84e5004e9ebb0ac5ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53c0b54eaa7f029e0b0a13bb3c02675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae53c0b54eaa7f029e0b0a13bb3c02675">regina::open</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:gae53c0b54eaa7f029e0b0a13bb3c02675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a Regina data file from the given input stream, and returns the corresponding packet tree.  <a href="group__packet.html#gae53c0b54eaa7f029e0b0a13bb3c02675">More...</a><br /></td></tr>
<tr class="separator:gae53c0b54eaa7f029e0b0a13bb3c02675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad369e1b9117672269c40c2e1dc75b2d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad369e1b9117672269c40c2e1dc75b2d9">regina::ChildIterator::ChildIterator</a> ()</td></tr>
<tr class="memdesc:gad369e1b9117672269c40c2e1dc75b2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a past-the-end iterator.  <a href="group__packet.html#gad369e1b9117672269c40c2e1dc75b2d9">More...</a><br /></td></tr>
<tr class="separator:gad369e1b9117672269c40c2e1dc75b2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab25e416c2756416f8faff87583566422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab25e416c2756416f8faff87583566422">regina::ChildIterator::ChildIterator</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gab25e416c2756416f8faff87583566422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__packet.html#gab25e416c2756416f8faff87583566422">More...</a><br /></td></tr>
<tr class="separator:gab25e416c2756416f8faff87583566422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075232d3523eb9c5974eaf0ce2163489"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga075232d3523eb9c5974eaf0ce2163489">regina::ChildIterator::ChildIterator</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *current)</td></tr>
<tr class="memdesc:ga075232d3523eb9c5974eaf0ce2163489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the given child packet.  <a href="group__packet.html#ga075232d3523eb9c5974eaf0ce2163489">More...</a><br /></td></tr>
<tr class="separator:ga075232d3523eb9c5974eaf0ce2163489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345ff5809b12d36f7ce53d81ebfcc4bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga345ff5809b12d36f7ce53d81ebfcc4bb">regina::ChildIterator::operator=</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga345ff5809b12d36f7ce53d81ebfcc4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="group__packet.html#ga345ff5809b12d36f7ce53d81ebfcc4bb">More...</a><br /></td></tr>
<tr class="separator:ga345ff5809b12d36f7ce53d81ebfcc4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a305d83c114887ce6c5bbce98aaaa64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8a305d83c114887ce6c5bbce98aaaa64">regina::ChildIterator::operator==</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga8a305d83c114887ce6c5bbce98aaaa64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="group__packet.html#ga8a305d83c114887ce6c5bbce98aaaa64">More...</a><br /></td></tr>
<tr class="separator:ga8a305d83c114887ce6c5bbce98aaaa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9eb1a069f3b0bcad8ebc1e663b0cb89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae9eb1a069f3b0bcad8ebc1e663b0cb89">regina::ChildIterator::operator!=</a> (const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gae9eb1a069f3b0bcad8ebc1e663b0cb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="group__packet.html#gae9eb1a069f3b0bcad8ebc1e663b0cb89">More...</a><br /></td></tr>
<tr class="separator:gae9eb1a069f3b0bcad8ebc1e663b0cb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e515b2ba38eba36cf621598447bfad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6e515b2ba38eba36cf621598447bfad6">regina::ChildIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga6e515b2ba38eba36cf621598447bfad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="group__packet.html#ga6e515b2ba38eba36cf621598447bfad6">More...</a><br /></td></tr>
<tr class="separator:ga6e515b2ba38eba36cf621598447bfad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8d33346fee85e3a0ccb4fb8e94e437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafc8d33346fee85e3a0ccb4fb8e94e437">regina::ChildIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:gafc8d33346fee85e3a0ccb4fb8e94e437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="group__packet.html#gafc8d33346fee85e3a0ccb4fb8e94e437">More...</a><br /></td></tr>
<tr class="separator:gafc8d33346fee85e3a0ccb4fb8e94e437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8bfb09c35881fc4804ea909dd878683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa8bfb09c35881fc4804ea909dd878683">regina::ChildIterator::operator*</a> () const</td></tr>
<tr class="memdesc:gaa8bfb09c35881fc4804ea909dd878683"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to.  <a href="group__packet.html#gaa8bfb09c35881fc4804ea909dd878683">More...</a><br /></td></tr>
<tr class="separator:gaa8bfb09c35881fc4804ea909dd878683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga552be006cf9fe432a6a678aed7f4c6ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga552be006cf9fe432a6a678aed7f4c6ac">regina::SubtreeIterator::SubtreeIterator</a> ()</td></tr>
<tr class="memdesc:ga552be006cf9fe432a6a678aed7f4c6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a past-the-end iterator.  <a href="group__packet.html#ga552be006cf9fe432a6a678aed7f4c6ac">More...</a><br /></td></tr>
<tr class="separator:ga552be006cf9fe432a6a678aed7f4c6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf619ec7a62275a926a723c015a386420"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf619ec7a62275a926a723c015a386420">regina::SubtreeIterator::SubtreeIterator</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gaf619ec7a62275a926a723c015a386420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__packet.html#gaf619ec7a62275a926a723c015a386420">More...</a><br /></td></tr>
<tr class="separator:gaf619ec7a62275a926a723c015a386420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ee02a48a9c4be604e85e49da97ed6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad6ee02a48a9c4be604e85e49da97ed6b">regina::SubtreeIterator::SubtreeIterator</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *subtree)</td></tr>
<tr class="memdesc:gad6ee02a48a9c4be604e85e49da97ed6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the first packet within the given subtree.  <a href="group__packet.html#gad6ee02a48a9c4be604e85e49da97ed6b">More...</a><br /></td></tr>
<tr class="separator:gad6ee02a48a9c4be604e85e49da97ed6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7ecbf7b86f80e45347fdbd67cd40884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf7ecbf7b86f80e45347fdbd67cd40884">regina::SubtreeIterator::SubtreeIterator</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *subtree, <a class="el" href="classregina_1_1Packet.html">Packet</a> *current)</td></tr>
<tr class="memdesc:gaf7ecbf7b86f80e45347fdbd67cd40884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the given packet within the given subtree.  <a href="group__packet.html#gaf7ecbf7b86f80e45347fdbd67cd40884">More...</a><br /></td></tr>
<tr class="separator:gaf7ecbf7b86f80e45347fdbd67cd40884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962997e07b8aa25d5b7a44ac4922d28e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga962997e07b8aa25d5b7a44ac4922d28e">regina::SubtreeIterator::operator=</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga962997e07b8aa25d5b7a44ac4922d28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="group__packet.html#ga962997e07b8aa25d5b7a44ac4922d28e">More...</a><br /></td></tr>
<tr class="separator:ga962997e07b8aa25d5b7a44ac4922d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa098cbbe41b9f6fba63297e915fa8992"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa098cbbe41b9f6fba63297e915fa8992">regina::SubtreeIterator::operator==</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:gaa098cbbe41b9f6fba63297e915fa8992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are equal.  <a href="group__packet.html#gaa098cbbe41b9f6fba63297e915fa8992">More...</a><br /></td></tr>
<tr class="separator:gaa098cbbe41b9f6fba63297e915fa8992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7473f5829b6a5d777ef62fc8d0b6a8b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7473f5829b6a5d777ef62fc8d0b6a8b3">regina::SubtreeIterator::operator!=</a> (const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ga7473f5829b6a5d777ef62fc8d0b6a8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given iterator are different.  <a href="group__packet.html#ga7473f5829b6a5d777ef62fc8d0b6a8b3">More...</a><br /></td></tr>
<tr class="separator:ga7473f5829b6a5d777ef62fc8d0b6a8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga130eb896f8e699b159d2c124d774f7b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga130eb896f8e699b159d2c124d774f7b1">regina::SubtreeIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga130eb896f8e699b159d2c124d774f7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="group__packet.html#ga130eb896f8e699b159d2c124d774f7b1">More...</a><br /></td></tr>
<tr class="separator:ga130eb896f8e699b159d2c124d774f7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1010344f9ccca0551bb80f0a5966cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad1010344f9ccca0551bb80f0a5966cf2">regina::SubtreeIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:gad1010344f9ccca0551bb80f0a5966cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="group__packet.html#gad1010344f9ccca0551bb80f0a5966cf2">More...</a><br /></td></tr>
<tr class="separator:gad1010344f9ccca0551bb80f0a5966cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537960c97e4cb7162da330c892115f55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga537960c97e4cb7162da330c892115f55">regina::SubtreeIterator::operator*</a> () const</td></tr>
<tr class="memdesc:ga537960c97e4cb7162da330c892115f55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to.  <a href="group__packet.html#ga537960c97e4cb7162da330c892115f55">More...</a><br /></td></tr>
<tr class="separator:ga537960c97e4cb7162da330c892115f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1deebd4b4c4c3b685b017386b4b6f8e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga1deebd4b4c4c3b685b017386b4b6f8e0">regina::PacketChildren::PacketChildren</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:ga1deebd4b4c4c3b685b017386b4b6f8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__packet.html#ga1deebd4b4c4c3b685b017386b4b6f8e0">More...</a><br /></td></tr>
<tr class="separator:ga1deebd4b4c4c3b685b017386b4b6f8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a3bc3386708cc7a52859df12f0b34e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga1a3bc3386708cc7a52859df12f0b34e0">regina::PacketChildren::PacketChildren</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *parent)</td></tr>
<tr class="memdesc:ga1a3bc3386708cc7a52859df12f0b34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the immediate children of the given packet.  <a href="group__packet.html#ga1a3bc3386708cc7a52859df12f0b34e0">More...</a><br /></td></tr>
<tr class="separator:ga1a3bc3386708cc7a52859df12f0b34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef24629212c08d93d4171816488e597"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4ef24629212c08d93d4171816488e597">regina::PacketChildren::operator=</a> (const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;)=default</td></tr>
<tr class="memdesc:ga4ef24629212c08d93d4171816488e597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="group__packet.html#ga4ef24629212c08d93d4171816488e597">More...</a><br /></td></tr>
<tr class="separator:ga4ef24629212c08d93d4171816488e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e5ca15289b85b0630d07ac1da20c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac7e5ca15289b85b0630d07ac1da20c84">regina::PacketChildren::begin</a> () const</td></tr>
<tr class="memdesc:gac7e5ca15289b85b0630d07ac1da20c84"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of children.  <a href="group__packet.html#gac7e5ca15289b85b0630d07ac1da20c84">More...</a><br /></td></tr>
<tr class="separator:gac7e5ca15289b85b0630d07ac1da20c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f68310c44da3f5f260b04a49694ea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga09f68310c44da3f5f260b04a49694ea2">regina::PacketChildren::end</a> () const</td></tr>
<tr class="memdesc:ga09f68310c44da3f5f260b04a49694ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of children.  <a href="group__packet.html#ga09f68310c44da3f5f260b04a49694ea2">More...</a><br /></td></tr>
<tr class="separator:ga09f68310c44da3f5f260b04a49694ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbbafcb328346116b72f1cb2f41b02c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaecbbafcb328346116b72f1cb2f41b02c">regina::PacketDescendants::PacketDescendants</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;)=default</td></tr>
<tr class="memdesc:gaecbbafcb328346116b72f1cb2f41b02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__packet.html#gaecbbafcb328346116b72f1cb2f41b02c">More...</a><br /></td></tr>
<tr class="separator:gaecbbafcb328346116b72f1cb2f41b02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3349803a6192301ffccc708dcf7c8efa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga3349803a6192301ffccc708dcf7c8efa">regina::PacketDescendants::PacketDescendants</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *subtree)</td></tr>
<tr class="memdesc:ga3349803a6192301ffccc708dcf7c8efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new object for iterating through the strict descendants of the given packet.  <a href="group__packet.html#ga3349803a6192301ffccc708dcf7c8efa">More...</a><br /></td></tr>
<tr class="separator:ga3349803a6192301ffccc708dcf7c8efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab143a69767e65df6b0e7fa4671b3d493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab143a69767e65df6b0e7fa4671b3d493">regina::PacketDescendants::operator=</a> (const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;)=default</td></tr>
<tr class="memdesc:gab143a69767e65df6b0e7fa4671b3d493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="group__packet.html#gab143a69767e65df6b0e7fa4671b3d493">More...</a><br /></td></tr>
<tr class="separator:gab143a69767e65df6b0e7fa4671b3d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae24129e2bed4ad821ec55526ef68abfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae24129e2bed4ad821ec55526ef68abfc">regina::PacketDescendants::begin</a> () const</td></tr>
<tr class="memdesc:gae24129e2bed4ad821ec55526ef68abfc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of strict descendants.  <a href="group__packet.html#gae24129e2bed4ad821ec55526ef68abfc">More...</a><br /></td></tr>
<tr class="separator:gae24129e2bed4ad821ec55526ef68abfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab56c66808490401dfc950ce16b268423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab56c66808490401dfc950ce16b268423">regina::PacketDescendants::end</a> () const</td></tr>
<tr class="memdesc:gab56c66808490401dfc950ce16b268423"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of strict descendants.  <a href="group__packet.html#gab56c66808490401dfc950ce16b268423">More...</a><br /></td></tr>
<tr class="separator:gab56c66808490401dfc950ce16b268423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga126ffc7b34aca93a3edba924d0764aaa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga126ffc7b34aca93a3edba924d0764aaa">regina::PacketShell::PacketShell</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga126ffc7b34aca93a3edba924d0764aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new shell referring to the given packet.  <a href="group__packet.html#ga126ffc7b34aca93a3edba924d0764aaa">More...</a><br /></td></tr>
<tr class="separator:ga126ffc7b34aca93a3edba924d0764aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4743ca941ad1c1c3849b72cb5d315ede"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4743ca941ad1c1c3849b72cb5d315ede">regina::PacketShell::PacketShell</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell)=default</td></tr>
<tr class="memdesc:ga4743ca941ad1c1c3849b72cb5d315ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given shell.  <a href="group__packet.html#ga4743ca941ad1c1c3849b72cb5d315ede">More...</a><br /></td></tr>
<tr class="separator:ga4743ca941ad1c1c3849b72cb5d315ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga515f5c71ddf046610d03714948264f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga515f5c71ddf046610d03714948264f4e">regina::PacketShell::operator=</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell)=default</td></tr>
<tr class="memdesc:ga515f5c71ddf046610d03714948264f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to be a copy of the given shell.  <a href="group__packet.html#ga515f5c71ddf046610d03714948264f4e">More...</a><br /></td></tr>
<tr class="separator:ga515f5c71ddf046610d03714948264f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbe65ec69b04755609d8294977dd989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaacbe65ec69b04755609d8294977dd989">regina::PacketShell::operator==</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell) const</td></tr>
<tr class="memdesc:gaacbe65ec69b04755609d8294977dd989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this and the given shell refer to the same underlying packet.  <a href="group__packet.html#gaacbe65ec69b04755609d8294977dd989">More...</a><br /></td></tr>
<tr class="separator:gaacbe65ec69b04755609d8294977dd989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b87fb099d8e833d62f0d386695ac4ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4b87fb099d8e833d62f0d386695ac4ab">regina::PacketShell::operator==</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet) const</td></tr>
<tr class="memdesc:ga4b87fb099d8e833d62f0d386695ac4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this shell refers to the given packet.  <a href="group__packet.html#ga4b87fb099d8e833d62f0d386695ac4ab">More...</a><br /></td></tr>
<tr class="separator:ga4b87fb099d8e833d62f0d386695ac4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce231143254c64a6c385ebe99bfdbb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8ce231143254c64a6c385ebe99bfdbb5">regina::PacketShell::operator!=</a> (const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;shell) const</td></tr>
<tr class="memdesc:ga8ce231143254c64a6c385ebe99bfdbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this and the given shell refer to different underlying packets.  <a href="group__packet.html#ga8ce231143254c64a6c385ebe99bfdbb5">More...</a><br /></td></tr>
<tr class="separator:ga8ce231143254c64a6c385ebe99bfdbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de163f6b93ae3df7aa8524cca7e6143"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga5de163f6b93ae3df7aa8524cca7e6143">regina::PacketShell::operator!=</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet) const</td></tr>
<tr class="memdesc:ga5de163f6b93ae3df7aa8524cca7e6143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if this shell does not refer to the given packet.  <a href="group__packet.html#ga5de163f6b93ae3df7aa8524cca7e6143">More...</a><br /></td></tr>
<tr class="separator:ga5de163f6b93ae3df7aa8524cca7e6143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5970247173515dd6e4bc93dd956922aa"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga5970247173515dd6e4bc93dd956922aa">regina::PacketShell::label</a> () const</td></tr>
<tr class="memdesc:ga5970247173515dd6e4bc93dd956922aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="group__packet.html#ga5970247173515dd6e4bc93dd956922aa">More...</a><br /></td></tr>
<tr class="separator:ga5970247173515dd6e4bc93dd956922aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee053db30fd6227cd420a3a5d19266e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0ee053db30fd6227cd420a3a5d19266e">regina::PacketShell::humanLabel</a> () const</td></tr>
<tr class="memdesc:ga0ee053db30fd6227cd420a3a5d19266e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="group__packet.html#ga0ee053db30fd6227cd420a3a5d19266e">More...</a><br /></td></tr>
<tr class="separator:ga0ee053db30fd6227cd420a3a5d19266e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4893445f043663e9a8595fc8bb0490a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa4893445f043663e9a8595fc8bb0490a">regina::PacketShell::hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:gaa4893445f043663e9a8595fc8bb0490a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="group__packet.html#gaa4893445f043663e9a8595fc8bb0490a">More...</a><br /></td></tr>
<tr class="separator:gaa4893445f043663e9a8595fc8bb0490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a2ab9c10c8a0d08b804a9bd02530e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab9a2ab9c10c8a0d08b804a9bd02530e5">regina::PacketShell::hasTags</a> () const</td></tr>
<tr class="memdesc:gab9a2ab9c10c8a0d08b804a9bd02530e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="group__packet.html#gab9a2ab9c10c8a0d08b804a9bd02530e5">More...</a><br /></td></tr>
<tr class="separator:gab9a2ab9c10c8a0d08b804a9bd02530e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60fe568711de8246572dc6ec376361df"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga60fe568711de8246572dc6ec376361df">regina::PacketShell::tags</a> () const</td></tr>
<tr class="memdesc:ga60fe568711de8246572dc6ec376361df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="group__packet.html#ga60fe568711de8246572dc6ec376361df">More...</a><br /></td></tr>
<tr class="separator:ga60fe568711de8246572dc6ec376361df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga826de400a7a8238d49c86e0413043738"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga826de400a7a8238d49c86e0413043738">regina::PacketShell::internalID</a> () const</td></tr>
<tr class="memdesc:ga826de400a7a8238d49c86e0413043738"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="group__packet.html#ga826de400a7a8238d49c86e0413043738">More...</a><br /></td></tr>
<tr class="separator:ga826de400a7a8238d49c86e0413043738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac717c06a744c38993b7d137c55e6de40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac717c06a744c38993b7d137c55e6de40">regina::operator==</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> shell)</td></tr>
<tr class="memdesc:gac717c06a744c38993b7d137c55e6de40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if the given shell refers to the given packet.  <a href="group__packet.html#gac717c06a744c38993b7d137c55e6de40">More...</a><br /></td></tr>
<tr class="separator:gac717c06a744c38993b7d137c55e6de40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace38aff17950c85385587ece7b0e7963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gace38aff17950c85385587ece7b0e7963">regina::operator!=</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> shell)</td></tr>
<tr class="memdesc:gace38aff17950c85385587ece7b0e7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies if the given shell does not refer to the given packet.  <a href="group__packet.html#gace38aff17950c85385587ece7b0e7963">More...</a><br /></td></tr>
<tr class="separator:gace38aff17950c85385587ece7b0e7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga842932466a8cdb50c359c584dd8e93ca"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga842932466a8cdb50c359c584dd8e93ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca">regina::forPacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> packetType, FunctionObject &amp;&amp;func, typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga842932466a8cdb50c359c584dd8e93ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime.  <a href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca">More...</a><br /></td></tr>
<tr class="separator:ga842932466a8cdb50c359c584dd8e93ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__packet.html#gae6cfcd14a51ee6ad01fef5af95d05458">regina::forPacket</a> (<a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> packetType, FunctionObject &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime.  <a href="group__packet.html#gae6cfcd14a51ee6ad01fef5af95d05458">More...</a><br /></td></tr>
<tr class="separator:gae6cfcd14a51ee6ad01fef5af95d05458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b20f6a5e04148126d18e535825c9fa4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6b20f6a5e04148126d18e535825c9fa4">regina::PDF::PDF</a> ()</td></tr>
<tr class="memdesc:ga6b20f6a5e04148126d18e535825c9fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet with no document stored.  <a href="group__packet.html#ga6b20f6a5e04148126d18e535825c9fa4">More...</a><br /></td></tr>
<tr class="separator:ga6b20f6a5e04148126d18e535825c9fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3aaa69bba9b626686ccf56cb735b01a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae3aaa69bba9b626686ccf56cb735b01a">regina::PDF::PDF</a> (const char *filename)</td></tr>
<tr class="memdesc:gae3aaa69bba9b626686ccf56cb735b01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet with data read from the given <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> file.  <a href="group__packet.html#gae3aaa69bba9b626686ccf56cb735b01a">More...</a><br /></td></tr>
<tr class="separator:gae3aaa69bba9b626686ccf56cb735b01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga336edef2caba28675b9e7d7f6dd98734"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga336edef2caba28675b9e7d7f6dd98734">regina::PDF::PDF</a> (char *<a class="el" href="group__packet.html#ga815e18c6ed85bd0dbfc957466239f2cd">data</a>, size_t <a class="el" href="group__packet.html#ga5ae1d5476b568afe205223d8fb10563c">size</a>, <a class="el" href="group__packet.html#gabb7c46c6bbb0cfe639525d1bf5700f2c">OwnershipPolicy</a> alloc)</td></tr>
<tr class="memdesc:ga336edef2caba28675b9e7d7f6dd98734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a packet to store the given <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> data.  <a href="group__packet.html#ga336edef2caba28675b9e7d7f6dd98734">More...</a><br /></td></tr>
<tr class="separator:ga336edef2caba28675b9e7d7f6dd98734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad866a30d6060f56ec693800091ac268b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad866a30d6060f56ec693800091ac268b">regina::PDF::~PDF</a> ()</td></tr>
<tr class="memdesc:gad866a30d6060f56ec693800091ac268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet and deallocates data if required.  <a href="group__packet.html#gad866a30d6060f56ec693800091ac268b">More...</a><br /></td></tr>
<tr class="separator:gad866a30d6060f56ec693800091ac268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71eb9786bd9f73c340450b1628331039"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga71eb9786bd9f73c340450b1628331039">regina::PDF::isNull</a> () const</td></tr>
<tr class="memdesc:ga71eb9786bd9f73c340450b1628331039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet is currently holding a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document.  <a href="group__packet.html#ga71eb9786bd9f73c340450b1628331039">More...</a><br /></td></tr>
<tr class="separator:ga71eb9786bd9f73c340450b1628331039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga815e18c6ed85bd0dbfc957466239f2cd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga815e18c6ed85bd0dbfc957466239f2cd">regina::PDF::data</a> () const</td></tr>
<tr class="memdesc:ga815e18c6ed85bd0dbfc957466239f2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the block of raw data that forms this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document.  <a href="group__packet.html#ga815e18c6ed85bd0dbfc957466239f2cd">More...</a><br /></td></tr>
<tr class="separator:ga815e18c6ed85bd0dbfc957466239f2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae1d5476b568afe205223d8fb10563c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga5ae1d5476b568afe205223d8fb10563c">regina::PDF::size</a> () const</td></tr>
<tr class="memdesc:ga5ae1d5476b568afe205223d8fb10563c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the size of this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document in bytes.  <a href="group__packet.html#ga5ae1d5476b568afe205223d8fb10563c">More...</a><br /></td></tr>
<tr class="separator:ga5ae1d5476b568afe205223d8fb10563c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf002f6fa65df2c1413b78e9f5b4f1ca4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf002f6fa65df2c1413b78e9f5b4f1ca4">regina::PDF::reset</a> ()</td></tr>
<tr class="memdesc:gaf002f6fa65df2c1413b78e9f5b4f1ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet so that no document is stored.  <a href="group__packet.html#gaf002f6fa65df2c1413b78e9f5b4f1ca4">More...</a><br /></td></tr>
<tr class="separator:gaf002f6fa65df2c1413b78e9f5b4f1ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9acf501a13dbf512d9d924fe47bab01f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9acf501a13dbf512d9d924fe47bab01f">regina::PDF::reset</a> (char *<a class="el" href="group__packet.html#ga815e18c6ed85bd0dbfc957466239f2cd">data</a>, size_t <a class="el" href="group__packet.html#ga5ae1d5476b568afe205223d8fb10563c">size</a>, <a class="el" href="group__packet.html#gabb7c46c6bbb0cfe639525d1bf5700f2c">OwnershipPolicy</a> alloc)</td></tr>
<tr class="memdesc:ga9acf501a13dbf512d9d924fe47bab01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refills this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet with the given <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> data.  <a href="group__packet.html#ga9acf501a13dbf512d9d924fe47bab01f">More...</a><br /></td></tr>
<tr class="separator:ga9acf501a13dbf512d9d924fe47bab01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11305aefef5da98326d74c8bebe4683a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga11305aefef5da98326d74c8bebe4683a">regina::PDF::savePDF</a> (const char *filename) const</td></tr>
<tr class="memdesc:ga11305aefef5da98326d74c8bebe4683a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document to the given file in <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> format.  <a href="group__packet.html#ga11305aefef5da98326d74c8bebe4683a">More...</a><br /></td></tr>
<tr class="separator:ga11305aefef5da98326d74c8bebe4683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb9f8c4de7a10db3ad24d0adb463d2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafbb9f8c4de7a10db3ad24d0adb463d2d">regina::PDF::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gafbb9f8c4de7a10db3ad24d0adb463d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__packet.html#gafbb9f8c4de7a10db3ad24d0adb463d2d">More...</a><br /></td></tr>
<tr class="separator:gafbb9f8c4de7a10db3ad24d0adb463d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf851c8f4fab949324ac45ba980c01fd"><td class="memItemLeft" align="right" valign="top"><a id="gaaf851c8f4fab949324ac45ba980c01fd"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PDF::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:gaaf851c8f4fab949324ac45ba980c01fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga845af51beb787b3de5ef34912c438457"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga845af51beb787b3de5ef34912c438457">regina::PDF::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga845af51beb787b3de5ef34912c438457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__packet.html#ga845af51beb787b3de5ef34912c438457">More...</a><br /></td></tr>
<tr class="separator:ga845af51beb787b3de5ef34912c438457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga814a47f567426f0def126844dcacb0bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga814a47f567426f0def126844dcacb0bb">regina::PDF::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:ga814a47f567426f0def126844dcacb0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__packet.html#ga814a47f567426f0def126844dcacb0bb">More...</a><br /></td></tr>
<tr class="separator:ga814a47f567426f0def126844dcacb0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab128672dc3fe2d6aee4674c16cdb6a6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaab128672dc3fe2d6aee4674c16cdb6a6">regina::PDF::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaab128672dc3fe2d6aee4674c16cdb6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__packet.html#gaab128672dc3fe2d6aee4674c16cdb6a6">More...</a><br /></td></tr>
<tr class="separator:gaab128672dc3fe2d6aee4674c16cdb6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23822dfb026d71ca78fddb84ebf77e7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga23822dfb026d71ca78fddb84ebf77e7e">regina::Script::Script</a> ()</td></tr>
<tr class="memdesc:ga23822dfb026d71ca78fddb84ebf77e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises to a script with no text and no variables.  <a href="group__packet.html#ga23822dfb026d71ca78fddb84ebf77e7e">More...</a><br /></td></tr>
<tr class="separator:ga23822dfb026d71ca78fddb84ebf77e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79c728e0fe7e945956323efea123c283"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga79c728e0fe7e945956323efea123c283">regina::Script::text</a> () const</td></tr>
<tr class="memdesc:ga79c728e0fe7e945956323efea123c283"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complete text of this script.  <a href="group__packet.html#ga79c728e0fe7e945956323efea123c283">More...</a><br /></td></tr>
<tr class="separator:ga79c728e0fe7e945956323efea123c283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6929451806373711b09c4864642a1345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6929451806373711b09c4864642a1345">regina::Script::setText</a> (const std::string &amp;newText)</td></tr>
<tr class="memdesc:ga6929451806373711b09c4864642a1345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the complete text of this script with the given string.  <a href="group__packet.html#ga6929451806373711b09c4864642a1345">More...</a><br /></td></tr>
<tr class="separator:ga6929451806373711b09c4864642a1345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c90e10216b1d5f2a641669e57a09865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6c90e10216b1d5f2a641669e57a09865">regina::Script::append</a> (const std::string &amp;extraText)</td></tr>
<tr class="memdesc:ga6c90e10216b1d5f2a641669e57a09865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given text to the end of this script.  <a href="group__packet.html#ga6c90e10216b1d5f2a641669e57a09865">More...</a><br /></td></tr>
<tr class="separator:ga6c90e10216b1d5f2a641669e57a09865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdf82c530167301864f61c86d4fcdbe4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4">regina::Script::countVariables</a> () const</td></tr>
<tr class="memdesc:gabdf82c530167301864f61c86d4fcdbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of variables associated with this script.  <a href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4">More...</a><br /></td></tr>
<tr class="separator:gabdf82c530167301864f61c86d4fcdbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d014bbd8516fe0416988e7e48d3fce1"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga2d014bbd8516fe0416988e7e48d3fce1">regina::Script::variableName</a> (size_t index) const</td></tr>
<tr class="memdesc:ga2d014bbd8516fe0416988e7e48d3fce1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of the requested variable associated with this script.  <a href="group__packet.html#ga2d014bbd8516fe0416988e7e48d3fce1">More...</a><br /></td></tr>
<tr class="separator:ga2d014bbd8516fe0416988e7e48d3fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073060339cc90df355f017f16f2f9a65"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga073060339cc90df355f017f16f2f9a65">regina::Script::variableIndex</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ga073060339cc90df355f017f16f2f9a65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the variable stored with the given name.  <a href="group__packet.html#ga073060339cc90df355f017f16f2f9a65">More...</a><br /></td></tr>
<tr class="separator:ga073060339cc90df355f017f16f2f9a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9548cc36df18774225d3954c223f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4d9548cc36df18774225d3954c223f7c">regina::Script::variableValue</a> (size_t index) const</td></tr>
<tr class="memdesc:ga4d9548cc36df18774225d3954c223f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the requested variable associated with this script.  <a href="group__packet.html#ga4d9548cc36df18774225d3954c223f7c">More...</a><br /></td></tr>
<tr class="separator:ga4d9548cc36df18774225d3954c223f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e30eb1563860eb32b5bc6facdae1a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga2e30eb1563860eb32b5bc6facdae1a3b">regina::Script::variableValue</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ga2e30eb1563860eb32b5bc6facdae1a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the variable stored with the given name.  <a href="group__packet.html#ga2e30eb1563860eb32b5bc6facdae1a3b">More...</a><br /></td></tr>
<tr class="separator:ga2e30eb1563860eb32b5bc6facdae1a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad01d2a901d584984e36e8893c9541300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad01d2a901d584984e36e8893c9541300">regina::Script::setVariableName</a> (size_t index, const std::string &amp;name)</td></tr>
<tr class="memdesc:gad01d2a901d584984e36e8893c9541300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of an existing variable associated with this script.  <a href="group__packet.html#gad01d2a901d584984e36e8893c9541300">More...</a><br /></td></tr>
<tr class="separator:gad01d2a901d584984e36e8893c9541300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5297bee2c6e54a37f83e448af86da6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad5297bee2c6e54a37f83e448af86da6a">regina::Script::setVariableValue</a> (size_t index, <a class="el" href="classregina_1_1Packet.html">Packet</a> *value)</td></tr>
<tr class="memdesc:gad5297bee2c6e54a37f83e448af86da6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value of an existing variable associated with this script.  <a href="group__packet.html#gad5297bee2c6e54a37f83e448af86da6a">More...</a><br /></td></tr>
<tr class="separator:gad5297bee2c6e54a37f83e448af86da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b20607a3d3c79f00455841cf995df5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad6b20607a3d3c79f00455841cf995df5">regina::Script::addVariable</a> (const std::string &amp;name, <a class="el" href="classregina_1_1Packet.html">Packet</a> *value)</td></tr>
<tr class="memdesc:gad6b20607a3d3c79f00455841cf995df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to add a new variable to be associated with this script.  <a href="group__packet.html#gad6b20607a3d3c79f00455841cf995df5">More...</a><br /></td></tr>
<tr class="separator:gad6b20607a3d3c79f00455841cf995df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c7b7c5ee615aa61e8c6b31056634ae"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga57c7b7c5ee615aa61e8c6b31056634ae">regina::Script::addVariableName</a> (const std::string &amp;name, <a class="el" href="classregina_1_1Packet.html">Packet</a> *value)</td></tr>
<tr class="memdesc:ga57c7b7c5ee615aa61e8c6b31056634ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new variable to be associated with this script, changing its name if necessary.  <a href="group__packet.html#ga57c7b7c5ee615aa61e8c6b31056634ae">More...</a><br /></td></tr>
<tr class="separator:ga57c7b7c5ee615aa61e8c6b31056634ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga879ee100b538daad0f4c21e9ad8dfc40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga879ee100b538daad0f4c21e9ad8dfc40">regina::Script::removeVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ga879ee100b538daad0f4c21e9ad8dfc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variable stored with the given name.  <a href="group__packet.html#ga879ee100b538daad0f4c21e9ad8dfc40">More...</a><br /></td></tr>
<tr class="separator:ga879ee100b538daad0f4c21e9ad8dfc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51766139616656bcd8a257fb9526cd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga51766139616656bcd8a257fb9526cd71">regina::Script::removeVariable</a> (size_t index)</td></tr>
<tr class="memdesc:ga51766139616656bcd8a257fb9526cd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variable stored at the given index.  <a href="group__packet.html#ga51766139616656bcd8a257fb9526cd71">More...</a><br /></td></tr>
<tr class="separator:ga51766139616656bcd8a257fb9526cd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0652968ebcda8deb215b167ed5e514bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0652968ebcda8deb215b167ed5e514bf">regina::Script::removeAllVariables</a> ()</td></tr>
<tr class="memdesc:ga0652968ebcda8deb215b167ed5e514bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all variables associated with this script.  <a href="group__packet.html#ga0652968ebcda8deb215b167ed5e514bf">More...</a><br /></td></tr>
<tr class="separator:ga0652968ebcda8deb215b167ed5e514bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga161bba5734a7675ae64dee54b8fd07ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga161bba5734a7675ae64dee54b8fd07ef">regina::Script::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga161bba5734a7675ae64dee54b8fd07ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__packet.html#ga161bba5734a7675ae64dee54b8fd07ef">More...</a><br /></td></tr>
<tr class="separator:ga161bba5734a7675ae64dee54b8fd07ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde4bee19f71a36759d51e1939a1a841"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacde4bee19f71a36759d51e1939a1a841">regina::Script::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gacde4bee19f71a36759d51e1939a1a841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__packet.html#gacde4bee19f71a36759d51e1939a1a841">More...</a><br /></td></tr>
<tr class="separator:gacde4bee19f71a36759d51e1939a1a841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345bf72b48aced97c6548a14c052b27c"><td class="memItemLeft" align="right" valign="top"><a id="ga345bf72b48aced97c6548a14c052b27c"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Script::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ga345bf72b48aced97c6548a14c052b27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f1e07ef835c561938bf2f36cb48e438"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4f1e07ef835c561938bf2f36cb48e438">regina::Script::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga4f1e07ef835c561938bf2f36cb48e438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__packet.html#ga4f1e07ef835c561938bf2f36cb48e438">More...</a><br /></td></tr>
<tr class="separator:ga4f1e07ef835c561938bf2f36cb48e438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad286098a247bcba4f440c5f42f4b6863"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad286098a247bcba4f440c5f42f4b6863">regina::Script::packetWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet) override</td></tr>
<tr class="memdesc:gad286098a247bcba4f440c5f42f4b6863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the packet label or tags have been changed.  <a href="group__packet.html#gad286098a247bcba4f440c5f42f4b6863">More...</a><br /></td></tr>
<tr class="separator:gad286098a247bcba4f440c5f42f4b6863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d97052be80a5b0e3ebb3ca104bf3edd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7d97052be80a5b0e3ebb3ca104bf3edd">regina::Script::packetToBeDestroyed</a> (<a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> packet) override</td></tr>
<tr class="memdesc:ga7d97052be80a5b0e3ebb3ca104bf3edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet is about to be destroyed.  <a href="group__packet.html#ga7d97052be80a5b0e3ebb3ca104bf3edd">More...</a><br /></td></tr>
<tr class="separator:ga7d97052be80a5b0e3ebb3ca104bf3edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5aa0da3c39b73fb341cd2cb3f59deb6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad5aa0da3c39b73fb341cd2cb3f59deb6">regina::Script::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:gad5aa0da3c39b73fb341cd2cb3f59deb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__packet.html#gad5aa0da3c39b73fb341cd2cb3f59deb6">More...</a><br /></td></tr>
<tr class="separator:gad5aa0da3c39b73fb341cd2cb3f59deb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac09bcb96ff3f280e15400bda3afb2d45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac09bcb96ff3f280e15400bda3afb2d45">regina::Script::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gac09bcb96ff3f280e15400bda3afb2d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__packet.html#gac09bcb96ff3f280e15400bda3afb2d45">More...</a><br /></td></tr>
<tr class="separator:gac09bcb96ff3f280e15400bda3afb2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5982b27f5b243d449138058fd18992e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga5982b27f5b243d449138058fd18992e7">regina::Text::Text</a> ()</td></tr>
<tr class="memdesc:ga5982b27f5b243d449138058fd18992e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the packet to the empty string.  <a href="group__packet.html#ga5982b27f5b243d449138058fd18992e7">More...</a><br /></td></tr>
<tr class="separator:ga5982b27f5b243d449138058fd18992e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ec2a83e111396b177e68fc31f8c3d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga26ec2a83e111396b177e68fc31f8c3d6">regina::Text::Text</a> (const std::string &amp;newText)</td></tr>
<tr class="memdesc:ga26ec2a83e111396b177e68fc31f8c3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the packet to the given string.  <a href="group__packet.html#ga26ec2a83e111396b177e68fc31f8c3d6">More...</a><br /></td></tr>
<tr class="separator:ga26ec2a83e111396b177e68fc31f8c3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae353fd8b40c8545943a59d4310123fb9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae353fd8b40c8545943a59d4310123fb9">regina::Text::Text</a> (const char *newText)</td></tr>
<tr class="memdesc:gae353fd8b40c8545943a59d4310123fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the packet to the given string.  <a href="group__packet.html#gae353fd8b40c8545943a59d4310123fb9">More...</a><br /></td></tr>
<tr class="separator:gae353fd8b40c8545943a59d4310123fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4315d50ce83303ed6e5bc2fef3bff229"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4315d50ce83303ed6e5bc2fef3bff229">regina::Text::text</a> () const</td></tr>
<tr class="memdesc:ga4315d50ce83303ed6e5bc2fef3bff229"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the string stored in the packet.  <a href="group__packet.html#ga4315d50ce83303ed6e5bc2fef3bff229">More...</a><br /></td></tr>
<tr class="separator:ga4315d50ce83303ed6e5bc2fef3bff229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2818598466f8b63a905cadb881da7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4f2818598466f8b63a905cadb881da7f">regina::Text::setText</a> (const std::string &amp;newText)</td></tr>
<tr class="memdesc:ga4f2818598466f8b63a905cadb881da7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the packet data to the given string.  <a href="group__packet.html#ga4f2818598466f8b63a905cadb881da7f">More...</a><br /></td></tr>
<tr class="separator:ga4f2818598466f8b63a905cadb881da7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3206bf85298d5fc24377f27d94926ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga3206bf85298d5fc24377f27d94926ff2">regina::Text::setText</a> (const char *newText)</td></tr>
<tr class="memdesc:ga3206bf85298d5fc24377f27d94926ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the packet data to the given string.  <a href="group__packet.html#ga3206bf85298d5fc24377f27d94926ff2">More...</a><br /></td></tr>
<tr class="separator:ga3206bf85298d5fc24377f27d94926ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b5ade64bc08041b7bdf135ae6e65f16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0b5ade64bc08041b7bdf135ae6e65f16">regina::Text::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga0b5ade64bc08041b7bdf135ae6e65f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__packet.html#ga0b5ade64bc08041b7bdf135ae6e65f16">More...</a><br /></td></tr>
<tr class="separator:ga0b5ade64bc08041b7bdf135ae6e65f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe65a9b4b9fc9430a6b161bae995f024"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafe65a9b4b9fc9430a6b161bae995f024">regina::Text::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gafe65a9b4b9fc9430a6b161bae995f024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__packet.html#gafe65a9b4b9fc9430a6b161bae995f024">More...</a><br /></td></tr>
<tr class="separator:gafe65a9b4b9fc9430a6b161bae995f024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c56d64c99ba6b8380da393db9b2933f"><td class="memItemLeft" align="right" valign="top"><a id="ga4c56d64c99ba6b8380da393db9b2933f"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Text::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ga4c56d64c99ba6b8380da393db9b2933f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e1640a424aa67f2ff1e406871fa63a6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6e1640a424aa67f2ff1e406871fa63a6">regina::Text::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga6e1640a424aa67f2ff1e406871fa63a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__packet.html#ga6e1640a424aa67f2ff1e406871fa63a6">More...</a><br /></td></tr>
<tr class="separator:ga6e1640a424aa67f2ff1e406871fa63a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ee6af15b1de3e79e8fe259244f1315c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4ee6af15b1de3e79e8fe259244f1315c">regina::Text::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:ga4ee6af15b1de3e79e8fe259244f1315c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__packet.html#ga4ee6af15b1de3e79e8fe259244f1315c">More...</a><br /></td></tr>
<tr class="separator:ga4ee6af15b1de3e79e8fe259244f1315c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081c43ec9110be27b224f430c4212861"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga081c43ec9110be27b224f430c4212861">regina::Text::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga081c43ec9110be27b224f430c4212861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__packet.html#ga081c43ec9110be27b224f430c4212861">More...</a><br /></td></tr>
<tr class="separator:ga081c43ec9110be27b224f430c4212861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3409bc6a8ba0447646285d437dbf971f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga3409bc6a8ba0447646285d437dbf971f">regina::XMLPacketReader::XMLPacketReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga3409bc6a8ba0447646285d437dbf971f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new packet element reader.  <a href="group__packet.html#ga3409bc6a8ba0447646285d437dbf971f">More...</a><br /></td></tr>
<tr class="separator:ga3409bc6a8ba0447646285d437dbf971f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde072f143d7c1ecc8e4916e52ceb1d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader::packet</a> ()</td></tr>
<tr class="memdesc:gacde072f143d7c1ecc8e4916e52ceb1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">More...</a><br /></td></tr>
<tr class="separator:gacde072f143d7c1ecc8e4916e52ceb1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83b13f4e881390c9a02e3ae1848d8e6b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps)</td></tr>
<tr class="memdesc:ga83b13f4e881390c9a02e3ae1848d8e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">More...</a><br /></td></tr>
<tr class="separator:ga83b13f4e881390c9a02e3ae1848d8e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9df4d0a5ff0a96c001094ee6b67f5b0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader)</td></tr>
<tr class="memdesc:gac9df4d0a5ff0a96c001094ee6b67f5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">More...</a><br /></td></tr>
<tr class="separator:gac9df4d0a5ff0a96c001094ee6b67f5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75cc7b21708011a1963811378edaf3ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab">regina::XMLPacketReader::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga75cc7b21708011a1963811378edaf3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab">More...</a><br /></td></tr>
<tr class="separator:ga75cc7b21708011a1963811378edaf3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8326fbf3c5e5fe26fa9d3dca2a86ce7d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d">regina::XMLPacketReader::endSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga8326fbf3c5e5fe26fa9d3dca2a86ce7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing has finished for a subelement of this XML element.  <a href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d">More...</a><br /></td></tr>
<tr class="separator:ga8326fbf3c5e5fe26fa9d3dca2a86ce7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9dde3d8d3d8d189d355e1b186f1b83a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa9dde3d8d3d8d189d355e1b186f1b83a">regina::XMLPacketReader::abort</a> (<a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:gaa9dde3d8d3d8d189d355e1b186f1b83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that XML parsing has been aborted.  <a href="group__packet.html#gaa9dde3d8d3d8d189d355e1b186f1b83a">More...</a><br /></td></tr>
<tr class="separator:gaa9dde3d8d3d8d189d355e1b186f1b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46932d1f67d986ef0a79b597800cdc58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga46932d1f67d986ef0a79b597800cdc58">regina::XMLContainerReader::XMLContainerReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga46932d1f67d986ef0a79b597800cdc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new container reader.  <a href="group__packet.html#ga46932d1f67d986ef0a79b597800cdc58">More...</a><br /></td></tr>
<tr class="separator:ga46932d1f67d986ef0a79b597800cdc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga273345f730f8b6681dad917ae87b56d1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga273345f730f8b6681dad917ae87b56d1">regina::XMLContainerReader::packet</a> () override</td></tr>
<tr class="memdesc:ga273345f730f8b6681dad917ae87b56d1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__packet.html#ga273345f730f8b6681dad917ae87b56d1">More...</a><br /></td></tr>
<tr class="separator:ga273345f730f8b6681dad917ae87b56d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9579071cdbbbe615d7f075251cbdd5a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9579071cdbbbe615d7f075251cbdd5a7">regina::XMLPDFReader::XMLPDFReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga9579071cdbbbe615d7f075251cbdd5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> reader.  <a href="group__packet.html#ga9579071cdbbbe615d7f075251cbdd5a7">More...</a><br /></td></tr>
<tr class="separator:ga9579071cdbbbe615d7f075251cbdd5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c7e739cd2062e09dd7a2c60dbc97ed"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad9c7e739cd2062e09dd7a2c60dbc97ed">regina::XMLPDFReader::packet</a> () override</td></tr>
<tr class="memdesc:gad9c7e739cd2062e09dd7a2c60dbc97ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__packet.html#gad9c7e739cd2062e09dd7a2c60dbc97ed">More...</a><br /></td></tr>
<tr class="separator:gad9c7e739cd2062e09dd7a2c60dbc97ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4aa2e06b6c0ebfc66ae0ee2be196422"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4aa2e06b6c0ebfc66ae0ee2be196422">regina::XMLPDFReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:gaf4aa2e06b6c0ebfc66ae0ee2be196422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#gaf4aa2e06b6c0ebfc66ae0ee2be196422">More...</a><br /></td></tr>
<tr class="separator:gaf4aa2e06b6c0ebfc66ae0ee2be196422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga968b7e08bbe0f3e1b6b63b1403488286"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga968b7e08bbe0f3e1b6b63b1403488286">regina::XMLPDFReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga968b7e08bbe0f3e1b6b63b1403488286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#ga968b7e08bbe0f3e1b6b63b1403488286">More...</a><br /></td></tr>
<tr class="separator:ga968b7e08bbe0f3e1b6b63b1403488286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b611020b93fcbc79a9c206420c19e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa2b611020b93fcbc79a9c206420c19e9">regina::XMLScriptReader::XMLScriptReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:gaa2b611020b93fcbc79a9c206420c19e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new script reader.  <a href="group__packet.html#gaa2b611020b93fcbc79a9c206420c19e9">More...</a><br /></td></tr>
<tr class="separator:gaa2b611020b93fcbc79a9c206420c19e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4354e1f761f87b27d75ebb0ddbad6cbc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4354e1f761f87b27d75ebb0ddbad6cbc">regina::XMLScriptReader::packet</a> () override</td></tr>
<tr class="memdesc:ga4354e1f761f87b27d75ebb0ddbad6cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__packet.html#ga4354e1f761f87b27d75ebb0ddbad6cbc">More...</a><br /></td></tr>
<tr class="separator:ga4354e1f761f87b27d75ebb0ddbad6cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb26942ce9450276dba92c3093f2129"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga1cb26942ce9450276dba92c3093f2129">regina::XMLScriptReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga1cb26942ce9450276dba92c3093f2129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#ga1cb26942ce9450276dba92c3093f2129">More...</a><br /></td></tr>
<tr class="separator:ga1cb26942ce9450276dba92c3093f2129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga469708e082f17d09034ee39bb39f46fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga469708e082f17d09034ee39bb39f46fc">regina::XMLScriptReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga469708e082f17d09034ee39bb39f46fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#ga469708e082f17d09034ee39bb39f46fc">More...</a><br /></td></tr>
<tr class="separator:ga469708e082f17d09034ee39bb39f46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84b3d1121619d803d38d1584acb733d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga84b3d1121619d803d38d1584acb733d2">regina::XMLTextReader::XMLTextReader</a> (<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga84b3d1121619d803d38d1584acb733d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new text packet reader.  <a href="group__packet.html#ga84b3d1121619d803d38d1584acb733d2">More...</a><br /></td></tr>
<tr class="separator:ga84b3d1121619d803d38d1584acb733d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6d12d3571e4c61cdc251b7c2e66aa94"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac6d12d3571e4c61cdc251b7c2e66aa94">regina::XMLTextReader::packet</a> () override</td></tr>
<tr class="memdesc:gac6d12d3571e4c61cdc251b7c2e66aa94"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__packet.html#gac6d12d3571e4c61cdc251b7c2e66aa94">More...</a><br /></td></tr>
<tr class="separator:gac6d12d3571e4c61cdc251b7c2e66aa94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24064e768fba37a4c95a09e53f3a7680"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga24064e768fba37a4c95a09e53f3a7680">regina::XMLTextReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga24064e768fba37a4c95a09e53f3a7680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#ga24064e768fba37a4c95a09e53f3a7680">More...</a><br /></td></tr>
<tr class="separator:ga24064e768fba37a4c95a09e53f3a7680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb4a46af9a9b0d7e0294fcccc097d5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafbb4a46af9a9b0d7e0294fcccc097d5a">regina::XMLTextReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:gafbb4a46af9a9b0d7e0294fcccc097d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__packet.html#gafbb4a46af9a9b0d7e0294fcccc097d5a">More...</a><br /></td></tr>
<tr class="separator:gafbb4a46af9a9b0d7e0294fcccc097d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4fcbf8842f420457ae01c30f4898d7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gabb4fcbf8842f420457ae01c30f4898d7">regina::XMLTreeResolutionTask::~XMLTreeResolutionTask</a> ()</td></tr>
<tr class="memdesc:gabb4fcbf8842f420457ae01c30f4898d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default construct that does nothing.  <a href="group__packet.html#gabb4fcbf8842f420457ae01c30f4898d7">More...</a><br /></td></tr>
<tr class="separator:gabb4fcbf8842f420457ae01c30f4898d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b2e3f85565701a0c717204bf5f04855"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6b2e3f85565701a0c717204bf5f04855">regina::XMLTreeResolutionTask::resolve</a> (const <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)=0</td></tr>
<tr class="memdesc:ga6b2e3f85565701a0c717204bf5f04855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a> after the entire data file has been read.  <a href="group__packet.html#ga6b2e3f85565701a0c717204bf5f04855">More...</a><br /></td></tr>
<tr class="separator:ga6b2e3f85565701a0c717204bf5f04855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61fd37b6db545006a3016b721c99a15b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga61fd37b6db545006a3016b721c99a15b">regina::XMLTreeResolver::XMLTreeResolver</a> ()</td></tr>
<tr class="memdesc:ga61fd37b6db545006a3016b721c99a15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a resolver with no tasks queued.  <a href="group__packet.html#ga61fd37b6db545006a3016b721c99a15b">More...</a><br /></td></tr>
<tr class="separator:ga61fd37b6db545006a3016b721c99a15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4285bf757b67d109b1e86de9f07211de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4285bf757b67d109b1e86de9f07211de">regina::XMLTreeResolver::~XMLTreeResolver</a> ()</td></tr>
<tr class="memdesc:ga4285bf757b67d109b1e86de9f07211de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys any tasks that were queued but not performed.  <a href="group__packet.html#ga4285bf757b67d109b1e86de9f07211de">More...</a><br /></td></tr>
<tr class="separator:ga4285bf757b67d109b1e86de9f07211de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedaa9594b36a2acf51013b9b2092aa0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaedaa9594b36a2acf51013b9b2092aa0c">regina::XMLTreeResolver::queueTask</a> (<a class="el" href="classregina_1_1XMLTreeResolutionTask.html">XMLTreeResolutionTask</a> *task)</td></tr>
<tr class="memdesc:gaedaa9594b36a2acf51013b9b2092aa0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queues a task for processing.  <a href="group__packet.html#gaedaa9594b36a2acf51013b9b2092aa0c">More...</a><br /></td></tr>
<tr class="separator:gaedaa9594b36a2acf51013b9b2092aa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542bbef6c5302a1aebdbb39851fb01ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga542bbef6c5302a1aebdbb39851fb01ca">regina::XMLTreeResolver::storeID</a> (const std::string &amp;id, <a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga542bbef6c5302a1aebdbb39851fb01ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the fact that the given packet is stored in the data file using the given internal ID.  <a href="group__packet.html#ga542bbef6c5302a1aebdbb39851fb01ca">More...</a><br /></td></tr>
<tr class="separator:ga542bbef6c5302a1aebdbb39851fb01ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef35326137566ebe6f22533d8707e28"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__packet.html#ga9bcdb1301b1f56d445352a56fc9973fb">IDMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafef35326137566ebe6f22533d8707e28">regina::XMLTreeResolver::ids</a> () const</td></tr>
<tr class="memdesc:gafef35326137566ebe6f22533d8707e28"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the map from internal IDs to packets, as stored in the data file.  <a href="group__packet.html#gafef35326137566ebe6f22533d8707e28">More...</a><br /></td></tr>
<tr class="separator:gafef35326137566ebe6f22533d8707e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6deb2e7eb029a52c8c73af2dfdda9484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6deb2e7eb029a52c8c73af2dfdda9484">regina::XMLTreeResolver::resolve</a> ()</td></tr>
<tr class="memdesc:ga6deb2e7eb029a52c8c73af2dfdda9484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="group__packet.html#ga6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> for all queued tasks.  <a href="group__packet.html#ga6deb2e7eb029a52c8c73af2dfdda9484">More...</a><br /></td></tr>
<tr class="separator:ga6deb2e7eb029a52c8c73af2dfdda9484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8405a2d4d3024719c931d256790a234b"><td class="memItemLeft" align="right" valign="top"><a id="ga8405a2d4d3024719c931d256790a234b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLTreeResolver::XMLTreeResolver</b> (const <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;)=delete</td></tr>
<tr class="separator:ga8405a2d4d3024719c931d256790a234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33e135cf48da11b0dfa514ecc685394"><td class="memItemLeft" align="right" valign="top"><a id="gaf33e135cf48da11b0dfa514ecc685394"></a>
<a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLTreeResolver::operator=</b> (const <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;)=delete</td></tr>
<tr class="separator:gaf33e135cf48da11b0dfa514ecc685394"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1bc5e3b33bf3a5ac165b99b9956b284e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga1bc5e3b33bf3a5ac165b99b9956b284e">regina::PACKET_TRIANGULATION</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64">PACKET_TRIANGULATION3</a></td></tr>
<tr class="memdesc:ga1bc5e3b33bf3a5ac165b99b9956b284e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_TRIANGULATION3.  <a href="group__packet.html#ga1bc5e3b33bf3a5ac165b99b9956b284e">More...</a><br /></td></tr>
<tr class="separator:ga1bc5e3b33bf3a5ac165b99b9956b284e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ee82ab98a53118996b1b0ef1be1c1a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga46ee82ab98a53118996b1b0ef1be1c1a">regina::PACKET_NORMALSURFACELIST</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc">PACKET_NORMALSURFACES</a></td></tr>
<tr class="memdesc:ga46ee82ab98a53118996b1b0ef1be1c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_NORMALSURFACES.  <a href="group__packet.html#ga46ee82ab98a53118996b1b0ef1be1c1a">More...</a><br /></td></tr>
<tr class="separator:ga46ee82ab98a53118996b1b0ef1be1c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga455ca759888786ae6bf7be5fb0b65236"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga455ca759888786ae6bf7be5fb0b65236">regina::PACKET_ANGLESTRUCTURELIST</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9">PACKET_ANGLESTRUCTURES</a></td></tr>
<tr class="memdesc:ga455ca759888786ae6bf7be5fb0b65236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_ANGLESTRUCTURES.  <a href="group__packet.html#ga455ca759888786ae6bf7be5fb0b65236">More...</a><br /></td></tr>
<tr class="separator:ga455ca759888786ae6bf7be5fb0b65236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63030f7812e66bd10741a6186c542c96"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga63030f7812e66bd10741a6186c542c96">regina::PACKET_DIM4TRIANGULATION</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff">PACKET_TRIANGULATION4</a></td></tr>
<tr class="memdesc:ga63030f7812e66bd10741a6186c542c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_TRIANGULATION4.  <a href="group__packet.html#ga63030f7812e66bd10741a6186c542c96">More...</a><br /></td></tr>
<tr class="separator:ga63030f7812e66bd10741a6186c542c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5161f01c333fa03786d0bb40b6f68580"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga5161f01c333fa03786d0bb40b6f68580">regina::PACKET_NORMALHYPERSURFACELIST</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e">PACKET_NORMALHYPERSURFACES</a></td></tr>
<tr class="memdesc:ga5161f01c333fa03786d0bb40b6f68580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_NORMALHYPERSURFACES.  <a href="group__packet.html#ga5161f01c333fa03786d0bb40b6f68580">More...</a><br /></td></tr>
<tr class="separator:ga5161f01c333fa03786d0bb40b6f68580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f45d5e55b081a0ada789479ed34f6c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga05f45d5e55b081a0ada789479ed34f6c">regina::PACKET_DIM2TRIANGULATION</a> = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815">PACKET_TRIANGULATION2</a></td></tr>
<tr class="memdesc:ga05f45d5e55b081a0ada789479ed34f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for PACKET_TRIANGULATION2.  <a href="group__packet.html#ga05f45d5e55b081a0ada789479ed34f6c">More...</a><br /></td></tr>
<tr class="separator:ga05f45d5e55b081a0ada789479ed34f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga322f7e7b2069dbcb08a1c858d639ae90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga322f7e7b2069dbcb08a1c858d639ae90">regina::XMLPacketReader::resolver_</a></td></tr>
<tr class="memdesc:ga322f7e7b2069dbcb08a1c858d639ae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">The master resolver that will be used to fix dangling packet references after the entire XML file has been read.  <a href="group__packet.html#ga322f7e7b2069dbcb08a1c858d639ae90">More...</a><br /></td></tr>
<tr class="separator:ga322f7e7b2069dbcb08a1c858d639ae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Packet Listener Interface</h2></td></tr>
<tr class="memitem:gae51cb555166657e5996a76768db998e3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae51cb555166657e5996a76768db998e3">regina::PacketListener::Packet</a></td></tr>
<tr class="memdesc:gae51cb555166657e5996a76768db998e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow packets to automatically deregister listeners as they are destroyed.  <a href="group__packet.html#gae51cb555166657e5996a76768db998e3">More...</a><br /></td></tr>
<tr class="separator:gae51cb555166657e5996a76768db998e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88fd0a82cc44c243e1f3d4041b86792a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga88fd0a82cc44c243e1f3d4041b86792a">regina::PacketListener::unregisterFromAllPackets</a> ()</td></tr>
<tr class="memdesc:ga88fd0a82cc44c243e1f3d4041b86792a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters this listener from any packets to which it is currently listening.  <a href="group__packet.html#ga88fd0a82cc44c243e1f3d4041b86792a">More...</a><br /></td></tr>
<tr class="separator:ga88fd0a82cc44c243e1f3d4041b86792a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacec00b1f4665c352ca6638819a7f7221"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacec00b1f4665c352ca6638819a7f7221">regina::PacketListener::packetToBeChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:gacec00b1f4665c352ca6638819a7f7221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the contents of the packet are to be changed.  <a href="group__packet.html#gacec00b1f4665c352ca6638819a7f7221">More...</a><br /></td></tr>
<tr class="separator:gacec00b1f4665c352ca6638819a7f7221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113b2c051046b67870da4a4953422438"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga113b2c051046b67870da4a4953422438">regina::PacketListener::packetWasChanged</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga113b2c051046b67870da4a4953422438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the contents of the packet have been changed.  <a href="group__packet.html#ga113b2c051046b67870da4a4953422438">More...</a><br /></td></tr>
<tr class="separator:ga113b2c051046b67870da4a4953422438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7756e8a51f95d68d84c9ea2e0a7838"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838">regina::PacketListener::packetToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:gaec7756e8a51f95d68d84c9ea2e0a7838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet label or tags are to be changed.  <a href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838">More...</a><br /></td></tr>
<tr class="separator:gaec7756e8a51f95d68d84c9ea2e0a7838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6d39aabd829a9417637a0b71b39acb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb">regina::PacketListener::packetWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:gadf6d39aabd829a9417637a0b71b39acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the packet label or tags have been changed.  <a href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb">More...</a><br /></td></tr>
<tr class="separator:gadf6d39aabd829a9417637a0b71b39acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f626506f5c7f4dc12fb41acde2ab97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga85f626506f5c7f4dc12fb41acde2ab97">regina::PacketListener::packetToBeDestroyed</a> (<a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> packet)</td></tr>
<tr class="memdesc:ga85f626506f5c7f4dc12fb41acde2ab97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet is about to be destroyed.  <a href="group__packet.html#ga85f626506f5c7f4dc12fb41acde2ab97">More...</a><br /></td></tr>
<tr class="separator:ga85f626506f5c7f4dc12fb41acde2ab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db49c766578d5d0f3b13cf5a6244a43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0db49c766578d5d0f3b13cf5a6244a43">regina::PacketListener::childToBeAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ga0db49c766578d5d0f3b13cf5a6244a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be inserted directly beneath the packet.  <a href="group__packet.html#ga0db49c766578d5d0f3b13cf5a6244a43">More...</a><br /></td></tr>
<tr class="separator:ga0db49c766578d5d0f3b13cf5a6244a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadffc274996ce2bfe35a85bc2cf7209ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadffc274996ce2bfe35a85bc2cf7209ee">regina::PacketListener::childWasAdded</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gadffc274996ce2bfe35a85bc2cf7209ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been inserted directly beneath the packet.  <a href="group__packet.html#gadffc274996ce2bfe35a85bc2cf7209ee">More...</a><br /></td></tr>
<tr class="separator:gadffc274996ce2bfe35a85bc2cf7209ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9953ae63b9b29634faeb5f36ba34ab91"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91">regina::PacketListener::childToBeRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ga9953ae63b9b29634faeb5f36ba34ab91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be removed from directly beneath the packet.  <a href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91">More...</a><br /></td></tr>
<tr class="separator:ga9953ae63b9b29634faeb5f36ba34ab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9528b072f69513fba62e382c9c2aed22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22">regina::PacketListener::childWasRemoved</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ga9528b072f69513fba62e382c9c2aed22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been removed from directly beneath the packet.  <a href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22">More...</a><br /></td></tr>
<tr class="separator:ga9528b072f69513fba62e382c9c2aed22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ce7ca97f2e668c73975d5048bd40dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga43ce7ca97f2e668c73975d5048bd40dd">regina::PacketListener::childrenToBeReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga43ce7ca97f2e668c73975d5048bd40dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the child packets directly beneath the packet are to be reordered.  <a href="group__packet.html#ga43ce7ca97f2e668c73975d5048bd40dd">More...</a><br /></td></tr>
<tr class="separator:ga43ce7ca97f2e668c73975d5048bd40dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a277eb9f504bd705903df678f91c3a7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6a277eb9f504bd705903df678f91c3a7">regina::PacketListener::childrenWereReordered</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet)</td></tr>
<tr class="memdesc:ga6a277eb9f504bd705903df678f91c3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the child packets directly beneath the packet have been reordered.  <a href="group__packet.html#ga6a277eb9f504bd705903df678f91c3a7">More...</a><br /></td></tr>
<tr class="separator:ga6a277eb9f504bd705903df678f91c3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c075ad56fc5bd7cde9e971693f3867"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867">regina::PacketListener::childToBeRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gaf0c075ad56fc5bd7cde9e971693f3867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before one of this packet's immediate children has its label or tags changed.  <a href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867">More...</a><br /></td></tr>
<tr class="separator:gaf0c075ad56fc5bd7cde9e971693f3867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad546812ede412a4c7583edf323d6a54a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad546812ede412a4c7583edf323d6a54a">regina::PacketListener::childWasRenamed</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *packet, <a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gad546812ede412a4c7583edf323d6a54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after one of this packet's immediate children has its label or tags changed.  <a href="group__packet.html#gad546812ede412a4c7583edf323d6a54a">More...</a><br /></td></tr>
<tr class="separator:gad546812ede412a4c7583edf323d6a54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23c67850c87e226f435b85a7b7ddd43"><td class="memItemLeft" align="right" valign="top"><a id="gaa23c67850c87e226f435b85a7b7ddd43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PacketListener::PacketListener</b> (const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;)=delete</td></tr>
<tr class="separator:gaa23c67850c87e226f435b85a7b7ddd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ada20d9f3cd4ebf4d08651ecc9b23c0"><td class="memItemLeft" align="right" valign="top"><a id="ga4ada20d9f3cd4ebf4d08651ecc9b23c0"></a>
<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::PacketListener::operator=</b> (const <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> &amp;)=delete</td></tr>
<tr class="separator:ga4ada20d9f3cd4ebf4d08651ecc9b23c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac869caf59c0e19e27006cb67d5742977"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac869caf59c0e19e27006cb67d5742977">regina::PacketListener::PacketListener</a> ()=default</td></tr>
<tr class="memdesc:gac869caf59c0e19e27006cb67d5742977"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default constructor that does nothing.  <a href="group__packet.html#gac869caf59c0e19e27006cb67d5742977">More...</a><br /></td></tr>
<tr class="separator:gac869caf59c0e19e27006cb67d5742977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:ga8bdfa10b9c80b9f36c54097a64977d4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">regina::Packet::Packet</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>=0)</td></tr>
<tr class="memdesc:ga8bdfa10b9c80b9f36c54097a64977d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that inserts the new packet into the overall tree structure.  <a href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">More...</a><br /></td></tr>
<tr class="separator:ga8bdfa10b9c80b9f36c54097a64977d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5fc332c4380895ff045b21025703b16"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad5fc332c4380895ff045b21025703b16">regina::Packet::~Packet</a> ()</td></tr>
<tr class="memdesc:gad5fc332c4380895ff045b21025703b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that also orphans this packet and destroys all of its descendants.  <a href="group__packet.html#gad5fc332c4380895ff045b21025703b16">More...</a><br /></td></tr>
<tr class="separator:gad5fc332c4380895ff045b21025703b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">regina::Packet::safeDelete</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either destroys or orphans the given packet, according to whether it has safe pointers that currently reference it.  <a href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">More...</a><br /></td></tr>
<tr class="separator:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Packet Identification</h2></td></tr>
<tr class="memitem:ga11e183185ea0a33e67e2574fc93c7469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">regina::Packet::type</a> () const =0</td></tr>
<tr class="memdesc:ga11e183185ea0a33e67e2574fc93c7469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet.  <a href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">More...</a><br /></td></tr>
<tr class="separator:ga11e183185ea0a33e67e2574fc93c7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787a09ec531988778fcfb0bc87effdd4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">regina::Packet::typeName</a> () const =0</td></tr>
<tr class="memdesc:ga787a09ec531988778fcfb0bc87effdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet.  <a href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">More...</a><br /></td></tr>
<tr class="separator:ga787a09ec531988778fcfb0bc87effdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">regina::Packet::label</a> () const</td></tr>
<tr class="memdesc:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">More...</a><br /></td></tr>
<tr class="separator:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfaee615502b79cbeef31628a1186dc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">regina::Packet::humanLabel</a> () const</td></tr>
<tr class="memdesc:gadfaee615502b79cbeef31628a1186dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">More...</a><br /></td></tr>
<tr class="separator:gadfaee615502b79cbeef31628a1186dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">regina::Packet::adornedLabel</a> (const std::string &amp;adornment) const</td></tr>
<tr class="memdesc:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string.  <a href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">More...</a><br /></td></tr>
<tr class="separator:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd869991cbf664891629f21a5432b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfd869991cbf664891629f21a5432b02">regina::Packet::setLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:gadfd869991cbf664891629f21a5432b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="group__packet.html#gadfd869991cbf664891629f21a5432b02">More...</a><br /></td></tr>
<tr class="separator:gadfd869991cbf664891629f21a5432b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f5775c175a56d06da14444b391ed3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">regina::Packet::fullName</a> () const</td></tr>
<tr class="memdesc:ga29f5775c175a56d06da14444b391ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet.  <a href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">More...</a><br /></td></tr>
<tr class="separator:ga29f5775c175a56d06da14444b391ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tags</h2></td></tr>
<tr class="memitem:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">regina::Packet::hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:gaf4315a8b8ebcf47e781c204927f8845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">More...</a><br /></td></tr>
<tr class="separator:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4404beade84983a4f1c051cd64035ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">regina::Packet::hasTags</a> () const</td></tr>
<tr class="memdesc:ga4404beade84983a4f1c051cd64035ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">More...</a><br /></td></tr>
<tr class="separator:ga4404beade84983a4f1c051cd64035ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">regina::Packet::addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">More...</a><br /></td></tr>
<tr class="separator:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">regina::Packet::removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">More...</a><br /></td></tr>
<tr class="separator:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">regina::Packet::removeAllTags</a> ()</td></tr>
<tr class="memdesc:gaee2405989e058dbfddf7ae445d47ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">More...</a><br /></td></tr>
<tr class="separator:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d41356ff086d078b04f34919aac26d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">regina::Packet::tags</a> () const</td></tr>
<tr class="memdesc:ga06d41356ff086d078b04f34919aac26d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">More...</a><br /></td></tr>
<tr class="separator:ga06d41356ff086d078b04f34919aac26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Event Handling</h2></td></tr>
<tr class="memitem:gaa504cfa813a3190c00337743915ffef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">regina::Packet::listen</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gaa504cfa813a3190c00337743915ffef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">More...</a><br /></td></tr>
<tr class="separator:gaa504cfa813a3190c00337743915ffef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">regina::Packet::isListening</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">More...</a><br /></td></tr>
<tr class="separator:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71b40cd2416de174bba61db2ec92f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">regina::Packet::unlisten</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gae71b40cd2416de174bba61db2ec92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">More...</a><br /></td></tr>
<tr class="separator:gae71b40cd2416de174bba61db2ec92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tree Queries</h2></td></tr>
<tr class="memitem:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">regina::Packet::parent</a> () const</td></tr>
<tr class="memdesc:gab80d6d7bc86d4600980f0c9555bb6237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">More...</a><br /></td></tr>
<tr class="separator:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">regina::Packet::firstChild</a> () const</td></tr>
<tr class="memdesc:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">More...</a><br /></td></tr>
<tr class="separator:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">regina::Packet::lastChild</a> () const</td></tr>
<tr class="memdesc:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">More...</a><br /></td></tr>
<tr class="separator:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">regina::Packet::nextSibling</a> () const</td></tr>
<tr class="memdesc:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">More...</a><br /></td></tr>
<tr class="separator:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84decda10642eccee55a109e70e10076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga84decda10642eccee55a109e70e10076">regina::Packet::prevSibling</a> () const</td></tr>
<tr class="memdesc:ga84decda10642eccee55a109e70e10076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="group__packet.html#ga84decda10642eccee55a109e70e10076">More...</a><br /></td></tr>
<tr class="separator:ga84decda10642eccee55a109e70e10076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">regina::Packet::root</a> () const</td></tr>
<tr class="memdesc:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">More...</a><br /></td></tr>
<tr class="separator:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">regina::Packet::levelsDownTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">More...</a><br /></td></tr>
<tr class="separator:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">regina::Packet::levelsUpTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *ancestor) const</td></tr>
<tr class="memdesc:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">More...</a><br /></td></tr>
<tr class="separator:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">regina::Packet::isGrandparentOf</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">More...</a><br /></td></tr>
<tr class="separator:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">regina::Packet::countChildren</a> () const</td></tr>
<tr class="memdesc:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet.  <a href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">More...</a><br /></td></tr>
<tr class="separator:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">regina::Packet::countDescendants</a> () const</td></tr>
<tr class="memdesc:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of strict descendants of this packet.  <a href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">More...</a><br /></td></tr>
<tr class="separator:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2519c2dac8e039b7acd5df8373c608d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">regina::Packet::totalTreeSize</a> () const</td></tr>
<tr class="memdesc:gae2519c2dac8e039b7acd5df8373c608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">More...</a><br /></td></tr>
<tr class="separator:gae2519c2dac8e039b7acd5df8373c608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Tree Manipulation</h2></td></tr>
<tr class="memitem:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">regina::Packet::insertChildFirst</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gac389781f5c53a7d3aac3206d51ecfd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">More...</a><br /></td></tr>
<tr class="separator:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">regina::Packet::insertChildLast</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gad3d02be74192f03b372a4195c9e5bc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">More...</a><br /></td></tr>
<tr class="separator:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9556e8405ca88517ccd5549471fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">regina::Packet::insertChildAfter</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newChild, <a class="el" href="classregina_1_1Packet.html">Packet</a> *prevChild)</td></tr>
<tr class="memdesc:gad7f9556e8405ca88517ccd5549471fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">More...</a><br /></td></tr>
<tr class="separator:gad7f9556e8405ca88517ccd5549471fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">regina::Packet::makeOrphan</a> ()</td></tr>
<tr class="memdesc:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree.  <a href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">More...</a><br /></td></tr>
<tr class="separator:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">regina::Packet::reparent</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent, bool first=false)</td></tr>
<tr class="memdesc:ga219920e1523d3edf2982da0a3ba1a33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">More...</a><br /></td></tr>
<tr class="separator:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">regina::Packet::transferChildren</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent)</td></tr>
<tr class="memdesc:ga27ce736503ede9e8c57fb5d169e6414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">More...</a><br /></td></tr>
<tr class="separator:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765186c1742fe402922433b77e5f439a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga765186c1742fe402922433b77e5f439a">regina::Packet::swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:ga765186c1742fe402922433b77e5f439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="group__packet.html#ga765186c1742fe402922433b77e5f439a">More...</a><br /></td></tr>
<tr class="separator:ga765186c1742fe402922433b77e5f439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">regina::Packet::moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">More...</a><br /></td></tr>
<tr class="separator:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adc13b6143cf994779796077aed731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga59adc13b6143cf994779796077aed731">regina::Packet::moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:ga59adc13b6143cf994779796077aed731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="group__packet.html#ga59adc13b6143cf994779796077aed731">More...</a><br /></td></tr>
<tr class="separator:ga59adc13b6143cf994779796077aed731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d7730c57940444bf7d3085459449e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">regina::Packet::moveToFirst</a> ()</td></tr>
<tr class="memdesc:gab4d7730c57940444bf7d3085459449e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">More...</a><br /></td></tr>
<tr class="separator:gab4d7730c57940444bf7d3085459449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">regina::Packet::moveToLast</a> ()</td></tr>
<tr class="memdesc:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">More...</a><br /></td></tr>
<tr class="separator:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91bc951714dc60db12810affb266b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">regina::Packet::sortChildren</a> ()</td></tr>
<tr class="memdesc:gaf91bc951714dc60db12810affb266b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">More...</a><br /></td></tr>
<tr class="separator:gaf91bc951714dc60db12810affb266b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Searching and Iterating</h2></td></tr>
<tr class="memitem:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">regina::Packet::begin</a> ()</td></tr>
<tr class="memdesc:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">More...</a><br /></td></tr>
<tr class="separator:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941baf3f572331538ec82154fd3dc997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">regina::Packet::end</a> ()</td></tr>
<tr class="memdesc:ga941baf3f572331538ec82154fd3dc997"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">More...</a><br /></td></tr>
<tr class="separator:ga941baf3f572331538ec82154fd3dc997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">regina::Packet::descendants</a> () const</td></tr>
<tr class="memdesc:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through all strict descendants of this packet in the packet tree.  <a href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">More...</a><br /></td></tr>
<tr class="separator:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17dd27f603463f226e64ccb65211060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">regina::Packet::children</a> () const</td></tr>
<tr class="memdesc:gaf17dd27f603463f226e64ccb65211060"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through the immediate children of this packet.  <a href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">More...</a><br /></td></tr>
<tr class="separator:gaf17dd27f603463f226e64ccb65211060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">regina::Packet::nextTreePacket</a> ()</td></tr>
<tr class="memdesc:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">More...</a><br /></td></tr>
<tr class="separator:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">regina::Packet::nextTreePacket</a> () const</td></tr>
<tr class="memdesc:gaeaff341860febcb3daadd1b9b4216c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">More...</a><br /></td></tr>
<tr class="separator:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e196f0f1c415b457df17f96d5b6518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">regina::Packet::firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga12e196f0f1c415b457df17f96d5b6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">More...</a><br /></td></tr>
<tr class="separator:ga12e196f0f1c415b457df17f96d5b6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">regina::Packet::firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">More...</a><br /></td></tr>
<tr class="separator:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">regina::Packet::nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">More...</a><br /></td></tr>
<tr class="separator:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74345507fd3326dc1b22a284b90da5d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">regina::Packet::nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga74345507fd3326dc1b22a284b90da5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">More...</a><br /></td></tr>
<tr class="separator:ga74345507fd3326dc1b22a284b90da5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">regina::Packet::findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">More...</a><br /></td></tr>
<tr class="separator:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7855ea352221d498d1ca38a34d85af5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">regina::Packet::findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>) const</td></tr>
<tr class="memdesc:gac7855ea352221d498d1ca38a34d85af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">More...</a><br /></td></tr>
<tr class="separator:gac7855ea352221d498d1ca38a34d85af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Packet Dependencies</h2></td></tr>
<tr class="memitem:ga36260b904a2bf98d9484869267ddf7b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet::dependsOnParent</a> () const =0</td></tr>
<tr class="memdesc:ga36260b904a2bf98d9484869267ddf7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">More...</a><br /></td></tr>
<tr class="separator:ga36260b904a2bf98d9484869267ddf7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">regina::Packet::isPacketEditable</a> () const</td></tr>
<tr class="memdesc:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children.  <a href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">More...</a><br /></td></tr>
<tr class="separator:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Cloning</h2></td></tr>
<tr class="memitem:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">regina::Packet::clone</a> (bool cloneDescendants=false, bool <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>=true) const</td></tr>
<tr class="memdesc:ga73c411ef1237a06ad6b634d3db67f17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">More...</a><br /></td></tr>
<tr class="separator:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">File I/O</h2></td></tr>
<tr class="memitem:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">regina::Packet::save</a> (const char *filename, bool compressed=true) const</td></tr>
<tr class="memdesc:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">More...</a><br /></td></tr>
<tr class="separator:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">regina::Packet::save</a> (std::ostream &amp;s, bool compressed=true) const</td></tr>
<tr class="memdesc:ga898ec49e8d39c46cd965ad506493f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">More...</a><br /></td></tr>
<tr class="separator:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">regina::Packet::writeXMLFile</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga0bf681a968d890cd848f1277ea22ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">More...</a><br /></td></tr>
<tr class="separator:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">regina::Packet::internalID</a> () const</td></tr>
<tr class="memdesc:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">More...</a><br /></td></tr>
<tr class="separator:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f48a115e3ad5912a038c8d00900eae1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6f48a115e3ad5912a038c8d00900eae1">regina::Packet::xmlReader</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga6f48a115e3ad5912a038c8d00900eae1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created XML element reader that will read the contents of a single XML packet element.  <a href="group__packet.html#ga6f48a115e3ad5912a038c8d00900eae1">More...</a><br /></td></tr>
<tr class="separator:ga6f48a115e3ad5912a038c8d00900eae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5646f70dfe6c538387ebc2148fc69dd8"><td class="memItemLeft" align="right" valign="top"><a id="ga5646f70dfe6c538387ebc2148fc69dd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::Packet</b> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;)=delete</td></tr>
<tr class="separator:ga5646f70dfe6c538387ebc2148fc69dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62521bbc99fbaf225e511b1d4d20282d"><td class="memItemLeft" align="right" valign="top"><a id="ga62521bbc99fbaf225e511b1d4d20282d"></a>
<a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Packet::operator=</b> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> &amp;)=delete</td></tr>
<tr class="separator:ga62521bbc99fbaf225e511b1d4d20282d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd4d2e82e583276a70128d952b46bd53"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const =0</td></tr>
<tr class="memdesc:gacd4d2e82e583276a70128d952b46bd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">More...</a><br /></td></tr>
<tr class="separator:gacd4d2e82e583276a70128d952b46bd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">regina::Packet::writeXMLPacketTree</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the subtree with this packet as matriarch.  <a href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">More...</a><br /></td></tr>
<tr class="separator:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7efec42b4c85d5590a07a0184bb3b0ec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet::writeXMLPacketData</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga7efec42b4c85d5590a07a0184bb3b0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">More...</a><br /></td></tr>
<tr class="separator:ga7efec42b4c85d5590a07a0184bb3b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54930e66829e2b832b2b8d5b6813e55d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet::writeTextShort</a> (std::ostream &amp;out) const =0</td></tr>
<tr class="memdesc:ga54930e66829e2b832b2b8d5b6813e55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">More...</a><br /></td></tr>
<tr class="separator:ga54930e66829e2b832b2b8d5b6813e55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet::writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">More...</a><br /></td></tr>
<tr class="separator:ga044a5c8d80d5aeb0e13a335bfc9b4ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">regina::Packet::hasOwner</a> () const</td></tr>
<tr class="memdesc:gac85ba39c124eda4ce631b653d6bb0a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object.  <a href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">More...</a><br /></td></tr>
<tr class="separator:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:gabd98cb9168c4333925f340e5f7310423"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gabd98cb9168c4333925f340e5f7310423">regina::PacketListener::~PacketListener</a> ()</td></tr>
<tr class="memdesc:gabd98cb9168c4333925f340e5f7310423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this listener.  <a href="group__packet.html#gabd98cb9168c4333925f340e5f7310423">More...</a><br /></td></tr>
<tr class="separator:gabd98cb9168c4333925f340e5f7310423"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> administration and some basic packet types. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaad9d413dab5c36f4a57d9ca811d24188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad9d413dab5c36f4a57d9ca811d24188">&#9670;&nbsp;</a></span>REGINA_PACKET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_PACKET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">public</span>: \</div>
<div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> typeID = id; \</div>
<div class="line">        inline <span class="keyword">virtual</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> type()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return id; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> std::string typeName()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return PacketInfo&lt;id&gt;::name(); \</div>
<div class="line">        }</div>
<div class="ttc" id="agroup__packet_html_ga982f45957b093a38120119066dc4cfef"><div class="ttname"><a href="group__packet.html#ga982f45957b093a38120119066dc4cfef">regina::PacketType</a></div><div class="ttdeci">PacketType</div><div class="ttdoc">Represents the different types of packet that are available in Regina.</div><div class="ttdef"><b>Definition:</b> packettype.h:57</div></div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a subclass of Packet. </p>
<p>Every subclass of Packet <em>must</em> include REGINA_PACKET at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>typeID</em> that is equal to the corresponding PacketType constant;</li>
<li>declarations and implementations of the virtual functions Packet::type() and Packet::typeName().</li>
</ul>
<p>The implementation of this macro relies on the helper class PacketInfo&lt;id&gt;. If the relevant specialisation of PacketInfo is not visible (as is the case, for instance, with templated packet classes such as Triangulation&lt;dim&gt;), then you may replace REGINA_PACKET with the macro REGINA_PACKET_FROM, which allows you to provide an alternative implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this descendant class of Packet. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding PacketType constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7b8ff3226c3356a8b73c5e46f64c268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b8ff3226c3356a8b73c5e46f64c268">&#9670;&nbsp;</a></span>REGINA_PACKET_FROM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_PACKET_FROM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">helper&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">public</span>: \</div>
<div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> typeID = helper::typeID; \</div>
<div class="line">        inline <span class="keyword">virtual</span> <a class="code" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> type()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return helper::typeID; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> std::string typeName()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return helper::name(); \</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>An alternative to REGINA_PACKET, for scenarios where the relevant PacketInfo specialisation is not visible. </p>
<p>This is intended for use with template classes such as Triangulation&lt;dim&gt;, where the corresponding PacketInfo specialisations are defined in a separate header to avoid triggering unwanted instantiations of every possible Triangulation class.</p>
<p>Like REGINA_PACKET, this macro should be placed in the definition of the relevant subclass of Packet, and in return it provides the same constants, types and virtual functions that REGINA_PACKET does. However, unlike REGINA_PACKET, it does not rely on PacketInfo for its implementation. Instead it calls upon the given class <em>helper</em>, which must provide:</p>
<ul>
<li>a compile-time constant <em>typeID</em> which is equal to the PacketType constant corresponding to this packet class;</li>
<li>a static function name() that returns a string giving the human-readable name of this packet type.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this descendant class of Packet. </td></tr>
    <tr><td class="paramname">helper</td><td>the helper class that provides the implementation details, as described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9bcdb1301b1f56d445352a56fc9973fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bcdb1301b1f56d445352a56fc9973fb">&#9670;&nbsp;</a></span>IDMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::string, <a class="el" href="classregina_1_1Packet.html">Packet</a>*&gt; <a class="el" href="group__packet.html#ga9bcdb1301b1f56d445352a56fc9973fb">regina::XMLTreeResolver::IDMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type that maps internal IDs from the data file to the corresponding packets. </p>
<p>See <a class="el" href="group__packet.html#gafef35326137566ebe6f22533d8707e28" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> for details. </p>

</div>
</div>
<a id="ga4dc907cfee17707d1409b1b4e499247c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dc907cfee17707d1409b1b4e499247c">&#9670;&nbsp;</a></span>NContainer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Container.html">Container</a> <a class="el" href="group__packet.html#ga4dc907cfee17707d1409b1b4e499247c">regina::NContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000087">Deprecated:</a></b></dt><dd>The class NContainer has now been renamed to <a class="el" href="classregina_1_1Container.html" title="A packet that simply contains other packets.">Container</a>. </dd></dl>

</div>
</div>
<a id="ga4f47ede3cd04a3b515ae8e375497a987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f47ede3cd04a3b515ae8e375497a987">&#9670;&nbsp;</a></span>NPacket</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a> <a class="el" href="group__packet.html#ga4f47ede3cd04a3b515ae8e375497a987">regina::NPacket</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000088">Deprecated:</a></b></dt><dd>The class NPacket has now been renamed to <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a>. </dd></dl>

</div>
</div>
<a id="ga58067e865d029237d3a1e0e8c39cf29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58067e865d029237d3a1e0e8c39cf29f">&#9670;&nbsp;</a></span>NPacketListener</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> <a class="el" href="group__packet.html#ga58067e865d029237d3a1e0e8c39cf29f">regina::NPacketListener</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000089">Deprecated:</a></b></dt><dd>The class NPacketListener has now been renamed to <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a>. </dd></dl>

</div>
</div>
<a id="gad4467bfb4bc172da71964a4b9967a04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4467bfb4bc172da71964a4b9967a04d">&#9670;&nbsp;</a></span>NPDF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1PDF.html">PDF</a> <a class="el" href="group__packet.html#gad4467bfb4bc172da71964a4b9967a04d">regina::NPDF</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000096">Deprecated:</a></b></dt><dd>The class NPDF has now been renamed to <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a>. </dd></dl>

</div>
</div>
<a id="ga80158507a6960da75b1f1c2c35d90148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80158507a6960da75b1f1c2c35d90148">&#9670;&nbsp;</a></span>NScript</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Script.html">Script</a> <a class="el" href="group__packet.html#ga80158507a6960da75b1f1c2c35d90148">regina::NScript</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000097">Deprecated:</a></b></dt><dd>The class NScript has now been renamed to <a class="el" href="classregina_1_1Script.html" title="A packet representing a Python script that can be run.">Script</a>. </dd></dl>

</div>
</div>
<a id="ga9581a76573ed62ddcd1623ae4963b72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9581a76573ed62ddcd1623ae4963b72d">&#9670;&nbsp;</a></span>NText</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Text.html">Text</a> <a class="el" href="group__packet.html#ga9581a76573ed62ddcd1623ae4963b72d">regina::NText</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000098">Deprecated:</a></b></dt><dd>The class NText has now been renamed to <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gabb7c46c6bbb0cfe639525d1bf5700f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb7c46c6bbb0cfe639525d1bf5700f2c">&#9670;&nbsp;</a></span>OwnershipPolicy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__packet.html#gabb7c46c6bbb0cfe639525d1bf5700f2c">regina::PDF::OwnershipPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes how a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet should claim ownership of a block of binary data. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabb7c46c6bbb0cfe639525d1bf5700f2caaab665d8c167fe6d05be283e87199361"></a>OWN_MALLOC&#160;</td><td class="fielddoc"><p>The packet should claim ownership of the block, and should assume that it was allocated using <em>malloc()</em>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb7c46c6bbb0cfe639525d1bf5700f2ca55bae618310250121649f4cf90ab4c8f"></a>OWN_NEW&#160;</td><td class="fielddoc"><p>The packet should claim ownership of the block, and should assume that it was allocated using <code>new</code>[]. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabb7c46c6bbb0cfe639525d1bf5700f2cad0a3996ebf3e955b1be0ebf0fff8e741"></a>DEEP_COPY&#160;</td><td class="fielddoc"><p>The packet should not claim ownership of the block, but should instead make its own deep copy. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga982f45957b093a38120119066dc4cfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982f45957b093a38120119066dc4cfef">&#9670;&nbsp;</a></span>PacketType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">regina::PacketType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents the different types of packet that are available in Regina. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own packet type, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefabc7680a0895a0d0540123f9e0596b38e"></a>PACKET_CONTAINER&#160;</td><td class="fielddoc"><p>Represents a container packet, of class <a class="el" href="classregina_1_1Container.html" title="A packet that simply contains other packets.">Container</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa54ede7ca089949c83b103489c1c3ad57"></a>PACKET_TEXT&#160;</td><td class="fielddoc"><p>Represents a text packet, of class <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc"></a>PACKET_NORMALSURFACES&#160;</td><td class="fielddoc"><p>Represents a normal surface list, of class <a class="el" href="classregina_1_1NormalSurfaces.html" title="A packet representing a collection of normal surfaces in a 3-manifold.">NormalSurfaces</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa44f343e9e3b4baf3b53f8943a4503f6e"></a>PACKET_SCRIPT&#160;</td><td class="fielddoc"><p>Represents a script packet, of class <a class="el" href="classregina_1_1Script.html" title="A packet representing a Python script that can be run.">Script</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa958e5099e4f7506590d6b351a9a889cf"></a>PACKET_SURFACEFILTER&#160;</td><td class="fielddoc"><p>Represents a normal surface filter, of class <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a> or one of its descendant classes. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9"></a>PACKET_ANGLESTRUCTURES&#160;</td><td class="fielddoc"><p>Represents an angle structure list, of class <a class="el" href="classregina_1_1AngleStructures.html" title="A packet representing a collection of angle structures on a triangulation.">AngleStructures</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa346e59a436dacb0d10922334f9e002e1"></a>PACKET_PDF&#160;</td><td class="fielddoc"><p>Represents a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document, of class <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e"></a>PACKET_NORMALHYPERSURFACES&#160;</td><td class="fielddoc"><p>Represents a normal hypersurface list, of class <a class="el" href="classregina_1_1NormalHypersurfaces.html" title="A packet representing a collection of normal hypersurfaces in a 4-manifold triangulation.">NormalHypersurfaces</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefac0835064733eb9d41e9db904afde7240"></a>PACKET_SNAPPEATRIANGULATION&#160;</td><td class="fielddoc"><p>Represents a triangulation in the embedded SnapPea kernel, of class <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefaa9042461f4df32b551cc9046f7d44f23"></a>PACKET_LINK&#160;</td><td class="fielddoc"><p>Represents a knot or link in the 3-sphere, of class <a class="el" href="classregina_1_1Link.html" title="Represents a directed knot or link in the 3-sphere.">Link</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815"></a>PACKET_TRIANGULATION2&#160;</td><td class="fielddoc"><p>Represents a 2-dimensional triangulation, of class <a class="el" href="classregina_1_1Triangulation_3_012_01_4.html" title="Represents a 2-manifold triangulation.">Triangulation&lt;2&gt;</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64"></a>PACKET_TRIANGULATION3&#160;</td><td class="fielddoc"><p>Represents a 3-dimensional triangulation, of class <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff"></a>PACKET_TRIANGULATION4&#160;</td><td class="fielddoc"><p>Represents a 4-dimensional triangulation, of class <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html" title="Represents a 4-dimensional triangulation, typically of a 4-manifold.">Triangulation&lt;4&gt;</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefad6af6b9c7e211662703204551c8f0a6c"></a>PACKET_TRIANGULATION5&#160;</td><td class="fielddoc"><p>Represents a 5-dimensional triangulation, of class Triangulation&lt;5&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefac241be6e856f68161d4e217b49260596"></a>PACKET_TRIANGULATION6&#160;</td><td class="fielddoc"><p>Represents a 6-dimensional triangulation, of class Triangulation&lt;6&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefae75828b18b7041a6602a41f61e900c4b"></a>PACKET_TRIANGULATION7&#160;</td><td class="fielddoc"><p>Represents a 7-dimensional triangulation, of class Triangulation&lt;7&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefadac8b650c87a395064f35d8dd7139174"></a>PACKET_TRIANGULATION8&#160;</td><td class="fielddoc"><p>Represents a 8-dimensional triangulation, of class Triangulation&lt;8&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefaae3f65ac7e3e3b14c06e866e4732f04f"></a>PACKET_TRIANGULATION9&#160;</td><td class="fielddoc"><p>Represents a 9-dimensional triangulation, of class Triangulation&lt;9&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa2e49b81db0006562994ba409db5fdbb2"></a>PACKET_TRIANGULATION10&#160;</td><td class="fielddoc"><p>Represents a 10-dimensional triangulation, of class Triangulation&lt;10&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa8239b1c5322caeb818c5dd8f3fb78ae3"></a>PACKET_TRIANGULATION11&#160;</td><td class="fielddoc"><p>Represents a 11-dimensional triangulation, of class Triangulation&lt;11&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa9abc4fbf3b98a845481d2d6a651c730f"></a>PACKET_TRIANGULATION12&#160;</td><td class="fielddoc"><p>Represents a 12-dimensional triangulation, of class Triangulation&lt;12&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa2a134929dda394ce55b128b661f68a9a"></a>PACKET_TRIANGULATION13&#160;</td><td class="fielddoc"><p>Represents a 13-dimensional triangulation, of class Triangulation&lt;13&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa7984ac7306b6a4301565b5d154daddb0"></a>PACKET_TRIANGULATION14&#160;</td><td class="fielddoc"><p>Represents a 14-dimensional triangulation, of class Triangulation&lt;14&gt;. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga982f45957b093a38120119066dc4cfefa0e5a2698ebebf778b6bc6209778cc3a3"></a>PACKET_TRIANGULATION15&#160;</td><td class="fielddoc"><p>Represents a 15-dimensional triangulation, of class Triangulation&lt;15&gt;. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa9dde3d8d3d8d189d355e1b186f1b83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9dde3d8d3d8d189d355e1b186f1b83a">&#9670;&nbsp;</a></span>abort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLPacketReader::abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that XML parsing has been aborted. </p>
<p>This element reader will be destroyed shortly after this routine is called.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subReader</td><td>the corresponding child reader if a subelement is currently being parsed, or 0 otherwise. If this parameter is non-zero, it is guaranteed that <a class="el" href="group__packet.html#gaa9dde3d8d3d8d189d355e1b186f1b83a" title="Signifies that XML parsing has been aborted.">abort()</a> has already been called upon the child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga999849c75bd67f6cc2e97c50f89cedf1">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga982b9936f9e9dc11ce932d4e8c7402de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982b9936f9e9dc11ce932d4e8c7402de">&#9670;&nbsp;</a></span>addTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::addTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associates the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tag is not the empty string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was successfully added, or <code>false</code> if the given tag was already present beforehand. </dd></dl>

</div>
</div>
<a id="gad6b20607a3d3c79f00455841cf995df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b20607a3d3c79f00455841cf995df5">&#9670;&nbsp;</a></span>addVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Script::addVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to add a new variable to be associated with this script. </p>
<p>If a variable with the given name is already stored, this routine will do nothing.</p>
<p>If you need to ensure that a new variable is always added, even if the variable name needs to change, see the routine <a class="el" href="group__packet.html#ga57c7b7c5ee615aa61e8c6b31056634ae" title="Adds a new variable to be associated with this script, changing its name if necessary.">addVariableName()</a> instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>The index of the new variable might not be <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1, and this operation may change the indices of other variables also. This is because (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the new variable. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the new variable; this is allowed to be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the variable was successfully added, or <code>false</code> if a variable with the given name was already stored. </dd></dl>

</div>
</div>
<a id="ga57c7b7c5ee615aa61e8c6b31056634ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57c7b7c5ee615aa61e8c6b31056634ae">&#9670;&nbsp;</a></span>addVariableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; regina::Script::addVariableName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new variable to be associated with this script, changing its name if necessary. </p>
<p>If the given variable name does not already exist as a variable name in this script, then it will be used without modification. Otherwise a new variable name will be constructed by appending additional characters to <em>name</em>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The index of the new variable might not be <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1, and this operation may change the indices of other variables also. This is because (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the string upon which the new variable name will be based. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the new variable; this is allowed to be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the variable that was added; this might or might not be equal to <em>name</em>. </dd></dl>

</div>
</div>
<a id="gae1cd6eea63e8cd41d7517f86b8c7776d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1cd6eea63e8cd41d7517f86b8c7776d">&#9670;&nbsp;</a></span>adornedLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::adornedLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adornment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string. </p>
<p>An adornment typically shows how a packet has been created and/or modified. For instance, the <em>adornment</em> argument might be "Filled", or "Summand #1".</p>
<p>The way in which the packet label is adorned depends upon the label itself (in particular, an empty packet label will be handled in a sensible way). The way in which the packet label is adorned is subject to change in future versions of Regina.</p>
<p>Note that, whilst this routine returns a modified version of the packet label, the label itself will not be permamently changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adornment</td><td>the string that will be used to adorn this packet label. The adornment should just be a piece of English, ideally beginning with an upper-case letter. It should not contain any surrounding punctuation such as brackets or a dash (this will be added automatically by this routine as required). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the packet label with the given adornment. </dd></dl>

</div>
</div>
<a id="ga6c90e10216b1d5f2a641669e57a09865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c90e10216b1d5f2a641669e57a09865">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extraText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given text to the end of this script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraText</td><td>the text to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7ab56cf7ba6ebdc6176b1b4bc2cb287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::Packet::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of packets in the subtree rooted at this packet. </p>
<p>Subtree iteration is depth-first, where a parent packet is always processed before its descendants. Therefore the iterator returned by <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> will always point to this packet itself.</p>
<p>The <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a> routines allow you to iterate through an entire packet subtree using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* subtree = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* p : *subtree) { ... }</div>
<div class="ttc" id="agroup__packet_html_ga8bdfa10b9c80b9f36c54097a64977d4c"><div class="ttname"><a href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">regina::Packet::Packet</a></div><div class="ttdeci">Packet(Packet *parent=0)</div><div class="ttdoc">Constructor that inserts the new packet into the overall tree structure.</div><div class="ttdef"><b>Definition:</b> packet.h:2538</div></div>
</div><!-- fragment --><p>In Python, each packet can be treated as an iterable object, again iterating through the corresponding subtree:</p>
<div class="fragment"><div class="line">subtree = ...</div>
<div class="line"><span class="keywordflow">for</span> p <span class="keywordflow">in</span> subtree:</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>See also <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a> for iterating through just the strict descendants in the subtree (i.e., excluding this packet itself), and <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating just through the immediate children of this packet (not the full subtree).</p>
<dl class="section note"><dt>Note</dt><dd>This routine is non-const because <em>dereferencing</em> a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> returns a non-const packet pointer.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>As well as treating each packet as an iterable object, Regina supplies a member function <code>Packet.subtree()</code> which returns an iterable object. Iterating over a packet directly is exactly the same as iterating over <code>Packet.subtree()</code>; the latter is offered because it may be clearer for readers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this subtree. </dd></dl>

</div>
</div>
<a id="gac7e5ca15289b85b0630d07ac1da20c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7e5ca15289b85b0630d07ac1da20c84">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> regina::PacketChildren::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of children. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code><b>iter</b>()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning iterator. </dd></dl>

</div>
</div>
<a id="gae24129e2bed4ad821ec55526ef68abfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae24129e2bed4ad821ec55526ef68abfc">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::PacketDescendants::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of strict descendants. </p>
<p>This will point to the first child packet (if one exists) of the packet whose descendants we are iterating over.</p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code><b>iter</b>()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the beginning iterator. </dd></dl>

</div>
</div>
<a id="ga089c4f6e4b1989fe9c89653091e6321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga089c4f6e4b1989fe9c89653091e6321e">&#9670;&nbsp;</a></span>ChangeEventSpan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Packet::ChangeEventSpan::ChangeEventSpan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new change event object for the given packet. </p>
<p>If this is the only <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a> currently in existence for the given packet, this constructor will call <a class="el" href="group__packet.html#gacec00b1f4665c352ca6638819a7f7221" title="Called before the contents of the packet are to be changed.">PacketListener::packetToBeChanged()</a> for all registered listeners for the given packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet whose data is about to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad369e1b9117672269c40c2e1dc75b2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad369e1b9117672269c40c2e1dc75b2d9">&#9670;&nbsp;</a></span>ChildIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ChildIterator::ChildIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a past-the-end iterator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> is via <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>. </dd></dl>

</div>
</div>
<a id="gab25e416c2756416f8faff87583566422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab25e416c2756416f8faff87583566422">&#9670;&nbsp;</a></span>ChildIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ChildIterator::ChildIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> is via <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>. </dd></dl>

</div>
</div>
<a id="ga075232d3523eb9c5974eaf0ce2163489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga075232d3523eb9c5974eaf0ce2163489">&#9670;&nbsp;</a></span>ChildIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::ChildIterator::ChildIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>current</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the given child packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1ChildIterator.html" title="A forward iterator for iterating through all immediate children of a given packet.">ChildIterator</a> is via <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">Packet::children()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>the child packet that the new iterator should point to, or 0 if the new iterator should be past-the-end. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf17dd27f603463f226e64ccb65211060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf17dd27f603463f226e64ccb65211060">&#9670;&nbsp;</a></span>children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> regina::Packet::children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through the immediate children of this packet. </p>
<p>This routine allows you to iterate through the immediate children of a given packet using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a> = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* child : <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>-&gt;<a class="code" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">children</a>()) { ... }</div>
<div class="ttc" id="agroup__packet_html_gab80d6d7bc86d4600980f0c9555bb6237"><div class="ttname"><a href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">regina::Packet::parent</a></div><div class="ttdeci">Packet * parent() const</div><div class="ttdoc">Determines the parent packet in the tree structure.</div><div class="ttdef"><b>Definition:</b> packet.h:2587</div></div>
<div class="ttc" id="agroup__packet_html_gaf17dd27f603463f226e64ccb65211060"><div class="ttname"><a href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">regina::Packet::children</a></div><div class="ttdeci">PacketChildren children() const</div><div class="ttdoc">Returns a lightweight object for iterating through the immediate children of this packet.</div><div class="ttdef"><b>Definition:</b> packet.h:2631</div></div>
</div><!-- fragment --><p>In Python, this routine returns an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div>
<div class="line"><span class="keywordflow">for</span> child <span class="keywordflow">in</span> parent.children():</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>This function returns a lightweight object in the sense that it does not generate a full list of children in advance, but instead just returns a small iterator that visits each child as required. In particular, this routine has small constant time and memory.</p>
<p>See <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a>, as well as <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">descendants()</a>, for iterating through the subtree rooted at this packet (not just the immediate children).</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the children of this packet. </dd></dl>

</div>
</div>
<a id="ga43ce7ca97f2e668c73975d5048bd40dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43ce7ca97f2e668c73975d5048bd40dd">&#9670;&nbsp;</a></span>childrenToBeReordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childrenToBeReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the child packets directly beneath the packet are to be reordered. </p>
<p>Once the reordering is done, <a class="el" href="group__packet.html#ga6a277eb9f504bd705903df678f91c3a7" title="Called after the child packets directly beneath the packet have been reordered.">childrenWereReordered()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a277eb9f504bd705903df678f91c3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a277eb9f504bd705903df678f91c3a7">&#9670;&nbsp;</a></span>childrenWereReordered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childrenWereReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the child packets directly beneath the packet have been reordered. </p>
<p>Before this reordering is done, <a class="el" href="group__packet.html#ga43ce7ca97f2e668c73975d5048bd40dd" title="Called before the child packets directly beneath the packet are to be reordered.">childrenToBeReordered()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0db49c766578d5d0f3b13cf5a6244a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db49c766578d5d0f3b13cf5a6244a43">&#9670;&nbsp;</a></span>childToBeAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childToBeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be inserted directly beneath the packet. </p>
<p>Once the child is inserted, <a class="el" href="group__packet.html#gadffc274996ce2bfe35a85bc2cf7209ee" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9953ae63b9b29634faeb5f36ba34ab91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9953ae63b9b29634faeb5f36ba34ab91">&#9670;&nbsp;</a></span>childToBeRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childToBeRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be removed from directly beneath the packet. </p>
<p>Once the child is removed, <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called also.</p>
<p>Be warned: we could already be inside either this packet's or the child packet's destructor:</p>
<ul>
<li>If this packet is being destroyed, then it will orphan all of its children, and then (unless they are being mananged by <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> safe pointers) it will delete these children also. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called <em>before</em> the child is destroyed. For both functions, <em>packet</em> will be passed as <code>null</code> (since the parent packet is already well into its destruction process).</li>
<li>If the child packet is being destroyed (but the parent is not), then it will be orphaned as part of its destructor. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called from within the child destructor, and <em>child</em> will be passed as <code>null</code> to both functions.</li>
</ul>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to, or <code>null</code> if this routine is being called from within this packet's destructor. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be removed, or <code>null</code> if this routine is being called from within the child's destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0c075ad56fc5bd7cde9e971693f3867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c075ad56fc5bd7cde9e971693f3867">&#9670;&nbsp;</a></span>childToBeRenamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before one of this packet's immediate children has its label or tags changed. </p>
<p>Before this change, <a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> </dd></dl>

</div>
</div>
<a id="gadffc274996ce2bfe35a85bc2cf7209ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadffc274996ce2bfe35a85bc2cf7209ee">&#9670;&nbsp;</a></span>childWasAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childWasAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been inserted directly beneath the packet. </p>
<p>Before this child is added, <a class="el" href="group__packet.html#ga0db49c766578d5d0f3b13cf5a6244a43" title="Called before a child packet is to be inserted directly beneath the packet.">childToBeAdded()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9528b072f69513fba62e382c9c2aed22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9528b072f69513fba62e382c9c2aed22">&#9670;&nbsp;</a></span>childWasRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childWasRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been removed from directly beneath the packet. </p>
<p>Before the child is removed, <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> will be called also.</p>
<p>Be warned: we could already be inside either this packet's or the child packet's destructor:</p>
<ul>
<li>If this packet is being destroyed, then it will orphan all of its children, and then (unless they are being mananged by <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> safe pointers) it will delete these children also. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called <em>before</em> the child is destroyed. For both functions, <em>packet</em> will be passed as <code>null</code> (since the parent packet is already well into its destruction process).</li>
<li>If the child packet is being destroyed (but the parent is not), then it will be orphaned as part of its destructor. In such a situation, both listener functions <a class="el" href="group__packet.html#ga9953ae63b9b29634faeb5f36ba34ab91" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> and <a class="el" href="group__packet.html#ga9528b072f69513fba62e382c9c2aed22" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called from within the child destructor, and <em>child</em> will be passed as <code>null</code> to both functions.</li>
</ul>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to, or <code>null</code> if this routine is being called from within this packet's destructor. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was removed, or <code>null</code> if this routine is being called from within the child's destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad546812ede412a4c7583edf323d6a54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad546812ede412a4c7583edf323d6a54a">&#9670;&nbsp;</a></span>childWasRenamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::childWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after one of this packet's immediate children has its label or tags changed. </p>
<p>Before this change, <a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> </dd></dl>

</div>
</div>
<a id="ga73c411ef1237a06ad6b634d3db67f17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73c411ef1237a06ad6b634d3db67f17d">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneDescendants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet. </p>
<p>Note that any string tags associated with this packet will <em>not</em> be cloned.</p>
<p>If this packet has no parent in the tree structure, no clone will be created and 0 will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneDescendants</td><td><code>true</code> if the descendants of this packet should also be cloned and inserted as descendants of the new packet. If this is passed as <code>false</code> (the default), only this packet will be cloned. </td></tr>
    <tr><td class="paramname">end</td><td><code>true</code> if the new packet should be inserted at the end of the parent's list of children (the default), or <code>false</code> if the new packet should be inserted as the sibling immediately after this packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly inserted packet, or 0 if this packet has no parent. </dd></dl>

</div>
</div>
<a id="ga50387f979321ede9f79c1cd7fb15304a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50387f979321ede9f79c1cd7fb15304a">&#9670;&nbsp;</a></span>Container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Container::Container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="ga0ff5a19504faae584888652a659b45dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ff5a19504faae584888652a659b45dc">&#9670;&nbsp;</a></span>Container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Container::Container </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new container with the given packet label. </p>
<p>This constructor is (for example) helpful when you are building a complex packet tree to save to a Regina data file, and you are using containers to organise the data in this tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the packet label for this new container. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2df11b3b1cecdfbce1a4c53bd1a0395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2df11b3b1cecdfbce1a4c53bd1a0395">&#9670;&nbsp;</a></span>countChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet. </p>
<p>Grandchildren and so on are not counted.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of immediate children. </dd></dl>

</div>
</div>
<a id="ga33da88ebed1a4ceccdf70172eff4e3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33da88ebed1a4ceccdf70172eff4e3f1">&#9670;&nbsp;</a></span>countDescendants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of strict descendants of this packet. </p>
<p>This includes children, grandchildren and so on. This packet is not included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of strict descendants. </dd></dl>

</div>
</div>
<a id="gabdf82c530167301864f61c86d4fcdbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdf82c530167301864f61c86d4fcdbe4">&#9670;&nbsp;</a></span>countVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Script::countVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of variables associated with this script. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables. </dd></dl>

</div>
</div>
<a id="ga815e18c6ed85bd0dbfc957466239f2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga815e18c6ed85bd0dbfc957466239f2cd">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * regina::PDF::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a pointer to the block of raw data that forms this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document. </p>
<p>The number of bytes in this block can be found by calling <a class="el" href="group__packet.html#ga5ae1d5476b568afe205223d8fb10563c" title="Returns the size of this PDF document in bytes.">size()</a>.</p>
<p>If no <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document is currently stored (i.e., <a class="el" href="group__packet.html#ga71eb9786bd9f73c340450b1628331039" title="Determines whether this packet is currently holding a PDF document.">isNull()</a> returns <code>true</code>), then this routine will return a null pointer.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the raw <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> data. </dd></dl>

</div>
</div>
<a id="ga36260b904a2bf98d9484869267ddf7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36260b904a2bf98d9484869267ddf7b5">&#9670;&nbsp;</a></span>dependsOnParent() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::Packet::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implemented in <a class="el" href="group__generic.html#ga88d1148417898781dba0769484711989">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="group__generic.html#ga88d1148417898781dba0769484711989">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="group__dim4.html#ga52891e48cbed1c50e5960b9977e45b67">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="group__dim3.html#ga937b00d0472570d29436cacecbaf701a">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="group__dim2.html#ga0a9012ef8d3274d1bbb4a5b57d7a43c0">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="group__surfaces.html#ga2cbf1c1dc39ca6a9792124e129ab54b4">regina::SurfaceFilter</a>, <a class="el" href="group__surfaces.html#gad33634993b549ee12249b97a019fe002">regina::NormalSurfaces</a>, <a class="el" href="group__snappea.html#ga69a2d5c64038c031ca6626b4fbc80175">regina::SnapPeaTriangulation</a>, <a class="el" href="group__packet.html#ga6e1640a424aa67f2ff1e406871fa63a6">regina::Text</a>, <a class="el" href="group__packet.html#ga4f1e07ef835c561938bf2f36cb48e438">regina::Script</a>, <a class="el" href="group__packet.html#ga845af51beb787b3de5ef34912c438457">regina::PDF</a>, <a class="el" href="group__packet.html#ga56c1588e7b5f30f8c5b70047c2b70fdc">regina::Container</a>, <a class="el" href="group__link.html#ga34359ae0aeda30012164cd24256dd29d">regina::Link</a>, <a class="el" href="group__hypersurface.html#ga56057aabcc51c84ea924dd68f2e1326a">regina::NormalHypersurfaces</a>, and <a class="el" href="group__angle.html#ga7c5ac676fbceae4514b483fb661a11c9">regina::AngleStructures</a>.</p>

</div>
</div>
<a id="ga56c1588e7b5f30f8c5b70047c2b70fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56c1588e7b5f30f8c5b70047c2b70fdc">&#9670;&nbsp;</a></span>dependsOnParent() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Container::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga845af51beb787b3de5ef34912c438457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga845af51beb787b3de5ef34912c438457">&#9670;&nbsp;</a></span>dependsOnParent() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PDF::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga4f1e07ef835c561938bf2f36cb48e438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f1e07ef835c561938bf2f36cb48e438">&#9670;&nbsp;</a></span>dependsOnParent() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Script::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga6e1640a424aa67f2ff1e406871fa63a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e1640a424aa67f2ff1e406871fa63a6">&#9670;&nbsp;</a></span>dependsOnParent() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Text::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga4cf495d57c19d371358ba5e9955a6dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cf495d57c19d371358ba5e9955a6dc5">&#9670;&nbsp;</a></span>descendants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> regina::Packet::descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through all strict descendants of this packet in the packet tree. </p>
<p>The order of iteration is exactly the same as when iterating over the full subtree rooted at this packet (as offered by <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">Packet::begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">Packet::end()</a>), except that the iteration <em>excludes</em> this packet itself. In particular, the iteration is depth-first, and each packet in the subtree is processed before its own descendants.</p>
<p>This routine allows you to iterate through all strict descendants of a given packet using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a> = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__packet.html#ga8bdfa10b9c80b9f36c54097a64977d4c">Packet</a>* desc : <a class="code" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>-&gt;<a class="code" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">descendants</a>()) { ... }</div>
<div class="ttc" id="agroup__packet_html_ga4cf495d57c19d371358ba5e9955a6dc5"><div class="ttname"><a href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">regina::Packet::descendants</a></div><div class="ttdeci">PacketDescendants descendants() const</div><div class="ttdoc">Returns a lightweight object for iterating through all strict descendants of this packet in the packe...</div><div class="ttdef"><b>Definition:</b> packet.h:2627</div></div>
</div><!-- fragment --><p>In Python, this routine returns an iterable object:</p>
<div class="fragment"><div class="line">parent = ...</div>
<div class="line"><span class="keywordflow">for</span> desc <span class="keywordflow">in</span> parent.descendants():</div>
<div class="line">    ...</div>
</div><!-- fragment --><p>This function returns a lightweight object in the sense that it does not generate a full list of descendants in advance, but instead just returns a small iterator that visits each descendant as required. In particular, this routine has small constant time and memory.</p>
<p>See also <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a> for iterating through the entire subtree <em>including</em> this packet, and <a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060" title="Returns a lightweight object for iterating through the immediate children of this packet.">children()</a> for iterating over just this packet's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>an object for iterating through the strict descendants of this packet. </dd></dl>

</div>
</div>
<a id="ga941baf3f572331538ec82154fd3dc997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941baf3f572331538ec82154fd3dc997">&#9670;&nbsp;</a></span>end() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::Packet::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of the range of packets in the subtree rooted at this packet. </p>
<p>In C++, the <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> and <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997" title="Returns an iterator beyond the end of the range of packets in the subtree rooted at this packet.">end()</a> routines allow you to iterate through an entire packet subtree using C++11 range-based <code>for</code> loops. In Python, each packet can be treated as an iterable object.</p>
<p>See the <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> documentation for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Again, see the <a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287" title="Returns an iterator at the beginning of the range of packets in the subtree rooted at this packet.">begin()</a> documentation for the iterable objects that Regina provides for Python users.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator beyond the end of this subtree. </dd></dl>

</div>
</div>
<a id="ga09f68310c44da3f5f260b04a49694ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09f68310c44da3f5f260b04a49694ea2">&#9670;&nbsp;</a></span>end() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> regina::PacketChildren::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of children. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code><b>iter</b>()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the past-the-end iterator. </dd></dl>

</div>
</div>
<a id="gab56c66808490401dfc950ce16b268423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab56c66808490401dfc950ce16b268423">&#9670;&nbsp;</a></span>end() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::PacketDescendants::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of strict descendants. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code><b>iter</b>()</code>, as described in the class notes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the past-the-end iterator. </dd></dl>

</div>
</div>
<a id="gac9df4d0a5ff0a96c001094ee6b67f5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9df4d0a5ff0a96c001094ee6b67f5b0">&#9670;&nbsp;</a></span>endContentSubElement() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLPacketReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__detail.html#ga855ad4db27697cc648b45736957f1224">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;</a>, <a class="el" href="group__detail.html#ga855ad4db27697cc648b45736957f1224">regina::detail::XMLTriangulationReaderBase&lt; 2 &gt;</a>, <a class="el" href="group__detail.html#ga855ad4db27697cc648b45736957f1224">regina::detail::XMLTriangulationReaderBase&lt; 3 &gt;</a>, <a class="el" href="group__detail.html#ga855ad4db27697cc648b45736957f1224">regina::detail::XMLTriangulationReaderBase&lt; 4 &gt;</a>, <a class="el" href="group__surfaces.html#gafa118509bfc5ec2f4192b94aa0c4dd35">regina::XMLNormalSurfacesReader</a>, <a class="el" href="group__surfaces.html#ga2bc7352000f92ad00fa8debb700163ab">regina::XMLFilterPacketReader</a>, <a class="el" href="group__snappea.html#ga8d90a3b40424192975ff454f1270e3d1">regina::XMLSnapPeaReader</a>, <a class="el" href="group__packet.html#gafbb4a46af9a9b0d7e0294fcccc097d5a">regina::XMLTextReader</a>, <a class="el" href="group__packet.html#ga469708e082f17d09034ee39bb39f46fc">regina::XMLScriptReader</a>, <a class="el" href="group__packet.html#ga968b7e08bbe0f3e1b6b63b1403488286">regina::XMLPDFReader</a>, <a class="el" href="group__link.html#ga9eceeda8be99a7fbb24789da450b24ba">regina::XMLLinkReader</a>, <a class="el" href="group__hypersurface.html#ga621bfbebd403377d6fe78bdb4df2cfa5">regina::XMLNormalHypersurfacesReader</a>, and <a class="el" href="group__angle.html#gaccb4c8c0c6b03102190875fbf18768f0">regina::XMLAngleStructuresReader</a>.</p>

</div>
</div>
<a id="ga968b7e08bbe0f3e1b6b63b1403488286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga968b7e08bbe0f3e1b6b63b1403488286">&#9670;&nbsp;</a></span>endContentSubElement() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLPDFReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__packet.html#gaf4aa2e06b6c0ebfc66ae0ee2be196422" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga469708e082f17d09034ee39bb39f46fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga469708e082f17d09034ee39bb39f46fc">&#9670;&nbsp;</a></span>endContentSubElement() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLScriptReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__packet.html#ga1cb26942ce9450276dba92c3093f2129" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gafbb4a46af9a9b0d7e0294fcccc097d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb4a46af9a9b0d7e0294fcccc097d5a">&#9670;&nbsp;</a></span>endContentSubElement() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLTextReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__packet.html#ga24064e768fba37a4c95a09e53f3a7680" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga8326fbf3c5e5fe26fa9d3dca2a86ce7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d">&#9670;&nbsp;</a></span>endSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLPacketReader::endSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing has finished for a subelement of this XML element. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga6957484c2540429d42866348285f0cf7">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga6f7c7be06c9ed6d15f99787ea5d883b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7c7be06c9ed6d15f99787ea5d883b2">&#9670;&nbsp;</a></span>findPacketLabel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a id="gac7855ea352221d498d1ca38a34d85af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7855ea352221d498d1ca38a34d85af5">&#9670;&nbsp;</a></span>findPacketLabel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a id="ga6eec5fa6ced4aa15edcef36d9d299a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eec5fa6ced4aa15edcef36d9d299a5d">&#9670;&nbsp;</a></span>firstChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::firstChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the first child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga12e196f0f1c415b457df17f96d5b6518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12e196f0f1c415b457df17f96d5b6518">&#9670;&nbsp;</a></span>firstTreePacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a id="ga9a8ec6e940be4cf49c3f19a563b9cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8ec6e940be4cf49c3f19a563b9cb16">&#9670;&nbsp;</a></span>firstTreePacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a id="gae6cfcd14a51ee6ad01fef5af95d05458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6cfcd14a51ee6ad01fef5af95d05458">&#9670;&nbsp;</a></span>forPacket() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::Void regina::forPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible packet types known to Regina.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new packet type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;PacketInfo&lt;t&gt;&gt;(...)</code> is defined for any valid PacketType enum value <em>t</em>. Then, when the user calls <code>forPacket(packetType, func, ...)</code>, this routine will call <code>func.operator()&lt;PacketInfo&lt;packetType&gt;&gt;(...)</code> in turn. If <em>packetType</em> does not denote a valid packet type, then <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em> (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>the given packet type. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a PacketInfo&lt;packetType&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a id="ga842932466a8cdb50c359c584dd8e93ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga842932466a8cdb50c359c584dd8e93ca">&#9670;&nbsp;</a></span>forPacket() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::ReturnType regina::forPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of PacketType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible packet types known to Regina.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new packet type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;PacketInfo&lt;t&gt;&gt;(...)</code> is defined for any valid PacketType enum value <em>t</em>. Then, when the user calls <code>forPacket(packetType, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;PacketInfo&lt;packetType&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>packetType</em> does not denote a valid packet type, then <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__packet.html#ga842932466a8cdb50c359c584dd8e93ca" title="Allows the user to call a template function whose template parameter matches a given value of PacketT...">forPacket()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from Returns&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>the given packet type. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a PacketInfo&lt;packetType&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given packet type is not valid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given packet type is not valid. </dd></dl>

</div>
</div>
<a id="ga29f5775c175a56d06da14444b391ed3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f5775c175a56d06da14444b391ed3a">&#9670;&nbsp;</a></span>fullName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::fullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet. </p>
<p>The string is of the form <em>label (packet-type)</em>.</p>
<p>The packet label will be adjusted for human-readable output according to the behaviour of <a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">humanLabel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the descriptive text string. </dd></dl>

</div>
</div>
<a id="gac85ba39c124eda4ce631b653d6bb0a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac85ba39c124eda4ce631b653d6bb0a29">&#9670;&nbsp;</a></span>hasOwner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object. </p>
<p>For packets, this returns <code>true</code> if and only if this packet has a parent in the packet tree (i.e., is not the root).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if some other object owns this object. </dd></dl>

</div>
</div>
<a id="gaf4315a8b8ebcf47e781c204927f8845f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4315a8b8ebcf47e781c204927f8845f">&#9670;&nbsp;</a></span>hasTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has the given associated tag. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gaa4893445f043663e9a8595fc8bb0490a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4893445f043663e9a8595fc8bb0490a">&#9670;&nbsp;</a></span>hasTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has the given associated tag. </p>
<p>See <a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d" title="Returns the set of all tags associated with this packet.">Packet::tags()</a> for further details on packet tags.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga4404beade84983a4f1c051cd64035ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4404beade84983a4f1c051cd64035ddf">&#9670;&nbsp;</a></span>hasTags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has any associated tags at all. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this packet has any tags, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gab9a2ab9c10c8a0d08b804a9bd02530e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a2ab9c10c8a0d08b804a9bd02530e5">&#9670;&nbsp;</a></span>hasTags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::hasTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has any associated tags at all. </p>
<p>See <a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d" title="Returns the set of all tags associated with this packet.">Packet::tags()</a> for further details on packet tags.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this packet has any tags, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gadfaee615502b79cbeef31628a1186dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfaee615502b79cbeef31628a1186dc4">&#9670;&nbsp;</a></span>humanLabel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::humanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<p>In particular, if the packet has no label assigned then this routine will return "(no label)", not the empty string.</p>
<dl class="section warning"><dt>Warning</dt><dd>The method by which this routine adjusts packet labels is subject to change in future versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="ga0ee053db30fd6227cd420a3a5d19266e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee053db30fd6227cd420a3a5d19266e">&#9670;&nbsp;</a></span>humanLabel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::PacketShell::humanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<p>See <a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e" title="Returns the label associated with this individual packet.">Packet::label()</a> and <a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">Packet::humanLabel()</a> for further details on packet labels.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="gafef35326137566ebe6f22533d8707e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafef35326137566ebe6f22533d8707e28">&#9670;&nbsp;</a></span>ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__packet.html#ga9bcdb1301b1f56d445352a56fc9973fb">XMLTreeResolver::IDMap</a> &amp; regina::XMLTreeResolver::ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the map from internal IDs to packets, as stored in the data file. </p>
<p>Packets in a data file may have individual string IDs stored alongside them, in the <em>id</em> attribute of the <code>&lt;packet&gt;</code> tag. These strings are optional, and do not need to be human-readable. Although packets are not required to have IDs, any IDs that <em>are</em> stored must be unique (i.e., two different packets cannot share the same ID).</p>
<p>Note that IDs read from the data file need not bear any relation to the IDs that are returned from <a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a>, although this is typically how they are constructed when a file is saved.</p>
<p>This map will be fleshed out as the data file is read. In particular, since each task runs <a class="el" href="group__packet.html#ga6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> only after the entire tree has been read, tasks may assume that this map contains all IDs that were explicitly stored in the data file.</p>
<p>Only packets with IDs will appear in this map (i.e., there may well be packets in the data file that do not appear in this map at all).</p>
<dl class="section return"><dt>Returns</dt><dd>the map from internal file IDs to packets. </dd></dl>

</div>
</div>
<a id="gad7f9556e8405ca88517ccd5549471fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f9556e8405ca88517ccd5549471fea">&#9670;&nbsp;</a></span>insertChildAfter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>prevChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given packet as a child of this packet at the given location in this packet's child list. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>newChild</em> has no parent packet. </dd>
<dd>
Parameter <em>prevChild</em> is already a child of this packet. </dd>
<dd>
This packet is not a descendant of <em>newChild</em>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newChild</td><td>the child to insert. </td></tr>
    <tr><td class="paramname">prevChild</td><td>the preexisting child of this packet after which <em>newChild</em> will be inserted, or 0 if <em>newChild</em> is to be the first child of this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac389781f5c53a7d3aac3206d51ecfd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac389781f5c53a7d3aac3206d51ecfd91">&#9670;&nbsp;</a></span>insertChildFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given packet as the first child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3d02be74192f03b372a4195c9e5bc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3d02be74192f03b372a4195c9e5bc1f">&#9670;&nbsp;</a></span>insertChildLast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildLast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the given packet as the last child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd4d2e82e583276a70128d952b46bd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd4d2e82e583276a70128d952b46bd53">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implemented in <a class="el" href="group__generic.html#gaf3ad2917495b976a4a449a1ecf72011a">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="group__generic.html#gaf3ad2917495b976a4a449a1ecf72011a">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="group__dim4.html#gadf21fab69f6841399139254ccd73e99d">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="group__dim3.html#ga9d64120795e92d1a7c18b0427180080a">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="group__dim2.html#ga0798b7fb0e21aa00f335380406628a94">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="group__surfaces.html#ga7ec5eeb4810c80741c71380d47315334">regina::SurfaceFilterProperties</a>, <a class="el" href="group__surfaces.html#ga233c06d9abc90d0d78e7505e330ace46">regina::SurfaceFilterCombination</a>, <a class="el" href="group__surfaces.html#gacb8bd5f5aaa07c895c1ff7b457056c80">regina::SurfaceFilter</a>, <a class="el" href="group__surfaces.html#gadc0ab53ae8085a452393a764bd8d5b27">regina::NormalSurfaces</a>, <a class="el" href="group__snappea.html#gaac5b4c8b62c4c1467bac25d2797629f7">regina::SnapPeaTriangulation</a>, <a class="el" href="group__packet.html#ga4ee6af15b1de3e79e8fe259244f1315c">regina::Text</a>, <a class="el" href="group__packet.html#gad5aa0da3c39b73fb341cd2cb3f59deb6">regina::Script</a>, <a class="el" href="group__packet.html#ga814a47f567426f0def126844dcacb0bb">regina::PDF</a>, <a class="el" href="group__packet.html#gaaca88e2d9f18a028110e0eff651c41db">regina::Container</a>, <a class="el" href="group__link.html#gaa36d8a4b0c964cafb2cbac86b0d5e272">regina::Link</a>, <a class="el" href="group__hypersurface.html#gafbfc6c679ae7ab07f4cd4953ae5c4efe">regina::NormalHypersurfaces</a>, and <a class="el" href="group__angle.html#ga045880691b243edd429661aa1d0fc859">regina::AngleStructures</a>.</p>

</div>
</div>
<a id="gaaca88e2d9f18a028110e0eff651c41db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca88e2d9f18a028110e0eff651c41db">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Container::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="ga814a47f567426f0def126844dcacb0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814a47f567426f0def126844dcacb0bb">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::PDF::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="gad5aa0da3c39b73fb341cd2cb3f59deb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5aa0da3c39b73fb341cd2cb3f59deb6">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Script::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="ga4ee6af15b1de3e79e8fe259244f1315c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ee6af15b1de3e79e8fe259244f1315c">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Text::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="ga0b6130ab1dda164f6c6a6158a854f79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6130ab1dda164f6c6a6158a854f79f">&#9670;&nbsp;</a></span>internalID() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::internalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet. </p>
<p>The user has no control over this ID, and it is not human readable. It is guaranteed to remain fixed throughout the lifetime of the program for a given packet, and it is guaranteed not to clash with the ID of any other packet.</p>
<p>If you change the contents of a packet, its ID will not change.</p>
<p>If you clone a packet, the new clone will receive a different ID. If you save and then load a packet to/from file, the ID will change. These behaviours are necessary to ensure that IDs remain unique (since, for instance, you could load several copies of the same data file into memory simultaneously).</p>
<p>The ID is implemented as an encoding of the underlying C++ pointer. This encoding is subject to change in later versions of Regina.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this packet. </dd></dl>

</div>
</div>
<a id="ga826de400a7a8238d49c86e0413043738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga826de400a7a8238d49c86e0413043738">&#9670;&nbsp;</a></span>internalID() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::PacketShell::internalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet. </p>
<p>The user has no control over this ID and it is not human readable, but it is guaranteed to be unique to this packet, and to remain fixed throughout the lifetime of the program for this packet.</p>
<p>See <a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f" title="Returns a unique string ID that identifies this packet.">Packet::internalID()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this packet. </dd></dl>

</div>
</div>
<a id="ga8848bba753ebfb2ea9940391da9c2eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8848bba753ebfb2ea9940391da9c2eb9">&#9670;&nbsp;</a></span>isGrandparentOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isGrandparentOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this packet is equal to or an ancestor of the given packet in the tree structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the other packet whose relationships we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet is equal to or an ancestor of <code>descendant</code>. </dd></dl>

</div>
</div>
<a id="gacd2dc2dee3396afb9dbf07c38fe10d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd2dc2dee3396afb9dbf07c38fe10d63">&#9670;&nbsp;</a></span>isListening()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isListening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given packet listener is currently listening for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener is currently registered with this packet, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga71eb9786bd9f73c340450b1628331039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71eb9786bd9f73c340450b1628331039">&#9670;&nbsp;</a></span>isNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PDF::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet is currently holding a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet is holding a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document. </dd></dl>

</div>
</div>
<a id="gaa03a6c9fb8c55dbed8a86f32b5975437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa03a6c9fb8c55dbed8a86f32b5975437">&#9670;&nbsp;</a></span>isPacketEditable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isPacketEditable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children. </p>
<p>Descendants further down the packet tree are not (and should not need to be) considered.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet may be edited. </dd></dl>

</div>
</div>
<a id="gafd05b16f0990a54ac7f95bc32cf1483e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd05b16f0990a54ac7f95bc32cf1483e">&#9670;&nbsp;</a></span>label() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::Packet::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet. </p>
<p>An example is <code>MyTriangulation</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="ga5970247173515dd6e4bc93dd956922aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5970247173515dd6e4bc93dd956922aa">&#9670;&nbsp;</a></span>label() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::PacketShell::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet. </p>
<p>See <a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e" title="Returns the label associated with this individual packet.">Packet::label()</a> and <a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">Packet::humanLabel()</a> for further details on packet labels.</p>
<p>The reference that is returned should be only used as a temporary, since the underlying packet (and therefore the string that is referenced) is in the process of being destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a id="ga0a6c8037ec9109e8bf422b3cade7676e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a6c8037ec9109e8bf422b3cade7676e">&#9670;&nbsp;</a></span>lastChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::lastChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the last child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the last child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga8d80a76204afdb9ea31bfef77b137bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d80a76204afdb9ea31bfef77b137bf3">&#9670;&nbsp;</a></span>levelsDownTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsDownTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given descendant in the tree structure. </p>
<p>If <code>descendant</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>descendant</code>, or can be obtained from <code>descendant</code> using only child-to-parent steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a id="gaf4ed7022c81276beb3ef81ca8db024fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4ed7022c81276beb3ef81ca8db024fa">&#9670;&nbsp;</a></span>levelsUpTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsUpTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given ancestor in the tree structure. </p>
<p>If <code>ancestor</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>ancestor</code>, or can be obtained from <code>ancestor</code> using only parent-to-child steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a id="gaa504cfa813a3190c00337743915ffef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa504cfa813a3190c00337743915ffef5">&#9670;&nbsp;</a></span>listen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers the given packet listener to listen for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully registered, or <code>false</code> if the given listener was already registered beforehand. </dd></dl>

</div>
</div>
<a id="gad9aa0488b40a1f3ec702838b2a2ceecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9aa0488b40a1f3ec702838b2a2ceecc">&#9670;&nbsp;</a></span>makeOrphan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::makeOrphan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree. </p>
<p>The tree information for both this packet and its parent will be updated.</p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet has a parent. </dd>
<dd>
This packet does not depend on its parent; see <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>After <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> is called, this packet will become the root of a new packet tree that is owned by Python. In particular, if you call <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and then delete all Python references to this packet, the entire packet subtree will be automatically destroyed. </dd></dl>

</div>
</div>
<a id="ga59adc13b6143cf994779796077aed731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59adc13b6143cf994779796077aed731">&#9670;&nbsp;</a></span>moveDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveDown </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the end of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very end of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a id="gab4d7730c57940444bf7d3085459449e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4d7730c57940444bf7d3085459449e8">&#9670;&nbsp;</a></span>moveToFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet to be the first in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a id="ga7fcff38ccb62b62d28bed83d2a3a28d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fcff38ccb62b62d28bed83d2a3a28d5">&#9670;&nbsp;</a></span>moveToLast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet to be the last in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a id="gae02f6b3ad3a7816cde5d7df456763aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae02f6b3ad3a7816cde5d7df456763aaf">&#9670;&nbsp;</a></span>moveUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveUp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the beginning of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very beginning of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a id="ga7afd16bf0e5cf7a3efe8f5d0944fe165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7afd16bf0e5cf7a3efe8f5d0944fe165">&#9670;&nbsp;</a></span>nextSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::nextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the next sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that follows this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the next sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga7bd2bc8fc84f44023a0a4b26ad839621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd2bc8fc84f44023a0a4b26ad839621">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a id="gaeaff341860febcb3daadd1b9b4216c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaff341860febcb3daadd1b9b4216c3d">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a id="ga6b3f24565a5053de126c8169d1a3ccdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b3f24565a5053de126c8169d1a3ccdb">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a id="ga74345507fd3326dc1b22a284b90da5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74345507fd3326dc1b22a284b90da5d1">&#9670;&nbsp;</a></span>nextTreePacket() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a id="ga964a605603a33a84e5004e9ebb0ac5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga964a605603a33a84e5004e9ebb0ac5ec">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a Regina data file, and returns the corresponding packet tree. </p>
<p>This uses Regina's native XML file format; it does not matter whether the XML file is compressed or uncompressed.</p>
<p>If the file could not be opened or the top-level packet in the tree could not be read, this routine will return 0. If some packet deeper within the tree could not be read then that particular packet (and its descendants, if any) will simply be ignored.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This function is not automatically imported into the global namespace when running regina-python, or when opening a Python console in the graphical user interface, or even when typing <code>from regina import *</code>. This is to avoid overriding Python's own built-in <a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec" title="Reads a Regina data file, and returns the corresponding packet tree.">open()</a> function. You can access Regina's <a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec" title="Reads a Regina data file, and returns the corresponding packet tree.">open()</a> function by calling <code><a class="el" href="group__packet.html#ga964a605603a33a84e5004e9ebb0ac5ec" title="Reads a Regina data file, and returns the corresponding packet tree.">regina.open()</a></code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the pathname of the file to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet tree read from file, or 0 on error (as explained above). </dd></dl>

</div>
</div>
<a id="gae53c0b54eaa7f029e0b0a13bb3c02675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae53c0b54eaa7f029e0b0a13bb3c02675">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::open </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a Regina data file from the given input stream, and returns the corresponding packet tree. </p>
<p>This uses Regina's native XML file format; it does not matter whether the XML file is compressed or uncompressed.</p>
<p>If the stream could not be read or if the top-level packet in the tree could not be read, then this routine will return 0. If some packet deeper within the tree could not be read then that particular packet (and its descendants, if any) will simply be ignored.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given stream is open for reading.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>the input stream to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet tree read from file, or 0 on error (as explained above). </dd></dl>

</div>
</div>
<a id="gae9eb1a069f3b0bcad8ebc1e663b0cb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9eb1a069f3b0bcad8ebc1e663b0cb89">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ChildIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="ga5de163f6b93ae3df7aa8524cca7e6143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5de163f6b93ae3df7aa8524cca7e6143">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this shell does not refer to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the right); this reversed test is defined as a global function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this shell does not refer to the given packet. </dd></dl>

</div>
</div>
<a id="gace38aff17950c85385587ece7b0e7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace38aff17950c85385587ece7b0e7963">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>shell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if the given shell does not refer to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the left); this reversed test is defined as a member function of <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
    <tr><td class="paramname">shell</td><td>the packet shell to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given shell does not refer to the given packet. </dd></dl>

</div>
</div>
<a id="ga8ce231143254c64a6c385ebe99bfdbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce231143254c64a6c385ebe99bfdbb5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this and the given shell refer to different underlying packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both shells refer to different packets. </dd></dl>

</div>
</div>
<a id="ga7473f5829b6a5d777ef62fc8d0b6a8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7473f5829b6a5d777ef62fc8d0b6a8b3">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SubtreeIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are different. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the packets that each iterator is currently pointing to. It does not compare the roots of the subtrees themselves.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are different. </dd></dl>

</div>
</div>
<a id="gaa8bfb09c35881fc4804ea909dd878683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8bfb09c35881fc4804ea909dd878683">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp; regina::ChildIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current child packet and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current packet. </dd></dl>

</div>
</div>
<a id="ga537960c97e4cb7162da330c892115f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga537960c97e4cb7162da330c892115f55">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> *const  &amp; regina::SubtreeIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the packet that this iterator is currently pointing to. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the current packet. </dd></dl>

</div>
</div>
<a id="ga6e515b2ba38eba36cf621598447bfad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e515b2ba38eba36cf621598447bfad6">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp; regina::ChildIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current child packet and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="ga130eb896f8e699b159d2c124d774f7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga130eb896f8e699b159d2c124d774f7b1">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp; regina::SubtreeIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="gafc8d33346fee85e3a0ccb4fb8e94e437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc8d33346fee85e3a0ccb4fb8e94e437">&#9670;&nbsp;</a></span>operator++() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> regina::ChildIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current child packet and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="gad1010344f9ccca0551bb80f0a5966cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1010344f9ccca0551bb80f0a5966cf2">&#9670;&nbsp;</a></span>operator++() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> regina::SubtreeIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="ga345ff5809b12d36f7ce53d81ebfcc4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345ff5809b12d36f7ce53d81ebfcc4bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a>&amp; regina::ChildIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>

</div>
</div>
<a id="ga4ef24629212c08d93d4171816488e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ef24629212c08d93d4171816488e597">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&amp; regina::PacketChildren::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gab143a69767e65df6b0e7fa4671b3d493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab143a69767e65df6b0e7fa4671b3d493">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&amp; regina::PacketDescendants::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga515f5c71ddf046610d03714948264f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga515f5c71ddf046610d03714948264f4e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&amp; regina::PacketShell::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to be a copy of the given shell. </p>
<p>Both shells will refer to the same underlying packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga962997e07b8aa25d5b7a44ac4922d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga962997e07b8aa25d5b7a44ac4922d28e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&amp; regina::SubtreeIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>

</div>
</div>
<a id="ga8a305d83c114887ce6c5bbce98aaaa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a305d83c114887ce6c5bbce98aaaa64">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::ChildIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1ChildIterator.html">ChildIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<a id="ga4b87fb099d8e833d62f0d386695ac4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b87fb099d8e833d62f0d386695ac4ab">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this shell refers to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the right); this reversed test is defined as a global function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this shell refers to the given packet. </dd></dl>

</div>
</div>
<a id="gac717c06a744c38993b7d137c55e6de40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac717c06a744c38993b7d137c55e6de40">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>shell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if the given shell refers to the given packet. </p>
<p>This test is also available the other way around (with <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> on the left); this reversed test is defined as a member function of <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to test against; this may be <code>null</code>. </td></tr>
    <tr><td class="paramname">shell</td><td>the packet shell to test against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given shell refers to the given packet. </dd></dl>

</div>
</div>
<a id="gaacbe65ec69b04755609d8294977dd989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacbe65ec69b04755609d8294977dd989">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PacketShell::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identifies if this and the given shell refer to the same underlying packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if both shells refer to the same packet. </dd></dl>

</div>
</div>
<a id="gaa098cbbe41b9f6fba63297e915fa8992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa098cbbe41b9f6fba63297e915fa8992">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SubtreeIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given iterator are equal. </p>
<dl class="section note"><dt>Note</dt><dd>This routine only compares the packets that each iterator is currently pointing to. It does not compare the roots of the subtrees themselves.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if the two iterators are equal. </dd></dl>

</div>
</div>
<a id="gacde072f143d7c1ecc8e4916e52ceb1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacde072f143d7c1ecc8e4916e52ceb1d0">&#9670;&nbsp;</a></span>packet() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLPacketReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented in <a class="el" href="group__detail.html#ga4de5260704d60064eaacb40fe2f286bc">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;</a>, <a class="el" href="group__detail.html#ga4de5260704d60064eaacb40fe2f286bc">regina::detail::XMLTriangulationReaderBase&lt; 2 &gt;</a>, <a class="el" href="group__detail.html#ga4de5260704d60064eaacb40fe2f286bc">regina::detail::XMLTriangulationReaderBase&lt; 3 &gt;</a>, <a class="el" href="group__detail.html#ga4de5260704d60064eaacb40fe2f286bc">regina::detail::XMLTriangulationReaderBase&lt; 4 &gt;</a>, <a class="el" href="group__surfaces.html#ga9372bff59f5fe548909a8717bdefb992">regina::XMLNormalSurfacesReader</a>, <a class="el" href="group__surfaces.html#ga9864adf21187883e54e04b8e2d86379a">regina::XMLFilterPacketReader</a>, <a class="el" href="group__snappea.html#ga91b65425b619bf3effdcd95cb5066fd0">regina::XMLSnapPeaReader</a>, <a class="el" href="group__packet.html#gac6d12d3571e4c61cdc251b7c2e66aa94">regina::XMLTextReader</a>, <a class="el" href="group__packet.html#ga4354e1f761f87b27d75ebb0ddbad6cbc">regina::XMLScriptReader</a>, <a class="el" href="group__packet.html#gad9c7e739cd2062e09dd7a2c60dbc97ed">regina::XMLPDFReader</a>, <a class="el" href="group__packet.html#ga273345f730f8b6681dad917ae87b56d1">regina::XMLContainerReader</a>, <a class="el" href="group__link.html#gaf49ae8900301d590eb89ffed050abac9">regina::XMLLinkReader</a>, <a class="el" href="group__hypersurface.html#ga9a4a84abd95fcb6b3dd4f8e168e61a23">regina::XMLNormalHypersurfacesReader</a>, and <a class="el" href="group__angle.html#ga28ac47d991921cb6e14c780fbd9c8d95">regina::XMLAngleStructuresReader</a>.</p>

</div>
</div>
<a id="ga273345f730f8b6681dad917ae87b56d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga273345f730f8b6681dad917ae87b56d1">&#9670;&nbsp;</a></span>packet() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLContainerReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gad9c7e739cd2062e09dd7a2c60dbc97ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c7e739cd2062e09dd7a2c60dbc97ed">&#9670;&nbsp;</a></span>packet() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLPDFReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga4354e1f761f87b27d75ebb0ddbad6cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4354e1f761f87b27d75ebb0ddbad6cbc">&#9670;&nbsp;</a></span>packet() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLScriptReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gac6d12d3571e4c61cdc251b7c2e66aa94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6d12d3571e4c61cdc251b7c2e66aa94">&#9670;&nbsp;</a></span>packet() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLTextReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga8bdfa10b9c80b9f36c54097a64977d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bdfa10b9c80b9f36c54097a64977d4c">&#9670;&nbsp;</a></span>Packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Packet::Packet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that inserts the new packet into the overall tree structure. </p>
<p>The new packet will be inserted as the last child of the given parent, and will be initialised with no children of its own.</p>
<p>Note that <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> is an abstract class and cannot be instantiated directly.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which to insert this packet, or 0 if this packet is to be the matriarch of a new tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a3bc3386708cc7a52859df12f0b34e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a3bc3386708cc7a52859df12f0b34e0">&#9670;&nbsp;</a></span>PacketChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketChildren::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the immediate children of the given packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the packet whose children we will iterate through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1deebd4b4c4c3b685b017386b4b6f8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1deebd4b4c4c3b685b017386b4b6f8e0">&#9670;&nbsp;</a></span>PacketChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketChildren::PacketChildren </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="ga3349803a6192301ffccc708dcf7c8efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3349803a6192301ffccc708dcf7c8efa">&#9670;&nbsp;</a></span>PacketDescendants() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketDescendants::PacketDescendants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>subtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new object for iterating through the strict descendants of the given packet. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td>the packet whose strict descendants we will iterate through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaecbbafcb328346116b72f1cb2f41b02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecbbafcb328346116b72f1cb2f41b02c">&#9670;&nbsp;</a></span>PacketDescendants() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketDescendants::PacketDescendants </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>

</div>
</div>
<a id="gac869caf59c0e19e27006cb67d5742977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac869caf59c0e19e27006cb67d5742977">&#9670;&nbsp;</a></span>PacketListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketListener::PacketListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default constructor that does nothing. </p>

</div>
</div>
<a id="ga126ffc7b34aca93a3edba924d0764aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga126ffc7b34aca93a3edba924d0764aaa">&#9670;&nbsp;</a></span>PacketShell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketShell::PacketShell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new shell referring to the given packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet to refer to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4743ca941ad1c1c3849b72cb5d315ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4743ca941ad1c1c3849b72cb5d315ede">&#9670;&nbsp;</a></span>PacketShell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PacketShell::PacketShell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1PacketShell.html">PacketShell</a> &amp;&#160;</td>
          <td class="paramname"><em>shell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given shell. </p>
<p>Both shells will refer to the same underlying packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shell</td><td>the shell to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacec00b1f4665c352ca6638819a7f7221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacec00b1f4665c352ca6638819a7f7221">&#9670;&nbsp;</a></span>packetToBeChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetToBeChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the contents of the packet are to be changed. </p>
<p>Once the contents are changed, <a class="el" href="group__packet.html#ga113b2c051046b67870da4a4953422438" title="Called after the contents of the packet have been changed.">packetWasChanged()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85f626506f5c7f4dc12fb41acde2ab97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85f626506f5c7f4dc12fb41acde2ab97">&#9670;&nbsp;</a></span>packetToBeDestroyed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetToBeDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet is about to be destroyed. </p>
<p>Note that there is no matching function called <em>after</em> the packet is destroyed, since the set of listeners will no longer be available at that stage.</p>
<p>When an entire packet subtree is to be destroyed, child packets will notify their listeners of the impending destruction before parent packets will.</p>
<p>Note that the packet will forcibly unregister this listener immediately <em>before</em> <a class="el" href="group__packet.html#ga85f626506f5c7f4dc12fb41acde2ab97" title="Called before the packet is about to be destroyed.">packetToBeDestroyed()</a> is called, to avoid any unpleasant consequences if this listener should also try to unregister itself. This means that, by the time this routine is called, this listener will no longer be registered with the packet in question (and any attempt to unregister it again will be harmless).</p>
<p>By the time this function is called, we are already inside the <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> destructor, and so most <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> member functions are no longer safe to call. Therefore the argument that is passed to this routine is a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>, which exposes only those member functions of <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> that are still safe to call at this time. Importantly, you can safely compare a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> against a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> pointer, in case you need to identify which particular packet is being destroyed.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>gives access to the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__packet.html#ga7d97052be80a5b0e3ebb3ca104bf3edd">regina::Script</a>.</p>

</div>
</div>
<a id="ga7d97052be80a5b0e3ebb3ca104bf3edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d97052be80a5b0e3ebb3ca104bf3edd">&#9670;&nbsp;</a></span>packetToBeDestroyed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Script::packetToBeDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketShell.html">PacketShell</a>&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet is about to be destroyed. </p>
<p>Note that there is no matching function called <em>after</em> the packet is destroyed, since the set of listeners will no longer be available at that stage.</p>
<p>When an entire packet subtree is to be destroyed, child packets will notify their listeners of the impending destruction before parent packets will.</p>
<p>Note that the packet will forcibly unregister this listener immediately <em>before</em> <a class="el" href="group__packet.html#ga7d97052be80a5b0e3ebb3ca104bf3edd" title="Called before the packet is about to be destroyed.">packetToBeDestroyed()</a> is called, to avoid any unpleasant consequences if this listener should also try to unregister itself. This means that, by the time this routine is called, this listener will no longer be registered with the packet in question (and any attempt to unregister it again will be harmless).</p>
<p>By the time this function is called, we are already inside the <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> destructor, and so most <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> member functions are no longer safe to call. Therefore the argument that is passed to this routine is a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a>, which exposes only those member functions of <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> that are still safe to call at this time. Importantly, you can safely compare a <a class="el" href="classregina_1_1PacketShell.html" title="Gives access to the final remains of a packet that is in the process of being destroyed.">PacketShell</a> against a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> pointer, in case you need to identify which particular packet is being destroyed.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>gives access to the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga85f626506f5c7f4dc12fb41acde2ab97">regina::PacketListener</a>.</p>

</div>
</div>
<a id="gaec7756e8a51f95d68d84c9ea2e0a7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec7756e8a51f95d68d84c9ea2e0a7838">&#9670;&nbsp;</a></span>packetToBeRenamed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet label or tags are to be changed. </p>
<p>Once the label or tags are changed, <a class="el" href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gaf0c075ad56fc5bd7cde9e971693f3867" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> </dd></dl>

</div>
</div>
<a id="ga113b2c051046b67870da4a4953422438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga113b2c051046b67870da4a4953422438">&#9670;&nbsp;</a></span>packetWasChanged()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetWasChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the contents of the packet have been changed. </p>
<p>Before the contents are changed, <a class="el" href="group__packet.html#gacec00b1f4665c352ca6638819a7f7221" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__snappea.html#ga44bfb39f2ed4cd387b2c20fcf62b5626">regina::SnapPeaTriangulation</a>.</p>

</div>
</div>
<a id="gadf6d39aabd829a9417637a0b71b39acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf6d39aabd829a9417637a0b71b39acb">&#9670;&nbsp;</a></span>packetWasRenamed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::packetWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the packet label or tags have been changed. </p>
<p>Before the label or tags are changed, <a class="el" href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gad546812ede412a4c7583edf323d6a54a" title="Called after one of this packet&#39;s immediate children has its label or tags changed.">childWasRenamed()</a> </dd></dl>

<p>Reimplemented in <a class="el" href="group__packet.html#gad286098a247bcba4f440c5f42f4b6863">regina::Script</a>.</p>

</div>
</div>
<a id="gad286098a247bcba4f440c5f42f4b6863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad286098a247bcba4f440c5f42f4b6863">&#9670;&nbsp;</a></span>packetWasRenamed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Script::packetWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the packet label or tags have been changed. </p>
<p>Before the label or tags are changed, <a class="el" href="group__packet.html#gaec7756e8a51f95d68d84c9ea2e0a7838" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__packet.html#gad546812ede412a4c7583edf323d6a54a" title="Called after one of this packet&#39;s immediate children has its label or tags changed.">childWasRenamed()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gadf6d39aabd829a9417637a0b71b39acb">regina::PacketListener</a>.</p>

</div>
</div>
<a id="gab80d6d7bc86d4600980f0c9555bb6237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab80d6d7bc86d4600980f0c9555bb6237">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the parent packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="ga6b20f6a5e04148126d18e535825c9fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b20f6a5e04148126d18e535825c9fa4">&#9670;&nbsp;</a></span>PDF() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PDF::PDF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet with no document stored. </p>

</div>
</div>
<a id="ga336edef2caba28675b9e7d7f6dd98734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga336edef2caba28675b9e7d7f6dd98734">&#9670;&nbsp;</a></span>PDF() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PDF::PDF </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet.html#gabb7c46c6bbb0cfe639525d1bf5700f2c">OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a packet to store the given <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> data. </p>
<p>The <em>data</em> array must contain a full <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document as a block of binary data.</p>
<p>The <em>alloc</em> argument shows if/how this packet claims ownership of the data. In particular, unless <em>alloc</em> is <em>DEEP_COPY</em>, this packet will claim ownership of the given data block and will deallocate it when the packet is destroyed. If <em>alloc</em> is <em>DEEP_COPY</em> then the given block of data will not be modified in any way.</p>
<p>It is possible to pass a null pointer as the data array, in which case the new packet will have no <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document stored (so <a class="el" href="group__packet.html#ga71eb9786bd9f73c340450b1628331039" title="Determines whether this packet is currently holding a PDF document.">isNull()</a> will return <code>true</code>).</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the block of binary data that forms the <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document, or <code>null</code> if no document is to be stored. </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes in this block of binary data; if actual data is passed (i.e., <em>data</em> is not <code>null</code>) then this must be strictly positive. </td></tr>
    <tr><td class="paramname">alloc</td><td>describes if/how this packet should claim ownership of the given block of data; see the notes above for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3aaa69bba9b626686ccf56cb735b01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3aaa69bba9b626686ccf56cb735b01a">&#9670;&nbsp;</a></span>PDF() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::PDF::PDF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet with data read from the given <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> file. </p>
<p>This routine does not check whether the given file <em>looks</em> like a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document; it simply loads the file contents blindly.</p>
<p>If the file could not be read or is empty, then no <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document will be stored in this packet. You can test this by calling <a class="el" href="group__packet.html#ga71eb9786bd9f73c340450b1628331039" title="Determines whether this packet is currently holding a PDF document.">isNull()</a>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the filename of the <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84decda10642eccee55a109e70e10076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84decda10642eccee55a109e70e10076">&#9670;&nbsp;</a></span>prevSibling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::prevSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the previous sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that precedes this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the previous sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a id="gaedaa9594b36a2acf51013b9b2092aa0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedaa9594b36a2acf51013b9b2092aa0c">&#9670;&nbsp;</a></span>queueTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLTreeResolver::queueTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolutionTask.html">XMLTreeResolutionTask</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queues a task for processing. </p>
<p>When the file I/O manager calls <a class="el" href="group__packet.html#ga6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a>, this will call <a class="el" href="group__packet.html#ga6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> for each task that has been queued.</p>
<p>This object will claim ownership of the given task, and will destroy it after <a class="el" href="group__packet.html#ga6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> has been called (or, if <a class="el" href="group__packet.html#ga6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> is never called, when this <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a> is destroyed).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task to be queued. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee2405989e058dbfddf7ae445d47ddcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2405989e058dbfddf7ae445d47ddcf">&#9670;&nbsp;</a></span>removeAllTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::removeAllTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all associated tags from this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet. </p>

</div>
</div>
<a id="ga0652968ebcda8deb215b167ed5e514bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0652968ebcda8deb215b167ed5e514bf">&#9670;&nbsp;</a></span>removeAllVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::removeAllVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all variables associated with this script. </p>

</div>
</div>
<a id="gacb9880c0189b8f60827cd0ce9a2bb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb9880c0189b8f60827cd0ce9a2bb32c">&#9670;&nbsp;</a></span>removeTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::removeTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the association of the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was removed, or <code>false</code> if the given tag was not actually associated with this packet. </dd></dl>

</div>
</div>
<a id="ga879ee100b538daad0f4c21e9ad8dfc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga879ee100b538daad0f4c21e9ad8dfc40">&#9670;&nbsp;</a></span>removeVariable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::removeVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the variable stored with the given name. </p>
<p>If no variable is stored with the given name, this routine will do nothing.</p>
<dl class="section warning"><dt>Warning</dt><dd>This may change the indices of other variables, since (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to remove; note that names are case sensitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga51766139616656bcd8a257fb9526cd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51766139616656bcd8a257fb9526cd71">&#9670;&nbsp;</a></span>removeVariable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::removeVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the variable stored at the given index. </p>
<dl class="section warning"><dt>Warning</dt><dd>This may change the indices of other variables, since (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable to remove; this must be between 0 and <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga219920e1523d3edf2982da0a3ba1a33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga219920e1523d3edf2982da0a3ba1a33d">&#9670;&nbsp;</a></span>reparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::reparent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead. </p>
<p>This routine is essentially a combination of <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> followed by either <a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> or <a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>.</p>
<p>This routine takes small constant time. It is safe to use regardless of whether this packet has a parent or not.</p>
<p>If you wish to reparent <em>all</em> of the children of a given packet, see <a class="el" href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f" title="Cuts all of this packet&#39;s children out of the packet tree, and reinserts them as children of the give...">transferChildren()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend on its parent; see <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is much simpler than combinations of <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and <a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> / <a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>, since there are no unpleasant ownership issues to deal with. However, if this packet currently has no parent then the ownership issues are unavoidable; in this case <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> will do nothing, and one of the insertChild...() routines must be used instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent of this packet, i.e., the packet beneath which this packet will be inserted. </td></tr>
    <tr><td class="paramname">first</td><td><code>true</code> if this packet should be inserted as the first child of the given parent, or <code>false</code> (the default) if it should be inserted as the last child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf002f6fa65df2c1413b78e9f5b4f1ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf002f6fa65df2c1413b78e9f5b4f1ca4">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PDF::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empties this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet so that no document is stored. </p>
<p>After calling this routine, <a class="el" href="group__packet.html#ga71eb9786bd9f73c340450b1628331039" title="Determines whether this packet is currently holding a PDF document.">isNull()</a> will return <code>true</code>.</p>
<p>The old data will be deallocated if required. </p>

</div>
</div>
<a id="ga9acf501a13dbf512d9d924fe47bab01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9acf501a13dbf512d9d924fe47bab01f">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PDF::reset </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet.html#gabb7c46c6bbb0cfe639525d1bf5700f2c">OwnershipPolicy</a>&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refills this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet with the given <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> data. </p>
<p>The old data will be deallocated if required.</p>
<p>This routine behaves like the class constructor; see the constructor documentation for details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the block of binary data that forms the new <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document, or <code>null</code> if no document is to be stored. </td></tr>
    <tr><td class="paramname">size</td><td>the number of bytes in this new block of binary data; if actual data is passed (i.e., <em>data</em> is not <code>null</code>) then this must be strictly positive. </td></tr>
    <tr><td class="paramname">alloc</td><td>describes if/how this packet should claim ownership of the given block of data; see the notes above for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6deb2e7eb029a52c8c73af2dfdda9484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6deb2e7eb029a52c8c73af2dfdda9484">&#9670;&nbsp;</a></span>resolve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLTreeResolver::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="group__packet.html#ga6b2e3f85565701a0c717204bf5f04855" title="Called by XMLTreeResolver after the entire data file has been read.">XMLTreeResolutionTask::resolve()</a> for all queued tasks. </p>
<p>The tasks will then be destroyed and removed from the queue (so subsequent calls to <a class="el" href="group__packet.html#ga6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">resolve()</a> are safe and will do nothing). </p>

</div>
</div>
<a id="ga6b2e3f85565701a0c717204bf5f04855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b2e3f85565701a0c717204bf5f04855">&#9670;&nbsp;</a></span>resolve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLTreeResolutionTask::resolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a> after the entire data file has been read. </p>
<p>Subclasses should override this routine to perform whatever "fleshing out" is necessary for a packet whose internal data is not yet complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver managing the resolution process, as outlined in the <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a> class notes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49a21b8f9147249e97d68ac6cdce0c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49a21b8f9147249e97d68ac6cdce0c20">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the root of the tree to which this packet belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the matriarch of the packet tree. </dd></dl>

</div>
</div>
<a id="ga2fe7098f6a0b61e94e9e301e4c93a89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fe7098f6a0b61e94e9e301e4c93a89e">&#9670;&nbsp;</a></span>safeDelete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void regina::Packet::safeDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Either destroys or orphans the given packet, according to whether it has safe pointers that currently reference it. </p>
<p>In this context, a "safe pointer" is either SafePtr&lt;Packet&gt; or a subclass; such pointers are (for instance) used to hold packets in regina's python bindings.</p>
<p>If there are no safe pointers currently pointing to <em>p</em>, then this routine simply deletes <em>p</em>. If there are one or more safe pointers currently pointing to <em>p</em>, then this routine orphans <em>p</em> in the packet tree and does nothing more; the safe pointers are left to manage the lifespan of <em>p</em> from here onwards.</p>
<p>C++ code should call <a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e" title="Either destroys or orphans the given packet, according to whether it has safe pointers that currently...">safeDelete()</a> instead of <code>delete</code> when it wishes to delete a packet, but there is a possibility that some external body (such as a python interpreter) still holds a reference to <em>p</em> and might still try to access it.</p>
<dl class="section user"><dt>Python</dt><dd>Not present, since when called from python there will always be a safe pointer, and so this is equivalent to <a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the packet to delete or orphan. It is safe to pass <code>null</code> (in which case this routine does nothing). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e2f7f2c116c52b44aa9dcf092a87892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2f7f2c116c52b44aa9dcf092a87892">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format. </p>
<p>The XML file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>This is the preferred way of saving a Regina data file. Typically this will be called from the root of the packet tree, which will save the entire packet tree to file.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the pathname of the file to write to. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a id="ga898ec49e8d39c46cd965ad506493f2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898ec49e8d39c46cd965ad506493f2cc">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file. </p>
<p>The data file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the given output stream.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given stream is open for writing. </dd>
<dd>
The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the data was successfully written. </dd></dl>

</div>
</div>
<a id="ga11305aefef5da98326d74c8bebe4683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11305aefef5da98326d74c8bebe4683a">&#9670;&nbsp;</a></span>savePDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PDF::savePDF </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document to the given file in <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> format. </p>
<p>This routine does not check whether the contents of this packet <em>look</em> like a <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document; it simply writes them blindly to the filesystem.</p>
<p>If no <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document is currently stored in this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet (i.e., <a class="el" href="group__packet.html#ga71eb9786bd9f73c340450b1628331039" title="Determines whether this packet is currently holding a PDF document.">isNull()</a> returns <code>true</code>), then this routine will do nothing and simply return <code>false</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it unchanged to low-level C/C++ file I/O routines.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> file to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file was successfully written, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga23822dfb026d71ca78fddb84ebf77e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23822dfb026d71ca78fddb84ebf77e7e">&#9670;&nbsp;</a></span>Script()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Script::Script </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises to a script with no text and no variables. </p>

</div>
</div>
<a id="gadfd869991cbf664891629f21a5432b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd869991cbf664891629f21a5432b02">&#9670;&nbsp;</a></span>setLabel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the label associated with this individual packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the new label to give this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3206bf85298d5fc24377f27d94926ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3206bf85298d5fc24377f27d94926ff2">&#9670;&nbsp;</a></span>setText() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Text::setText </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the packet data to the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>the new value for the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6929451806373711b09c4864642a1345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6929451806373711b09c4864642a1345">&#9670;&nbsp;</a></span>setText() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::setText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the complete text of this script with the given string. </p>
<p>Variables are not considered part of the text; you can get and set them through other member functions (see below).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>the new text for this script. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f2818598466f8b63a905cadb881da7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2818598466f8b63a905cadb881da7f">&#9670;&nbsp;</a></span>setText() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Text::setText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the packet data to the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>the new value for the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad01d2a901d584984e36e8893c9541300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad01d2a901d584984e36e8893c9541300">&#9670;&nbsp;</a></span>setVariableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::setVariableName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the name of an existing variable associated with this script. </p>
<dl class="section warning"><dt>Warning</dt><dd>This may change the indices of this and other variables, since (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable whose name should change; this must be between 0 and <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">name</td><td>the new name to assign to the variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5297bee2c6e54a37f83e448af86da6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5297bee2c6e54a37f83e448af86da6a">&#9670;&nbsp;</a></span>setVariableValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::setVariableValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the value of an existing variable associated with this script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable whose value should change; this must be between 0 and <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ae1d5476b568afe205223d8fb10563c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ae1d5476b568afe205223d8fb10563c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::PDF::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the size of this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document in bytes. </p>
<p>If no <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> document is currently stored (i.e., <a class="el" href="group__packet.html#ga71eb9786bd9f73c340450b1628331039" title="Determines whether this packet is currently holding a PDF document.">isNull()</a> returns <code>true</code>), then this routine will return zero.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes. </dd></dl>

</div>
</div>
<a id="gaf91bc951714dc60db12810affb266b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf91bc951714dc60db12810affb266b8a">&#9670;&nbsp;</a></span>sortChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::sortChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the immediate children of this packet according to their packet labels. </p>
<p>Note that this routine is not recursive (for instance, grandchildren will not be sorted within each child packet).</p>
<p>This routine takes quadratic time in the number of immediate children (and it's slow quadratic at that). </p>

</div>
</div>
<a id="ga83b13f4e881390c9a02e3ae1848d8e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b13f4e881390c9a02e3ae1848d8e6b">&#9670;&nbsp;</a></span>startContentSubElement() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * regina::XMLPacketReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented in <a class="el" href="group__detail.html#ga15f7e12e1c4be36e550c0873d227cdca">regina::detail::XMLTriangulationReaderBase&lt; dim &gt;</a>, <a class="el" href="group__detail.html#ga15f7e12e1c4be36e550c0873d227cdca">regina::detail::XMLTriangulationReaderBase&lt; 2 &gt;</a>, <a class="el" href="group__detail.html#ga15f7e12e1c4be36e550c0873d227cdca">regina::detail::XMLTriangulationReaderBase&lt; 3 &gt;</a>, <a class="el" href="group__detail.html#ga15f7e12e1c4be36e550c0873d227cdca">regina::detail::XMLTriangulationReaderBase&lt; 4 &gt;</a>, <a class="el" href="group__surfaces.html#gaae3356c94debf7c1128136248f54a953">regina::XMLNormalSurfacesReader</a>, <a class="el" href="group__surfaces.html#ga47377e99609a1ed88175aa5aee16f3ca">regina::XMLFilterPacketReader</a>, <a class="el" href="group__snappea.html#ga920f6b1984b48feb47f779c61c6e05cf">regina::XMLSnapPeaReader</a>, <a class="el" href="group__packet.html#ga24064e768fba37a4c95a09e53f3a7680">regina::XMLTextReader</a>, <a class="el" href="group__packet.html#ga1cb26942ce9450276dba92c3093f2129">regina::XMLScriptReader</a>, <a class="el" href="group__packet.html#gaf4aa2e06b6c0ebfc66ae0ee2be196422">regina::XMLPDFReader</a>, <a class="el" href="group__link.html#ga7fcee2a779b45b242dca26dff055a569">regina::XMLLinkReader</a>, <a class="el" href="group__hypersurface.html#ga1426c1a6e47bc103b23974d6fe014e6a">regina::XMLNormalHypersurfacesReader</a>, and <a class="el" href="group__angle.html#ga8b64ec2647a1c62138028feb61afbed6">regina::XMLAngleStructuresReader</a>.</p>

</div>
</div>
<a id="gaf4aa2e06b6c0ebfc66ae0ee2be196422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4aa2e06b6c0ebfc66ae0ee2be196422">&#9670;&nbsp;</a></span>startContentSubElement() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLPDFReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga1cb26942ce9450276dba92c3093f2129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cb26942ce9450276dba92c3093f2129">&#9670;&nbsp;</a></span>startContentSubElement() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLScriptReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga24064e768fba37a4c95a09e53f3a7680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24064e768fba37a4c95a09e53f3a7680">&#9670;&nbsp;</a></span>startContentSubElement() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> * regina::XMLTextReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga75cc7b21708011a1963811378edaf3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75cc7b21708011a1963811378edaf3ab">&#9670;&nbsp;</a></span>startSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLPacketReader::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga542bbef6c5302a1aebdbb39851fb01ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga542bbef6c5302a1aebdbb39851fb01ca">&#9670;&nbsp;</a></span>storeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::XMLTreeResolver::storeID </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the fact that the given packet is stored in the data file using the given internal ID. </p>
<p>Associations between IDs and packets can be queried through the <a class="el" href="group__packet.html#gafef35326137566ebe6f22533d8707e28" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> function. See <a class="el" href="group__packet.html#gafef35326137566ebe6f22533d8707e28" title="Returns the map from internal IDs to packets, as stored in the data file.">ids()</a> for further information on internal IDs.</p>
<p>This will be called automatically by <a class="el" href="classregina_1_1XMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">XMLPacketReader</a> as it processes packet tags in the data file. Users and/or subclasses of <a class="el" href="classregina_1_1XMLPacketReader.html" title="An XML element reader that reads the data for an individual packet.">XMLPacketReader</a> do not need to call this function themselves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the internal ID of the given packet, as stored in the data file. </td></tr>
    <tr><td class="paramname">packet</td><td>the corresponding packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga552be006cf9fe432a6a678aed7f4c6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga552be006cf9fe432a6a678aed7f4c6ac">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a past-the-end iterator. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself. </dd></dl>

</div>
</div>
<a id="gaf7ecbf7b86f80e45347fdbd67cd40884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7ecbf7b86f80e45347fdbd67cd40884">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>subtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>current</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the given packet within the given subtree. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td>the packet subtree that we are iterating through. This does not need to be the root of the overall packet tree (i.e., <em>subtree</em> is allowed to have a non-null parent). </td></tr>
    <tr><td class="paramname">current</td><td>the packet within the subtree that the new iterator should point to, or 0 if the new iterator should be past-the-end. If <em>current</em> is not null, then it must be equal to or a descendant of <em>subtree</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf619ec7a62275a926a723c015a386420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf619ec7a62275a926a723c015a386420">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself. </dd></dl>

</div>
</div>
<a id="gad6ee02a48a9c4be604e85e49da97ed6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6ee02a48a9c4be604e85e49da97ed6b">&#9670;&nbsp;</a></span>SubtreeIterator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SubtreeIterator::SubtreeIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>subtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the first packet within the given subtree. </p>
<p>Dereferencing this iterator will return <em>subtree</em> itself.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. The only way to create a <a class="el" href="classregina_1_1SubtreeIterator.html" title="A forward iterator for iterating through the entire packet subtree rooted at a given packet.">SubtreeIterator</a> is via Packet::subtree() or <a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5" title="Returns a lightweight object for iterating through all strict descendants of this packet in the packe...">Packet::descendants()</a>, or by iterating over a <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subtree</td><td>the packet subtree that we are iterating through. This does not need to be the root of the overall packet tree (i.e., <em>subtree</em> is allowed to have a non-null parent). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga765186c1742fe402922433b77e5f439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765186c1742fe402922433b77e5f439a">&#9670;&nbsp;</a></span>swapWithNextSibling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::swapWithNextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps this packet with its next sibling in the sequence of children beneath their common parent packet. </p>
<p>Calling this routine is equivalent to calling <a class="el" href="group__packet.html#ga59adc13b6143cf994779796077aed731" title="Moves this packet the given number of steps towards the end of its sibling list.">moveDown()</a>.</p>
<p>This routine takes small constant time.</p>
<p>If this packet has no next sibling then this routine does nothing. </p>

</div>
</div>
<a id="ga06d41356ff086d078b04f34919aac26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06d41356ff086d078b04f34919aac26d">&#9670;&nbsp;</a></span>tags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::Packet::tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set of all tags associated with this packet. </dd></dl>

</div>
</div>
<a id="ga60fe568711de8246572dc6ec376361df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60fe568711de8246572dc6ec376361df">&#9670;&nbsp;</a></span>tags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::PacketShell::tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet. </p>
<p>See <a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d" title="Returns the set of all tags associated with this packet.">Packet::tags()</a> for further details on packet tags.</p>
<p>The reference that is returned should be only used as a temporary, since the underlying packet (and therefore the set that is referenced) is in the process of being destroyed.</p>
<dl class="section user"><dt>Python</dt><dd>This routine returns a python set.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set of all tags associated with this packet. </dd></dl>

</div>
</div>
<a id="ga5982b27f5b243d449138058fd18992e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5982b27f5b243d449138058fd18992e7">&#9670;&nbsp;</a></span>Text() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Text::Text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the packet to the empty string. </p>

</div>
</div>
<a id="ga79c728e0fe7e945956323efea123c283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79c728e0fe7e945956323efea123c283">&#9670;&nbsp;</a></span>text() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::Script::text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complete text of this script. </p>
<p>Variables are not considered part of the text; you can get and set them through other member functions (see below).</p>
<dl class="section return"><dt>Returns</dt><dd>the complete text of this script. </dd></dl>

</div>
</div>
<a id="ga4315d50ce83303ed6e5bc2fef3bff229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4315d50ce83303ed6e5bc2fef3bff229">&#9670;&nbsp;</a></span>text() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::Text::text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the string stored in the packet. </p>
<dl class="section return"><dt>Returns</dt><dd>the stored string. </dd></dl>

</div>
</div>
<a id="gae353fd8b40c8545943a59d4310123fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae353fd8b40c8545943a59d4310123fb9">&#9670;&nbsp;</a></span>Text() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Text::Text </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the packet to the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>the new value for the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26ec2a83e111396b177e68fc31f8c3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ec2a83e111396b177e68fc31f8c3d6">&#9670;&nbsp;</a></span>Text() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Text::Text </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises the packet to the given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>the new value for the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae2519c2dac8e039b7acd5df8373c608d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2519c2dac8e039b7acd5df8373c608d">&#9670;&nbsp;</a></span>totalTreeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::totalTreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the total number of packets in the tree or subtree for which this packet is matriarch. </p>
<p>This packet is included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total tree or subtree size. </dd></dl>

</div>
</div>
<a id="ga27ce736503ede9e8c57fb5d169e6414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27ce736503ede9e8c57fb5d169e6414f">&#9670;&nbsp;</a></span>transferChildren()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::transferChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead. </p>
<p>The children of this packet will be appended to the end of the new parent's child list, in the same order as they were previously.</p>
<p>This is equivalent to calling <a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> on each child, but should be somewhat faster if there are many children to move.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None of the children of this packet depend on their current parent; see <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent beneath which the children will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga11e183185ea0a33e67e2574fc93c7469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e183185ea0a33e67e2574fc93c7469">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::Packet::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet. </p>
<p>This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type ID. </dd></dl>

</div>
</div>
<a id="ga787a09ec531988778fcfb0bc87effdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga787a09ec531988778fcfb0bc87effdd4">&#9670;&nbsp;</a></span>typeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string regina::Packet::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet. </p>
<p>An example is <code>Triangulation3</code>. This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type name. </dd></dl>

</div>
</div>
<a id="gae71b40cd2416de174bba61db2ec92f1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae71b40cd2416de174bba61db2ec92f1d">&#9670;&nbsp;</a></span>unlisten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::unlisten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters the given packet listener so that it no longer listens for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully unregistered, or <code>false</code> if the given listener was not registered in the first place. </dd></dl>

</div>
</div>
<a id="ga88fd0a82cc44c243e1f3d4041b86792a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88fd0a82cc44c243e1f3d4041b86792a">&#9670;&nbsp;</a></span>unregisterFromAllPackets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PacketListener::unregisterFromAllPackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters this listener from any packets to which it is currently listening. </p>

</div>
</div>
<a id="ga073060339cc90df355f017f16f2f9a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073060339cc90df355f017f16f2f9a65">&#9670;&nbsp;</a></span>variableIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::Script::variableIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the variable stored with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the requested variable; note that names are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the requested variable as an integer between 0 and <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive, or -1 if there is no variable with the given name. </dd></dl>

</div>
</div>
<a id="ga2d014bbd8516fe0416988e7e48d3fce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d014bbd8516fe0416988e7e48d3fce1">&#9670;&nbsp;</a></span>variableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; regina::Script::variableName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of the requested variable associated with this script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested variable; this must be between 0 and <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the requested variable. </dd></dl>

</div>
</div>
<a id="ga2e30eb1563860eb32b5bc6facdae1a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e30eb1563860eb32b5bc6facdae1a3b">&#9670;&nbsp;</a></span>variableValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Script::variableValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the variable stored with the given name. </p>
<p>Variables may take the value <code>null</code>.</p>
<p>If no variable is stored with the given name, then <code>null</code> will likewise be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the requested variable; note that names are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the requested variable. </dd></dl>

</div>
</div>
<a id="ga4d9548cc36df18774225d3954c223f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d9548cc36df18774225d3954c223f7c">&#9670;&nbsp;</a></span>variableValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Script::variableValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the requested variable associated with this script. </p>
<p>Variables may take the value <code>null</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested variable; this must be between 0 and <a class="el" href="group__packet.html#gabdf82c530167301864f61c86d4fcdbe4" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the requested variable. </dd></dl>

</div>
</div>
<a id="ga044a5c8d80d5aeb0e13a335bfc9b4ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__generic.html#gab333a00e997d1ce0b0fecdc8688d4578">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="group__generic.html#gab333a00e997d1ce0b0fecdc8688d4578">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="group__dim4.html#ga5c1649cc8c94d07193c81a55ffd76120">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="group__dim3.html#ga0e3c9276224681ca932912e989485266">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="group__dim2.html#ga0f6866e00e66265effb4cdc4e9e4eda8">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="group__surfaces.html#ga7c50e18076483d95864ad345650d2888">regina::SurfaceFilterProperties</a>, <a class="el" href="group__surfaces.html#ga151cff12a4c85a04fd8e5d7f617a90f0">regina::SurfaceFilterCombination</a>, <a class="el" href="group__surfaces.html#gad07dcdec28b20348705f8cec15838957">regina::NormalSurfaces</a>, <a class="el" href="group__snappea.html#gaf07da75247cb831ad93b1b5cd865d598">regina::SnapPeaTriangulation</a>, <a class="el" href="group__packet.html#gafe65a9b4b9fc9430a6b161bae995f024">regina::Text</a>, <a class="el" href="group__packet.html#gacde4bee19f71a36759d51e1939a1a841">regina::Script</a>, <a class="el" href="group__link.html#ga58309b754fc2392ea83ee63c77a961b8">regina::Link</a>, <a class="el" href="group__hypersurface.html#ga938dd8acfd2cdab2f6854305bbae4c97">regina::NormalHypersurfaces</a>, and <a class="el" href="group__angle.html#ga12c0c8c9b7bb190f32e48573b4299de4">regina::AngleStructures</a>.</p>

</div>
</div>
<a id="gacde4bee19f71a36759d51e1939a1a841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacde4bee19f71a36759d51e1939a1a841">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Script::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="gafe65a9b4b9fc9430a6b161bae995f024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe65a9b4b9fc9430a6b161bae995f024">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Text::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="ga54930e66829e2b832b2b8d5b6813e55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54930e66829e2b832b2b8d5b6813e55d">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Packet::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__generic.html#gac16b56b45355b0e5b78d64d0b4415dd5">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="group__generic.html#gac16b56b45355b0e5b78d64d0b4415dd5">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="group__dim4.html#ga53da06903ab0b18888259626b947adcf">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="group__dim3.html#gaf5d26032c0c2af5a7c9f931df93edaed">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="group__dim2.html#ga7c34d61039e1c28d575815f4b90c0daf">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="group__surfaces.html#gaf9ec7fe3b0c83880fc4d8bde58853cae">regina::SurfaceFilter</a>, <a class="el" href="group__surfaces.html#ga6801fb032b55c800bb82e89fce2bbe71">regina::NormalSurfaces</a>, <a class="el" href="group__snappea.html#ga97281c7fda7388050d52d3450b83d195">regina::SnapPeaTriangulation</a>, <a class="el" href="group__packet.html#ga0b5ade64bc08041b7bdf135ae6e65f16">regina::Text</a>, <a class="el" href="group__packet.html#ga161bba5734a7675ae64dee54b8fd07ef">regina::Script</a>, <a class="el" href="group__packet.html#gafbb9f8c4de7a10db3ad24d0adb463d2d">regina::PDF</a>, <a class="el" href="group__packet.html#ga0ab175cd8a5430641393166c9d6ff0d8">regina::Container</a>, <a class="el" href="group__link.html#ga645147f6f603066ea0eb85a8d0978578">regina::Link</a>, <a class="el" href="group__hypersurface.html#ga3f0bf074f42a0da5e565bb79831d6d30">regina::NormalHypersurfaces</a>, and <a class="el" href="group__angle.html#ga125b651b08f8aa07d79f450a6f29ff7d">regina::AngleStructures</a>.</p>

</div>
</div>
<a id="ga0ab175cd8a5430641393166c9d6ff0d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ab175cd8a5430641393166c9d6ff0d8">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Container::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="gafbb9f8c4de7a10db3ad24d0adb463d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb9f8c4de7a10db3ad24d0adb463d2d">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::PDF::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="ga161bba5734a7675ae64dee54b8fd07ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga161bba5734a7675ae64dee54b8fd07ef">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Script::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="ga0b5ade64bc08041b7bdf135ae6e65f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b5ade64bc08041b7bdf135ae6e65f16">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Text::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="ga0bf681a968d890cd848f1277ea22ea0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bf681a968d890cd848f1277ea22ea0f">&#9670;&nbsp;</a></span>writeXMLFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format. </p>
<p>Ths is similar to calling <a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a>, except that (i) the user has a more flexible choice of output stream, and (ii) the XML will always be written in plain text (i.e., it will not be compressed).</p>
<p>If you simply wish to save your data to a file on the filesystem, you should call <a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a> instead.</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the output stream.</p>
<p>The output from this routine cannot be used as a piece of an XML file; it must be the entire XML file. For a piece of an XML file, see routine <a class="el" href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54" title="Writes a chunk of XML containing the subtree with this packet as matriarch.">writeXMLPacketTree()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend upon its parent.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>The argument <em>out</em> is not present; instead the XML data is written to standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML data file should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7efec42b4c85d5590a07a0184bb3b0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7efec42b4c85d5590a07a0184bb3b0ec">&#9670;&nbsp;</a></span>writeXMLPacketData() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Packet::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="group__generic.html#ga959254d7310092ce115f5ff90529aceb">regina::Triangulation&lt; dim &gt;</a>, <a class="el" href="group__generic.html#ga959254d7310092ce115f5ff90529aceb">regina::Triangulation&lt; dim-1 &gt;</a>, <a class="el" href="group__dim4.html#gaf9229ac59708fe4332b37eae95760bd4">regina::Triangulation&lt; 4 &gt;</a>, <a class="el" href="group__dim3.html#ga3951498021127cad3b20bb1e1c415809">regina::Triangulation&lt; 3 &gt;</a>, <a class="el" href="group__dim2.html#gacadc8156422f519fc0747dbf9afee9a1">regina::Triangulation&lt; 2 &gt;</a>, <a class="el" href="group__surfaces.html#gae94055c65c176f663111268c8f8de9d4">regina::SurfaceFilter</a>, <a class="el" href="group__surfaces.html#gaa5539ec7f016ba2e9fca94f00971f4c3">regina::NormalSurfaces</a>, <a class="el" href="group__snappea.html#gac22f69e3264630bc043c69d97921a316">regina::SnapPeaTriangulation</a>, <a class="el" href="group__packet.html#ga081c43ec9110be27b224f430c4212861">regina::Text</a>, <a class="el" href="group__packet.html#gac09bcb96ff3f280e15400bda3afb2d45">regina::Script</a>, <a class="el" href="group__packet.html#gaab128672dc3fe2d6aee4674c16cdb6a6">regina::PDF</a>, <a class="el" href="group__packet.html#ga913d6a5436e25a67c22d751167966b6f">regina::Container</a>, <a class="el" href="group__link.html#ga4df95452d2c6fdd8ec754c5adbaf9505">regina::Link</a>, <a class="el" href="group__hypersurface.html#gaf3d6b7be21b48e6ed50652634a85fcac">regina::NormalHypersurfaces</a>, and <a class="el" href="group__angle.html#gafe639ef03c5af712afaae0b602dab37f">regina::AngleStructures</a>.</p>

</div>
</div>
<a id="ga913d6a5436e25a67c22d751167966b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga913d6a5436e25a67c22d751167966b6f">&#9670;&nbsp;</a></span>writeXMLPacketData() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Container::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="gaab128672dc3fe2d6aee4674c16cdb6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab128672dc3fe2d6aee4674c16cdb6a6">&#9670;&nbsp;</a></span>writeXMLPacketData() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::PDF::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="gac09bcb96ff3f280e15400bda3afb2d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac09bcb96ff3f280e15400bda3afb2d45">&#9670;&nbsp;</a></span>writeXMLPacketData() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Script::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="ga081c43ec9110be27b224f430c4212861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081c43ec9110be27b224f430c4212861">&#9670;&nbsp;</a></span>writeXMLPacketData() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::Text::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="ga690d1f04ae42ab3778726d37fbd0fe54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga690d1f04ae42ab3778726d37fbd0fe54">&#9670;&nbsp;</a></span>writeXMLPacketTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLPacketTree </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the subtree with this packet as matriarch. </p>
<p>This is the preferred way of writing a packet tree to file.</p>
<p>The output from this routine is only a piece of XML; it should not be used as a complete XML file. For a complete XML file, see routine <a class="el" href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f" title="Writes the subtree rooted at this packet to the given output stream in Regina&#39;s native XML file forma...">writeXMLFile()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46932d1f67d986ef0a79b597800cdc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46932d1f67d986ef0a79b597800cdc58">&#9670;&nbsp;</a></span>XMLContainerReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLContainerReader::XMLContainerReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new container reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3409bc6a8ba0447646285d437dbf971f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3409bc6a8ba0447646285d437dbf971f">&#9670;&nbsp;</a></span>XMLPacketReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLPacketReader::XMLPacketReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new packet element reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9579071cdbbbe615d7f075251cbdd5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9579071cdbbbe615d7f075251cbdd5a7">&#9670;&nbsp;</a></span>XMLPDFReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLPDFReader::XMLPDFReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f48a115e3ad5912a038c8d00900eae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f48a115e3ad5912a038c8d00900eae1">&#9670;&nbsp;</a></span>xmlReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a>* regina::Packet::xmlReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created XML element reader that will read the contents of a single XML packet element. </p>
<p>You may assume that the packet to be read is of the same type as the class in which you are implementing this routine.</p>
<p>The XML element reader should read exactly what <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec" title="Writes a chunk of XML containing the data for this packet only.">writeXMLPacketData()</a> writes, and vice versa.</p>
<p><em>parent</em> represents the packet which will become the new packet's parent in the tree structure, and may be assumed to have already been read from the file. This information is for reference only, and does not need to be used. The XML element reader can either insert or not insert the new packet beneath <em>parent</em> in the tree structure as it pleases. Note however that <em>parent</em> will be 0 if the new packet is to become a tree matriarch.</p>
<p>If the new packet needs to store pointers to other packets that might not have been read yet (such as a script packet that needs pointers to its variables), then it should queue a new <a class="el" href="classregina_1_1XMLTreeResolutionTask.html" title="An individual task for resolving dangling packet references after an XML data file has been read.">XMLTreeResolutionTask</a> to the given <a class="el" href="classregina_1_1XMLTreeResolver.html" title="Provides a mechanism to resolve dangling packet references after a complete packet tree has been read...">XMLTreeResolver</a>. After the complete data file has been read, <a class="el" href="group__packet.html#ga6deb2e7eb029a52c8c73af2dfdda9484" title="Calls XMLTreeResolutionTask::resolve() for all queued tasks.">XMLTreeResolver::resolve()</a> will run all of its queued tasks, at which point the new packet can resolve any dangling references.</p>
<p>This routine is not actually provided for <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> itself, but must be declared and implemented for every packet subclass that will be instantiated.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the packet which will become the new packet's parent in the tree structure, or 0 if the new packet is to be tree matriarch. </td></tr>
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created XML element reader. </dd></dl>

</div>
</div>
<a id="gaa2b611020b93fcbc79a9c206420c19e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b611020b93fcbc79a9c206420c19e9">&#9670;&nbsp;</a></span>XMLScriptReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLScriptReader::XMLScriptReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new script reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84b3d1121619d803d38d1584acb733d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84b3d1121619d803d38d1584acb733d2">&#9670;&nbsp;</a></span>XMLTextReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLTextReader::XMLTextReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new text packet reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61fd37b6db545006a3016b721c99a15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61fd37b6db545006a3016b721c99a15b">&#9670;&nbsp;</a></span>XMLTreeResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLTreeResolver::XMLTreeResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a resolver with no tasks queued. </p>

</div>
</div>
<a id="ga90b86447dbb2a828673adb6b5c508d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90b86447dbb2a828673adb6b5c508d34">&#9670;&nbsp;</a></span>~ChangeEventSpan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::Packet::ChangeEventSpan::~ChangeEventSpan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this change event object. </p>
<p>If this is the only <a class="el" href="classregina_1_1Packet_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a> currently in existence for the given packet, this destructor will call <a class="el" href="group__packet.html#ga113b2c051046b67870da4a4953422438" title="Called after the contents of the packet have been changed.">PacketListener::packetWasChanged()</a> for all registered listeners for the given packet. </p>

</div>
</div>
<a id="gad5fc332c4380895ff045b21025703b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5fc332c4380895ff045b21025703b16">&#9670;&nbsp;</a></span>~Packet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::Packet::~Packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor that also orphans this packet and destroys all of its descendants. </p>
<p>This destructor calls <a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e" title="Either destroys or orphans the given packet, according to whether it has safe pointers that currently...">safeDelete()</a> on its descendants. Therefore, if any descendants have safe pointers that reference them, those descendants will remain orphaned but alive (and their lifespans will now be managed by <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> instead). See <a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e" title="Either destroys or orphans the given packet, according to whether it has safe pointers that currently...">safeDelete()</a> for details. </p>

</div>
</div>
<a id="gabd98cb9168c4333925f340e5f7310423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd98cb9168c4333925f340e5f7310423">&#9670;&nbsp;</a></span>~PacketListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::PacketListener::~PacketListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this listener. </p>
<p>This listener will be unregistered from any packets to which it is currently listening. </p>

</div>
</div>
<a id="gad866a30d6060f56ec693800091ac268b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad866a30d6060f56ec693800091ac268b">&#9670;&nbsp;</a></span>~PDF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PDF::~PDF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this <a class="el" href="classregina_1_1PDF.html" title="A packet that can hold a PDF document.">PDF</a> packet and deallocates data if required. </p>

</div>
</div>
<a id="gabb4fcbf8842f420457ae01c30f4898d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb4fcbf8842f420457ae01c30f4898d7">&#9670;&nbsp;</a></span>~XMLTreeResolutionTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLTreeResolutionTask::~XMLTreeResolutionTask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A default construct that does nothing. </p>

</div>
</div>
<a id="ga4285bf757b67d109b1e86de9f07211de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4285bf757b67d109b1e86de9f07211de">&#9670;&nbsp;</a></span>~XMLTreeResolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLTreeResolver::~XMLTreeResolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys any tasks that were queued but not performed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga455ca759888786ae6bf7be5fb0b65236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga455ca759888786ae6bf7be5fb0b65236">&#9670;&nbsp;</a></span>PACKET_ANGLESTRUCTURELIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_ANGLESTRUCTURELIST = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa3d118073db391a7c5d74791bdcbddfa9">PACKET_ANGLESTRUCTURES</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_ANGLESTRUCTURES. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000092">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_ANGLESTRUCTURES. </dd></dl>

</div>
</div>
<a id="ga05f45d5e55b081a0ada789479ed34f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05f45d5e55b081a0ada789479ed34f6c">&#9670;&nbsp;</a></span>PACKET_DIM2TRIANGULATION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_DIM2TRIANGULATION = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa5f0b8f982543a100097916c828cc3815">PACKET_TRIANGULATION2</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_TRIANGULATION2. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000095">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_TRIANGULATION2. </dd></dl>

</div>
</div>
<a id="ga63030f7812e66bd10741a6186c542c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63030f7812e66bd10741a6186c542c96">&#9670;&nbsp;</a></span>PACKET_DIM4TRIANGULATION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_DIM4TRIANGULATION = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa511a7e4a0e8e77e4ebd9ca9ef7efedff">PACKET_TRIANGULATION4</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_TRIANGULATION4. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000093">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_TRIANGULATION4. </dd></dl>

</div>
</div>
<a id="ga5161f01c333fa03786d0bb40b6f68580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5161f01c333fa03786d0bb40b6f68580">&#9670;&nbsp;</a></span>PACKET_NORMALHYPERSURFACELIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_NORMALHYPERSURFACELIST = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa69a30e6df7c39d51337e474b49cec47e">PACKET_NORMALHYPERSURFACES</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_NORMALHYPERSURFACES. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000094">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_NORMALHYPERSURFACES. </dd></dl>

</div>
</div>
<a id="ga46ee82ab98a53118996b1b0ef1be1c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46ee82ab98a53118996b1b0ef1be1c1a">&#9670;&nbsp;</a></span>PACKET_NORMALSURFACELIST</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_NORMALSURFACELIST = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefa99315edbd085157bfad36adda33eeffc">PACKET_NORMALSURFACES</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_NORMALSURFACES. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000091">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_NORMALSURFACES. </dd></dl>

</div>
</div>
<a id="ga1bc5e3b33bf3a5ac165b99b9956b284e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc5e3b33bf3a5ac165b99b9956b284e">&#9670;&nbsp;</a></span>PACKET_TRIANGULATION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::PACKET_TRIANGULATION = <a class="el" href="group__packet.html#gga982f45957b093a38120119066dc4cfefac4ccce0feddec583050b2dfe802b0e64">PACKET_TRIANGULATION3</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated alias for PACKET_TRIANGULATION3. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000090">Deprecated:</a></b></dt><dd>This constant has been renamed to PACKET_TRIANGULATION3. </dd></dl>

</div>
</div>
<a id="ga322f7e7b2069dbcb08a1c858d639ae90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga322f7e7b2069dbcb08a1c858d639ae90">&#9670;&nbsp;</a></span>resolver_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a>&amp; regina::XMLPacketReader::resolver_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The master resolver that will be used to fix dangling packet references after the entire XML file has been read. </p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="gae51cb555166657e5996a76768db998e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51cb555166657e5996a76768db998e3">&#9670;&nbsp;</a></span>Packet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classregina_1_1Packet.html">Packet</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow packets to automatically deregister listeners as they are destroyed. </p>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
