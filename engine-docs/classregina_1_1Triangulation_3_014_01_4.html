<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::Triangulation&lt; 4 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html">Triangulation< 4 ></a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Triangulation_3_014_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::Triangulation&lt; 4 &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__dim4.html">4-Manifold Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a 4-dimensional triangulation, typically of a 4-manifold.  
 <a href="classregina_1_1Triangulation_3_014_01_4.html#details">More...</a></p>

<p><code>#include &lt;triangulation/dim4.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Triangulation&lt; 4 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Triangulation_3_014_01_4.png" usemap="#regina::Triangulation&lt; 4 &gt;_map" alt=""/>
  <map id="regina::Triangulation&lt; 4 &gt;_map" name="regina::Triangulation&lt; 4 &gt;_map">
<area href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon." alt="regina::Packet" shape="rect" coords="0,336,404,360"/>
<area href="classregina_1_1detail_1_1TriangulationBase.html" alt="regina::detail::TriangulationBase&lt; 4 &gt;" shape="rect" coords="828,336,1232,360"/>
<area href="classregina_1_1alias_1_1FacesOfTriangulation.html" alt="regina::alias::FacesOfTriangulation&lt; TriangulationBase&lt; dim &gt;, dim &gt;" shape="rect" coords="1242,224,1646,248"/>
<area href="classregina_1_1alias_1_1FaceOfTriangulation.html" alt="regina::alias::FaceOfTriangulation&lt; TriangulationBase&lt; dim &gt;, dim &gt;" shape="rect" coords="1242,168,1646,192"/>
<area href="classregina_1_1alias_1_1SimplexAt.html" alt="regina::alias::SimplexAt&lt; TriangulationBase&lt; dim &gt;, dim, true &gt;" shape="rect" coords="1242,112,1646,136"/>
<area href="classregina_1_1alias_1_1Simplices.html" alt="regina::alias::Simplices&lt; TriangulationBase&lt; dim &gt;, dim &gt;" shape="rect" coords="1242,56,1646,80"/>
<area href="classregina_1_1detail_1_1FaceListSuite.html" alt="regina::detail::FaceListSuite&lt; dim, dim-1 &gt;" shape="rect" coords="1242,0,1646,24"/>
<area href="classregina_1_1SafePointeeBase.html" alt="regina::SafePointeeBase&lt; Packet &gt;" shape="rect" coords="414,224,818,248"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Packet &gt;" shape="rect" coords="414,168,818,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac33fe1474aae3d6f9e163e8a2f07af1f"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a><br class="typebreak"/>
&lt; 4 &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ac33fe1474aae3d6f9e163e8a2f07af1f">PentachoronIterator</a></td></tr>
<tr class="memdesc:ac33fe1474aae3d6f9e163e8a2f07af1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for SimplexIterator, used to iterate through pentachora.  <a href="#ac33fe1474aae3d6f9e163e8a2f07af1f">More...</a><br/></td></tr>
<tr class="separator:ac33fe1474aae3d6f9e163e8a2f07af1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad704df006b6f8f32c33701ecf4440bde"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; 4, 3 &gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ad704df006b6f8f32c33701ecf4440bde">TetrahedronIterator</a></td></tr>
<tr class="memdesc:ad704df006b6f8f32c33701ecf4440bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through tetrahedra.  <a href="#ad704df006b6f8f32c33701ecf4440bde">More...</a><br/></td></tr>
<tr class="separator:ad704df006b6f8f32c33701ecf4440bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea4acf0ddfe4cf058f1c5b7e144d058"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; 4, 2 &gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#afea4acf0ddfe4cf058f1c5b7e144d058">TriangleIterator</a></td></tr>
<tr class="memdesc:afea4acf0ddfe4cf058f1c5b7e144d058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through triangles.  <a href="#afea4acf0ddfe4cf058f1c5b7e144d058">More...</a><br/></td></tr>
<tr class="separator:afea4acf0ddfe4cf058f1c5b7e144d058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0ad96a6f6924ea13b98d66f3e34aae"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; 4, 1 &gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a0b0ad96a6f6924ea13b98d66f3e34aae">EdgeIterator</a></td></tr>
<tr class="memdesc:a0b0ad96a6f6924ea13b98d66f3e34aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through edges.  <a href="#a0b0ad96a6f6924ea13b98d66f3e34aae">More...</a><br/></td></tr>
<tr class="separator:a0b0ad96a6f6924ea13b98d66f3e34aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc805e64ba49509346eee9976a289c1d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; 4, 0 &gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#afc805e64ba49509346eee9976a289c1d">VertexIterator</a></td></tr>
<tr class="memdesc:afc805e64ba49509346eee9976a289c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through vertices.  <a href="#afc805e64ba49509346eee9976a289c1d">More...</a><br/></td></tr>
<tr class="separator:afc805e64ba49509346eee9976a289c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td></tr>
<tr class="memdesc:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object being pointed to.  <a href="#a2e4bacf91fc79a12ae3a02f4339ed034">More...</a><br/></td></tr>
<tr class="separator:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3023c0479b8cc8aeec3dffa6fa62eb"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a><br class="typebreak"/>
&lt; dim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9f3023c0479b8cc8aeec3dffa6fa62eb">SimplexIterator</a></td></tr>
<tr class="memdesc:a9f3023c0479b8cc8aeec3dffa6fa62eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through top-dimensional simplices.  <a href="#a9f3023c0479b8cc8aeec3dffa6fa62eb">More...</a><br/></td></tr>
<tr class="separator:a9f3023c0479b8cc8aeec3dffa6fa62eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb85b172fe187672d3495a557aa394bf"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a><br class="typebreak"/>
&lt; dim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#acb85b172fe187672d3495a557aa394bf">ComponentIterator</a></td></tr>
<tr class="memdesc:acb85b172fe187672d3495a557aa394bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through connected components.  <a href="#acb85b172fe187672d3495a557aa394bf">More...</a><br/></td></tr>
<tr class="separator:acb85b172fe187672d3495a557aa394bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaff07ebf1a7c7d92dc100c1fdc343ba"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt;<br class="typebreak"/>
 * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afaff07ebf1a7c7d92dc100c1fdc343ba">BoundaryComponentIterator</a></td></tr>
<tr class="memdesc:afaff07ebf1a7c7d92dc100c1fdc343ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to iterate through boundary components.  <a href="#afaff07ebf1a7c7d92dc100c1fdc343ba">More...</a><br/></td></tr>
<tr class="separator:afaff07ebf1a7c7d92dc100c1fdc343ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a169e28db650e7ad0b25d27a028a83ea0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a169e28db650e7ad0b25d27a028a83ea0">hasOwner</a> () const </td></tr>
<tr class="memdesc:a169e28db650e7ad0b25d27a028a83ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object.  <a href="#a169e28db650e7ad0b25d27a028a83ea0">More...</a><br/></td></tr>
<tr class="separator:a169e28db650e7ad0b25d27a028a83ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9277bf15589bb730bded019289311ac7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9277bf15589bb730bded019289311ac7">makeCanonical</a> ()</td></tr>
<tr class="memdesc:a9277bf15589bb730bded019289311ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form.  <a href="#a9277bf15589bb730bded019289311ac7">More...</a><br/></td></tr>
<tr class="separator:a9277bf15589bb730bded019289311ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:a4fd3ec37dc565bc0fd85e687b8c2e0a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a4fd3ec37dc565bc0fd85e687b8c2e0a8">Triangulation</a> ()</td></tr>
<tr class="memdesc:a4fd3ec37dc565bc0fd85e687b8c2e0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a4fd3ec37dc565bc0fd85e687b8c2e0a8">More...</a><br/></td></tr>
<tr class="separator:a4fd3ec37dc565bc0fd85e687b8c2e0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74447c6c16259c2f393d5ed70666633"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ac74447c6c16259c2f393d5ed70666633">Triangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> &amp;copy)</td></tr>
<tr class="memdesc:ac74447c6c16259c2f393d5ed70666633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given triangulation.  <a href="#ac74447c6c16259c2f393d5ed70666633">More...</a><br/></td></tr>
<tr class="separator:ac74447c6c16259c2f393d5ed70666633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220911cb1d36d4ea426916bd60873c62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a220911cb1d36d4ea426916bd60873c62">Triangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> &amp;copy, bool cloneProps)</td></tr>
<tr class="memdesc:a220911cb1d36d4ea426916bd60873c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties also.  <a href="#a220911cb1d36d4ea426916bd60873c62">More...</a><br/></td></tr>
<tr class="separator:a220911cb1d36d4ea426916bd60873c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8a0ae3adcbadf6d4a6f3d834507acb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a7c8a0ae3adcbadf6d4a6f3d834507acb">Triangulation</a> (const std::string &amp;description)</td></tr>
<tr class="memdesc:a7c8a0ae3adcbadf6d4a6f3d834507acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Magic" constructor that tries to find some way to interpret the given string as a triangulation.  <a href="#a7c8a0ae3adcbadf6d4a6f3d834507acb">More...</a><br/></td></tr>
<tr class="separator:a7c8a0ae3adcbadf6d4a6f3d834507acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d2c8a64156a5e125832a53573b67c9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a51d2c8a64156a5e125832a53573b67c9">~Triangulation</a> ()</td></tr>
<tr class="memdesc:a51d2c8a64156a5e125832a53573b67c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this triangulation.  <a href="#a51d2c8a64156a5e125832a53573b67c9">More...</a><br/></td></tr>
<tr class="separator:a51d2c8a64156a5e125832a53573b67c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Administration</div></td></tr>
<tr class="memitem:a40a83bcecd330e4c4a1f4f154b7063f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a40a83bcecd330e4c4a1f4f154b7063f7">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a40a83bcecd330e4c4a1f4f154b7063f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a40a83bcecd330e4c4a1f4f154b7063f7">More...</a><br/></td></tr>
<tr class="separator:a40a83bcecd330e4c4a1f4f154b7063f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea340c604530a924c5dbd39aa5296114"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aea340c604530a924c5dbd39aa5296114">writeTextLong</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:aea340c604530a924c5dbd39aa5296114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#aea340c604530a924c5dbd39aa5296114">More...</a><br/></td></tr>
<tr class="separator:aea340c604530a924c5dbd39aa5296114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bedb5d2600fe116d84b4aee4233f994"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a1bedb5d2600fe116d84b4aee4233f994">dependsOnParent</a> () const </td></tr>
<tr class="memdesc:a1bedb5d2600fe116d84b4aee4233f994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="#a1bedb5d2600fe116d84b4aee4233f994">More...</a><br/></td></tr>
<tr class="separator:a1bedb5d2600fe116d84b4aee4233f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pentachora</div></td></tr>
<tr class="memitem:a1d69a225b15d4481c083a59dbcb03234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a1d69a225b15d4481c083a59dbcb03234">newPentachoron</a> ()</td></tr>
<tr class="memdesc:a1d69a225b15d4481c083a59dbcb03234"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>.  <a href="#a1d69a225b15d4481c083a59dbcb03234">More...</a><br/></td></tr>
<tr class="separator:a1d69a225b15d4481c083a59dbcb03234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c7037574e244df13e5d01e1a383054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a59c7037574e244df13e5d01e1a383054">newPentachoron</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a59c7037574e244df13e5d01e1a383054"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>.  <a href="#a59c7037574e244df13e5d01e1a383054">More...</a><br/></td></tr>
<tr class="separator:a59c7037574e244df13e5d01e1a383054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314107e68322e78d6ed299df38731a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a314107e68322e78d6ed299df38731a58">removePentachoron</a> (<a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *tet)</td></tr>
<tr class="memdesc:a314107e68322e78d6ed299df38731a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a>.  <a href="#a314107e68322e78d6ed299df38731a58">More...</a><br/></td></tr>
<tr class="separator:a314107e68322e78d6ed299df38731a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad555b8265046c5f3fc09c2b53fab832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ad555b8265046c5f3fc09c2b53fab832f">removePentachoronAt</a> (size_t index)</td></tr>
<tr class="memdesc:ad555b8265046c5f3fc09c2b53fab832f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a>.  <a href="#ad555b8265046c5f3fc09c2b53fab832f">More...</a><br/></td></tr>
<tr class="separator:ad555b8265046c5f3fc09c2b53fab832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae3b14078042b410238501a0947dcc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#abae3b14078042b410238501a0947dcc4">removeAllPentachora</a> ()</td></tr>
<tr class="memdesc:abae3b14078042b410238501a0947dcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a>.  <a href="#abae3b14078042b410238501a0947dcc4">More...</a><br/></td></tr>
<tr class="separator:abae3b14078042b410238501a0947dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Properties</div></td></tr>
<tr class="memitem:a3285165a44c7b17d366f6ce114cc5abd"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a3285165a44c7b17d366f6ce114cc5abd">eulerCharManifold</a> () const </td></tr>
<tr class="memdesc:a3285165a44c7b17d366f6ce114cc5abd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the corresponding compact manifold.  <a href="#a3285165a44c7b17d366f6ce114cc5abd">More...</a><br/></td></tr>
<tr class="separator:a3285165a44c7b17d366f6ce114cc5abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aae2fbe0e82421d616d094ed59951e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a71aae2fbe0e82421d616d094ed59951e">isIdeal</a> () const </td></tr>
<tr class="memdesc:a71aae2fbe0e82421d616d094ed59951e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is ideal.  <a href="#a71aae2fbe0e82421d616d094ed59951e">More...</a><br/></td></tr>
<tr class="separator:a71aae2fbe0e82421d616d094ed59951e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8497f646fe594b88b0490e3f60138cbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a8497f646fe594b88b0490e3f60138cbe">isClosed</a> () const </td></tr>
<tr class="memdesc:a8497f646fe594b88b0490e3f60138cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is closed.  <a href="#a8497f646fe594b88b0490e3f60138cbe">More...</a><br/></td></tr>
<tr class="separator:a8497f646fe594b88b0490e3f60138cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebraic Properties</div></td></tr>
<tr class="memitem:af1744de7cd6f1d4b6c269f4f62d4f77c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#af1744de7cd6f1d4b6c269f4f62d4f77c">homologyH2</a> () const </td></tr>
<tr class="memdesc:af1744de7cd6f1d4b6c269f4f62d4f77c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second homology group for this triangulation.  <a href="#af1744de7cd6f1d4b6c269f4f62d4f77c">More...</a><br/></td></tr>
<tr class="separator:af1744de7cd6f1d4b6c269f4f62d4f77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Transformations</div></td></tr>
<tr class="memitem:aaa321f1bfb037aac23161b1f40745337"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aaa321f1bfb037aac23161b1f40745337">intelligentSimplify</a> ()</td></tr>
<tr class="memdesc:aaa321f1bfb037aac23161b1f40745337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to simplify the triangulation as intelligently as possible without further input.  <a href="#aaa321f1bfb037aac23161b1f40745337">More...</a><br/></td></tr>
<tr class="separator:aaa321f1bfb037aac23161b1f40745337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2cee85d413b4bec25ce97a7feadd86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aac2cee85d413b4bec25ce97a7feadd86">simplifyToLocalMinimum</a> (bool perform=true)</td></tr>
<tr class="memdesc:aac2cee85d413b4bec25ce97a7feadd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses all known simplification moves to reduce the triangulation monotonically to some local minimum number of pentachora.  <a href="#aac2cee85d413b4bec25ce97a7feadd86">More...</a><br/></td></tr>
<tr class="separator:aac2cee85d413b4bec25ce97a7feadd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea57a753fbe674471b3abaa24e4098ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aea57a753fbe674471b3abaa24e4098ff">fourTwoMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:aea57a753fbe674471b3abaa24e4098ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 4-2 move about the given edge.  <a href="#aea57a753fbe674471b3abaa24e4098ff">More...</a><br/></td></tr>
<tr class="separator:aea57a753fbe674471b3abaa24e4098ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74167a47084c10334c086d8c4cce7c4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a74167a47084c10334c086d8c4cce7c4c">threeThreeMove</a> (<a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 4 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a74167a47084c10334c086d8c4cce7c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 3-3 move about the given triangle.  <a href="#a74167a47084c10334c086d8c4cce7c4c">More...</a><br/></td></tr>
<tr class="separator:a74167a47084c10334c086d8c4cce7c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21e8b23c65ad86ef13bafab18f5be37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#af21e8b23c65ad86ef13bafab18f5be37">twoFourMove</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 4 &gt; *f, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:af21e8b23c65ad86ef13bafab18f5be37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-4 move about the given facet.  <a href="#af21e8b23c65ad86ef13bafab18f5be37">More...</a><br/></td></tr>
<tr class="separator:af21e8b23c65ad86ef13bafab18f5be37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4bc27f38ebe29c0b1c97b54198905"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aceb4bc27f38ebe29c0b1c97b54198905">oneFiveMove</a> (<a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *p, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:aceb4bc27f38ebe29c0b1c97b54198905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 1-5 move upon the given pentachoron.  <a href="#aceb4bc27f38ebe29c0b1c97b54198905">More...</a><br/></td></tr>
<tr class="separator:aceb4bc27f38ebe29c0b1c97b54198905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d260a693839e3b4a2568d2912468989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a5d260a693839e3b4a2568d2912468989">twoZeroMove</a> (<a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 4 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a5d260a693839e3b4a2568d2912468989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-0 move about the given triangle of degree 2.  <a href="#a5d260a693839e3b4a2568d2912468989">More...</a><br/></td></tr>
<tr class="separator:a5d260a693839e3b4a2568d2912468989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88995126c5d87e4385707405d13e293d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a88995126c5d87e4385707405d13e293d">twoZeroMove</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:a88995126c5d87e4385707405d13e293d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a 2-0 move about the given edge of degree 2.  <a href="#a88995126c5d87e4385707405d13e293d">More...</a><br/></td></tr>
<tr class="separator:a88995126c5d87e4385707405d13e293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee16539dda7c9dbb9d61cdf9d3613886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aee16539dda7c9dbb9d61cdf9d3613886">openBook</a> (<a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 4 &gt; *t, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:aee16539dda7c9dbb9d61cdf9d3613886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a book opening move about the given tetrahedron.  <a href="#aee16539dda7c9dbb9d61cdf9d3613886">More...</a><br/></td></tr>
<tr class="separator:aee16539dda7c9dbb9d61cdf9d3613886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44adb3b646f2fa05ba474e3943db766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ae44adb3b646f2fa05ba474e3943db766">shellBoundary</a> (<a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *p, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ae44adb3b646f2fa05ba474e3943db766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a boundary shelling move on the given pentachoron.  <a href="#ae44adb3b646f2fa05ba474e3943db766">More...</a><br/></td></tr>
<tr class="separator:ae44adb3b646f2fa05ba474e3943db766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d810266ae73fffbea59f2f384f8791"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ac5d810266ae73fffbea59f2f384f8791">collapseEdge</a> (<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *e, bool check=true, bool perform=true)</td></tr>
<tr class="memdesc:ac5d810266ae73fffbea59f2f384f8791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the eligibility of and/or performs a collapse of an edge in such a way that the topology of the manifold does not change and the number of vertices of the triangulation decreases by one.  <a href="#ac5d810266ae73fffbea59f2f384f8791">More...</a><br/></td></tr>
<tr class="separator:ac5d810266ae73fffbea59f2f384f8791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subdivisions and Covers</div></td></tr>
<tr class="memitem:a20c32f9ef9d04f13a5dfca9ec9ecf9df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a20c32f9ef9d04f13a5dfca9ec9ecf9df">idealToFinite</a> ()</td></tr>
<tr class="memdesc:a20c32f9ef9d04f13a5dfca9ec9ecf9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an ideal triangulation into a finite triangulation.  <a href="#a20c32f9ef9d04f13a5dfca9ec9ecf9df">More...</a><br/></td></tr>
<tr class="separator:a20c32f9ef9d04f13a5dfca9ec9ecf9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Identification</div></td></tr>
<tr class="memitem:a11e183185ea0a33e67e2574fc93c7469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a> () const =0</td></tr>
<tr class="memdesc:a11e183185ea0a33e67e2574fc93c7469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet.  <a href="#a11e183185ea0a33e67e2574fc93c7469">More...</a><br/></td></tr>
<tr class="separator:a11e183185ea0a33e67e2574fc93c7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787a09ec531988778fcfb0bc87effdd4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a787a09ec531988778fcfb0bc87effdd4">typeName</a> () const =0</td></tr>
<tr class="memdesc:a787a09ec531988778fcfb0bc87effdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet.  <a href="#a787a09ec531988778fcfb0bc87effdd4">More...</a><br/></td></tr>
<tr class="separator:a787a09ec531988778fcfb0bc87effdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae432b7b94461616ae85f6f85723b9ed"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aae432b7b94461616ae85f6f85723b9ed">label</a> () const </td></tr>
<tr class="memdesc:aae432b7b94461616ae85f6f85723b9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="#aae432b7b94461616ae85f6f85723b9ed">More...</a><br/></td></tr>
<tr class="separator:aae432b7b94461616ae85f6f85723b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1eb0e0738d6630b5d1035de8eb7ba2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a3c1eb0e0738d6630b5d1035de8eb7ba2">humanLabel</a> () const </td></tr>
<tr class="memdesc:a3c1eb0e0738d6630b5d1035de8eb7ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="#a3c1eb0e0738d6630b5d1035de8eb7ba2">More...</a><br/></td></tr>
<tr class="separator:a3c1eb0e0738d6630b5d1035de8eb7ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25f42d1d2d7917b05212a6f4747ce5b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ab25f42d1d2d7917b05212a6f4747ce5b">adornedLabel</a> (const std::string &amp;adornment) const </td></tr>
<tr class="memdesc:ab25f42d1d2d7917b05212a6f4747ce5b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string.  <a href="#ab25f42d1d2d7917b05212a6f4747ce5b">More...</a><br/></td></tr>
<tr class="separator:ab25f42d1d2d7917b05212a6f4747ce5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd869991cbf664891629f21a5432b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#adfd869991cbf664891629f21a5432b02">setLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#aae432b7b94461616ae85f6f85723b9ed">label</a>)</td></tr>
<tr class="memdesc:adfd869991cbf664891629f21a5432b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="#adfd869991cbf664891629f21a5432b02">More...</a><br/></td></tr>
<tr class="separator:adfd869991cbf664891629f21a5432b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f599699f40265ec3695157a46177a53"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a6f599699f40265ec3695157a46177a53">fullName</a> () const </td></tr>
<tr class="memdesc:a6f599699f40265ec3695157a46177a53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet.  <a href="#a6f599699f40265ec3695157a46177a53">More...</a><br/></td></tr>
<tr class="separator:a6f599699f40265ec3695157a46177a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tags</div></td></tr>
<tr class="memitem:a51cdf35ec8b6ffb3a77df6fcf1dd754f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a51cdf35ec8b6ffb3a77df6fcf1dd754f">hasTag</a> (const std::string &amp;tag) const </td></tr>
<tr class="memdesc:a51cdf35ec8b6ffb3a77df6fcf1dd754f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="#a51cdf35ec8b6ffb3a77df6fcf1dd754f">More...</a><br/></td></tr>
<tr class="separator:a51cdf35ec8b6ffb3a77df6fcf1dd754f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19b52d4bca489f771bb8485c7627cb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#af19b52d4bca489f771bb8485c7627cb1">hasTags</a> () const </td></tr>
<tr class="memdesc:af19b52d4bca489f771bb8485c7627cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="#af19b52d4bca489f771bb8485c7627cb1">More...</a><br/></td></tr>
<tr class="separator:af19b52d4bca489f771bb8485c7627cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982b9936f9e9dc11ce932d4e8c7402de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a982b9936f9e9dc11ce932d4e8c7402de">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a982b9936f9e9dc11ce932d4e8c7402de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="#a982b9936f9e9dc11ce932d4e8c7402de">More...</a><br/></td></tr>
<tr class="separator:a982b9936f9e9dc11ce932d4e8c7402de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9880c0189b8f60827cd0ce9a2bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#acb9880c0189b8f60827cd0ce9a2bb32c">removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:acb9880c0189b8f60827cd0ce9a2bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="#acb9880c0189b8f60827cd0ce9a2bb32c">More...</a><br/></td></tr>
<tr class="separator:acb9880c0189b8f60827cd0ce9a2bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2405989e058dbfddf7ae445d47ddcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aee2405989e058dbfddf7ae445d47ddcf">removeAllTags</a> ()</td></tr>
<tr class="memdesc:aee2405989e058dbfddf7ae445d47ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="#aee2405989e058dbfddf7ae445d47ddcf">More...</a><br/></td></tr>
<tr class="separator:aee2405989e058dbfddf7ae445d47ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2941beca61f6d0149739217aa66e9ccf"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a2941beca61f6d0149739217aa66e9ccf">tags</a> () const </td></tr>
<tr class="memdesc:a2941beca61f6d0149739217aa66e9ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="#a2941beca61f6d0149739217aa66e9ccf">More...</a><br/></td></tr>
<tr class="separator:a2941beca61f6d0149739217aa66e9ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event Handling</div></td></tr>
<tr class="memitem:aa504cfa813a3190c00337743915ffef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aa504cfa813a3190c00337743915ffef5">listen</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:aa504cfa813a3190c00337743915ffef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="#aa504cfa813a3190c00337743915ffef5">More...</a><br/></td></tr>
<tr class="separator:aa504cfa813a3190c00337743915ffef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2dc2dee3396afb9dbf07c38fe10d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#acd2dc2dee3396afb9dbf07c38fe10d63">isListening</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:acd2dc2dee3396afb9dbf07c38fe10d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="#acd2dc2dee3396afb9dbf07c38fe10d63">More...</a><br/></td></tr>
<tr class="separator:acd2dc2dee3396afb9dbf07c38fe10d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71b40cd2416de174bba61db2ec92f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae71b40cd2416de174bba61db2ec92f1d">unlisten</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:ae71b40cd2416de174bba61db2ec92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="#ae71b40cd2416de174bba61db2ec92f1d">More...</a><br/></td></tr>
<tr class="separator:ae71b40cd2416de174bba61db2ec92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Queries</div></td></tr>
<tr class="memitem:a151d4d7f2edd7d05a5f9de90e4bcc971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a151d4d7f2edd7d05a5f9de90e4bcc971">parent</a> () const </td></tr>
<tr class="memdesc:a151d4d7f2edd7d05a5f9de90e4bcc971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="#a151d4d7f2edd7d05a5f9de90e4bcc971">More...</a><br/></td></tr>
<tr class="separator:a151d4d7f2edd7d05a5f9de90e4bcc971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbfb42f7d720111842cddf7132f0af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a8bbfb42f7d720111842cddf7132f0af0">firstChild</a> () const </td></tr>
<tr class="memdesc:a8bbfb42f7d720111842cddf7132f0af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="#a8bbfb42f7d720111842cddf7132f0af0">More...</a><br/></td></tr>
<tr class="separator:a8bbfb42f7d720111842cddf7132f0af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2221cea4ccbc180f504a01e43942730c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a2221cea4ccbc180f504a01e43942730c">lastChild</a> () const </td></tr>
<tr class="memdesc:a2221cea4ccbc180f504a01e43942730c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="#a2221cea4ccbc180f504a01e43942730c">More...</a><br/></td></tr>
<tr class="separator:a2221cea4ccbc180f504a01e43942730c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16104a06312dbf644e7a958cc95abfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#af16104a06312dbf644e7a958cc95abfc">nextSibling</a> () const </td></tr>
<tr class="memdesc:af16104a06312dbf644e7a958cc95abfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="#af16104a06312dbf644e7a958cc95abfc">More...</a><br/></td></tr>
<tr class="separator:af16104a06312dbf644e7a958cc95abfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70ae40804abd3b7a519b60341e2d9d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ab70ae40804abd3b7a519b60341e2d9d7">prevSibling</a> () const </td></tr>
<tr class="memdesc:ab70ae40804abd3b7a519b60341e2d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="#ab70ae40804abd3b7a519b60341e2d9d7">More...</a><br/></td></tr>
<tr class="separator:ab70ae40804abd3b7a519b60341e2d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc7da993bfbdb423f6c932c381dad50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a3dc7da993bfbdb423f6c932c381dad50">root</a> () const </td></tr>
<tr class="memdesc:a3dc7da993bfbdb423f6c932c381dad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="#a3dc7da993bfbdb423f6c932c381dad50">More...</a><br/></td></tr>
<tr class="separator:a3dc7da993bfbdb423f6c932c381dad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfe6ac47f15c1ad9884c53ea1b5e15f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a1dfe6ac47f15c1ad9884c53ea1b5e15f">levelsDownTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const </td></tr>
<tr class="memdesc:a1dfe6ac47f15c1ad9884c53ea1b5e15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="#a1dfe6ac47f15c1ad9884c53ea1b5e15f">More...</a><br/></td></tr>
<tr class="separator:a1dfe6ac47f15c1ad9884c53ea1b5e15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fad051ab9e08d8723595088ddcc873"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#af3fad051ab9e08d8723595088ddcc873">levelsUpTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *ancestor) const </td></tr>
<tr class="memdesc:af3fad051ab9e08d8723595088ddcc873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="#af3fad051ab9e08d8723595088ddcc873">More...</a><br/></td></tr>
<tr class="separator:af3fad051ab9e08d8723595088ddcc873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa9cbfad2644de54abe3673a7181c0c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a3fa9cbfad2644de54abe3673a7181c0c">isGrandparentOf</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const </td></tr>
<tr class="memdesc:a3fa9cbfad2644de54abe3673a7181c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="#a3fa9cbfad2644de54abe3673a7181c0c">More...</a><br/></td></tr>
<tr class="separator:a3fa9cbfad2644de54abe3673a7181c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f3b34f6e0162d1e8e807879d4fe9b1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ac3f3b34f6e0162d1e8e807879d4fe9b1">countChildren</a> () const </td></tr>
<tr class="memdesc:ac3f3b34f6e0162d1e8e807879d4fe9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet.  <a href="#ac3f3b34f6e0162d1e8e807879d4fe9b1">More...</a><br/></td></tr>
<tr class="separator:ac3f3b34f6e0162d1e8e807879d4fe9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d041e3d33adabadee5002342346a25"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a63d041e3d33adabadee5002342346a25">countDescendants</a> () const </td></tr>
<tr class="memdesc:a63d041e3d33adabadee5002342346a25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of descendants of this packet.  <a href="#a63d041e3d33adabadee5002342346a25">More...</a><br/></td></tr>
<tr class="separator:a63d041e3d33adabadee5002342346a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887f3982f980246091cb209648e004dd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a887f3982f980246091cb209648e004dd">totalTreeSize</a> () const </td></tr>
<tr class="memdesc:a887f3982f980246091cb209648e004dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="#a887f3982f980246091cb209648e004dd">More...</a><br/></td></tr>
<tr class="separator:a887f3982f980246091cb209648e004dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Manipulation</div></td></tr>
<tr class="memitem:ac389781f5c53a7d3aac3206d51ecfd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ac389781f5c53a7d3aac3206d51ecfd91">insertChildFirst</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ac389781f5c53a7d3aac3206d51ecfd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="#ac389781f5c53a7d3aac3206d51ecfd91">More...</a><br/></td></tr>
<tr class="separator:ac389781f5c53a7d3aac3206d51ecfd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d02be74192f03b372a4195c9e5bc1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ad3d02be74192f03b372a4195c9e5bc1f">insertChildLast</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:ad3d02be74192f03b372a4195c9e5bc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="#ad3d02be74192f03b372a4195c9e5bc1f">More...</a><br/></td></tr>
<tr class="separator:ad3d02be74192f03b372a4195c9e5bc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f9556e8405ca88517ccd5549471fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ad7f9556e8405ca88517ccd5549471fea">insertChildAfter</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newChild, <a class="el" href="classregina_1_1Packet.html">Packet</a> *prevChild)</td></tr>
<tr class="memdesc:ad7f9556e8405ca88517ccd5549471fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="#ad7f9556e8405ca88517ccd5549471fea">More...</a><br/></td></tr>
<tr class="separator:ad7f9556e8405ca88517ccd5549471fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc">makeOrphan</a> ()</td></tr>
<tr class="memdesc:ad9aa0488b40a1f3ec702838b2a2ceecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree.  <a href="#ad9aa0488b40a1f3ec702838b2a2ceecc">More...</a><br/></td></tr>
<tr class="separator:ad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219920e1523d3edf2982da0a3ba1a33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a219920e1523d3edf2982da0a3ba1a33d">reparent</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent, bool first=false)</td></tr>
<tr class="memdesc:a219920e1523d3edf2982da0a3ba1a33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="#a219920e1523d3edf2982da0a3ba1a33d">More...</a><br/></td></tr>
<tr class="separator:a219920e1523d3edf2982da0a3ba1a33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ce736503ede9e8c57fb5d169e6414f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a27ce736503ede9e8c57fb5d169e6414f">transferChildren</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent)</td></tr>
<tr class="memdesc:a27ce736503ede9e8c57fb5d169e6414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="#a27ce736503ede9e8c57fb5d169e6414f">More...</a><br/></td></tr>
<tr class="separator:a27ce736503ede9e8c57fb5d169e6414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765186c1742fe402922433b77e5f439a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a765186c1742fe402922433b77e5f439a">swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:a765186c1742fe402922433b77e5f439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="#a765186c1742fe402922433b77e5f439a">More...</a><br/></td></tr>
<tr class="separator:a765186c1742fe402922433b77e5f439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02f6b3ad3a7816cde5d7df456763aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae02f6b3ad3a7816cde5d7df456763aaf">moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:ae02f6b3ad3a7816cde5d7df456763aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="#ae02f6b3ad3a7816cde5d7df456763aaf">More...</a><br/></td></tr>
<tr class="separator:ae02f6b3ad3a7816cde5d7df456763aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59adc13b6143cf994779796077aed731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a59adc13b6143cf994779796077aed731">moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:a59adc13b6143cf994779796077aed731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="#a59adc13b6143cf994779796077aed731">More...</a><br/></td></tr>
<tr class="separator:a59adc13b6143cf994779796077aed731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d7730c57940444bf7d3085459449e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ab4d7730c57940444bf7d3085459449e8">moveToFirst</a> ()</td></tr>
<tr class="memdesc:ab4d7730c57940444bf7d3085459449e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="#ab4d7730c57940444bf7d3085459449e8">More...</a><br/></td></tr>
<tr class="separator:ab4d7730c57940444bf7d3085459449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a7fcff38ccb62b62d28bed83d2a3a28d5">moveToLast</a> ()</td></tr>
<tr class="memdesc:a7fcff38ccb62b62d28bed83d2a3a28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="#a7fcff38ccb62b62d28bed83d2a3a28d5">More...</a><br/></td></tr>
<tr class="separator:a7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91bc951714dc60db12810affb266b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#af91bc951714dc60db12810affb266b8a">sortChildren</a> ()</td></tr>
<tr class="memdesc:af91bc951714dc60db12810affb266b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="#af91bc951714dc60db12810affb266b8a">More...</a><br/></td></tr>
<tr class="separator:af91bc951714dc60db12810affb266b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Searching and Iterating</div></td></tr>
<tr class="memitem:a7bd2bc8fc84f44023a0a4b26ad839621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a7bd2bc8fc84f44023a0a4b26ad839621">nextTreePacket</a> ()</td></tr>
<tr class="memdesc:a7bd2bc8fc84f44023a0a4b26ad839621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="#a7bd2bc8fc84f44023a0a4b26ad839621">More...</a><br/></td></tr>
<tr class="separator:a7bd2bc8fc84f44023a0a4b26ad839621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c57cdfb7f6845181b3eac467c890d0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a90c57cdfb7f6845181b3eac467c890d0">nextTreePacket</a> () const </td></tr>
<tr class="memdesc:a90c57cdfb7f6845181b3eac467c890d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="#a90c57cdfb7f6845181b3eac467c890d0">More...</a><br/></td></tr>
<tr class="separator:a90c57cdfb7f6845181b3eac467c890d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3f24565a5053de126c8169d1a3ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a6b3f24565a5053de126c8169d1a3ccdb">nextTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:a6b3f24565a5053de126c8169d1a3ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="#a6b3f24565a5053de126c8169d1a3ccdb">More...</a><br/></td></tr>
<tr class="separator:a6b3f24565a5053de126c8169d1a3ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9adaefe48dec07f40f2a076df2d1c73"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aa9adaefe48dec07f40f2a076df2d1c73">nextTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>) const </td></tr>
<tr class="memdesc:aa9adaefe48dec07f40f2a076df2d1c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="#aa9adaefe48dec07f40f2a076df2d1c73">More...</a><br/></td></tr>
<tr class="separator:aa9adaefe48dec07f40f2a076df2d1c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e196f0f1c415b457df17f96d5b6518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a12e196f0f1c415b457df17f96d5b6518">firstTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:a12e196f0f1c415b457df17f96d5b6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="#a12e196f0f1c415b457df17f96d5b6518">More...</a><br/></td></tr>
<tr class="separator:a12e196f0f1c415b457df17f96d5b6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a3e247a149b3d099d617612768ac8f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a94a3e247a149b3d099d617612768ac8f">firstTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#a11e183185ea0a33e67e2574fc93c7469">type</a>) const </td></tr>
<tr class="memdesc:a94a3e247a149b3d099d617612768ac8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="#a94a3e247a149b3d099d617612768ac8f">More...</a><br/></td></tr>
<tr class="separator:a94a3e247a149b3d099d617612768ac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a6f7c7be06c9ed6d15f99787ea5d883b2">findPacketLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#aae432b7b94461616ae85f6f85723b9ed">label</a>)</td></tr>
<tr class="memdesc:a6f7c7be06c9ed6d15f99787ea5d883b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="#a6f7c7be06c9ed6d15f99787ea5d883b2">More...</a><br/></td></tr>
<tr class="separator:a6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc0dfa7ac79544d9ef7f9911eb9eda5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a3bc0dfa7ac79544d9ef7f9911eb9eda5">findPacketLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1Packet.html#aae432b7b94461616ae85f6f85723b9ed">label</a>) const </td></tr>
<tr class="memdesc:a3bc0dfa7ac79544d9ef7f9911eb9eda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="#a3bc0dfa7ac79544d9ef7f9911eb9eda5">More...</a><br/></td></tr>
<tr class="separator:a3bc0dfa7ac79544d9ef7f9911eb9eda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Dependencies</div></td></tr>
<tr class="memitem:a49c4e1c1474b0a50703741257cf23889"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a49c4e1c1474b0a50703741257cf23889">isPacketEditable</a> () const </td></tr>
<tr class="memdesc:a49c4e1c1474b0a50703741257cf23889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children.  <a href="#a49c4e1c1474b0a50703741257cf23889">More...</a><br/></td></tr>
<tr class="separator:a49c4e1c1474b0a50703741257cf23889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloning</div></td></tr>
<tr class="memitem:aa0406519acd8f197be3c3bfde46f3b72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aa0406519acd8f197be3c3bfde46f3b72">clone</a> (bool cloneDescendants=false, bool <a class="el" href="group__generic.html#ga45bd2d30911e68b272b26de716f35ad1">end</a>=true) const </td></tr>
<tr class="memdesc:aa0406519acd8f197be3c3bfde46f3b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="#aa0406519acd8f197be3c3bfde46f3b72">More...</a><br/></td></tr>
<tr class="separator:aa0406519acd8f197be3c3bfde46f3b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File I/O</div></td></tr>
<tr class="memitem:ae4533d4c7c40eb9ba7c9327606af6f4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae4533d4c7c40eb9ba7c9327606af6f4a">save</a> (const char *filename, bool compressed=true) const </td></tr>
<tr class="memdesc:ae4533d4c7c40eb9ba7c9327606af6f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="#ae4533d4c7c40eb9ba7c9327606af6f4a">More...</a><br/></td></tr>
<tr class="separator:ae4533d4c7c40eb9ba7c9327606af6f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae70a504949f02a1dd5b9ceac3c787f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#aae70a504949f02a1dd5b9ceac3c787f3">save</a> (std::ostream &amp;s, bool compressed=true) const </td></tr>
<tr class="memdesc:aae70a504949f02a1dd5b9ceac3c787f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="#aae70a504949f02a1dd5b9ceac3c787f3">More...</a><br/></td></tr>
<tr class="separator:aae70a504949f02a1dd5b9ceac3c787f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b63b1c8b1e24e99e4103aced7027e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a2b63b1c8b1e24e99e4103aced7027e44">writeXMLFile</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a2b63b1c8b1e24e99e4103aced7027e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="#a2b63b1c8b1e24e99e4103aced7027e44">More...</a><br/></td></tr>
<tr class="separator:a2b63b1c8b1e24e99e4103aced7027e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7278a3a79aec0493d0ad0c98ff8b3f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#a9d7278a3a79aec0493d0ad0c98ff8b3f">internalID</a> () const </td></tr>
<tr class="memdesc:a9d7278a3a79aec0493d0ad0c98ff8b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="#a9d7278a3a79aec0493d0ad0c98ff8b3f">More...</a><br/></td></tr>
<tr class="separator:a9d7278a3a79aec0493d0ad0c98ff8b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Simplices</div></td></tr>
<tr class="memitem:a6ca55a972a8c21f7e87960431d9ef64c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c">size</a> () const</td></tr>
<tr class="memdesc:a6ca55a972a8c21f7e87960431d9ef64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of top-dimensional simplices in the triangulation.  <a href="#a6ca55a972a8c21f7e87960431d9ef64c">More...</a><br/></td></tr>
<tr class="separator:a6ca55a972a8c21f7e87960431d9ef64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721e084ec08bb631e35e14ff1c844f63"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a><br class="typebreak"/>
&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a721e084ec08bb631e35e14ff1c844f63">simplices</a> () const</td></tr>
<tr class="memdesc:a721e084ec08bb631e35e14ff1c844f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all top-dimensional simplices in the triangulation.  <a href="#a721e084ec08bb631e35e14ff1c844f63">More...</a><br/></td></tr>
<tr class="separator:a721e084ec08bb631e35e14ff1c844f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e269a7332e80aeec3603881fd175d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">simplex</a> (size_t index)</td></tr>
<tr class="memdesc:ae2e269a7332e80aeec3603881fd175d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-dimensional simplex at the given index in the triangulation.  <a href="#ae2e269a7332e80aeec3603881fd175d3">More...</a><br/></td></tr>
<tr class="separator:ae2e269a7332e80aeec3603881fd175d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ac843dd4a46316960d65a56c28fff8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a61ac843dd4a46316960d65a56c28fff8">simplex</a> (size_t index) const</td></tr>
<tr class="memdesc:a61ac843dd4a46316960d65a56c28fff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the top-dimensional simplex at the given index in the triangulation.  <a href="#a61ac843dd4a46316960d65a56c28fff8">More...</a><br/></td></tr>
<tr class="separator:a61ac843dd4a46316960d65a56c28fff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107a418e2691dc5ad7bb9e90dcba437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437">newSimplex</a> ()</td></tr>
<tr class="memdesc:ad107a418e2691dc5ad7bb9e90dcba437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex and adds it to this triangulation.  <a href="#ad107a418e2691dc5ad7bb9e90dcba437">More...</a><br/></td></tr>
<tr class="separator:ad107a418e2691dc5ad7bb9e90dcba437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829224a264241e43a8f2bbdf5bfcb253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a829224a264241e43a8f2bbdf5bfcb253">newSimplex</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a829224a264241e43a8f2bbdf5bfcb253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new top-dimensional simplex with the given description and adds it to this triangulation.  <a href="#a829224a264241e43a8f2bbdf5bfcb253">More...</a><br/></td></tr>
<tr class="separator:a829224a264241e43a8f2bbdf5bfcb253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba">removeSimplex</a> (<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae2e269a7332e80aeec3603881fd175d3">simplex</a>)</td></tr>
<tr class="memdesc:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given top-dimensional simplex from this triangulation.  <a href="#a7b349c4e1fb4b27a9b20ed53b277a7ba">More...</a><br/></td></tr>
<tr class="separator:a7b349c4e1fb4b27a9b20ed53b277a7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec">removeSimplexAt</a> (size_t index)</td></tr>
<tr class="memdesc:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the top-dimensional simplex at the given index in this triangulation.  <a href="#ac9f36b004ba6af3d6ce11bdb655650ec">More...</a><br/></td></tr>
<tr class="separator:ac9f36b004ba6af3d6ce11bdb655650ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91a640743f9ce2710d17eda77d520a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a">removeAllSimplices</a> ()</td></tr>
<tr class="memdesc:a3e91a640743f9ce2710d17eda77d520a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all simplices from the triangulation.  <a href="#a3e91a640743f9ce2710d17eda77d520a">More...</a><br/></td></tr>
<tr class="separator:a3e91a640743f9ce2710d17eda77d520a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43e7587b785f281f5f5c553f263484e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad43e7587b785f281f5f5c553f263484e">swapContents</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other)</td></tr>
<tr class="memdesc:ad43e7587b785f281f5f5c553f263484e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this and the given triangulation.  <a href="#ad43e7587b785f281f5f5c553f263484e">More...</a><br/></td></tr>
<tr class="separator:ad43e7587b785f281f5f5c553f263484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae3fa3daf9672da64a0fa8a82a439d65b">moveContentsTo</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;dest)</td></tr>
<tr class="memdesc:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents.  <a href="#ae3fa3daf9672da64a0fa8a82a439d65b">More...</a><br/></td></tr>
<tr class="separator:ae3fa3daf9672da64a0fa8a82a439d65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Queries</div></td></tr>
<tr class="memitem:a2ea7f4ec2de2b34dbe345bf2ac71274d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ea7f4ec2de2b34dbe345bf2ac71274d">countComponents</a> () const</td></tr>
<tr class="memdesc:a2ea7f4ec2de2b34dbe345bf2ac71274d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected components in this triangulation.  <a href="#a2ea7f4ec2de2b34dbe345bf2ac71274d">More...</a><br/></td></tr>
<tr class="separator:a2ea7f4ec2de2b34dbe345bf2ac71274d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dad220753e25845aa715b3a8747179"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af0dad220753e25845aa715b3a8747179">countBoundaryComponents</a> () const</td></tr>
<tr class="memdesc:af0dad220753e25845aa715b3a8747179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of boundary components in this triangulation.  <a href="#af0dad220753e25845aa715b3a8747179">More...</a><br/></td></tr>
<tr class="separator:af0dad220753e25845aa715b3a8747179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b62f7033765a5e146cdaa855e62c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac42b62f7033765a5e146cdaa855e62c1">countFaces</a> () const</td></tr>
<tr class="memdesc:ac42b62f7033765a5e146cdaa855e62c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <em>subdim</em>-faces in this triangulation.  <a href="#ac42b62f7033765a5e146cdaa855e62c1">More...</a><br/></td></tr>
<tr class="separator:ac42b62f7033765a5e146cdaa855e62c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff2a6ce37f4021f6d93309ec29a2232"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0ff2a6ce37f4021f6d93309ec29a2232">fVector</a> () const</td></tr>
<tr class="memdesc:a0ff2a6ce37f4021f6d93309ec29a2232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the f-vector of this triangulation, which counts the number of faces of all dimensions.  <a href="#a0ff2a6ce37f4021f6d93309ec29a2232">More...</a><br/></td></tr>
<tr class="separator:a0ff2a6ce37f4021f6d93309ec29a2232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52f03e39a1ac74ad4572d6dc3cb6081"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classregina_1_1Component.html">Component</a><br class="typebreak"/>
&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af52f03e39a1ac74ad4572d6dc3cb6081">components</a> () const</td></tr>
<tr class="memdesc:af52f03e39a1ac74ad4572d6dc3cb6081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all connected components of this triangulation.  <a href="#af52f03e39a1ac74ad4572d6dc3cb6081">More...</a><br/></td></tr>
<tr class="separator:af52f03e39a1ac74ad4572d6dc3cb6081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea09cab6930d8333a969f7a3ef5eec6"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aeea09cab6930d8333a969f7a3ef5eec6">boundaryComponents</a> () const</td></tr>
<tr class="memdesc:aeea09cab6930d8333a969f7a3ef5eec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all boundary components of this triangulation.  <a href="#aeea09cab6930d8333a969f7a3ef5eec6">More...</a><br/></td></tr>
<tr class="separator:aeea09cab6930d8333a969f7a3ef5eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b031c48014d00ee9fee402dd989ef5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a90b031c48014d00ee9fee402dd989ef5">faces</a> () const</td></tr>
<tr class="memdesc:a90b031c48014d00ee9fee402dd989ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation.  <a href="#a90b031c48014d00ee9fee402dd989ef5">More...</a><br/></td></tr>
<tr class="separator:a90b031c48014d00ee9fee402dd989ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ee1eaa26fe337535ca3945ef063972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aa5ee1eaa26fe337535ca3945ef063972">component</a> (size_t index) const</td></tr>
<tr class="memdesc:aa5ee1eaa26fe337535ca3945ef063972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested connected component of this triangulation.  <a href="#aa5ee1eaa26fe337535ca3945ef063972">More...</a><br/></td></tr>
<tr class="separator:aa5ee1eaa26fe337535ca3945ef063972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085d2ef5acff06731f06d2e78a80bc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a085d2ef5acff06731f06d2e78a80bc3a">boundaryComponent</a> (size_t index) const</td></tr>
<tr class="memdesc:a085d2ef5acff06731f06d2e78a80bc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested boundary component of this triangulation.  <a href="#a085d2ef5acff06731f06d2e78a80bc3a">More...</a><br/></td></tr>
<tr class="separator:a085d2ef5acff06731f06d2e78a80bc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0333fa8a47302bcf44fa05e3158d9761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0333fa8a47302bcf44fa05e3158d9761">face</a> (size_t index) const</td></tr>
<tr class="memdesc:a0333fa8a47302bcf44fa05e3158d9761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested <em>subdim</em>-face of this triangulation.  <a href="#a0333fa8a47302bcf44fa05e3158d9761">More...</a><br/></td></tr>
<tr class="separator:a0333fa8a47302bcf44fa05e3158d9761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Properties</div></td></tr>
<tr class="memitem:ad26eb19438346ff47f0bf56598070a0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad26eb19438346ff47f0bf56598070a0a">isEmpty</a> () const</td></tr>
<tr class="memdesc:ad26eb19438346ff47f0bf56598070a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this triangulation is empty.  <a href="#ad26eb19438346ff47f0bf56598070a0a">More...</a><br/></td></tr>
<tr class="separator:ad26eb19438346ff47f0bf56598070a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4602a09cb4e9babf8d9bfd33031c6dc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4602a09cb4e9babf8d9bfd33031c6dc5">isValid</a> () const</td></tr>
<tr class="memdesc:a4602a09cb4e9babf8d9bfd33031c6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is valid.  <a href="#a4602a09cb4e9babf8d9bfd33031c6dc5">More...</a><br/></td></tr>
<tr class="separator:a4602a09cb4e9babf8d9bfd33031c6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517c0fd1ec5190115785b91cca9e61b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a517c0fd1ec5190115785b91cca9e61b4">hasBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:a517c0fd1ec5190115785b91cca9e61b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation has any boundary facets.  <a href="#a517c0fd1ec5190115785b91cca9e61b4">More...</a><br/></td></tr>
<tr class="separator:a517c0fd1ec5190115785b91cca9e61b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f070bcbd3431b51bb680ff7c3077431"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3f070bcbd3431b51bb680ff7c3077431">countBoundaryFacets</a> () const</td></tr>
<tr class="memdesc:a3f070bcbd3431b51bb680ff7c3077431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of boundary facets in this triangulation.  <a href="#a3f070bcbd3431b51bb680ff7c3077431">More...</a><br/></td></tr>
<tr class="separator:a3f070bcbd3431b51bb680ff7c3077431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97ba0e2d6e92e92e233d28e237b8a24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab97ba0e2d6e92e92e233d28e237b8a24">isOrientable</a> () const</td></tr>
<tr class="memdesc:ab97ba0e2d6e92e92e233d28e237b8a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is orientable.  <a href="#ab97ba0e2d6e92e92e233d28e237b8a24">More...</a><br/></td></tr>
<tr class="separator:ab97ba0e2d6e92e92e233d28e237b8a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1b7c2fbd1ea4a7a226993caa29e57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2ee1b7c2fbd1ea4a7a226993caa29e57">isConnected</a> () const</td></tr>
<tr class="memdesc:a2ee1b7c2fbd1ea4a7a226993caa29e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is connected.  <a href="#a2ee1b7c2fbd1ea4a7a226993caa29e57">More...</a><br/></td></tr>
<tr class="separator:a2ee1b7c2fbd1ea4a7a226993caa29e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52193108182bb6cefd2ea267f35479ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a52193108182bb6cefd2ea267f35479ab">isOriented</a> () const</td></tr>
<tr class="memdesc:a52193108182bb6cefd2ea267f35479ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets.  <a href="#a52193108182bb6cefd2ea267f35479ab">More...</a><br/></td></tr>
<tr class="separator:a52193108182bb6cefd2ea267f35479ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb338fc35c6ab52d7568896e4e4d4371"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aeb338fc35c6ab52d7568896e4e4d4371">eulerCharTri</a> () const</td></tr>
<tr class="memdesc:aeb338fc35c6ab52d7568896e4e4d4371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Euler characteristic of this triangulation.  <a href="#aeb338fc35c6ab52d7568896e4e4d4371">More...</a><br/></td></tr>
<tr class="separator:aeb338fc35c6ab52d7568896e4e4d4371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Algebraic Properties</div></td></tr>
<tr class="memitem:a21ba3093cb762d6dd200243170f29090"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a21ba3093cb762d6dd200243170f29090">fundamentalGroup</a> () const</td></tr>
<tr class="memdesc:a21ba3093cb762d6dd200243170f29090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fundamental group of this triangulation.  <a href="#a21ba3093cb762d6dd200243170f29090">More...</a><br/></td></tr>
<tr class="separator:a21ba3093cb762d6dd200243170f29090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74cde5c3b790195df3e10e2e53e390b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af74cde5c3b790195df3e10e2e53e390b">simplifiedFundamentalGroup</a> (<a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> *newGroup)</td></tr>
<tr class="memdesc:af74cde5c3b790195df3e10e2e53e390b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the triangulation that you have simplified the presentation of its fundamental group.  <a href="#af74cde5c3b790195df3e10e2e53e390b">More...</a><br/></td></tr>
<tr class="separator:af74cde5c3b790195df3e10e2e53e390b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5cba1c19ba697c73c7ee7d2d0bca20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#abe5cba1c19ba697c73c7ee7d2d0bca20">homology</a> () const</td></tr>
<tr class="memdesc:abe5cba1c19ba697c73c7ee7d2d0bca20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first homology group for this triangulation.  <a href="#abe5cba1c19ba697c73c7ee7d2d0bca20">More...</a><br/></td></tr>
<tr class="separator:abe5cba1c19ba697c73c7ee7d2d0bca20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c5cfbc3e88b51ce9bb9a1974c9396"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ada9c5cfbc3e88b51ce9bb9a1974c9396">homologyH1</a> () const</td></tr>
<tr class="memdesc:ada9c5cfbc3e88b51ce9bb9a1974c9396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first homology group for this triangulation.  <a href="#ada9c5cfbc3e88b51ce9bb9a1974c9396">More...</a><br/></td></tr>
<tr class="separator:ada9c5cfbc3e88b51ce9bb9a1974c9396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Skeletal Transformations</div></td></tr>
<tr class="memitem:a2711fd7c7115ce19b6833f0d61c42bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2711fd7c7115ce19b6833f0d61c42bec">orient</a> ()</td></tr>
<tr class="memdesc:a2711fd7c7115ce19b6833f0d61c42bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible.  <a href="#a2711fd7c7115ce19b6833f0d61c42bec">More...</a><br/></td></tr>
<tr class="separator:a2711fd7c7115ce19b6833f0d61c42bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subdivisions, Extensions and Covers</div></td></tr>
<tr class="memitem:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ae061e36e8ecbfa2f1edc36ed9eb99a51">makeDoubleCover</a> ()</td></tr>
<tr class="memdesc:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this triangulation into its double cover.  <a href="#ae061e36e8ecbfa2f1edc36ed9eb99a51">More...</a><br/></td></tr>
<tr class="separator:ae061e36e8ecbfa2f1edc36ed9eb99a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13345c67f4c82d9976863c8c5372db5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a13345c67f4c82d9976863c8c5372db5b">barycentricSubdivision</a> ()</td></tr>
<tr class="memdesc:a13345c67f4c82d9976863c8c5372db5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a barycentric subdivision of the triangulation.  <a href="#a13345c67f4c82d9976863c8c5372db5b">More...</a><br/></td></tr>
<tr class="separator:a13345c67f4c82d9976863c8c5372db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25a58b48e39f3c7f8621b84432d294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#adc25a58b48e39f3c7f8621b84432d294">finiteToIdeal</a> ()</td></tr>
<tr class="memdesc:adc25a58b48e39f3c7f8621b84432d294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts each real boundary component into a cusp (i.e., an ideal vertex).  <a href="#adc25a58b48e39f3c7f8621b84432d294">More...</a><br/></td></tr>
<tr class="separator:adc25a58b48e39f3c7f8621b84432d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decompositions</div></td></tr>
<tr class="memitem:a269bd2c09cea50d26a2a6bb125d55652"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a269bd2c09cea50d26a2a6bb125d55652">splitIntoComponents</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *componentParent=0, bool setLabels=true)</td></tr>
<tr class="memdesc:a269bd2c09cea50d26a2a6bb125d55652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a disconnected triangulation into many smaller triangulations, one for each component.  <a href="#a269bd2c09cea50d26a2a6bb125d55652">More...</a><br/></td></tr>
<tr class="separator:a269bd2c09cea50d26a2a6bb125d55652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Isomorphism Testing</div></td></tr>
<tr class="memitem:a00301fd26f1eaaa4df55b94b8369a054"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a00301fd26f1eaaa4df55b94b8369a054">isIdenticalTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a00301fd26f1eaaa4df55b94b8369a054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially identical to the given triangulation.  <a href="#a00301fd26f1eaaa4df55b94b8369a054">More...</a><br/></td></tr>
<tr class="separator:a00301fd26f1eaaa4df55b94b8369a054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f9aeb3cd023425abe5642deb8b8a27"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a12f9aeb3cd023425abe5642deb8b8a27">isIsomorphicTo</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a12f9aeb3cd023425abe5642deb8b8a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this triangulation is combinatorially isomorphic to the given triangulation.  <a href="#a12f9aeb3cd023425abe5642deb8b8a27">More...</a><br/></td></tr>
<tr class="separator:a12f9aeb3cd023425abe5642deb8b8a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae91eb26428486e1804cef4fed7bebd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a><br class="typebreak"/>
&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaae91eb26428486e1804cef4fed7bebd">isContainedIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other) const</td></tr>
<tr class="memdesc:aaae91eb26428486e1804cef4fed7bebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="#aaae91eb26428486e1804cef4fed7bebd">More...</a><br/></td></tr>
<tr class="separator:aaae91eb26428486e1804cef4fed7bebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de089bc182f4e43410ea8b262d47cac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5de089bc182f4e43410ea8b262d47cac">findAllIsomorphisms</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, OutputIterator output) const</td></tr>
<tr class="memdesc:a5de089bc182f4e43410ea8b262d47cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation.  <a href="#a5de089bc182f4e43410ea8b262d47cac">More...</a><br/></td></tr>
<tr class="separator:a5de089bc182f4e43410ea8b262d47cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58db7e35de591b91e021fde0838bafd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad58db7e35de591b91e021fde0838bafd">findAllSubcomplexesIn</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;other, OutputIterator output) const</td></tr>
<tr class="memdesc:ad58db7e35de591b91e021fde0838bafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components).  <a href="#ad58db7e35de591b91e021fde0838bafd">More...</a><br/></td></tr>
<tr class="separator:ad58db7e35de591b91e021fde0838bafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Building Triangulations</div></td></tr>
<tr class="memitem:a2bf93dbca6715c1a455a2d47f66a6476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a2bf93dbca6715c1a455a2d47f66a6476">insertTriangulation</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;source)</td></tr>
<tr class="memdesc:a2bf93dbca6715c1a455a2d47f66a6476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a copy of the given triangulation into this triangulation.  <a href="#a2bf93dbca6715c1a455a2d47f66a6476">More...</a><br/></td></tr>
<tr class="separator:a2bf93dbca6715c1a455a2d47f66a6476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e8b7cf820ff452059f817d55536155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#af1e8b7cf820ff452059f817d55536155">insertConstruction</a> (size_t nSimplices, const int adjacencies[][dim+1], const int gluings[][dim+1][dim+1])</td></tr>
<tr class="memdesc:af1e8b7cf820ff452059f817d55536155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a given triangulation into this triangulation, where the given triangulation is described by a pair of integer arrays.  <a href="#af1e8b7cf820ff452059f817d55536155">More...</a><br/></td></tr>
<tr class="separator:af1e8b7cf820ff452059f817d55536155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exporting Triangulations</div></td></tr>
<tr class="memitem:afee58a1ea4ea31f25849490a7cd2afad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afee58a1ea4ea31f25849490a7cd2afad">isoSig</a> (<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; **relabelling=0) const</td></tr>
<tr class="memdesc:afee58a1ea4ea31f25849490a7cd2afad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the isomorphism signature for this triangulation.  <a href="#afee58a1ea4ea31f25849490a7cd2afad">More...</a><br/></td></tr>
<tr class="separator:afee58a1ea4ea31f25849490a7cd2afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df13959cbb5b7cc2510eb30b503c166"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a5df13959cbb5b7cc2510eb30b503c166">dumpConstruction</a> () const</td></tr>
<tr class="memdesc:a5df13959cbb5b7cc2510eb30b503c166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns C++ code that can be used with insertConstruction() to reconstruct this triangulation.  <a href="#a5df13959cbb5b7cc2510eb30b503c166">More...</a><br/></td></tr>
<tr class="separator:a5df13959cbb5b7cc2510eb30b503c166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a61887b746d76c479c7a7497cdb040cac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61887b746d76c479c7a7497cdb040cac"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="classregina_1_1Packet.html#a151d4d7f2edd7d05a5f9de90e4bcc971">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:a61887b746d76c479c7a7497cdb040cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Importing Triangulations</div></td></tr>
<tr class="memitem:a1a40b9288ac97b1df6a702b12dbe5325"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325">fromIsoSig</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:a1a40b9288ac97b1df6a702b12dbe5325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers a full triangulation from an isomorphism signature.  <a href="#a1a40b9288ac97b1df6a702b12dbe5325">More...</a><br/></td></tr>
<tr class="separator:a1a40b9288ac97b1df6a702b12dbe5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2309f88209fdc55a5408838e5983caf"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ab2309f88209fdc55a5408838e5983caf">isoSigComponentSize</a> (const std::string &amp;sig)</td></tr>
<tr class="memdesc:ab2309f88209fdc55a5408838e5983caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature.  <a href="#ab2309f88209fdc55a5408838e5983caf">More...</a><br/></td></tr>
<tr class="separator:ab2309f88209fdc55a5408838e5983caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3ef8ae8c6af5b7757dddc44327ea3133"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3ef8ae8c6af5b7757dddc44327ea3133">dimension</a></td></tr>
<tr class="memdesc:a3ef8ae8c6af5b7757dddc44327ea3133"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant that gives the dimension of the triangulation.  <a href="#a3ef8ae8c6af5b7757dddc44327ea3133">More...</a><br/></td></tr>
<tr class="separator:a3ef8ae8c6af5b7757dddc44327ea3133"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ga0be8028a8f015b7fff2e37769a17dfac"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, <br class="typebreak"/>
subdim &gt; * &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a></td></tr>
<tr class="memdesc:ga0be8028a8f015b7fff2e37769a17dfac"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator type for iterating through this list of faces.  <a href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">More...</a><br/></td></tr>
<tr class="separator:ga0be8028a8f015b7fff2e37769a17dfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af085005271a4bfcdeacc5f9d84e1e401"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#af085005271a4bfcdeacc5f9d84e1e401">internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="classregina_1_1Packet.html#a151d4d7f2edd7d05a5f9de90e4bcc971">parent</a>) const </td></tr>
<tr class="memdesc:af085005271a4bfcdeacc5f9d84e1e401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="#af085005271a4bfcdeacc5f9d84e1e401">More...</a><br/></td></tr>
<tr class="separator:af085005271a4bfcdeacc5f9d84e1e401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e41a57dbb8b5ca197a26cbcd09ccd4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a91e41a57dbb8b5ca197a26cbcd09ccd4">writeXMLPacketData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a91e41a57dbb8b5ca197a26cbcd09ccd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="#a91e41a57dbb8b5ca197a26cbcd09ccd4">More...</a><br/></td></tr>
<tr class="separator:a91e41a57dbb8b5ca197a26cbcd09ccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af776b191fe7d2ca2eed7500772789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Packet.html#ae0af776b191fe7d2ca2eed7500772789">writeXMLPacketTree</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:ae0af776b191fe7d2ca2eed7500772789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the subtree with this packet as matriarch.  <a href="#ae0af776b191fe7d2ca2eed7500772789">More...</a><br/></td></tr>
<tr class="separator:ae0af776b191fe7d2ca2eed7500772789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac385cd2115fc4eaabaf591ba58046cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac385cd2115fc4eaabaf591ba58046cad">ensureSkeleton</a> () const</td></tr>
<tr class="memdesc:ac385cd2115fc4eaabaf591ba58046cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that all "on demand" skeletal objects have been calculated.  <a href="#ac385cd2115fc4eaabaf591ba58046cad">More...</a><br/></td></tr>
<tr class="separator:ac385cd2115fc4eaabaf591ba58046cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf5ad2a8b5eb264f015405a4a89bb1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a4cf5ad2a8b5eb264f015405a4a89bb1d">calculatedSkeleton</a> () const</td></tr>
<tr class="memdesc:a4cf5ad2a8b5eb264f015405a4a89bb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the skeletal objects and properties of this triangulation have been calculated.  <a href="#a4cf5ad2a8b5eb264f015405a4a89bb1d">More...</a><br/></td></tr>
<tr class="separator:a4cf5ad2a8b5eb264f015405a4a89bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104a20d744b0b646783b60d819f43d22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a104a20d744b0b646783b60d819f43d22">clearBaseProperties</a> ()</td></tr>
<tr class="memdesc:a104a20d744b0b646783b60d819f43d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all properties that are managed by this base class.  <a href="#a104a20d744b0b646783b60d819f43d22">More...</a><br/></td></tr>
<tr class="separator:a104a20d744b0b646783b60d819f43d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed565fd71935ebdc8f9d6af6bd46d666"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aed565fd71935ebdc8f9d6af6bd46d666">swapBaseProperties</a> (<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aaa79cc9e7f5b4f6ea27045ebf3c8fabc">TriangulationBase</a>&lt; dim &gt; &amp;other)</td></tr>
<tr class="memdesc:aed565fd71935ebdc8f9d6af6bd46d666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all properties that are managed by this base class, including skeletal data, with the given triangulation.  <a href="#aed565fd71935ebdc8f9d6af6bd46d666">More...</a><br/></td></tr>
<tr class="separator:aed565fd71935ebdc8f9d6af6bd46d666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c51de87cc69b8c7fc2385d26382385"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a89c51de87cc69b8c7fc2385d26382385">writeXMLBaseProperties</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a89c51de87cc69b8c7fc2385d26382385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing properties of this triangulation.  <a href="#a89c51de87cc69b8c7fc2385d26382385">More...</a><br/></td></tr>
<tr class="separator:a89c51de87cc69b8c7fc2385d26382385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b34020172394d10592dd4251468bcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#a45b34020172394d10592dd4251468bcc">deleteFaces</a> ()</td></tr>
<tr class="memdesc:a45b34020172394d10592dd4251468bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all faces of dimension <em>subdim</em> and below.  <a href="#a45b34020172394d10592dd4251468bcc">More...</a><br/></td></tr>
<tr class="separator:a45b34020172394d10592dd4251468bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013abf7fffeba839fb47a2dcfaee19f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#a013abf7fffeba839fb47a2dcfaee19f5">swapFaces</a> (FaceListSuite&lt; dim, subdim &gt; &amp;other)</td></tr>
<tr class="memdesc:a013abf7fffeba839fb47a2dcfaee19f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all faces of dimension <em>subdim</em> and below with those of the given triangulation.  <a href="#a013abf7fffeba839fb47a2dcfaee19f5">More...</a><br/></td></tr>
<tr class="separator:a013abf7fffeba839fb47a2dcfaee19f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8adeb83255137b4ba522408f77fbe58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#aa8adeb83255137b4ba522408f77fbe58">fillFVector</a> (std::vector&lt; size_t &gt; &amp;result) const</td></tr>
<tr class="memdesc:aa8adeb83255137b4ba522408f77fbe58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the given vector with the first (<em>subdim</em> + 1) elements of the f-vector.  <a href="#aa8adeb83255137b4ba522408f77fbe58">More...</a><br/></td></tr>
<tr class="separator:aa8adeb83255137b4ba522408f77fbe58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af963f8d8cb94d216df5158e5204e4927"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#af963f8d8cb94d216df5158e5204e4927">sameFVector</a> (const FaceListSuite&lt; dim, subdim &gt; &amp;other) const</td></tr>
<tr class="memdesc:af963f8d8cb94d216df5158e5204e4927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same number of <em>k</em>-faces, for each facial dimension <em>k</em> &le; <em>subdim</em>.  <a href="#af963f8d8cb94d216df5158e5204e4927">More...</a><br/></td></tr>
<tr class="separator:af963f8d8cb94d216df5158e5204e4927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8035ecc57099d3d28d59599b65af5feb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html#a8035ecc57099d3d28d59599b65af5feb">sameDegrees</a> (const FaceListSuite&lt; dim, subdim &gt; &amp;other) const</td></tr>
<tr class="memdesc:a8035ecc57099d3d28d59599b65af5feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same <em>k</em>-face degree sequences, for each facial dimension <em>k</em> &le; <em>subdim</em>.  <a href="#a8035ecc57099d3d28d59599b65af5feb">More...</a><br/></td></tr>
<tr class="separator:a8035ecc57099d3d28d59599b65af5feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5605932cdf6dacacdfb2d90151bac356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga5605932cdf6dacacdfb2d90151bac356">sameDegrees</a> (const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp;other) const </td></tr>
<tr class="memdesc:ga5605932cdf6dacacdfb2d90151bac356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether this and the given triangulation have the same <em>subdim</em>-face degree sequences.  <a href="group__generic.html#ga5605932cdf6dacacdfb2d90151bac356">More...</a><br/></td></tr>
<tr class="separator:ga5605932cdf6dacacdfb2d90151bac356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e9b6234d46c518a6bdd7fc0d4750cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga87e9b6234d46c518a6bdd7fc0d4750cd">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:ga87e9b6234d46c518a6bdd7fc0d4750cd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the requested <em>subdim</em>-face.  <a href="group__generic.html#ga87e9b6234d46c518a6bdd7fc0d4750cd">More...</a><br/></td></tr>
<tr class="separator:ga87e9b6234d46c518a6bdd7fc0d4750cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1671ff7a32ea81850ebbc402b04bfddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga1671ff7a32ea81850ebbc402b04bfddb">begin</a> () const </td></tr>
<tr class="memdesc:ga1671ff7a32ea81850ebbc402b04bfddb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing to the first <em>subdim</em>-face.  <a href="group__generic.html#ga1671ff7a32ea81850ebbc402b04bfddb">More...</a><br/></td></tr>
<tr class="separator:ga1671ff7a32ea81850ebbc402b04bfddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45bd2d30911e68b272b26de716f35ad1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga45bd2d30911e68b272b26de716f35ad1">end</a> () const </td></tr>
<tr class="memdesc:ga45bd2d30911e68b272b26de716f35ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator pointing beyond the last <em>subdim</em>-face.  <a href="group__generic.html#ga45bd2d30911e68b272b26de716f35ad1">More...</a><br/></td></tr>
<tr class="separator:ga45bd2d30911e68b272b26de716f35ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9055978b413d79bbb7783d4730c00ad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga9055978b413d79bbb7783d4730c00ad1">push_back</a> (<a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a0333fa8a47302bcf44fa05e3158d9761">face</a>)</td></tr>
<tr class="memdesc:ga9055978b413d79bbb7783d4730c00ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the given face onto the end of this list.  <a href="group__generic.html#ga9055978b413d79bbb7783d4730c00ad1">More...</a><br/></td></tr>
<tr class="separator:ga9055978b413d79bbb7783d4730c00ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd29e5cef4315d5b40c37ab997645b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga1cd29e5cef4315d5b40c37ab997645b8">destroy</a> ()</td></tr>
<tr class="memdesc:ga1cd29e5cef4315d5b40c37ab997645b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all faces in this list, and clears the list itself.  <a href="group__generic.html#ga1cd29e5cef4315d5b40c37ab997645b8">More...</a><br/></td></tr>
<tr class="separator:ga1cd29e5cef4315d5b40c37ab997645b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga425fc00273288a36288fc08452ad4bf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__generic.html#ga425fc00273288a36288fc08452ad4bf3">swap</a> (<a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt; dim, subdim &gt; &amp;other)</td></tr>
<tr class="memdesc:ga425fc00273288a36288fc08452ad4bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps all faces in this list with those in the given list.  <a href="group__generic.html#ga425fc00273288a36288fc08452ad4bf3">More...</a><br/></td></tr>
<tr class="separator:ga425fc00273288a36288fc08452ad4bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3fba432b4a7a57ee4e21a9523151c660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt; <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3fba432b4a7a57ee4e21a9523151c660">simplices_</a></td></tr>
<tr class="memdesc:a3fba432b4a7a57ee4e21a9523151c660"><td class="mdescLeft">&#160;</td><td class="mdescRight">The top-dimensional simplices that form the triangulation.  <a href="#a3fba432b4a7a57ee4e21a9523151c660">More...</a><br/></td></tr>
<tr class="separator:a3fba432b4a7a57ee4e21a9523151c660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac280128dabd3208670cb0fdc010dffb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a><br class="typebreak"/>
&lt; <a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt; dim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac280128dabd3208670cb0fdc010dffb8">boundaryComponents_</a></td></tr>
<tr class="memdesc:ac280128dabd3208670cb0fdc010dffb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The components that form the boundary of the triangulation.  <a href="#ac280128dabd3208670cb0fdc010dffb8">More...</a><br/></td></tr>
<tr class="separator:ac280128dabd3208670cb0fdc010dffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327ad9e8143772575b5701a3c4ad6007"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a327ad9e8143772575b5701a3c4ad6007">valid_</a></td></tr>
<tr class="memdesc:a327ad9e8143772575b5701a3c4ad6007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this triangulation valid? See isValid() for details on what this means.  <a href="#a327ad9e8143772575b5701a3c4ad6007">More...</a><br/></td></tr>
<tr class="separator:a327ad9e8143772575b5701a3c4ad6007"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af4a695d935d4bcdcc1fcc92c7f9175ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a695d935d4bcdcc1fcc92c7f9175ad"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::Face&lt; 4, 4 &gt;</b></td></tr>
<tr class="separator:af4a695d935d4bcdcc1fcc92c7f9175ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3913a00be32443a5afd055940d6e82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b3913a00be32443a5afd055940d6e82"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::SimplexBase&lt; 4 &gt;</b></td></tr>
<tr class="separator:a7b3913a00be32443a5afd055940d6e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac560f8f0bdbb9c2fb7748bb3d5fcda6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac560f8f0bdbb9c2fb7748bb3d5fcda6f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::detail::TriangulationBase&lt; 4 &gt;</b></td></tr>
<tr class="separator:ac560f8f0bdbb9c2fb7748bb3d5fcda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5629163314451dc2e5bf6f7740a741"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d5629163314451dc2e5bf6f7740a741"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::XMLTriangulationReader&lt; 4 &gt;</b></td></tr>
<tr class="separator:a3d5629163314451dc2e5bf6f7740a741"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;&gt;<br/>
class regina::Triangulation&lt; 4 &gt;</h3>

<p>Represents a 4-dimensional triangulation, typically of a 4-manifold. </p>
<p>This is a specialisation of the generic <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> class template; see the <a class="el" href="classregina_1_1Triangulation.html" title="A dim-dimensional triangulation, built by gluing together dim-dimensional simplices along their (dim-...">Triangulation</a> documentation for a general overview of how the triangulation classes work.</p>
<p>This 4-dimensional specialisation offers significant extra functionality, including many functions specific to 4-manifolds.</p>
<p>A 4-manifold triangulation is built from pentachora: a <em>pentachoron</em> is a 4-dimensional simplex, with five vertices. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="afaff07ebf1a7c7d92dc100c1fdc343ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#afaff07ebf1a7c7d92dc100c1fdc343ba">BoundaryComponentIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to iterate through boundary components. </p>

</div>
</div>
<a class="anchor" id="acb85b172fe187672d3495a557aa394bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#acb85b172fe187672d3495a557aa394bf">ComponentIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to iterate through connected components. </p>

</div>
</div>
<a class="anchor" id="a0b0ad96a6f6924ea13b98d66f3e34aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;4, 1&gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a0b0ad96a6f6924ea13b98d66f3e34aae">EdgeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through edges. </p>

</div>
</div>
<a class="anchor" id="ac33fe1474aae3d6f9e163e8a2f07af1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt;4&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ac33fe1474aae3d6f9e163e8a2f07af1f">PentachoronIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A dimension-specific alias for SimplexIterator, used to iterate through pentachora. </p>

</div>
</div>
<a class="anchor" id="a2e4bacf91fc79a12ae3a02f4339ed034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>  <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a>  &gt;::<a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of object being pointed to. </p>

</div>
</div>
<a class="anchor" id="a9f3023c0479b8cc8aeec3dffa6fa62eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt;*&gt;::const_iterator <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::<a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a9f3023c0479b8cc8aeec3dffa6fa62eb">SimplexIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to iterate through top-dimensional simplices. </p>

</div>
</div>
<a class="anchor" id="ad704df006b6f8f32c33701ecf4440bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;4, 3&gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ad704df006b6f8f32c33701ecf4440bde">TetrahedronIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through tetrahedra. </p>

</div>
</div>
<a class="anchor" id="afea4acf0ddfe4cf058f1c5b7e144d058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;4, 2&gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#afea4acf0ddfe4cf058f1c5b7e144d058">TriangleIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through triangles. </p>

</div>
</div>
<a class="anchor" id="afc805e64ba49509346eee9976a289c1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;4, 0&gt;::<a class="el" href="group__generic.html#ga0be8028a8f015b7fff2e37769a17dfac">Iterator</a> <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#afc805e64ba49509346eee9976a289c1d">VertexIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to iterate through vertices. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4fd3ec37dc565bc0fd85e687b8c2e0a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty triangulation. </p>

</div>
</div>
<a class="anchor" id="ac74447c6c16259c2f393d5ed70666633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a copy of the given triangulation. </p>
<p>The packet tree structure and packet label are <em>not</em> copied.</p>
<p>This will clone any computed properties (such as homology, fundamental group, and so on) of the given triangulation also. If you want a "clean" copy that resets all properties to unknown, you can use the two-argument copy constructor instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the triangulation to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a220911cb1d36d4ea426916bd60873c62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new copy of the given triangulation, with the option of whether or not to clone its computed properties also. </p>
<p>Regardless of the argument <em>cloneProps</em>, if it is known that all vertex links of <em>copy</em> are 3-sphere or 3-balls, this knowledge will be copied over to the new triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>the triangulation to copy. </td></tr>
    <tr><td class="paramname">cloneProps</td><td><code>true</code> if this should also clone any computed properties of the given triangulation (such as homology, fundamental group, and so on), or <code>false</code> if the new triangulation should have all properties marked as unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c8a0ae3adcbadf6d4a6f3d834507acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Magic" constructor that tries to find some way to interpret the given string as a triangulation. </p>
<p>At present, Regina understands the following types of strings (and attempts to parse them in the following order):</p>
<ul>
<li>isomorphism signatures (see <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a1a40b9288ac97b1df6a702b12dbe5325" title="Recovers a full triangulation from an isomorphism signature.">fromIsoSig()</a>).</li>
</ul>
<p>This list may grow in future versions of Regina.</p>
<p>Regina will also set the packet label accordingly.</p>
<p>If Regina cannot interpret the given string, this will be left as the empty triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">description</td><td>a string that describes a 4-manifold triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51d2c8a64156a5e125832a53573b67c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::~<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this triangulation. </p>
<p>The constituent pentachora, the cellular structure and all other properties will also be deallocated. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a982b9936f9e9dc11ce932d4e8c7402de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::addTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tag is not the empty string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was successfully added, or <code>false</code> if the given tag was already present beforehand. </dd></dl>

</div>
</div>
<a class="anchor" id="ab25f42d1d2d7917b05212a6f4747ce5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::adornedLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adornment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string. </p>
<p>An adornment typically shows how a packet has been created and/or modified. For instance, the <em>adornment</em> argument might be "Filled", or "Summand #1".</p>
<p>The way in which the packet label is adorned depends upon the label itself (in particular, an empty packet label will be handled in a sensible way). The way in which the packet label is adorned is subject to change in future versions of Regina.</p>
<p>Note that, whilst this routine returns a modified version of the packet label, the label itself will not be permamently changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adornment</td><td>the string that will be used to adorn this packet label. The adornment should just be a piece of English, ideally beginning with an upper-case letter. It should not contain any surrounding punctuation such as brackets or a dash (this will be added automatically by this routine as required). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the packet label with the given adornment. </dd></dl>

</div>
</div>
<a class="anchor" id="a13345c67f4c82d9976863c8c5372db5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::barycentricSubdivision </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does a barycentric subdivision of the triangulation. </p>
<p>This is done in-place, i.e., the triangulation will be modified directly.</p>
<p>Each top-dimensional simplex <em>s</em> is divided into (<em>dim</em> + 1) factorial sub-simplices by placing an extra vertex at the centroid of every face of every dimension. Each of these sub-simplices <em>t</em> is described by a permutation <em>p</em> of (0, ..., <em>dim</em>). The vertices of such a sub-simplex <em>t</em> are:</p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em>;</li>
<li>...</li>
<li>the centroid of face (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2], <em>p</em>[<em>dim</em>]) of <em>s</em>, which is the entire simplex <em>s</em> itself.</li>
</ul>
<p>The sub-simplices have their vertices numbered in a way that mirrors the original simplex <em>s:</em> </p>
<ul>
<li>vertex <em>p</em>[0] of <em>s</em> will be labelled <em>p</em>[0] in <em>t</em>;</li>
<li>the centre of edge (<em>p</em>[0], <em>p</em>[1]) of <em>s</em> will be labelled <em>p</em>[1] in <em>t</em>;</li>
<li>the centroid of triangle (<em>p</em>[0], <em>p</em>[1], <em>p</em>[2]) of <em>s</em> will be labelled <em>p</em>[2] in <em>t</em>;</li>
<li>...</li>
<li>the centroid of <em>s</em> itself will be labelled <em>p</em>[<em>dim</em>] in <em>t</em>.</li>
</ul>
<p>If simplex <em>s</em> has index <em>i</em> in the original triangulation, then its sub-simplex corresponding to permutation <em>p</em> will have index <code>((dim + 1)! * i + p.index())</code> in the resulting triangulation. In other words: sub-simplices are ordered first according to the original simplex that contains them, and then according to the lexicographical ordering of the corresponding permutations <em>p</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dim</em> is one of Regina's standard dimensions. This precondition is a safety net, since in higher dimensions the triangulation would explode too quickly in size (and for the highest dimensions, possibly beyond the limits of <code>size_t</code>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimensions 3 and 4, both the labelling and ordering of sub-simplices in the subdivided triangulation has changed as of Regina 5.1. (Earlier versions of Regina made no guarantee about the labelling and ordering; these guarantees are also new to Regina 5.1). </dd></dl>

</div>
</div>
<a class="anchor" id="a085d2ef5acff06731f06d2e78a80bc3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::boundaryComponent </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested boundary component of this triangulation. </p>
<p>Note that each time the triangulation changes, all boundary components will be deleted and replaced with new ones. Therefore this object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired boundary component; this must be between 0 and countBoundaryComponents()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested boundary component. </dd></dl>

</div>
</div>
<a class="anchor" id="aeea09cab6930d8333a969f7a3ef5eec6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::boundaryComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all boundary components of this triangulation. </p>
<p>Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the BoundaryComponent class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<p>Bear in mind that each time the triangulation changes, all boundary component objects will be deleted and replaced with new ones. Therefore these boundary component objects should be considered temporary only.</p>
<p>In contrast, this reference to the <em>list</em> of BoundaryComponent objects will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all boundary components. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cf5ad2a8b5eb264f015405a4a89bb1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::calculatedSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the skeletal objects and properties of this triangulation have been calculated. </p>
<p>These are only calculated "on demand", when a skeletal property is first queried.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the skeleton has been calculated. </dd></dl>

</div>
</div>
<a class="anchor" id="a104a20d744b0b646783b60d819f43d22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::clearBaseProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all properties that are managed by this base class. </p>
<p>This includes deleting all skeletal objects and emptying the corresponding internal lists, as well as clearing other cached properties and deallocating the corresponding memory where required.</p>
<p>Note that TriangulationBase never calls this routine itself. Typically clearBaseProperties() is only ever called by Triangulation&lt;dim&gt;::clearAllProperties(), which in turn is called by "atomic" routines that change the triangluation (before firing packet change events), as well as the <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> destructor. </p>

</div>
</div>
<a class="anchor" id="aa0406519acd8f197be3c3bfde46f3b72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneDescendants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet. </p>
<p>Note that any string tags associated with this packet will <em>not</em> be cloned.</p>
<p>If this packet has no parent in the tree structure, no clone will be created and 0 will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneDescendants</td><td><code>true</code> if the descendants of this packet should also be cloned and inserted as descendants of the new packet. If this is passed as <code>false</code> (the default), only this packet will be cloned. </td></tr>
    <tr><td class="paramname">end</td><td><code>true</code> if the new packet should be inserted at the end of the parent's list of children (the default), or <code>false</code> if the new packet should be inserted as the sibling immediately after this packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly inserted packet, or 0 if this packet has no parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5d810266ae73fffbea59f2f384f8791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::collapseEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a collapse of an edge in such a way that the topology of the manifold does not change and the number of vertices of the triangulation decreases by one. </p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (facets, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<p>The eligibility requirements for this move are somewhat involved, and are discussed in detail in the <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ac5d810266ae73fffbea59f2f384f8791" title="Checks the eligibility of and/or performs a collapse of an edge in such a way that the topology of th...">collapseEdge()</a> source code for those who are interested.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge to collapse. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the given edge may be collapsed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5ee1eaa26fe337535ca3945ef063972"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::component </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested connected component of this triangulation. </p>
<p>Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore this component object should be considered temporary only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired component; this must be between 0 and countComponents()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested component. </dd></dl>

</div>
</div>
<a class="anchor" id="af52f03e39a1ac74ad4572d6dc3cb6081"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classregina_1_1Component.html">Component</a>&lt;dim&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all connected components of this triangulation. </p>
<p>Note that each time the triangulation changes, all component objects will be deleted and replaced with new ones. Therefore these component objects should be considered temporary only.</p>
<p>In contrast, this reference to the <em>list</em> of all components will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all components. </dd></dl>

</div>
</div>
<a class="anchor" id="af0dad220753e25845aa715b3a8747179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::countBoundaryComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of boundary components in this triangulation. </p>
<p>Note that, in Regina's <a class="el" href="stddim.html">standard dimensions</a>, each ideal vertex forms its own boundary component, and some invalid vertices do also. See the BoundaryComponent class notes for full details on what constitutes a boundary component in standard and non-standard dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of boundary components. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f070bcbd3431b51bb680ff7c3077431"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::countBoundaryFacets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of boundary facets in this triangulation. </p>
<p>This routine counts facets of top-dimensional simplices that are not glued to some adjacent top-dimensional simplex.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of boundary facets. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3f3b34f6e0162d1e8e807879d4fe9b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet. </p>
<p>Grandchildren and so on are not counted.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of immediate children. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ea7f4ec2de2b34dbe345bf2ac71274d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::countComponents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of connected components in this triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of connected components. </dd></dl>

</div>
</div>
<a class="anchor" id="a63d041e3d33adabadee5002342346a25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::countDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of descendants of this packet. </p>
<p>This includes children, grandchildren and so on. This packet is not included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of descendants. </dd></dl>

</div>
</div>
<a class="anchor" id="ac42b62f7033765a5e146cdaa855e62c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::countFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <em>subdim</em>-faces in this triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and <em>dim</em>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>countFaces(subdim)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a class="anchor" id="a45b34020172394d10592dd4251468bcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::deleteFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all faces of dimension <em>subdim</em> and below. </p>
<p>This routine destroys the corresponding Face objects and clears the lists that contain them. </p>

</div>
</div>
<a class="anchor" id="a1bedb5d2600fe116d84b4aee4233f994"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Packet.html#a36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5df13959cbb5b7cc2510eb30b503c166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::dumpConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns C++ code that can be used with insertConstruction() to reconstruct this triangulation. </p>
<p>The code produced will consist of the following:</p>
<ul>
<li>the declaration and initialisation of two integer arrays, describing the gluings between simplices of this trianguation;</li>
<li>two additional lines that declare a new <a class="el" href="classregina_1_1Triangulation.html">Triangulation&lt;dim&gt;</a> and call insertConstruction() to rebuild this triangulation.</li>
</ul>
<p>The main purpose of this routine is to generate the two integer arrays, which can be tedious and error-prone to code up by hand.</p>
<p>Note that the number of lines of code produced grows linearly with the number of simplices. If this triangulation is very large, the returned string will be very large as well.</p>
<dl class="section return"><dt>Returns</dt><dd>the C++ code that was generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ac385cd2115fc4eaabaf591ba58046cad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::ensureSkeleton </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that all "on demand" skeletal objects have been calculated. </p>

</div>
</div>
<a class="anchor" id="a3285165a44c7b17d366f6ce114cc5abd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::eulerCharManifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of the corresponding compact manifold. </p>
<p>Instead of simply calculating <em>V-E+F-T+P</em>, this routine also treats ideal vertices as 3-manifold boundary components (i.e., effectively truncates them).</p>
<p>For ideal triangulations, this routine therefore computes the proper Euler characteristic of the manifold (unlike <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aeb338fc35c6ab52d7568896e4e4d4371" title="Returns the Euler characteristic of this triangulation.">eulerCharTri()</a>, which does not).</p>
<p>For triangulations whose vertex links are all 3-spheres or 3-balls, this routine and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#aeb338fc35c6ab52d7568896e4e4d4371" title="Returns the Euler characteristic of this triangulation.">eulerCharTri()</a> give identical results.</p>
<p>This routine does <em>not</em> yet handle invalid triangulations correctly. For this reason, this routine currently insists on a valid triangulation as a precondition.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of the corresponding compact manifold. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb338fc35c6ab52d7568896e4e4d4371"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::eulerCharTri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Euler characteristic of this triangulation. </p>
<p>This will be evaluated strictly as the alternating sum of the number of <em>i</em>-faces (that is, <code>countVertices() - countEdges() + countTriangles() - ...</code>).</p>
<p>Note that this routine handles ideal triangulations in a non-standard way. Since it computes the Euler characteristic of the triangulation (and not the underlying manifold), this routine will treat each ideal boundary component as a single vertex, and <em>not</em> as an entire (<em>dim</em>-1)-dimensional boundary component.</p>
<p>In Regina's <a class="el" href="stddim.html">standard dimensions</a>, for a routine that handles ideal boundary components properly (by treating them as (<em>dim</em>-1)-dimensional boundary components when computing Euler characteristic), you can use the routine eulerCharManifold() instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic of this triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="a0333fa8a47302bcf44fa05e3158d9761"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::face </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the requested <em>subdim</em>-face of this triangulation. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The template argument <em>subdim</em> is between 0 and <em>dim</em>-1 inclusive.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Python does not support templates. Instead, Python users should call this function in the form <code>face(subdim, index)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the desired face, ranging from 0 to countFaces&lt;subdim&gt;()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested face. </dd></dl>

</div>
</div>
<a class="anchor" id="a90b031c48014d00ee9fee402dd989ef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FaceList.html">FaceList</a>&lt;dim, subdim&gt;&amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an object that allows iteration through and random access to all <em>subdim</em>-faces of this triangulation. </p>
<p>Bear in mind that each time the triangulation changes, all face objects will be deleted and replaced with new ones. Therefore these face objects should be considered temporary only.</p>
<p>In contrast, this reference to the FaceList object itself will remain valid and up-to-date for as long as the triangulation exists.</p>
<dl class="section user"><dt>Python:</dt><dd>Python users should call this function in the form <code>faces(subdim)</code>. It will then return a Python list containing all the <em>subdim</em>-faces of the triangulation. Be warned that, unlike in C++, this Python list will be a snapshot of the faces when this function is called, and will <em>not</em> be kept up-to-date as the triangulation changes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>access to the list of all <em>subdim</em>-faces. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8adeb83255137b4ba522408f77fbe58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::fillFVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills the given vector with the first (<em>subdim</em> + 1) elements of the f-vector. </p>
<p>Specifically, this routine pushes the values <em>f</em>[0], ..., <em>f</em>[<em>subdim</em>] onto the end of the given vector, where <em>f</em>[<em>k</em>] denotes the number of <em>k</em>-faces that this object stores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the vector in which the results will be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5de089bc182f4e43410ea8b262d47cac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::findAllIsomorphisms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>This routine behaves identically to isIsomorphicTo(), except that instead of returning just one isomorphism, all such isomorphisms are returned.</p>
<p>See the isIsomorphicTo() notes for additional information.</p>
<p>The isomorphisms that are found will be written to the given output iterator. This iterator must accept objects of type Isomorphism&lt;dim&gt;*. As an example, <em>output</em> might be a back_insert_iterator for a std::vector&lt;Isomorphism&lt;dim&gt;*&gt;.</p>
<p>The isomorphisms that are written to the given output iterator will be newly created, and the caller of this routine is responsible for destroying them.</p>
<dl class="section user"><dt>Python:</dt><dd>The <em>output</em> argument is not present. Instead, this routine returns a python list containing all of the isomorphisms that were found.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to which the isomorphisms will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of isomorphisms that were found. </dd></dl>

</div>
</div>
<a class="anchor" id="ad58db7e35de591b91e021fde0838bafd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::findAllSubcomplexesIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds all ways in which an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>This routine behaves identically to isContainedIn(), except that instead of returning just one isomorphism (which may be boundary incomplete and need not be onto), all such isomorphisms are returned.</p>
<p>See the isContainedIn() notes for additional information.</p>
<p>The isomorphisms that are found will be written to the given output iterator. This iterator must accept objects of type Isomorphism&lt;dim&gt;*. As an example, <em>output</em> might be a back_insert_iterator for a std::vector&lt;Isomorphism&lt;dim&gt;*&gt;.</p>
<p>The isomorphisms that are written to the given output iterator will be newly created, and the caller of this routine is responsible for destroying them.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for isomorphic copies of this triangulation. </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to which the isomorphisms will be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of isomorphisms that were found. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f7c7be06c9ed6d15f99787ea5d883b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bc0dfa7ac79544d9ef7f9911eb9eda5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a class="anchor" id="adc25a58b48e39f3c7f8621b84432d294"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::finiteToIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts each real boundary component into a cusp (i.e., an ideal vertex). </p>
<p>Only boundary components formed from real (<em>dim</em>-1)-faces will be affected; ideal boundary components are already cusps and so will not be changed.</p>
<p>One side-effect of this operation is that all spherical boundary components will be filled in with balls.</p>
<p>This operation is performed by attaching a new <em>dim</em>-simplex to each boundary (<em>dim</em>-1)-face, and then gluing these new simplices together in a way that mirrors the adjacencies of the underlying boundary facets. Each boundary component will thereby be pushed up through the new simplices and converted into a cusp formed using vertices of these new simplices.</p>
<p>In Regina's <a class="el" href="stddim.html">standard dimensions</a>, where triangulations also support an idealToFinite() operation, this routine is a loose converse of that operation.</p>
<p>In dimension 2, every boundary component is spherical and so this routine simply fills all the punctures in the underlying surface. (In dimension 2, triangulations cannot have cusps).</p>
<dl class="section warning"><dt>Warning</dt><dd>If a real boundary component contains vertices whose links are not discs, this operation may have unexpected results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if changes were made, or <code>false</code> if the original triangulation contained no real boundary components. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bbfb42f7d720111842cddf7132f0af0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::firstChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the first child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="a12e196f0f1c415b457df17f96d5b6518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1Packet.html#a787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a class="anchor" id="a94a3e247a149b3d099d617612768ac8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1Packet.html#a787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a class="anchor" id="aea57a753fbe674471b3abaa24e4098ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::fourTwoMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 4-2 move about the given edge. </p>
<p>This involves replacing the four pentachora joined at that edge with two pentachora joined along a single facet. This can be done iff (i) the edge is valid and non-boundary, (ii) the four pentachora are distinct, and (iii) the pentachora are joined in such a way that the link of the edge is the standard 3-simplex triangulation of the 2-sphere.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (facets, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>e</em>) can no longer be used.</p>
<p>See the page on <a class="el" href="pachner.html">Pachner moves on triangulations</a> for definitions and terminology relating to Pachner moves. After the move, the new belt face will be <code>pentachora().back()-&gt;tetrahedron(4)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a40b9288ac97b1df6a702b12dbe5325"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::fromIsoSig </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recovers a full triangulation from an isomorphism signature. </p>
<p>See isoSig() for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>The triangulation that is returned will be newly created, and it is the responsibility of the caller of this routine to destroy it.</p>
<p>Calling isoSig() followed by fromIsoSig() is not guaranteed to produce an <em>identical</em> triangulation to the original, but it is guaranteed to produce a combinatorially <em>isomorphic</em> triangulation. In other words, fromIsoSig() may reconstruct the triangulation with its simplices and/or vertices relabelled. The optional argument to isoSig() allows you to determine the precise relabelling that will be used, if you need to know it.</p>
<p>For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of the triangulation to construct. Note that isomorphism signature are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated triangulation if the reconstruction was successful, or <code>null</code> if the given string was not a valid <em>dim</em>-dimensional isomorphism signature. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f599699f40265ec3695157a46177a53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::fullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet. </p>
<p>The string is of the form <em>label (packet-type)</em>.</p>
<p>The packet label will be adjusted for human-readable output according to the behaviour of <a class="el" href="classregina_1_1Packet.html#a3c1eb0e0738d6630b5d1035de8eb7ba2" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">humanLabel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the descriptive text string. </dd></dl>

</div>
</div>
<a class="anchor" id="a21ba3093cb762d6dd200243170f29090"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a>&amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::fundamentalGroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fundamental group of this triangulation. </p>
<p>The fundamental group is computed in the dual 2-skeleton. This means:</p>
<ul>
<li>If the triangulation contains any ideal vertices, the fundamental group will be calculated as if each such vertex had been truncated.</li>
</ul>
<ul>
<li>Likewise, if the triangulation contains any invalid faces of dimension 0,1,...,(<em>dim</em>-3), these will effectively be truncated also.</li>
</ul>
<ul>
<li>In contrast, if the triangulation contains any invalid (<em>dim</em>-2)-faces (i.e., codimension-2-faces that are identified with themselves under a non-trivial map), the fundamental group will be computed <em>without</em> truncating the centroid of the face. For instance, if a 3-manifold triangulation has an edge identified with itself in reverse, then the fundamental group will be computed without truncating the resulting projective plane cusp. This means that, if a barycentric subdivision is performed on a such a triangulation, the result of fundamentalGroup() might change.</li>
</ul>
<p>Bear in mind that each time the triangulation changes, the fundamental group will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, fundamentalGroup() should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation has at most one component.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass SnapPeaTriangulation then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's Triangulation&lt;3&gt; class.) If you wish to compute the fundamental group with fillings, call SnapPeaTriangulation::fundamentalGroupFilled() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the fundamental group. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ff2a6ce37f4021f6d93309ec29a2232"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::fVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the f-vector of this triangulation, which counts the number of faces of all dimensions. </p>
<p>The vector that is returned will have length <em>dim</em>+1. If this vector is <em>f</em>, then <em>f</em>[<em>k</em>] will be the number of <em>k</em>-faces for each 0 &le; <em>k</em> &le; <em>dim</em>.</p>
<p>This routine is significantly more heavyweight than countFaces(). Its advantage is that, unlike the templatised countFaces(), it allows you to count faces whose dimensions are not known until runtime.</p>
<dl class="section return"><dt>Returns</dt><dd>the f-vector of this triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="a517c0fd1ec5190115785b91cca9e61b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::hasBoundaryFacets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation has any boundary facets. </p>
<p>This routine returns <code>true</code> if and only if the triangulation contains some top-dimension simplex with at least one facet that is not glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there are boundary facets. </dd></dl>

</div>
</div>
<a class="anchor" id="a169e28db650e7ad0b25d27a028a83ea0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object. </p>
<p>For packets, this returns <code>true</code> if and only if this packet has a parent in the packet tree (i.e., is not the root).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if some other object owns this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a51cdf35ec8b6ffb3a77df6fcf1dd754f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has the given associated tag. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af19b52d4bca489f771bb8485c7627cb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::hasTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has any associated tags at all. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this packet has any tags, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abe5cba1c19ba697c73c7ee7d2d0bca20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::homology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first homology group for this triangulation. </p>
<p>The homology is computed in the dual 2-skeleton. This means:</p>
<ul>
<li>If the triangulation contains any ideal vertices, the homology will be calculated as if each such vertex had been truncated.</li>
</ul>
<ul>
<li>Likewise, if the triangulation contains any invalid faces of dimension 0,1,...,(<em>dim</em>-3), these will effectively be truncated also.</li>
</ul>
<ul>
<li>In contrast, if the triangulation contains any invalid (<em>dim</em>-2)-faces (i.e., codimension-2-faces that are identified with themselves under a non-trivial map), the homology will be computed <em>without</em> truncating the centroid of the face. For instance, if a 3-manifold triangulation has an edge identified with itself in reverse, then the homology will be computed without truncating the resulting projective plane cusp. This means that, if a barycentric subdivision is performed on a such a triangulation, the result of homology() might change.</li>
</ul>
<p>This routine can also be accessed via the alias homologyH1() (a name that is more specific, but a little longer to type).</p>
<p>Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, homology() should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section warning"><dt>Warning</dt><dd>In dimension 3, if you are calling this from the subclass SnapPeaTriangulation then <b>any fillings on the cusps will be ignored</b>. (This is the same as for every routine implemented by Regina's Triangulation&lt;3&gt; class.) If you wish to compute homology with fillings, call SnapPeaTriangulation::homologyFilled() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the first homology group. </dd></dl>

</div>
</div>
<a class="anchor" id="ada9c5cfbc3e88b51ce9bb9a1974c9396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::homologyH1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first homology group for this triangulation. </p>
<p>This is identical to calling homology(). See the homology() documentation for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the first homology group. </dd></dl>

</div>
</div>
<a class="anchor" id="af1744de7cd6f1d4b6c269f4f62d4f77c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1AbelianGroup.html">AbelianGroup</a>&amp; <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::homologyH2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the second homology group for this triangulation. </p>
<p>If this triangulation contains any ideal vertices, the homology group will be calculated as if each such vertex had been truncated.</p>
<p>Bear in mind that each time the triangulation changes, the homology groups will be deleted. Thus the reference that is returned from this routine should not be kept for later use. Instead, <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#af1744de7cd6f1d4b6c269f4f62d4f77c" title="Returns the second homology group for this triangulation.">homologyH2()</a> should be called again; this will be instantaneous if the group has already been calculated.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This triangulation is valid.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the second homology group. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c1eb0e0738d6630b5d1035de8eb7ba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::humanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<p>In particular, if the packet has no label assigned then this routine will return "(no label)", not the empty string.</p>
<dl class="section warning"><dt>Warning</dt><dd>The method by which this routine adjusts packet labels is subject to change in future versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a class="anchor" id="a20c32f9ef9d04f13a5dfca9ec9ecf9df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::idealToFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an ideal triangulation into a finite triangulation. </p>
<p>All ideal or invalid vertices are truncated and thus converted into real boundary components made from unglued facets of pentachora.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the triangulation was changed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7f9556e8405ca88517ccd5549471fea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>prevChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as a child of this packet at the given location in this packet's child list. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>newChild</em> has no parent packet. </dd>
<dd>
Parameter <em>prevChild</em> is already a child of this packet. </dd>
<dd>
This packet is not a descendant of <em>newChild</em>.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="classregina_1_1Packet.html#a219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newChild</td><td>the child to insert. </td></tr>
    <tr><td class="paramname">prevChild</td><td>the preexisting child of this packet after which <em>newChild</em> will be inserted, or 0 if <em>newChild</em> is to be the first child of this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac389781f5c53a7d3aac3206d51ecfd91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as the first child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="classregina_1_1Packet.html#a219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3d02be74192f03b372a4195c9e5bc1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::insertChildLast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as the last child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="classregina_1_1Packet.html#a219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1e8b7cf820ff452059f817d55536155"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::insertConstruction </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nSimplices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>adjacencies</em>[][dim+1], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>gluings</em>[][dim+1][dim+1]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a given triangulation into this triangulation, where the given triangulation is described by a pair of integer arrays. </p>
<p>The main purpose of this routine is to allow users to hard-code triangulations into C++ source files. In particular, all of the simplex gluings can be hard-coded into a pair of integer arrays at the beginning of the source file, avoiding an otherwise tedious sequence of many calls to Simplex&lt;dim&gt;::join(). If you have a particular triangulation that you would like to hard-code in this way, you can call dumpConstruction() to generate the corresponding integer arrays as C++ source code.</p>
<p>This routine will insert an additional <em>nSimplices</em> top-dimensional simplices into this triangulation. We number these simplices 0,1,...,<em>nSimplices</em>-1. The gluings between these new simplices should be stored in the two arrays as follows.</p>
<p>The <em>adjacencies</em> array describes which simplices are joined to which others. Specifically, <code>adjacencies[s][f]</code> indicates which of the new simplices is joined to facet <em>f</em> of simplex <em>s</em>. This should be between 0 and <em>nSimplices</em>-1 inclusive, or -1 if facet <em>f</em> of simplex <em>s</em> is to be left as a boundary facet.</p>
<p>The <em>gluings</em> array describes the particular gluing permutations used to join these simplices together. Specifically, <code>gluings[s][f][0..<em>dim</em>]</code> should describe the permutation used to join facet <em>f</em> of simplex <em>s</em> to its adjacent simplex. These <em>dim</em>+1 integers should be 0,1,...,<em>dim</em> in some order, so that <code>gluings[s][f][i]</code> contains the image of <em>i</em> under this permutation. If facet <em>f</em> of simplex <em>s</em> is to be left as a boundary facet, then <code>gluings[s][f][0..<em>dim</em>]</code> may contain anything (and will be duly ignored).</p>
<p>If this triangulation is empty before this routine is called, then the new simplices will be given indices 0,1,...,<em>nSimplices</em>-1 according to the numbering described above. Otherwise they will be inserted after any pre-existing simplices, and so they will be given larger indices instead. In the latter case, the <em>adjacencies</em> array should still refer to the new simplices as 0,1,...,<em>nSimplices</em>-1, and this routine will handle any renumbering automatically at runtime.</p>
<p>It is the responsibility of the caller of this routine to ensure that the given arrays are correct and consistent. No error checking will be performed by this routine.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nSimplices</td><td>the number of additional simplices to insert. </td></tr>
    <tr><td class="paramname">adjacencies</td><td>describes which simplices are adjace to which others, as described above. This array must have initial dimension at least <em>nSimplices</em>. </td></tr>
    <tr><td class="paramname">gluings</td><td>describes the specific gluing permutations, as described above. This array must also have initial dimension at least <em>nSimplices</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bf93dbca6715c1a455a2d47f66a6476"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::insertTriangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a copy of the given triangulation into this triangulation. </p>
<p>The top-dimensional simplices of <em>source</em> will be copied into this triangulation in the same order in which they appear in <em>source</em>. That is, if the original size of this triangulation was <em>S</em>, then the simplex at index <em>i</em> in <em>source</em> will be copied into this triangulation as a new simplex at index <em>S</em>+<em>i</em>.</p>
<p>The copies will use the same vertex numbering and descriptions as the original simplices from <em>source</em>, and any gluings between the simplices of <em>source</em> will likewise be copied across as gluings between their copies in this triangulation.</p>
<p>This routine behaves correctly when <em>source</em> is this triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the triangulation whose copy will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa321f1bfb037aac23161b1f40745337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::intelligentSimplify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to simplify the triangulation as intelligently as possible without further input. </p>
<p>Specifically, this routine will attempt to reduce the number of pentachora in the triangulation.</p>
<p>Currently this routine uses <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aac2cee85d413b4bec25ce97a7feadd86" title="Uses all known simplification moves to reduce the triangulation monotonically to some local minimum n...">simplifyToLocalMinimum()</a> in combination with random 3-3 moves and book opening moves.</p>
<dl class="section warning"><dt>Warning</dt><dd>The specific behaviour of this routine will almost certainly change between releases. At present, simplification for 4-manifold triangulations is extremely weak (as opposed to 3-manifolds, where a rich library of simplification techinques is available to call upon).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the triangulation was changed. </dd></dl>

</div>
</div>
<a class="anchor" id="af085005271a4bfcdeacc5f9d84e1e401"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1Packet.html#acd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a class="anchor" id="a9d7278a3a79aec0493d0ad0c98ff8b3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::Packet::internalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet. </p>
<p>The user has no control over this ID, and it is not human readable. It is guaranteed to remain fixed throughout the lifetime of the program for a given packet, and it is guaranteed not to clash with the ID of any other packet.</p>
<p>If you change the contents of a packet, its ID will not change.</p>
<p>If you clone a packet, the new clone will receive a different ID. If you save and then load a packet to/from file, the ID will change. These behaviours are necessary to ensure that IDs remain unique (since, for instance, you could load several copies of the same data file into memory simultaneously).</p>
<p>The ID is implemented as an encoding of the underlying C++ pointer. This encoding is subject to change in later versions of Regina.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a8497f646fe594b88b0490e3f60138cbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is closed. </p>
<p>This is the case if and only if it has no boundary components.</p>
<p>Note that ideal triangulations are not closed. Triangulations with invalid vertices are also considered not closed; see <a class="el" href="classregina_1_1detail_1_1FaceBase.html#a0d18bbe888a506d895e057a98d9b6e77" title="Determines if this face lies entirely on the boundary of the triangulation.">Vertex&lt;4&gt;::isBoundary()</a> for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is closed. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ee1b7c2fbd1ea4a7a226993caa29e57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is connected. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is connected. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae91eb26428486e1804cef4fed7bebd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isContainedIn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if an isomorphic copy of this triangulation is contained within the given triangulation, possibly as a subcomplex of some larger component (or components). </p>
<p>Specifically, this routine determines if there is a boundary incomplete combinatorial isomorphism from this triangulation to <em>other</em>. Boundary incomplete isomorphisms are described in detail in the Isomorphism class notes.</p>
<p>In particular, note that facets of top-dimensional simplices that lie on the boundary of this triangulation need not correspond to boundary facets of <em>other</em>, and that <em>other</em> may contain more top-dimensional simplices than this triangulation.</p>
<p>If a boundary incomplete isomorphism is found, the details of this isomorphism are returned. The isomorphism is newly constructed, and so to assist with memory management is returned as a std::unique_ptr. Thus, to test whether an isomorphism exists without having to explicitly deal with the isomorphism itself, you can call <code>if (isContainedIn(other).get())</code> and the newly created isomorphism (if it exists) will be automatically destroyed.</p>
<p>If more than one such isomorphism exists, only one will be returned. For a routine that returns all such isomorphisms, see findAllSubcomplexesIn().</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation in which to search for an isomorphic copy of this triangulation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if such a copy is found, or a null pointer otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad26eb19438346ff47f0bf56598070a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this triangulation is empty. </p>
<p>An empty triangulation is one with no simplices at all.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fa9cbfad2644de54abe3673a7181c0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isGrandparentOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet is equal to or an ancestor of the given packet in the tree structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the other packet whose relationships we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet is equal to or an ancestor of <code>descendant</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a71aae2fbe0e82421d616d094ed59951e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::isIdeal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is ideal. </p>
<p>A triangulation is ideal if and only if (i) the triangulation is valid, and (ii) one of the vertex links is closed but not a 3-sphere.</p>
<p>Note that for 4-manifolds, <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#a71aae2fbe0e82421d616d094ed59951e" title="Determines if this triangulation is ideal.">isIdeal()</a> will only return <code>true</code> if the triangulation is valid (unlike 3-manifolds, where invalid ideal triangulations are allowed). This is to avoid situations like 4-manifold vertices whose links are cusped 3-manifolds (a situation that has no analogue in lower dimensions).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is ideal. </dd></dl>

</div>
</div>
<a class="anchor" id="a00301fd26f1eaaa4df55b94b8369a054"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isIdenticalTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially identical to the given triangulation. </p>
<p>Here "identical" means that the triangulations have the same number of top-dimensional simplices, with gluings between the same pairs of numbered simplices using the same gluing permutations. In other words, "identical" means that the triangulations are isomorphic via the identity isomorphism.</p>
<p>For the less strict notion of <em>isomorphic</em> triangulations, which allows relabelling of the top-dimensional simplices and their vertices, see isIsomorphicTo() instead.</p>
<p>This test does <em>not</em> examine the textual simplex descriptions, as seen in Simplex&lt;dim&gt;::description(); these may still differ. It also does not test whether lower-dimensional faces are numbered identically (vertices, edges and so on); this routine is only concerned with top-dimensional simplices.</p>
<p>(At the time of writing, two identical triangulations will always number their lower-dimensional faces in the same way. However, it is conceivable that in future versions of Regina there may be situations in which identical triangulations can acquire different numberings for vertices, edges, and so on.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the two triangulations are combinatorially identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a12f9aeb3cd023425abe5642deb8b8a27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isIsomorphicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is combinatorially isomorphic to the given triangulation. </p>
<p>Two triangulations are <em>isomorphic</em> if and only it is possible to relabel their top-dimensional simplices and the (<em>dim</em>+1) vertices of each simplex in a way that makes the two triangulations combinatorially identical, as returned by isIdenticalTo().</p>
<p>Equivalently, two triangulations are isomorphic if and only if there is a one-to-one and onto boundary complete combinatorial isomorphism from this triangulation to <em>other</em>, as described in the Isomorphism class notes.</p>
<p>In particular, note that this triangulation and <em>other</em> must contain the same number of top-dimensional simplices for such an isomorphism to exist.</p>
<p>If the triangulations are isomorphic, then this routine returns one such boundary complete isomorphism (i.e., one such relabelling). The isomorphism will be newly constructed, and to assist with memory management, it will be returned as a std::unique_ptr. Thus, to test whether an isomorphism exists without having to explicitly manage with the isomorphism itself, you can just call <code>if (isIsomorphicTo(other).get())</code>, in which case the newly created isomorphism (if it exists) will be automatically destroyed.</p>
<p>There may be many such isomorphisms between the two triangulations. If you need to find <em>all</em> such isomorphisms, you may call findAllIsomorphisms() instead.</p>
<p>If you need to ensure that top-dimensional simplices are labelled the same in both triangulations (i.e., that the triangulations are related by the <em>identity</em> isomorphism), you should call the stricter test isIdenticalTo() instead.</p>
<dl class="section warning"><dt>Warning</dt><dd>For large dimensions, this routine can become extremely slow: its running time includes a factor of (<em>dim</em>+1)!.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000047">Todo:</a></b></dt><dd><em>Optimise:</em> Improve the complexity by choosing a simplex mapping from each component and following gluings to determine the others.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare with this one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>details of the isomorphism if the two triangulations are combinatorially isomorphic, or a null pointer otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acd2dc2dee3396afb9dbf07c38fe10d63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isListening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given packet listener is currently listening for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener is currently registered with this packet, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab97ba0e2d6e92e92e233d28e237b8a24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is orientable. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is orientable. </dd></dl>

</div>
</div>
<a class="anchor" id="a52193108182bb6cefd2ea267f35479ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is oriented; that is, if the vertices of its top-dimensional simplices are labelled in a way that preserves orientation across adjacent facets. </p>
<p>Specifically, this routine returns <code>true</code> if and only if every gluing permutation has negative sign.</p>
<p>Note that <em>orientable</em> triangulations are not always <em>oriented</em> by default. You can call orient() if you need the top-dimensional simplices to be oriented consistently as described above.</p>
<p>A non-orientable triangulation can never be oriented.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all top-dimensional simplices are oriented consistently.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Matthias Goerner </dd></dl>

</div>
</div>
<a class="anchor" id="afee58a1ea4ea31f25849490a7cd2afad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isoSig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Isomorphism.html">Isomorphism</a>&lt; dim &gt; **&#160;</td>
          <td class="paramname"><em>relabelling</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the isomorphism signature for this triangulation. </p>
<p>An <em>isomorphism signature</em> is a compact text representation of a triangulation that uniquely determines the triangulation up to combinatorial isomorphism. That is, two triangulations of dimension <em>dim</em> are combinatorially isomorphic if and only if their isomorphism signatures are the same.</p>
<p>The isomorphism signature is constructed entirely of printable characters, and has length proportional to <code>n log n</code>, where <em>n</em> is the number of top-dimenisonal simplices.</p>
<p>Whilst the format of an isomorphism signature bears some similarity to dehydration strings for 3-manifolds, they are more general: isomorphism signatures can be used with any triangulations, including closed, bounded and/or disconnected triangulations, as well as triangulations with many simplices. Note also that 3-manifold dehydration strings are not unique up to isomorphism (they depend on the particular labelling of tetrahedra).</p>
<p>The time required to construct the isomorphism signature of a triangulation is <code>O((dim!) n^2 log^2 n)</code>. Whilst this is fine for large triangulation, it will be extremly slow for large <em>dimensions</em>.</p>
<p>The routine fromIsoSig() can be used to recover a triangulation from an isomorphism signature. The triangulation recovered might not be identical to the original, but it will be combinatorially isomorphic.</p>
<p>If <em>relabelling</em> is non-null (i.e., it points to some Isomorphism pointer <em>p</em>), then it will be modified to point to a new isomorphism that describes the precise relationship between this triangulation and the reconstruction from fromIsoSig(). Specifically, the triangulation that is reconstructed from fromIsoSig() will be combinatorially identical to <code>relabelling.apply(this)</code>.</p>
<p>For a full and precise description of the isomorphism signature format for 3-manifold triangulations, see <em>Simplification paths in the Pachner graphs of closed orientable 3-manifold triangulations</em>, Burton, 2011, <code>arXiv:1110.6080</code>. The format for other dimensions is essentially the same, but with minor dimension-specific adjustments.</p>
<dl class="section user"><dt>Python:</dt><dd>The isomorphism argument is not present. Instead there are two routines: fromIsoSig(), which returns a string only, and fromIsoSigDetail(), which returns a pair (<em>signature</em>, <em>relabelling</em>).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>If <em>relabelling</em> is non-null, then this triangulation must be non-empty and connected. The facility to return a relabelling for disconnected triangulations may be added to Regina in a later release.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relabelling</td><td>if this is non-null, it will be modified to point to a new isomorphism that describes the relationship between this triangulation and the triangulation that will be reconstructed from fromIsoSig(), as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the isomorphism signature of this triangulation. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2309f88209fdc55a5408838e5983caf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isoSigComponentSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deduces the number of top-dimensional simplices in a connected triangulation from its isomorphism signature. </p>
<p>See isoSig() for more information on isomorphism signatures. It will be assumed that the signature describes a triangulation of dimension <em>dim</em>.</p>
<p>If the signature describes a connected triangulation, this routine will simply return the size of that triangulation (e.g., the number of tetrahedra in the case <em>dim</em> = 3). You can also pass an isomorphism signature that describes a disconnected triangulation; however, this routine will only return the number of top-dimensional simplices in the first connected component. If you need the total size of a disconnected triangulation, you will need to reconstruct the full triangulation by calling fromIsoSig() instead.</p>
<p>This routine is very fast, since it only examines the first few characters of the isomorphism signature (in which the size of the first component is encoded). However, a side-effect of this is that it is possible to pass an <em>invalid</em> isomorphism signature and still receive a positive result. If you need to test whether a signature is valid or not, you must call fromIsoSig() instead, which will examine the entire signature in full.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix isomorphism signatures between dimensions! It is possible that the same string could corresponding to both a <em>p-dimensional</em> triangulation and a <em>q-dimensional</em> triangulation for different dimensions <em>p</em> and <em>q</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>the isomorphism signature of a <em>dim</em>-dimensional triangulation. Note that isomorphism signature are case-sensitive (unlike, for example, dehydration strings for 3-manifolds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of top-dimensional simplices in the first connected component, or 0 if this could not be determined because the given string was not a valid isomorphism signature. </dd></dl>

</div>
</div>
<a class="anchor" id="a49c4e1c1474b0a50703741257cf23889"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::isPacketEditable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children. </p>
<p>Descendants further down the packet tree are not (and should not need to be) considered.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet may be edited. </dd></dl>

</div>
</div>
<a class="anchor" id="a4602a09cb4e9babf8d9bfd33031c6dc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this triangulation is valid. </p>
<p>There are several conditions that might make a <em>dim</em>-dimensional triangulation invalid:</p>
<ol type="1">
<li>if some face is identified with itself under a non-identity permutation (e.g., an edge is identified with itself in reverse, or a triangle is identified with itself under a rotation);</li>
<li>if some <em>subdim</em>-face does not have an appropriate link. Here the meaning of "appropriate" depends upon the type of face:<ul>
<li>for a face that belongs to some boundary facet(s) of this triangulation, its link must be a topological ball;</li>
<li>for a vertex that does not belong to any boundary facets, its link must be a closed (<em>dim</em> - 1)-manifold;</li>
<li>for a (<em>subdim</em> &ge; 1)-face that does not belong to any boundary facets, its link must be a topological sphere.</li>
</ul>
</li>
</ol>
<p>Condition (1) is tested for all dimensions <em>dim</em>. Condition (2) is more difficult, since it relies on undecidable problems. As a result, (2) is <em>only</em> tested when <em>dim</em> is one of Regina's <a class="el" href="stddim.html">standard dimensions</a>.</p>
<p>If a triangulation is invalid then you can call Face&lt;dim, subdim&gt;::isValid() to discover exactly which face(s) are responsible, and you can call Face&lt;dim, subdim&gt;::hasBadIdentification() and/or Face&lt;dim, subdim&gt;::hasBadLink() to discover exactly which conditions fail.</p>
<p>Note that all invalid vertices are considered to be on the boundary; see isBoundary() for details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this triangulation is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="aae432b7b94461616ae85f6f85723b9ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::Packet::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet. </p>
<p>An example is <code>MyTriangulation</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a class="anchor" id="a2221cea4ccbc180f504a01e43942730c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::lastChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the last child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the last child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dfe6ac47f15c1ad9884c53ea1b5e15f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsDownTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given descendant in the tree structure. </p>
<p>If <code>descendant</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>descendant</code>, or can be obtained from <code>descendant</code> using only child-to-parent steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a class="anchor" id="af3fad051ab9e08d8723595088ddcc873"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::Packet::levelsUpTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given ancestor in the tree structure. </p>
<p>If <code>ancestor</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>ancestor</code>, or can be obtained from <code>ancestor</code> using only parent-to-child steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a class="anchor" id="aa504cfa813a3190c00337743915ffef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the given packet listener to listen for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully registered, or <code>false</code> if the given listener was already registered beforehand. </dd></dl>

</div>
</div>
<a class="anchor" id="a9277bf15589bb730bded019289311ac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::makeCanonical </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relabel the top-dimensional simplices and their vertices so that this triangulation is in canonical form. </p>
<p>This is essentially the lexicographically smallest labelling when the facet gluings are written out in order.</p>
<p>Two triangulations are isomorphic if and only if their canonical forms are identical.</p>
<p>The lexicographic ordering assumes that the facet gluings are written in order of simplex index and then facet number. Each gluing is written as the destination simplex index followed by the gluing permutation (which in turn is written as the images of 0,1,...,<em>dim</em> in order).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This routine currently works only when the triangulation is connected. It may be extended to work with disconnected triangulations in later versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the triangulation was changed, or <code>false</code> if the triangulation was in canonical form to begin with. </dd></dl>

</div>
</div>
<a class="anchor" id="ae061e36e8ecbfa2f1edc36ed9eb99a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::makeDoubleCover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts this triangulation into its double cover. </p>
<p>Each orientable component will be duplicated, and each non-orientable component will be converted into its orientable double cover. </p>

</div>
</div>
<a class="anchor" id="ad9aa0488b40a1f3ec702838b2a2ceecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::makeOrphan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree. </p>
<p>The tree information for both this packet and its parent will be updated.</p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet has a parent. </dd>
<dd>
This packet does not depend on its parent; see <a class="el" href="classregina_1_1Packet.html#a36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>After <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> is called, this packet will become the root of a new packet tree that is owned by Python. In particular, if you call <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and then delete all Python references to this packet, the entire packet subtree will be automatically destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3fa3daf9672da64a0fa8a82a439d65b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::moveContentsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the contents of this triangulation into the given destination triangulation, without destroying any pre-existing contents. </p>
<p>All top-dimensional simplices that currently belong to <em>dest</em> will remain there (and will keep the same indices in <em>dest</em>). All top-dimensional simplices that belong to this triangulation will be moved into <em>dest</em> also (but in general their indices will change).</p>
<p>This triangulation will become empty as a result.</p>
<p>Any pointers or references to Simplex&lt;dim&gt; objects will remain valid.</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>dest</em> is not this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the triangulation into which simplices should be moved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a59adc13b6143cf994779796077aed731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveDown </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the end of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very end of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d7730c57940444bf7d3085459449e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet to be the first in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a class="anchor" id="a7fcff38ccb62b62d28bed83d2a3a28d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveToLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet to be the last in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a class="anchor" id="ae02f6b3ad3a7816cde5d7df456763aaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::moveUp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the beginning of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very beginning of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d69a225b15d4481c083a59dbcb03234"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::newPentachoron </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> for further information. </p>

</div>
</div>
<a class="anchor" id="a59c7037574e244df13e5d01e1a383054"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; * <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::newPentachoron </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a>. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ad107a418e2691dc5ad7bb9e90dcba437" title="Creates a new top-dimensional simplex and adds it to this triangulation.">newSimplex()</a> for further information. </p>

</div>
</div>
<a class="anchor" id="ad107a418e2691dc5ad7bb9e90dcba437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex and adds it to this triangulation. </p>
<p>The new simplex will have an empty description. All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index size()-1.</p>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="a829224a264241e43a8f2bbdf5bfcb253"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::newSimplex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new top-dimensional simplex with the given description and adds it to this triangulation. </p>
<p>All (<em>dim</em>+1) facets of the new simplex will be boundary facets.</p>
<p>Descriptions are optional, may have any format, and may be empty. How descriptions are used is entirely up to the user.</p>
<p>The new simplex will become the last simplex in this triangulation; that is, it will have index size()-1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the description to give to the new simplex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="af16104a06312dbf644e7a958cc95abfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::nextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the next sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that follows this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the next sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bd2bc8fc84f44023a0a4b26ad839621"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="a90c57cdfb7f6845181b3eac467c890d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b3f24565a5053de126c8169d1a3ccdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="classregina_1_1Packet.html#a12e196f0f1c415b457df17f96d5b6518" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1Packet.html#a787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9adaefe48dec07f40f2a076df2d1c73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="classregina_1_1Packet.html#a12e196f0f1c415b457df17f96d5b6518" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1Packet.html#a787a09ec531988778fcfb0bc87effdd4" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="aceb4bc27f38ebe29c0b1c97b54198905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::oneFiveMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 1-5 move upon the given pentachoron. </p>
<p>This involves replacing one pentachoron with five pentachora: each new pentachoron runs from one facet of the original pentachoron to a new common internal degree five vertex.</p>
<p>This move can always be performed. The <em>check</em> argument is present (as for other moves), but is simply ignored (since the move is always legal). The <em>perform</em> argument is also present for consistency with other moves, but if it is set to <code>false</code> then this routine does nothing and returns no useful information.</p>
<p>Note that after performing this move, all skeletal objects (facets, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>p</em>) can no longer be used.</p>
<p>See the page on <a class="el" href="pachner.html">Pachner moves on triangulations</a> for definitions and terminology relating to Pachner moves. After the move, the new belt face will be <code>pentachora().back()-&gt;vertex(4)</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given pentachoron is a pentachoron of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the pentachoron about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td>this argument is ignored, since this move is always legal (see the notes above). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> always. </dd></dl>

</div>
</div>
<a class="anchor" id="aee16539dda7c9dbb9d61cdf9d3613886"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::openBook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a book opening move about the given tetrahedron. </p>
<p>This involves taking a tetrahedron meeting the boundary along precisely one, two or three triangles, and ungluing it to create two new boundary facets (thus exposing the pentachora it initially joined). This move is intended to open the way for new <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#ae44adb3b646f2fa05ba474e3943db766" title="Checks the eligibility of and/or performs a boundary shelling move on the given pentachoron.">shellBoundary()</a> moves.</p>
<p>This move can be done if:</p>
<ul>
<li>all vertices, edges and triangles of the tetrahedron are valid;</li>
</ul>
<ul>
<li>the tetrahedron meets the boundary in precisely one, two or three triangles (and therefore also joins two pentachora);</li>
</ul>
<ul>
<li>if the tetrahedron meets the boundary in precisely one triangle, then the remaining vertex of the tetrahedron is non-boundary, and no two of the remaining three edges of the tetrahedron are identified;</li>
</ul>
<ul>
<li>if the tetrahedron meets the boundary in precisely two triangles, then the remaining edge of the tetrahedron is non-boundary, and the remaining two triangles of the tetrahedron are not identified.</li>
</ul>
<p>The validity condition in particular is stronger than it needs to be, but the resulting "lost opportunities" only affect invalid triangulations.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (edges, components, etc.) will be reconstructed, which means that any pointers to old skeletal objects (such as the argument <em>t</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given tetrahedron is a tetrahedron of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the tetrahedron about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2711fd7c7115ce19b6833f0d61c42bec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::orient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relabels the vertices of top-dimensional simplices in this triangulation so that all simplices are oriented consistently, if possible. </p>
<p>This routine works by flipping vertices (<em>dim</em> - 1) and <em>dim</em> of each top-dimensional simplices that has negative orientation. The result will be a triangulation where the top-dimensional simplices have their vertices labelled in a way that preserves orientation across adjacent facets. In particular, every gluing permutation will have negative sign.</p>
<p>If this triangulation includes both orientable and non-orientable components, the orientable components will be oriented as described above and the non-orientable components will be left untouched. </p>

</div>
</div>
<a class="anchor" id="a151d4d7f2edd7d05a5f9de90e4bcc971"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the parent packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="ab70ae40804abd3b7a519b60341e2d9d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::Packet::prevSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the previous sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that precedes this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the previous sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="abae3b14078042b410238501a0947dcc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::removeAllPentachora </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a>. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a3e91a640743f9ce2710d17eda77d520a" title="Removes all simplices from the triangulation.">removeAllSimplices()</a> for further information. </p>

</div>
</div>
<a class="anchor" id="a3e91a640743f9ce2710d17eda77d520a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::removeAllSimplices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all simplices from the triangulation. </p>
<p>As a result, this triangulation will become empty.</p>
<p>All of the simplices that belong to this triangulation will be destroyed immediately. </p>

</div>
</div>
<a class="anchor" id="aee2405989e058dbfddf7ae445d47ddcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::removeAllTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all associated tags from this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet. </p>

</div>
</div>
<a class="anchor" id="a314107e68322e78d6ed299df38731a58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::removePentachoron </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>tet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a>. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a7b349c4e1fb4b27a9b20ed53b277a7ba" title="Removes the given top-dimensional simplex from this triangulation.">removeSimplex()</a> for further information. </p>

</div>
</div>
<a class="anchor" id="ad555b8265046c5f3fc09c2b53fab832f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::removePentachoronAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a>. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#ac9f36b004ba6af3d6ce11bdb655650ec" title="Removes the top-dimensional simplex at the given index in this triangulation.">removeSimplexAt()</a> for further information. </p>

</div>
</div>
<a class="anchor" id="a7b349c4e1fb4b27a9b20ed53b277a7ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::removeSimplex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>simplex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given top-dimensional simplex from this triangulation. </p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex is a top-dimensional simplex in this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td>the simplex to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9f36b004ba6af3d6ce11bdb655650ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::removeSimplexAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the top-dimensional simplex at the given index in this triangulation. </p>
<p>This is equivalent to calling <code>removeSimplex(simplex(index))</code>.</p>
<p>The given simplex will be unglued from any adjacent simplices (if any), and will be destroyed immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which top-dimensionalsimplex to remove; this must be between 0 and size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb9880c0189b8f60827cd0ce9a2bb32c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::removeTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the association of the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was removed, or <code>false</code> if the given tag was not actually associated with this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a219920e1523d3edf2982da0a3ba1a33d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::reparent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead. </p>
<p>This routine is essentially a combination of <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> followed by either <a class="el" href="classregina_1_1Packet.html#ac389781f5c53a7d3aac3206d51ecfd91" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> or <a class="el" href="classregina_1_1Packet.html#ad3d02be74192f03b372a4195c9e5bc1f" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>.</p>
<p>This routine takes small constant time. It is safe to use regardless of whether this packet has a parent or not.</p>
<p>If you wish to reparent <em>all</em> of the children of a given packet, see <a class="el" href="classregina_1_1Packet.html#a27ce736503ede9e8c57fb5d169e6414f" title="Cuts all of this packet&#39;s children out of the packet tree, and reinserts them as children of the give...">transferChildren()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend on its parent; see <a class="el" href="classregina_1_1Packet.html#a36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>This routine is much simpler than combinations of <a class="el" href="classregina_1_1Packet.html#ad9aa0488b40a1f3ec702838b2a2ceecc" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and <a class="el" href="classregina_1_1Packet.html#ac389781f5c53a7d3aac3206d51ecfd91" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> / <a class="el" href="classregina_1_1Packet.html#ad3d02be74192f03b372a4195c9e5bc1f" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>, since there are no unpleasant ownership issues to deal with. However, if this packet currently has no parent then the ownership issues are unavoidable; in this case <a class="el" href="classregina_1_1Packet.html#a219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> will do nothing, and one of the insertChild...() routines must be used instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent of this packet, i.e., the packet beneath which this packet will be inserted. </td></tr>
    <tr><td class="paramname">first</td><td><code>true</code> if this packet should be inserted as the first child of the given parent, or <code>false</code> (the default) if it should be inserted as the last child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dc7da993bfbdb423f6c932c381dad50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::Packet::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the root of the tree to which this packet belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the matriarch of the packet tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a8035ecc57099d3d28d59599b65af5feb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::sameDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given triangulation have the same <em>k</em>-face degree sequences, for each facial dimension <em>k</em> &le; <em>subdim</em>. </p>
<p>For the purposes of this routine, degree sequences are considered to be unordered.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given triangulation are known to have the same number of <em>k</em>-faces as each other, for each facial dimension <em>k</em> &le; <em>subdim</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if all degree sequences considered are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="af963f8d8cb94d216df5158e5204e4927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::sameFVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether this and the given triangulation have the same number of <em>k</em>-faces, for each facial dimension <em>k</em> &le; <em>subdim</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation to compare against this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the face counts considered are identical for both triangluations. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4533d4c7c40eb9ba7c9327606af6f4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format. </p>
<p>The XML file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>This is the preferred way of saving a Regina data file. Typically this will be called from the root of the packet tree, which will save the entire packet tree to file.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Internationalisation:</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the pathname of the file to write to. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a class="anchor" id="aae70a504949f02a1dd5b9ceac3c787f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file. </p>
<p>The data file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the given output stream.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given stream is open for writing. </dd>
<dd>
The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the data was successfully written. </dd></dl>

</div>
</div>
<a class="anchor" id="adfd869991cbf664891629f21a5432b02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the label associated with this individual packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the new label to give this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae44adb3b646f2fa05ba474e3943db766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::shellBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaf6d8edc6c6e383805f39c3b318d39125">Pentachoron</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a boundary shelling move on the given pentachoron. </p>
<p>This involves simply popping off a pentachoron that touches the boundary. This can be done if:</p>
<ul>
<li>all edges and triangles of the pentachoron are valid;</li>
</ul>
<ul>
<li>precisely one, two, three or four facets of the pentachoron lie in the boundary;</li>
</ul>
<ul>
<li>if one facet lies in the boundary, then the opposite vertex does not lie in the boundary, and no two of the remaining four edges are identified;</li>
</ul>
<ul>
<li>if two facets lie in the boundary, then the edge that sits opposite their common triangle does not lie in the boundary, and no two of the remaining three triangles are identified;</li>
</ul>
<ul>
<li>if three facets lie in the boundary, then the triangle that sits opposite their common edge does not lie in the boundary, and the remaining two facets of the tetrahedron are not identified.</li>
</ul>
<p>The validity condition in particular is stronger than it needs to be, but the resulting "lost opportunities" only affect invalid triangulations.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (edges, components, etc.) will be reconstructed, which means that any pointers to old skeletal objects can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given pentachoron is a pentachoron of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>the pentachoron upon which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <em>true</em>, this function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, this function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2e269a7332e80aeec3603881fd175d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="a61ac843dd4a46316960d65a56c28fff8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt;* <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::simplex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the top-dimensional simplex at the given index in the triangulation. </p>
<p>Note that indexing may change when a simplex is added to or removed from the triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>specifies which simplex to return; this value should be between 0 and size()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <em>index</em>th top-dimensional simplex. </dd></dl>

</div>
</div>
<a class="anchor" id="a721e084ec08bb631e35e14ff1c844f63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt;*&gt;&amp; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::simplices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns all top-dimensional simplices in the triangulation. </p>
<p>The reference that is returned will remain valid for as long as the triangulation exists: even as simplices are added and/or removed, it will always reflect the simplices that are currently in the triangulation.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all top-dimensional simplices. </dd></dl>

</div>
</div>
<a class="anchor" id="af74cde5c3b790195df3e10e2e53e390b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::simplifiedFundamentalGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1GroupPresentation.html">GroupPresentation</a> *&#160;</td>
          <td class="paramname"><em>newGroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Notifies the triangulation that you have simplified the presentation of its fundamental group. </p>
<p>The old group presentation will be destroyed, and this triangulation will take ownership of the new (hopefully simpler) group that is passed.</p>
<p>This routine is useful for situations in which some external body (such as GAP) has simplified the group presentation better than Regina can.</p>
<p>Regina does <em>not</em> verify that the new group presentation is equivalent to the old, since this is - well, hard.</p>
<p>If the fundamental group has not yet been calculated for this triangulation, this routine will nevertheless take ownership of the new group, under the assumption that you have worked out the group through some other clever means without ever having needed to call fundamentalGroup() at all.</p>
<p>Note that this routine will not fire a packet change event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newGroup</td><td>a new (and hopefully simpler) presentation of the fundamental group of this triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac2cee85d413b4bec25ce97a7feadd86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::simplifyToLocalMinimum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uses all known simplification moves to reduce the triangulation monotonically to some local minimum number of pentachora. </p>
<p>End users will probably not want to call this routine. You should call <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aaa321f1bfb037aac23161b1f40745337" title="Attempts to simplify the triangulation as intelligently as possible without further input...">intelligentSimplify()</a> if you want a fast method of simplifying a triangulation.</p>
<p>The moves used by this routine include collapsing edges, 4-2 moves, and boundary shelling moves.</p>
<p>Moves that do not reduce the number of pentachora (such as 3-3 moves or book opening moves) are not used in this routine. Such moves do however feature in <a class="el" href="classregina_1_1Triangulation_3_014_01_4.html#aaa321f1bfb037aac23161b1f40745337" title="Attempts to simplify the triangulation as intelligently as possible without further input...">intelligentSimplify()</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>The specific behaviour of this routine will almost certainly change between releases. At present, simplification for 4-manifold triangulations is extremely weak (as opposed to 3-manifolds, where a rich library of simplification techinques is available to call upon).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the simplifications, or <code>false</code> if we are only to investigate whether simplifications are possible (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <em>perform</em> is <code>true</code>, this routine returns <code>true</code> if and only if the triangulation was changed to reduce the number of pentachora; if <em>perform</em> is <code>false</code>, this routine returns <code>true</code> if and only if it determines that it is capable of performing such a change. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ca55a972a8c21f7e87960431d9ef64c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of top-dimensional simplices in the triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of top-dimensional simplices. </dd></dl>

</div>
</div>
<a class="anchor" id="af91bc951714dc60db12810affb266b8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::sortChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the immediate children of this packet according to their packet labels. </p>
<p>Note that this routine is not recursive (for instance, grandchildren will not be sorted within each child packet).</p>
<p>This routine takes quadratic time in the number of immediate children (and it's slow quadratic at that). </p>

</div>
</div>
<a class="anchor" id="a269bd2c09cea50d26a2a6bb125d55652"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::splitIntoComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>componentParent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>setLabels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a disconnected triangulation into many smaller triangulations, one for each component. </p>
<p>The new component triangulations will be inserted as children of the given parent packet. The original triangulation (i.e., this triangulation) will be left unchanged.</p>
<p>If the given parent packet is 0, the new component triangulations will be inserted as children of this triangulation.</p>
<p>By default, this routine will assign sensible packet labels to each of the new component triangulations. If these component triangulations are only temporary objects used as part of some larger algorithm, then labels are unnecessary - in this case you can pass <em>setLabels</em> as <code>false</code> to avoid the (small) overhead that these packet labels incur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">componentParent</td><td>the packet beneath which the new component triangulations will be inserted, or 0 if they should be inserted directly beneath this triangulation. </td></tr>
    <tr><td class="paramname">setLabels</td><td><code>true</code> if the new component triangulations should be assigned sensible packet labels, or <code>false</code> if they should be left without labels at all. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of new component triangulations constructed. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aed565fd71935ebdc8f9d6af6bd46d666"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::swapBaseProperties </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">TriangulationBase</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all properties that are managed by this base class, including skeletal data, with the given triangulation. </p>
<p>Note that TriangulationBase never calls this routine itself. Typically swapBaseProperties() is only ever called by Triangulation&lt;dim&gt;::swapAllProperties(), which in turn is called by swapContents().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose properties should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad43e7587b785f281f5f5c553f263484e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::swapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the contents of this and the given triangulation. </p>
<p>All top-dimensional simplices that belong to this triangulation will be moved to <em>other</em>, and all top-dimensional simplices that belong to <em>other</em> will be moved to this triangulation. Likewise, all skeletal objects (such as lower-dimensional faces, components, and boundary components) and all cached properties (such as homology and fundamental group) will be swapped.</p>
<p>In particular, any pointers or references to Simplex&lt;dim&gt; and/or <a class="el" href="classregina_1_1Face.html">Face&lt;dim, subdim&gt;</a> objects will remain valid.</p>
<p>This routine will behave correctly if <em>other</em> is in fact this triangulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the triangulation whose contents should be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a013abf7fffeba839fb47a2dcfaee19f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">regina::detail::FaceListSuite</a>&lt; dim, subdim &gt;::swapFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1detail_1_1FaceListSuite.html">FaceListSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps all faces of dimension <em>subdim</em> and below with those of the given triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the face storage for the triangulation whose faces are to be swapped with this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a765186c1742fe402922433b77e5f439a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::swapWithNextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this packet with its next sibling in the sequence of children beneath their common parent packet. </p>
<p>Calling this routine is equivalent to calling <a class="el" href="classregina_1_1Packet.html#a59adc13b6143cf994779796077aed731" title="Moves this packet the given number of steps towards the end of its sibling list.">moveDown()</a>.</p>
<p>This routine takes small constant time.</p>
<p>If this packet has no next sibling then this routine does nothing. </p>

</div>
</div>
<a class="anchor" id="a2941beca61f6d0149739217aa66e9ccf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::Packet::tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list of strings.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set of all tags associated with this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a74167a47084c10334c086d8c4cce7c4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::threeThreeMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 3-3 move about the given triangle. </p>
<p>This involves replacing the three pentachora joined along that triangle with three pentachora joined along a transverse triangle. This can be done iff (i) the triangle is valid and non-boundary, and (ii) the three pentachora are distinct.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (facets, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<p>See the page on <a class="el" href="pachner.html">Pachner moves on triangulations</a> for definitions and terminology relating to Pachner moves. After the move, the new belt face will be <code>pentachora().back()-&gt;triangle(Triangle&lt;4&gt;::triangleNumber[0][1][2])</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given triangle is a triangle of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a887f3982f980246091cb209648e004dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::Packet::totalTreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the total number of packets in the tree or subtree for which this packet is matriarch. </p>
<p>This packet is included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total tree or subtree size. </dd></dl>

</div>
</div>
<a class="anchor" id="a27ce736503ede9e8c57fb5d169e6414f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::transferChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead. </p>
<p>The children of this packet will be appended to the end of the new parent's child list, in the same order as they were previously.</p>
<p>This is equivalent to calling <a class="el" href="classregina_1_1Packet.html#a219920e1523d3edf2982da0a3ba1a33d" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> on each child, but should be somewhat faster if there are many children to move.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None of the children of this packet depend on their current parent; see <a class="el" href="classregina_1_1Packet.html#a36260b904a2bf98d9484869267ddf7b5" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent beneath which the children will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af21e8b23c65ad86ef13bafab18f5be37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::twoFourMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gabca1e9191042206a1ee162eecb643010">Tetrahedron</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-4 move about the given facet. </p>
<p>This involves replacing the two pentachora joined along that facet with four pentachora joined along a transverse edge. This can be done iff the two pentachora are distinct.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (facets, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<p>See the page on <a class="el" href="pachner.html">Pachner moves on triangulations</a> for definitions and terminology relating to Pachner moves. After the move, the new belt face will be <code>pentachora().back()-&gt;edge(Edge&lt;4&gt;::edgeNumber[0][1])</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given facet is a facet of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the facet about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d260a693839e3b4a2568d2912468989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::twoZeroMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#gaa4bd693cb8baf750ec16d086a13d7baa">Triangle</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-0 move about the given triangle of degree 2. </p>
<p>This involves taking the two pentachora joined at that triangle and squashing them flat.</p>
<p>The eligibility requirements for this move are somewhat involved, and are discussed in detail in the source code for those who are interested.</p>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (tetrahedra, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given triangle is a triangle of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the triangle about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a88995126c5d87e4385707405d13e293d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::twoZeroMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>perform</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the eligibility of and/or performs a 2-0 move about the given edge of degree 2. </p>
<p>This involves taking the two pentachora joined at that edge and squashing them flat. This can be done if:</p>
<ul>
<li>the edge is valid and non-boundary and has a 2-sphere edge link;</li>
</ul>
<ul>
<li>the two pentachora are distinct;</li>
</ul>
<ul>
<li>the triangles opposite <em>e</em> in each pentachoron are distinct and not both boundary;</li>
</ul>
<ul>
<li>if facets <em>f1</em> and <em>f2</em> of one pentachoron are to be flattened onto facets <em>g1</em> and <em>g2</em> of the other respectively, then (a) <em>f1</em> and <em>g1</em> are distinct, (b) <em>f2</em> and <em>g2</em> are distinct, (c) we do not have both <em>f1</em> = <em>g2</em> and <em>g1</em> = <em>f2</em>, (d) we do not have both <em>f1</em> = <em>f2</em> and <em>g1</em> = <em>g2</em>, and (e) we do not have two of the facets boundary and the other two identified;</li>
</ul>
<ul>
<li>the two pentachora meet each other on all three facets touching the edge (as opposed to meeting each other on one facet and being glued to themselves along the other two).</li>
</ul>
<p>If the routine is asked to both check and perform, the move will only be performed if the check shows it is legal.</p>
<p>Note that after performing this move, all skeletal objects (tetrahedra, components, etc.) will be reconstructed, which means any pointers to old skeletal objects (such as the argument <em>f</em>) can no longer be used.</p>
<dl class="section pre"><dt>Precondition</dt><dd>If the move is being performed and no check is being run, it must be known in advance that the move is legal. </dd>
<dd>
The given edge is an edge of this triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the edge about which to perform the move. </td></tr>
    <tr><td class="paramname">check</td><td><code>true</code> if we are to check whether the move is allowed (defaults to <code>true</code>). </td></tr>
    <tr><td class="paramname">perform</td><td><code>true</code> if we are to perform the move (defaults to <code>true</code>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>check</em> is <code>true</code>, the function returns <code>true</code> if and only if the requested move may be performed without changing the topology of the manifold. If <em>check</em> is <code>false</code>, the function simply returns <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a11e183185ea0a33e67e2574fc93c7469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::Packet::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet. </p>
<p>This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type ID. </dd></dl>

</div>
</div>
<a class="anchor" id="a787a09ec531988778fcfb0bc87effdd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string regina::Packet::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet. </p>
<p>An example is <code>Triangulation3</code>. This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type name. </dd></dl>

</div>
</div>
<a class="anchor" id="ae71b40cd2416de174bba61db2ec92f1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::Packet::unlisten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters the given packet listener so that it no longer listens for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1PacketListener.html" title="An object that can be registered to listen for packet events.">PacketListener</a> class notes for details.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully unregistered, or <code>false</code> if the given listener was not registered in the first place. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aea340c604530a924c5dbd39aa5296114"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1Packet.html#a71ff7e67e51fd235b1ffa139ae561508">regina::Packet</a>.</p>

</div>
</div>
<a class="anchor" id="a40a83bcecd330e4c4a1f4f154b7063f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1Packet.html#a54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a class="anchor" id="a89c51de87cc69b8c7fc2385d26382385"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::writeXMLBaseProperties </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing properties of this triangulation. </p>
<p>This routine covers those properties that are managed by this base class TriangulationBase and that have already been computed for this triangulation.</p>
<p>This routine is typically called from within Triangulation&lt;dim&gt;::writeXMLPacketData(). The XML elements that it writes are child elements of the <code>packet</code> element.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b63b1c8b1e24e99e4103aced7027e44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format. </p>
<p>Ths is similar to calling <a class="el" href="classregina_1_1Packet.html#ae4533d4c7c40eb9ba7c9327606af6f4a" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a>, except that (i) the user has a more flexible choice of output stream, and (ii) the XML will always be written in plain text (i.e., it will not be compressed).</p>
<p>If you simply wish to save your data to a file on the filesystem, you should call <a class="el" href="classregina_1_1Packet.html#ae4533d4c7c40eb9ba7c9327606af6f4a" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a> instead.</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the output stream.</p>
<p>The output from this routine cannot be used as a piece of an XML file; it must be the entire XML file. For a piece of an XML file, see routine <a class="el" href="classregina_1_1Packet.html#ae0af776b191fe7d2ca2eed7500772789" title="Writes a chunk of XML containing the subtree with this packet as matriarch.">writeXMLPacketTree()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend upon its parent.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>The argument <em>out</em> is not present; instead the XML data is written to standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML data file should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91e41a57dbb8b5ca197a26cbcd09ccd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation</a>&lt; 4 &gt;::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1Packet.html#a7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a class="anchor" id="ae0af776b191fe7d2ca2eed7500772789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::Packet::writeXMLPacketTree </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the subtree with this packet as matriarch. </p>
<p>This is the preferred way of writing a packet tree to file.</p>
<p>The output from this routine is only a piece of XML; it should not be used as a complete XML file. For a complete XML file, see routine <a class="el" href="classregina_1_1Packet.html#a2b63b1c8b1e24e99e4103aced7027e44" title="Writes the subtree rooted at this packet to the given output stream in Regina&#39;s native XML file forma...">writeXMLFile()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac280128dabd3208670cb0fdc010dffb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="classregina_1_1BoundaryComponent.html">BoundaryComponent</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::boundaryComponents_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The components that form the boundary of the triangulation. </p>

</div>
</div>
<a class="anchor" id="a3ef8ae8c6af5b7757dddc44327ea3133"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A compile-time constant that gives the dimension of the triangulation. </p>

</div>
</div>
<a class="anchor" id="a3fba432b4a7a57ee4e21a9523151c660"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1MarkedVector.html">MarkedVector</a>&lt;<a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt;dim&gt; &gt; <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::simplices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The top-dimensional simplices that form the triangulation. </p>

</div>
</div>
<a class="anchor" id="a327ad9e8143772575b5701a3c4ad6007"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">regina::detail::TriangulationBase</a>&lt; int &gt;::valid_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this triangulation valid? See isValid() for details on what this means. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>triangulation/dim4/<a class="el" href="triangulation4_8h.html">triangulation4.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
