<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::CompactSearcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1CompactSearcher.html">CompactSearcher</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classregina_1_1CompactSearcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::CompactSearcher Class Reference<div class="ingroups"><a class="el" href="group__census.html">Census of Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A gluing permutation search class that offers a specialised search algorithm for when only compact (finite) 3-manifold triangulations are required.  
 <a href="classregina_1_1CompactSearcher.html#details">More...</a></p>

<p><code>#include &lt;census/gluingpermsearcher3.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::CompactSearcher:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1CompactSearcher.png" usemap="#regina::CompactSearcher_map" alt=""/>
  <map id="regina::CompactSearcher_map" name="regina::CompactSearcher_map">
<area href="classregina_1_1GluingPermSearcher_3_013_01_4.html" title="A utility class for searching through all possible gluing permutation sets that correspond to a given..." alt="regina::GluingPermSearcher&lt; 3 &gt;" shape="rect" coords="0,56,203,80"/>
<area href="classregina_1_1GluingPerms.html" alt="regina::GluingPerms&lt; 3 &gt;" shape="rect" coords="0,0,203,24"/>
<area href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed..." alt="regina::ClosedPrimeMinSearcher" shape="rect" coords="0,168,203,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">TetEdgeState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron edges as the gluing permutation set is constructed.  <a href="structregina_1_1CompactSearcher_1_1TetEdgeState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">TetVertexState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set is constructed.  <a href="structregina_1_1CompactSearcher_1_1TetVertexState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:gada3ab4fafaa359d394afabb2b56253b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gada3ab4fafaa359d394afabb2b56253b2">PurgeFlags</a> { <br />
&#160;&#160;<a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a82e983dba291b66ddf05b4f99d2e85ce">PURGE_NONE</a> = 0
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2af774c239c72c690a3dc88527904ba57a">PURGE_NON_MINIMAL</a> = 1
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a88dbd756465fbe8ed551b9c4089eba14">PURGE_NON_PRIME</a> = 2
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a488784291610d2080c8fd9be7fb0d99e">PURGE_NON_MINIMAL_PRIME</a> = 3
, <br />
&#160;&#160;<a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a9d84a4d217e149b8d1340f6b2754abe4">PURGE_NON_MINIMAL_HYP</a> = 9
, <a class="el" href="group__census.html#ggada3ab4fafaa359d394afabb2b56253b2a761c00f0760cd3af4d6b07162218a6b0">PURGE_P2_REDUCIBLE</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:gada3ab4fafaa359d394afabb2b56253b2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classregina_1_1Flags.html" title="A class representing a bitwise combination of flags defined by an enumeration type.">Flags</a> to indicate that our enumeration may (at the discretion of the enumeration algorithm) ignore certain classes of triangulations.  <a href="group__census.html#gada3ab4fafaa359d394afabb2b56253b2">More...</a><br /></td></tr>
<tr class="separator:gada3ab4fafaa359d394afabb2b56253b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c89ca6699633f872a9611273995730"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>) (const <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; *, void *)</td></tr>
<tr class="memdesc:ga40c89ca6699633f872a9611273995730"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine that can do arbitrary processing upon a set of gluing permutations.  <a href="group__census.html#ga40c89ca6699633f872a9611273995730">More...</a><br /></td></tr>
<tr class="separator:ga40c89ca6699633f872a9611273995730"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga9c9b0e336f9e35995a83d38fecc93bb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9c9b0e336f9e35995a83d38fecc93bb2">CompactSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga9c9b0e336f9e35995a83d38fecc93bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager for use when only compact 3-manifold triangulations are required.  <a href="group__census.html#ga9c9b0e336f9e35995a83d38fecc93bb2">More...</a><br /></td></tr>
<tr class="separator:ga9c9b0e336f9e35995a83d38fecc93bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa168e472dd2efdad10fbbadff7cf64a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa168e472dd2efdad10fbbadff7cf64a1">CompactSearcher</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:gaa168e472dd2efdad10fbbadff7cf64a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a new search manager based on data read from the given input stream.  <a href="group__census.html#gaa168e472dd2efdad10fbbadff7cf64a1">More...</a><br /></td></tr>
<tr class="separator:gaa168e472dd2efdad10fbbadff7cf64a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17d63870ed80ed980f5f5733881b641"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa17d63870ed80ed980f5f5733881b641">~CompactSearcher</a> ()</td></tr>
<tr class="memdesc:gaa17d63870ed80ed980f5f5733881b641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this search manager and all supporting data structures.  <a href="group__census.html#gaa17d63870ed80ed980f5f5733881b641">More...</a><br /></td></tr>
<tr class="separator:gaa17d63870ed80ed980f5f5733881b641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef94a9fe76fd50d2275a34174bf52bb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb">dumpData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga4ef94a9fe76fd50d2275a34174bf52bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format to the given output stream.  <a href="group__census.html#ga4ef94a9fe76fd50d2275a34174bf52bb">More...</a><br /></td></tr>
<tr class="separator:ga4ef94a9fe76fd50d2275a34174bf52bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1f3fa096d1bcbacc3a52d3fc28bb503"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503">runSearch</a> (long maxDepth=-1) override</td></tr>
<tr class="memdesc:gaf1f3fa096d1bcbacc3a52d3fc28bb503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates all possible gluing permutation sets that satisfy the current search criteria.  <a href="group__census.html#gaf1f3fa096d1bcbacc3a52d3fc28bb503">More...</a><br /></td></tr>
<tr class="separator:gaf1f3fa096d1bcbacc3a52d3fc28bb503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0d472300ed37ee9ba02e60bb0f90f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8">completePermSet</a> () const</td></tr>
<tr class="memdesc:ga9c0d472300ed37ee9ba02e60bb0f90f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this search manager holds a complete gluing permutation set or just a partially completed search state.  <a href="group__census.html#ga9c0d472300ed37ee9ba02e60bb0f90f8">More...</a><br /></td></tr>
<tr class="separator:ga9c0d472300ed37ee9ba02e60bb0f90f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68aae09c481982555e0a9f744264e8dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga68aae09c481982555e0a9f744264e8dc">dumpTaggedData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga68aae09c481982555e0a9f744264e8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps all internal data in a plain text format, along with a marker to signify which precise class the data belongs to.  <a href="group__census.html#ga68aae09c481982555e0a9f744264e8dc">More...</a><br /></td></tr>
<tr class="separator:ga68aae09c481982555e0a9f744264e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0d16509c016c37f87b239b77f1c8f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1">inputError</a> () const</td></tr>
<tr class="memdesc:ga1a0d16509c016c37f87b239b77f1c8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Was an error found during construction from an input stream?  <a href="group__census.html#ga1a0d16509c016c37f87b239b77f1c8f1">More...</a><br /></td></tr>
<tr class="separator:ga1a0d16509c016c37f87b239b77f1c8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052f8788995d20de83982daedffa9868"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga052f8788995d20de83982daedffa9868">size</a> () const</td></tr>
<tr class="memdesc:ga052f8788995d20de83982daedffa9868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of simplices under consideration.  <a href="group__census.html#ga052f8788995d20de83982daedffa9868">More...</a><br /></td></tr>
<tr class="separator:ga052f8788995d20de83982daedffa9868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceabd6f42214d77e7cb132e2a37d790f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f">facetPairing</a> () const</td></tr>
<tr class="memdesc:gaceabd6f42214d77e7cb132e2a37d790f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the specific pairing of simplex facets that this set of gluing permutations complements.  <a href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f">More...</a><br /></td></tr>
<tr class="separator:gaceabd6f42214d77e7cb132e2a37d790f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6efb577f8be677717e20624a75037de6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6">gluingPerm</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:ga6efb577f8be677717e20624a75037de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="group__census.html#ga6efb577f8be677717e20624a75037de6">More...</a><br /></td></tr>
<tr class="separator:ga6efb577f8be677717e20624a75037de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8621f1370a90132ec44b032c7926066f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8621f1370a90132ec44b032c7926066f">gluingPerm</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:ga8621f1370a90132ec44b032c7926066f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation associated with the given simplex facet.  <a href="group__census.html#ga8621f1370a90132ec44b032c7926066f">More...</a><br /></td></tr>
<tr class="separator:ga8621f1370a90132ec44b032c7926066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48d4e4a6f2423844a747d921e1e8459c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga48d4e4a6f2423844a747d921e1e8459c">triangulate</a> () const</td></tr>
<tr class="memdesc:ga48d4e4a6f2423844a747d921e1e8459c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing.  <a href="group__census.html#ga48d4e4a6f2423844a747d921e1e8459c">More...</a><br /></td></tr>
<tr class="separator:ga48d4e4a6f2423844a747d921e1e8459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga6a125fcef3581b87f04eec6eb8044328"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328">findAllPerms</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga6a125fcef3581b87f04eec6eb8044328"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main entry routine for running a search for all gluing permutation sets that complement a given face pairing.  <a href="group__census.html#ga6a125fcef3581b87f04eec6eb8044328">More...</a><br /></td></tr>
<tr class="separator:ga6a125fcef3581b87f04eec6eb8044328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ac77c210fb2ae44e799f3f7db02300"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga83ac77c210fb2ae44e799f3f7db02300">bestSearcher</a> (const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt; *pairing, const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *autos, bool orientableOnly, bool finiteOnly, int whichPurge, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga83ac77c210fb2ae44e799f3f7db02300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a search manager of the best possible class for the given search parameters.  <a href="group__census.html#ga83ac77c210fb2ae44e799f3f7db02300">More...</a><br /></td></tr>
<tr class="separator:ga83ac77c210fb2ae44e799f3f7db02300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga987cf019e19f63f5a470f59588dd0d69"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69">readTaggedData</a> (std::istream &amp;in, <a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a> use, void *useArgs=0)</td></tr>
<tr class="memdesc:ga987cf019e19f63f5a470f59588dd0d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new search manager based on tagged data read from the given input stream.  <a href="group__census.html#ga987cf019e19f63f5a470f59588dd0d69">More...</a><br /></td></tr>
<tr class="separator:ga987cf019e19f63f5a470f59588dd0d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:gad5b7628164ce0e0c14232abfe3150ce4"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad5b7628164ce0e0c14232abfe3150ce4">dataTag_</a></td></tr>
<tr class="memdesc:gad5b7628164ce0e0c14232abfe3150ce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A character used to identify this class when reading and writing tagged data in text format.  <a href="group__census.html#gad5b7628164ce0e0c14232abfe3150ce4">More...</a><br /></td></tr>
<tr class="separator:gad5b7628164ce0e0c14232abfe3150ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:gae8f9493c7d14a63ed912bf069b4a11ea"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae8f9493c7d14a63ed912bf069b4a11ea">dataTag</a> () const override</td></tr>
<tr class="memdesc:gae8f9493c7d14a63ed912bf069b4a11ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the character used to identify this class when storing tagged data in text format.  <a href="group__census.html#gae8f9493c7d14a63ed912bf069b4a11ea">More...</a><br /></td></tr>
<tr class="separator:gae8f9493c7d14a63ed912bf069b4a11ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68af81af372f748e01f1cea1fe262d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga68af81af372f748e01f1cea1fe262d55">findEdgeClass</a> (int edgeID) const</td></tr>
<tr class="memdesc:ga68af81af372f748e01f1cea1fe262d55"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="group__census.html#ga68af81af372f748e01f1cea1fe262d55">More...</a><br /></td></tr>
<tr class="separator:ga68af81af372f748e01f1cea1fe262d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6b44b688c1947d87b6b11f6f34fa42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0d6b44b688c1947d87b6b11f6f34fa42">findEdgeClass</a> (int edgeID, char &amp;twisted) const</td></tr>
<tr class="memdesc:ga0d6b44b688c1947d87b6b11f6f34fa42"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the representative of the equivalence class containing the given tetrahedron edge.  <a href="group__census.html#ga0d6b44b688c1947d87b6b11f6f34fa42">More...</a><br /></td></tr>
<tr class="separator:ga0d6b44b688c1947d87b6b11f6f34fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac275f880cb36e0c4b8c7e9222329960f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac275f880cb36e0c4b8c7e9222329960f">mergeVertexClasses</a> ()</td></tr>
<tr class="memdesc:gac275f880cb36e0c4b8c7e9222329960f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron vertices as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#gac275f880cb36e0c4b8c7e9222329960f">More...</a><br /></td></tr>
<tr class="separator:gac275f880cb36e0c4b8c7e9222329960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933487c0bfbb7553b1a29aa52d9eb498"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga933487c0bfbb7553b1a29aa52d9eb498">mergeEdgeClasses</a> ()</td></tr>
<tr class="memdesc:ga933487c0bfbb7553b1a29aa52d9eb498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge the classes of tetrahedron edges as required by the new gluing made at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga933487c0bfbb7553b1a29aa52d9eb498">More...</a><br /></td></tr>
<tr class="separator:ga933487c0bfbb7553b1a29aa52d9eb498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe76d64503d19198a82fab9fbba1285e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gafe76d64503d19198a82fab9fbba1285e">splitVertexClasses</a> ()</td></tr>
<tr class="memdesc:gafe76d64503d19198a82fab9fbba1285e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron vertices to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#gafe76d64503d19198a82fab9fbba1285e">More...</a><br /></td></tr>
<tr class="separator:gafe76d64503d19198a82fab9fbba1285e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762df77fdee5bb5202e5dc2578a45139"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga762df77fdee5bb5202e5dc2578a45139">splitEdgeClasses</a> ()</td></tr>
<tr class="memdesc:ga762df77fdee5bb5202e5dc2578a45139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the classes of tetrahedron edges to mirror the undoing of the gluing at stage <em>orderElt</em> of the search.  <a href="group__census.html#ga762df77fdee5bb5202e5dc2578a45139">More...</a><br /></td></tr>
<tr class="separator:ga762df77fdee5bb5202e5dc2578a45139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2d97b7e726fed0edfa487de17fe3895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad2d97b7e726fed0edfa487de17fe3895">vtxBdryJoin</a> (int vertexID, char end, int adjVertexID, char twist)</td></tr>
<tr class="memdesc:gad2d97b7e726fed0edfa487de17fe3895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the boundary edges supplied by the vertex linking triangles for the two given tetrahedron vertices should be marked as adjacent.  <a href="group__census.html#gad2d97b7e726fed0edfa487de17fe3895">More...</a><br /></td></tr>
<tr class="separator:gad2d97b7e726fed0edfa487de17fe3895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31979e14cdda4468520bafc0b5aa3b04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga31979e14cdda4468520bafc0b5aa3b04">vtxBdryFixAdj</a> (int vertexID)</td></tr>
<tr class="memdesc:ga31979e14cdda4468520bafc0b5aa3b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the <em>bdryNext</em> and <em>bdryTwist</em> arrays for nearby tetrahedron vertices, to ensure that these arrays are consistent with the <em>bdryNext</em> and <em>bdryTwist</em> arrays stored with the given vertex.  <a href="group__census.html#ga31979e14cdda4468520bafc0b5aa3b04">More...</a><br /></td></tr>
<tr class="separator:ga31979e14cdda4468520bafc0b5aa3b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac088ddb578c020c3c9e806427de158aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac088ddb578c020c3c9e806427de158aa">vtxBdryBackup</a> (int vertexID)</td></tr>
<tr class="memdesc:gac088ddb578c020c3c9e806427de158aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNext</em> and <em>bdryTwist</em> arrays to the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays for the given tetrahedron vertex.  <a href="group__census.html#gac088ddb578c020c3c9e806427de158aa">More...</a><br /></td></tr>
<tr class="separator:gac088ddb578c020c3c9e806427de158aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ffbb57a869d61b80f4c75ea6e4776d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga3ffbb57a869d61b80f4c75ea6e4776d5">vtxBdryRestore</a> (int vertexID)</td></tr>
<tr class="memdesc:ga3ffbb57a869d61b80f4c75ea6e4776d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the <em>bdryNextOld</em> and <em>bdryTwistOld</em> arrays to the <em>bdryNext</em> and <em>bdryTwist</em> arrays for the given tetrahedron vertex.  <a href="group__census.html#ga3ffbb57a869d61b80f4c75ea6e4776d5">More...</a><br /></td></tr>
<tr class="separator:ga3ffbb57a869d61b80f4c75ea6e4776d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95813159f052c7d9651006074a518dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga95813159f052c7d9651006074a518dc4">vtxBdryNext</a> (int vertexID, int tet, int vertex, int bdryFace, int next[2], char twist[2])</td></tr>
<tr class="memdesc:ga95813159f052c7d9651006074a518dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assuming the given edge of the vertex linking triangle for the given tetrahedron vertex lies on the boundary of the vertex link, this routine identifies the adjacent boundary edges of the vertex link in each direction.  <a href="group__census.html#ga95813159f052c7d9651006074a518dc4">More...</a><br /></td></tr>
<tr class="separator:ga95813159f052c7d9651006074a518dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e9cf39a6be337c436128f7a7ff6db7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab1e9cf39a6be337c436128f7a7ff6db7">vtxBdryLength1</a> (int vertexID)</td></tr>
<tr class="memdesc:gab1e9cf39a6be337c436128f7a7ff6db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether one of the edges of the vertex linking triangle for the given tetrahedron vertex in fact forms an entire one-edge boundary component of the overall vertex link.  <a href="group__census.html#gab1e9cf39a6be337c436128f7a7ff6db7">More...</a><br /></td></tr>
<tr class="separator:gab1e9cf39a6be337c436128f7a7ff6db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac20ad95521261ade949844c625197ad3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac20ad95521261ade949844c625197ad3">vtxBdryLength2</a> (int vertexID1, int vertexID2)</td></tr>
<tr class="memdesc:gac20ad95521261ade949844c625197ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether edges of the vertex linking triangles for each of the given tetrahedron vertices combine to form an entire two-edge boundary component of the overall vertex link, with one edge from each triangle.  <a href="group__census.html#gac20ad95521261ade949844c625197ad3">More...</a><br /></td></tr>
<tr class="separator:gac20ad95521261ade949844c625197ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f48b181c140153c25b69014ec3c368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga47f48b181c140153c25b69014ec3c368">vtxBdryConsistencyCheck</a> ()</td></tr>
<tr class="memdesc:ga47f48b181c140153c25b69014ec3c368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a number of tests on all tetrahedron vertices to locate consistency errors in the <em>bdryEdges</em>, <em>bdryNext</em> and <em>bdryTwist</em> members of the <a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html" title="A structure used to track equivalence classes of tetrahedron vertices as the gluing permutation set i...">TetVertexState</a> class.  <a href="group__census.html#ga47f48b181c140153c25b69014ec3c368">More...</a><br /></td></tr>
<tr class="separator:ga47f48b181c140153c25b69014ec3c368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43099ebf5e634f11439eb12be6d9b4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae43099ebf5e634f11439eb12be6d9b4b">vtxBdryDump</a> (std::ostream &amp;out)</td></tr>
<tr class="memdesc:gae43099ebf5e634f11439eb12be6d9b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dumps a summary of <em>bdryNext</em>, <em>bdryTwist</em> and <em>bdryEdges</em> for every vertex of every tetrahedron to the given output stream.  <a href="group__census.html#gae43099ebf5e634f11439eb12be6d9b4b">More...</a><br /></td></tr>
<tr class="separator:gae43099ebf5e634f11439eb12be6d9b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8c7e6c6d0cce1efb0335a09ae6bdcd1f">isCanonical</a> () const</td></tr>
<tr class="memdesc:ga8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the current set of gluing permutations with its preimage under each automorphism of the underlying face pairing, in order to see whether the current set is in canonical form (i.e., is lexicographically smallest).  <a href="group__census.html#ga8c7e6c6d0cce1efb0335a09ae6bdcd1f">More...</a><br /></td></tr>
<tr class="separator:ga8c7e6c6d0cce1efb0335a09ae6bdcd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941c419f7a3a7d86e850a8d32a6bdd86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga941c419f7a3a7d86e850a8d32a6bdd86">badEdgeLink</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face) const</td></tr>
<tr class="memdesc:ga941c419f7a3a7d86e850a8d32a6bdd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with an edge identified with itself in reverse.  <a href="group__census.html#ga941c419f7a3a7d86e850a8d32a6bdd86">More...</a><br /></td></tr>
<tr class="separator:ga941c419f7a3a7d86e850a8d32a6bdd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f4089dd2a85f436724655825f082b81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9f4089dd2a85f436724655825f082b81">lowDegreeEdge</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; &amp;face, bool testDegree12, bool testDegree3) const</td></tr>
<tr class="memdesc:ga9f4089dd2a85f436724655825f082b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the permutations already constructed model a triangulation with a low degree edge.  <a href="group__census.html#ga9f4089dd2a85f436724655825f082b81">More...</a><br /></td></tr>
<tr class="separator:ga9f4089dd2a85f436724655825f082b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f6711eb803742af936b68a0680888f"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga28f6711eb803742af936b68a0680888f">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>)</td></tr>
<tr class="memdesc:ga28f6711eb803742af936b68a0680888f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#ga28f6711eb803742af936b68a0680888f">More...</a><br /></td></tr>
<tr class="separator:ga28f6711eb803742af936b68a0680888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memItemLeft" align="right" valign="top">int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa1eb17b2d09a1fc64176b5eda1e057e4">permIndex</a> (unsigned simp, unsigned facet)</td></tr>
<tr class="memdesc:gaa1eb17b2d09a1fc64176b5eda1e057e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#gaa1eb17b2d09a1fc64176b5eda1e057e4">More...</a><br /></td></tr>
<tr class="separator:gaa1eb17b2d09a1fc64176b5eda1e057e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb19364415afbf88d139ee26d5c6d2af"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaeb19364415afbf88d139ee26d5c6d2af">permIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>) const</td></tr>
<tr class="memdesc:gaeb19364415afbf88d139ee26d5c6d2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#gaeb19364415afbf88d139ee26d5c6d2af">More...</a><br /></td></tr>
<tr class="separator:gaeb19364415afbf88d139ee26d5c6d2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d9aa920a0554ac7a26b2baaab25bf25"><td class="memItemLeft" align="right" valign="top">const int &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8d9aa920a0554ac7a26b2baaab25bf25">permIndex</a> (unsigned simp, unsigned facet) const</td></tr>
<tr class="memdesc:ga8d9aa920a0554ac7a26b2baaab25bf25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner.  <a href="group__census.html#ga8d9aa920a0554ac7a26b2baaab25bf25">More...</a><br /></td></tr>
<tr class="separator:ga8d9aa920a0554ac7a26b2baaab25bf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8da0ad1c66af05624ecdd711785e702c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8da0ad1c66af05624ecdd711785e702c">gluingToIndex</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:ga8da0ad1c66af05624ecdd711785e702c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="group__census.html#ga8da0ad1c66af05624ecdd711785e702c">More...</a><br /></td></tr>
<tr class="separator:ga8da0ad1c66af05624ecdd711785e702c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga254d849ef372fc0da9c02cf4b3a74a83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga254d849ef372fc0da9c02cf4b3a74a83">gluingToIndex</a> (unsigned simp, unsigned facet, const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;gluing) const</td></tr>
<tr class="memdesc:ga254d849ef372fc0da9c02cf4b3a74a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner.  <a href="group__census.html#ga254d849ef372fc0da9c02cf4b3a74a83">More...</a><br /></td></tr>
<tr class="separator:ga254d849ef372fc0da9c02cf4b3a74a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47d0241ebd3fc55fd001b4ac34ccbc96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga47d0241ebd3fc55fd001b4ac34ccbc96">indexToGluing</a> (const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;<a class="el" href="namespaceregina.html#adcfb69a69d63e77fb947c071b0b65cb8">source</a>, int index) const</td></tr>
<tr class="memdesc:ga47d0241ebd3fc55fd001b4ac34ccbc96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array Perm&lt;dim+1&gt;::Sn_1.  <a href="group__census.html#ga47d0241ebd3fc55fd001b4ac34ccbc96">More...</a><br /></td></tr>
<tr class="separator:ga47d0241ebd3fc55fd001b4ac34ccbc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7326ddb0a6e4f78fbc25a9a30a4a5bc3">indexToGluing</a> (unsigned simp, unsigned facet, int index) const</td></tr>
<tr class="memdesc:ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gluing permutation from the given facet to its partner that corresponds to the given index into array Perm&lt;dim+1&gt;::Sn_1.  <a href="group__census.html#ga7326ddb0a6e4f78fbc25a9a30a4a5bc3">More...</a><br /></td></tr>
<tr class="separator:ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ga7aea8813a101710e3650e36e564ee1c0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga7aea8813a101710e3650e36e564ee1c0">nVertexClasses</a></td></tr>
<tr class="memdesc:ga7aea8813a101710e3650e36e564ee1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron vertices.  <a href="group__census.html#ga7aea8813a101710e3650e36e564ee1c0">More...</a><br /></td></tr>
<tr class="separator:ga7aea8813a101710e3650e36e564ee1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae799bb54f485575692d7d35858b2dd8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1CompactSearcher_1_1TetVertexState.html">TetVertexState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae799bb54f485575692d7d35858b2dd8f">vertexState</a></td></tr>
<tr class="memdesc:gae799bb54f485575692d7d35858b2dd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron vertices.  <a href="group__census.html#gae799bb54f485575692d7d35858b2dd8f">More...</a><br /></td></tr>
<tr class="separator:gae799bb54f485575692d7d35858b2dd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d401e8806d12fd2274bfd24e97d292"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga42d401e8806d12fd2274bfd24e97d292">vertexStateChanged</a></td></tr>
<tr class="memdesc:ga42d401e8806d12fd2274bfd24e97d292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the vertexState[] array has been updated over time.  <a href="group__census.html#ga42d401e8806d12fd2274bfd24e97d292">More...</a><br /></td></tr>
<tr class="separator:ga42d401e8806d12fd2274bfd24e97d292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga395f2feb52dfc9d7d5e3506ec8bbff14"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga395f2feb52dfc9d7d5e3506ec8bbff14">nEdgeClasses</a></td></tr>
<tr class="memdesc:ga395f2feb52dfc9d7d5e3506ec8bbff14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of equivalence classes of identified tetrahedron edges.  <a href="group__census.html#ga395f2feb52dfc9d7d5e3506ec8bbff14">More...</a><br /></td></tr>
<tr class="separator:ga395f2feb52dfc9d7d5e3506ec8bbff14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dbdcdd9bcbab1d2686808a2d7c2d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1CompactSearcher_1_1TetEdgeState.html">TetEdgeState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gab2dbdcdd9bcbab1d2686808a2d7c2d50">edgeState</a></td></tr>
<tr class="memdesc:gab2dbdcdd9bcbab1d2686808a2d7c2d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for tracking equivalence classes of identified tetrahedron edges.  <a href="group__census.html#gab2dbdcdd9bcbab1d2686808a2d7c2d50">More...</a><br /></td></tr>
<tr class="separator:gab2dbdcdd9bcbab1d2686808a2d7c2d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1feea9d0c86a4582d091745b8883a18"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaa1feea9d0c86a4582d091745b8883a18">edgeStateChanged</a></td></tr>
<tr class="memdesc:gaa1feea9d0c86a4582d091745b8883a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the way in which the edgeState[] array has been updated over time.  <a href="group__census.html#gaa1feea9d0c86a4582d091745b8883a18">More...</a><br /></td></tr>
<tr class="separator:gaa1feea9d0c86a4582d091745b8883a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad99ec414c677a67e55ed8588316fcf88"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; 3 &gt;::IsoList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad99ec414c677a67e55ed8588316fcf88">autos_</a></td></tr>
<tr class="memdesc:gad99ec414c677a67e55ed8588316fcf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of isomorphisms that define equivalence of gluing permutation sets.  <a href="group__census.html#gad99ec414c677a67e55ed8588316fcf88">More...</a><br /></td></tr>
<tr class="separator:gad99ec414c677a67e55ed8588316fcf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924106126b7edca7b1b337d52abad3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga924106126b7edca7b1b337d52abad3c2">autosNew</a></td></tr>
<tr class="memdesc:ga924106126b7edca7b1b337d52abad3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did we create the isomorphism list autos_ ourselves (in which case we must destroy it also)?  <a href="group__census.html#ga924106126b7edca7b1b337d52abad3c2">More...</a><br /></td></tr>
<tr class="separator:ga924106126b7edca7b1b337d52abad3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7086cef35b30a1e10385ec3f12bce31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gae7086cef35b30a1e10385ec3f12bce31">orientableOnly_</a></td></tr>
<tr class="memdesc:gae7086cef35b30a1e10385ec3f12bce31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to orientable triangulations?  <a href="group__census.html#gae7086cef35b30a1e10385ec3f12bce31">More...</a><br /></td></tr>
<tr class="separator:gae7086cef35b30a1e10385ec3f12bce31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107d4ea96e2006fce01b49508221e604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga107d4ea96e2006fce01b49508221e604">finiteOnly_</a></td></tr>
<tr class="memdesc:ga107d4ea96e2006fce01b49508221e604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are we only searching for gluing permutations that correspond to finite triangulations?  <a href="group__census.html#ga107d4ea96e2006fce01b49508221e604">More...</a><br /></td></tr>
<tr class="separator:ga107d4ea96e2006fce01b49508221e604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59856e878dab0a1eedd13521a436f7e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga59856e878dab0a1eedd13521a436f7e1">whichPurge_</a></td></tr>
<tr class="memdesc:ga59856e878dab0a1eedd13521a436f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are there any types of triangulation that we may optionally avoid constructing? This should be a bitwise OR of constants from the PurgeFlags enumeration.  <a href="group__census.html#ga59856e878dab0a1eedd13521a436f7e1">More...</a><br /></td></tr>
<tr class="separator:ga59856e878dab0a1eedd13521a436f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24e6601298a3b8e111eaebb30223a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1GluingPermSearcher.html">GluingPermSearcher</a>&lt; 3 &gt;::<a class="el" href="group__census.html#ga40c89ca6699633f872a9611273995730">Use</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac24e6601298a3b8e111eaebb30223a0e">use_</a></td></tr>
<tr class="memdesc:gac24e6601298a3b8e111eaebb30223a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to call each time a gluing permutation set is found during the search.  <a href="group__census.html#gac24e6601298a3b8e111eaebb30223a0e">More...</a><br /></td></tr>
<tr class="separator:gac24e6601298a3b8e111eaebb30223a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5f9d4ba646538829c4c1fafe4bd1ccb"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaf5f9d4ba646538829c4c1fafe4bd1ccb">useArgs_</a></td></tr>
<tr class="memdesc:gaf5f9d4ba646538829c4c1fafe4bd1ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional user-supplied data to be passed as the second argument to the <em>use_</em> routine.  <a href="group__census.html#gaf5f9d4ba646538829c4c1fafe4bd1ccb">More...</a><br /></td></tr>
<tr class="separator:gaf5f9d4ba646538829c4c1fafe4bd1ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ef778b520739058cf77d70963d7ab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga46ef778b520739058cf77d70963d7ab6">started</a></td></tr>
<tr class="memdesc:ga46ef778b520739058cf77d70963d7ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the search started yet? This helps distinguish between a new search and the resumption of a partially completed search.  <a href="group__census.html#ga46ef778b520739058cf77d70963d7ab6">More...</a><br /></td></tr>
<tr class="separator:ga46ef778b520739058cf77d70963d7ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07986d0a577e24601d762c07c43226eb"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga07986d0a577e24601d762c07c43226eb">orientation</a></td></tr>
<tr class="memdesc:ga07986d0a577e24601d762c07c43226eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the orientation of each tetrahedron in the underlying triangulation.  <a href="group__census.html#ga07986d0a577e24601d762c07c43226eb">More...</a><br /></td></tr>
<tr class="separator:ga07986d0a577e24601d762c07c43226eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8738eee160530cfdcf10a05f626212da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga8738eee160530cfdcf10a05f626212da">order</a></td></tr>
<tr class="memdesc:ga8738eee160530cfdcf10a05f626212da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the order in which gluing permutations are assigned to faces.  <a href="group__census.html#ga8738eee160530cfdcf10a05f626212da">More...</a><br /></td></tr>
<tr class="separator:ga8738eee160530cfdcf10a05f626212da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2208e4c544e9b5fd2e2d9ff317b94575"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga2208e4c544e9b5fd2e2d9ff317b94575">orderSize</a></td></tr>
<tr class="memdesc:ga2208e4c544e9b5fd2e2d9ff317b94575"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of edges in the face pairing graph, i.e., the number of elements of interest in the order[] array.  <a href="group__census.html#ga2208e4c544e9b5fd2e2d9ff317b94575">More...</a><br /></td></tr>
<tr class="separator:ga2208e4c544e9b5fd2e2d9ff317b94575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db9ca62cfe5caf9ca9e357121912cb5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga9db9ca62cfe5caf9ca9e357121912cb5">orderElt</a></td></tr>
<tr class="memdesc:ga9db9ca62cfe5caf9ca9e357121912cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks which element of order[] we are currently examining at this stage of the search.  <a href="group__census.html#ga9db9ca62cfe5caf9ca9e357121912cb5">More...</a><br /></td></tr>
<tr class="separator:ga9db9ca62cfe5caf9ca9e357121912cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9fb5bb6ec20f8822927d49c100738e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gad9fb5bb6ec20f8822927d49c100738e5">pairing_</a></td></tr>
<tr class="memdesc:gad9fb5bb6ec20f8822927d49c100738e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The facet pairing that this permutation set complements.  <a href="group__census.html#gad9fb5bb6ec20f8822927d49c100738e5">More...</a><br /></td></tr>
<tr class="separator:gad9fb5bb6ec20f8822927d49c100738e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae038d32acaf9c1fc1f086dc8a344417"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaae038d32acaf9c1fc1f086dc8a344417">permIndices_</a></td></tr>
<tr class="memdesc:gaae038d32acaf9c1fc1f086dc8a344417"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index into array Perm&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner.  <a href="group__census.html#gaae038d32acaf9c1fc1f086dc8a344417">More...</a><br /></td></tr>
<tr class="separator:gaae038d32acaf9c1fc1f086dc8a344417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df91f50200ff5d6e76ede8c123e8ce6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga4df91f50200ff5d6e76ede8c123e8ce6">inputError_</a></td></tr>
<tr class="memdesc:ga4df91f50200ff5d6e76ede8c123e8ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has an error occurred during construction from an input stream?  <a href="group__census.html#ga4df91f50200ff5d6e76ede8c123e8ce6">More...</a><br /></td></tr>
<tr class="separator:ga4df91f50200ff5d6e76ede8c123e8ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:gac363812100d31dbed52621e0ac4d4d66"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gac363812100d31dbed52621e0ac4d4d66">VLINK_CLOSED</a></td></tr>
<tr class="memdesc:gac363812100d31dbed52621e0ac4d4d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been closed off (i.e., the link has no remaining boundary edges).  <a href="group__census.html#gac363812100d31dbed52621e0ac4d4d66">More...</a><br /></td></tr>
<tr class="separator:gac363812100d31dbed52621e0ac4d4d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d604d18112b6385930665f88e9b0e6b"><td class="memItemLeft" align="right" valign="top">static const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga0d604d18112b6385930665f88e9b0e6b">VLINK_NON_SPHERE</a></td></tr>
<tr class="memdesc:ga0d604d18112b6385930665f88e9b0e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a vertex link has been made into something other than a 2-sphere with zero or more punctures.  <a href="group__census.html#ga0d604d18112b6385930665f88e9b0e6b">More...</a><br /></td></tr>
<tr class="separator:ga0d604d18112b6385930665f88e9b0e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea2e93753783fd73caa1805e68062d9"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#gaaea2e93753783fd73caa1805e68062d9">vertexLinkNextFace</a> [4][4]</td></tr>
<tr class="memdesc:gaaea2e93753783fd73caa1805e68062d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maintains an ordering of the three tetrahedron faces surrounding a vertex in a tetrahedron.  <a href="group__census.html#gaaea2e93753783fd73caa1805e68062d9">More...</a><br /></td></tr>
<tr class="separator:gaaea2e93753783fd73caa1805e68062d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b498e1004898fe021328583c9a397ad"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__census.html#ga2b498e1004898fe021328583c9a397ad">vertexLinkPrevFace</a> [4][4]</td></tr>
<tr class="memdesc:ga2b498e1004898fe021328583c9a397ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides backwards links for the ordering described by <em>vertexLinkNextFace</em>.  <a href="group__census.html#ga2b498e1004898fe021328583c9a397ad">More...</a><br /></td></tr>
<tr class="separator:ga2b498e1004898fe021328583c9a397ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A gluing permutation search class that offers a specialised search algorithm for when only compact (finite) 3-manifold triangulations are required. </p>
<p>The only constraints placed upon a triangulation are that every edge must be valid (i.e., not identified with itself in reverse), and that the link of every vertex must be a disk or a sphere.</p>
<p>The search algorithm uses modified union-find structures on both edge and vertex equivalence classes to prune searches that are guaranteed to lead to bad edge or vertex links. For details see "Enumeration of non-orientable 3-manifolds using face-pairing graphs and
union-find", Benjamin A. Burton, Discrete Comput. Geom. 38 (2007), no. 3, 527&ndash;571; and "Detecting genus in vertex links for the fast enumeration
of 3-manifold triangulations", Benjamin A. Burton, in "ISSAC 2011: Proceedings of the 36th International Symposium on Symbolic and Algebraic Computation", ACM, 2011, pp. 59-66.</p>
<p>No additional unwanted triangulations will be produced by this search (in contrast to other search classes, such as <a class="el" href="classregina_1_1ClosedPrimeMinSearcher.html" title="A gluing permutation search class that offers a specialised search algorithm for when (i) only closed...">ClosedPrimeMinSearcher</a>). That is, <em>only</em> compact 3-manifolds will be produced.</p>
<dl class="section user"><dt>Python</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="gaceabd6f42214d77e7cb132e2a37d790f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceabd6f42214d77e7cb132e2a37d790f">&#9670;&nbsp;</a></span>facetPairing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt; dim &gt; * <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::facetPairing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific pairing of simplex facets that this set of gluing permutations complements. </p>
<dl class="section return"><dt>Returns</dt><dd>the corresponding simplex facet pairing. </dd></dl>

</div>
</div>
<a id="ga6efb577f8be677717e20624a75037de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6efb577f8be677717e20624a75037de6">&#9670;&nbsp;</a></span>gluingPerm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements.">facetPairing()</a>). </dd>
<dd>
The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a id="ga8621f1370a90132ec44b032c7926066f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8621f1370a90132ec44b032c7926066f">&#9670;&nbsp;</a></span>gluingPerm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingPerm </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation associated with the given simplex facet. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is actually paired with some other facet in the underlying pairwise matching (see routine <a class="el" href="group__census.html#gaceabd6f42214d77e7cb132e2a37d790f" title="Returns the specific pairing of simplex facets that this set of gluing permutations complements.">facetPairing()</a>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the associated gluing permutation. </dd></dl>

</div>
</div>
<a id="ga8da0ad1c66af05624ecdd711785e702c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da0ad1c66af05624ecdd711785e702c">&#9670;&nbsp;</a></span>gluingToIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a id="ga254d849ef372fc0da9c02cf4b3a74a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga254d849ef372fc0da9c02cf4b3a74a83">&#9670;&nbsp;</a></span>gluingToIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::gluingToIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the given facet to its partner. </p>
<p>This need not be the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet. </dd>
<dd>
If the given simplex facet and its partner are facets <em>x</em> and <em>y</em> of their respective simplices, then the given gluing permutation maps <em>x</em> to <em>y</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">gluing</td><td>a possible gluing permutation from the given simplex facet to its partner according to the underlying facet pairing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation; this will be between 0 and <em>dim!-1</em> inclusive. </dd></dl>

</div>
</div>
<a id="ga47d0241ebd3fc55fd001b4ac34ccbc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d0241ebd3fc55fd001b4ac34ccbc96">&#9670;&nbsp;</a></span>indexToGluing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a id="ga7326ddb0a6e4f78fbc25a9a30a4a5bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7326ddb0a6e4f78fbc25a9a30a4a5bc3">&#9670;&nbsp;</a></span>indexToGluing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::indexToGluing </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the gluing permutation from the given facet to its partner that corresponds to the given index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </p>
<p>This index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 need not be the index that is currently stored for the given facet.</p>
<p>Indices into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 are stored internally in the array <em>permIndices_</em>. Full gluing permutations on the other hand are used in constructing triangulations.</p>
<p>If the given simplex facet and its partner according to the underlying facet pairing are facets <em>x</em> and <em>y</em> of their respective simplices, then the resulting gluing permutation will map <em>x</em> to <em>y</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given simplex facet has a partner according to the underlying facet pairing, i.e., is not a boundary facet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation; this must be strictly less than the total number of simplices under consideration. </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">index</td><td>an index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1; this must be between 0 and <em>dim!-1</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gluing permutation corresponding to the given index into <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1. </dd></dl>

</div>
</div>
<a id="ga1a0d16509c016c37f87b239b77f1c8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0d16509c016c37f87b239b77f1c8f1">&#9670;&nbsp;</a></span>inputError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Was an error found during construction from an input stream? </p>
<p>This routine returns <code>true</code> if an input stream constructor was used to create this object but the data in the input stream was invalid or incorrectly formatted.</p>
<p>If a different constructor was called (i.e., no input stream was used), then this routine will always return <code>false</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an error occurred during construction from an input stream, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga28f6711eb803742af936b68a0680888f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f6711eb803742af936b68a0680888f">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="gaeb19364415afbf88d139ee26d5c6d2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb19364415afbf88d139ee26d5c6d2af">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1FacetSpec.html">FacetSpec</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet is a real simplex facet (not boundary, before-the-start or past-the-end).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>the simplex facet under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="gaa1eb17b2d09a1fc64176b5eda1e057e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1eb17b2d09a1fc64176b5eda1e057e4">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="ga8d9aa920a0554ac7a26b2baaab25bf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d9aa920a0554ac7a26b2baaab25bf25">&#9670;&nbsp;</a></span>permIndex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int &amp; <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>simp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>facet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how the the given facet is joined to its partner. </p>
<p>Note that this permutation is not a gluing permutation as such, but rather a permutation of 0,...,<em>dim-1</em> only. For a real facet gluing permutation, see routine <a class="el" href="group__census.html#ga6efb577f8be677717e20624a75037de6" title="Returns the gluing permutation associated with the given simplex facet.">gluingPerm()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simp</td><td>the simplex under investigation (this must be strictly less than the total number of simplices under consideration). </td></tr>
    <tr><td class="paramname">facet</td><td>the facet of the given simplex under investigation (between 0 and <em>dim</em> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the corresponding array index. </dd></dl>

</div>
</div>
<a id="ga052f8788995d20de83982daedffa9868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052f8788995d20de83982daedffa9868">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of simplices under consideration. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of simplices under consideration. </dd></dl>

</div>
</div>
<a id="ga48d4e4a6f2423844a747d921e1e8459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48d4e4a6f2423844a747d921e1e8459c">&#9670;&nbsp;</a></span>triangulate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created triangulation as modelled by this set of gluing permutations and the associated simplex facet pairing. </p>
<p>Each matched pair of facets and their associated permutations will be realised as two simplex facets in the triangulation glued together with the corresponding gluing permutation. Each unmatched facet will be realised as a boundary facet in the triangulation.</p>
<p>It is the responsibility of the caller of this routine to delete this triangulation once it is no longer required.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly created triangulation modelled by this structure. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ga4df91f50200ff5d6e76ede8c123e8ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df91f50200ff5d6e76ede8c123e8ce6">&#9670;&nbsp;</a></span>inputError_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::inputError_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has an error occurred during construction from an input stream? </p>

</div>
</div>
<a id="gad9fb5bb6ec20f8822927d49c100738e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9fb5bb6ec20f8822927d49c100738e5">&#9670;&nbsp;</a></span>pairing_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1FacetPairing.html">FacetPairing</a>&lt;dim&gt;* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::pairing_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The facet pairing that this permutation set complements. </p>
<p>This is guaranteed to be the minimal representative of its facet pairing isomorphism class. </p>

</div>
</div>
<a id="gaae038d32acaf9c1fc1f086dc8a344417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae038d32acaf9c1fc1f086dc8a344417">&#9670;&nbsp;</a></span>permIndices_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classregina_1_1GluingPerms.html">regina::GluingPerms</a>&lt; dim &gt;::permIndices_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The index into array <a class="el" href="classregina_1_1Perm.html" title="Represents a permutation of {0,1,...,n-1}.">Perm</a>&lt;dim+1&gt;::Sn_1 describing how each simplex facet is glued to its partner. </p>
<p>Note that this is not a gluing permutation as such but rather a permutation of 0,...,<em>dim-1</em> only (see the routines <a class="el" href="group__census.html#ga8da0ad1c66af05624ecdd711785e702c" title="Returns the index into array Perm&lt;dim+1&gt;::Sn_1 corresponding to the given gluing permutation from the...">gluingToIndex()</a> and <a class="el" href="group__census.html#ga47d0241ebd3fc55fd001b4ac34ccbc96" title="Returns the gluing permutation from the given facet to its partner that corresponds to the given inde...">indexToGluing()</a> for conversions). If a permutation has not yet been selected (e.g., if this permutation set is still under construction) then this index is -1. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>census/<a class="el" href="gluingpermsearcher3_8h.html">gluingpermsearcher3.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
