<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Normal Surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Normal Surfaces</div>  </div>
</div><!--header-->
<div class="contents">

<p>Normal surfaces in 3-manifold triangulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single normal disc in a normal surface.  <a href="structregina_1_1DiscSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetTet.html">regina::DiscSetTet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of normal discs inside a single tetrahedron.  <a href="classregina_1_1DiscSetTet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data of type <code>T</code> for every normal disc inside a single tetrahedron.  <a href="classregina_1_1DiscSetTetData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetSurface.html">regina::DiscSetSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the set of all normal discs forming a normal surface.  <a href="classregina_1_1DiscSetSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data of type <code>T</code> for every normal disc within a particular normal surface.  <a href="classregina_1_1DiscSetSurfaceData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSpecIterator.html">regina::DiscSpecIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator used for running through all normal discs in a normal surface.  <a href="classregina_1_1DiscSpecIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1DiscSpecIterator_01_4.html">std::iterator_traits&lt; regina::DiscSpecIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1DiscType.html">regina::DiscType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a single normal or almost normal disc type within a triangulation.  <a href="structregina_1_1DiscType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix&lt; T, ring &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of elements of the given type <em>T</em>.  <a href="classregina_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NormalInfo.html">regina::NormalInfo&lt; coordType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular normal coordinate system.  <a href="structregina_1_1NormalInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html">regina::NormalSurfaceVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the vector of a single normal surface in a 3-manifold.  <a href="classregina_1_1NormalSurfaceVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html">regina::NormalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single normal surface in a 3-manifold.  <a href="classregina_1_1NormalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html">regina::NormalSurfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a collection of normal surfaces in a 3-manifold.  <a href="classregina_1_1NormalSurfaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">regina::NormalSurfaces::VectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional iterator that runs through the raw vectors for surfaces in this list.  <a href="classregina_1_1NormalSurfaces_1_1VectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">regina::NormalSurfaces::SurfaceInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output iterator used to insert surfaces into an <a class="el" href="classregina_1_1NormalSurfaces.html" title="A packet representing a collection of normal surfaces in a 3-manifold.">NormalSurfaces</a>.  <a href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorANStandard.html">regina::NSVectorANStandard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An almost normal surface vector using standard triangle-quad-oct coordinates.  <a href="classregina_1_1NSVectorANStandard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html">regina::NSVectorMirrored</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calculations.  <a href="classregina_1_1NSVectorMirrored.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html">regina::NSVectorOriented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using transversely oriented standard (triangle-quad) coordinates.  <a href="classregina_1_1NSVectorOriented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOrientedQuad.html">regina::NSVectorOrientedQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using transversely oriented quadrilateral coordinates.  <a href="classregina_1_1NSVectorOrientedQuad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuad.html">regina::NSVectorQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using quad coordinates.  <a href="classregina_1_1NSVectorQuad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuadClosed.html">regina::NSVectorQuadClosed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector for a normal surface in an ideal triangulation, expressed using quad coordinates and enumerated to include closed surfaces only.  <a href="classregina_1_1NSVectorQuadClosed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuadOct.html">regina::NSVectorQuadOct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An almost normal surface vector using quad-oct coordinates.  <a href="classregina_1_1NSVectorQuadOct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuadOctClosed.html">regina::NSVectorQuadOctClosed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector for an almost normal surface in an ideal triangulation, expressed using quad-oct coordinates and enumerated to include closed surfaces only.  <a href="classregina_1_1NSVectorQuadOctClosed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorStandard.html">regina::NSVectorStandard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using standard triangle-quad coordinates.  <a href="classregina_1_1NSVectorStandard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1PrismSpec.html">regina::PrismSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single triangular prism in a tetrahedron.  <a href="structregina_1_1PrismSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SurfaceFilterInfo.html">regina::SurfaceFilterInfo&lt; filterType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular type of normal surface filter.  <a href="structregina_1_1SurfaceFilterInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html">regina::SurfaceFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that accepts or rejects normal surfaces.  <a href="classregina_1_1SurfaceFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilterCombination.html">regina::SurfaceFilterCombination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that simply combines other filters.  <a href="classregina_1_1SurfaceFilterCombination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilterProperties.html">regina::SurfaceFilterProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that filters by basic properties of the normal surface.  <a href="classregina_1_1SurfaceFilterProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLFilterReader.html">regina::XMLFilterReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads the specific details of a normal surface filter.  <a href="classregina_1_1XMLFilterReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLFilterPacketReader.html">regina::XMLFilterPacketReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single surface filter.  <a href="classregina_1_1XMLFilterPacketReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLNormalSurfaceReader.html">regina::XMLNormalSurfaceReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads a single normal surface.  <a href="classregina_1_1XMLNormalSurfaceReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLNormalSurfacesReader.html">regina::XMLNormalSurfacesReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single normal surface list.  <a href="classregina_1_1XMLNormalSurfacesReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga28d182dc4885f0c9045d90e6e7c259ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga28d182dc4885f0c9045d90e6e7c259ad">REGINA_NORMAL_SURFACE_FLAVOUR</a>(class_,  id,  superclass)</td></tr>
<tr class="memdesc:ga28d182dc4885f0c9045d90e6e7c259ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a subclass of NormalSurfaceVector.  <a href="group__surfaces.html#ga28d182dc4885f0c9045d90e6e7c259ad">More...</a><br /></td></tr>
<tr class="separator:ga28d182dc4885f0c9045d90e6e7c259ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga665eac8de6a24d68bddbfa631bcca6c9">REGINA_SURFACE_FILTER</a>(class_,  id)</td></tr>
<tr class="memdesc:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a descendant class of SurfaceFilter.  <a href="group__surfaces.html#ga665eac8de6a24d68bddbfa631bcca6c9">More...</a><br /></td></tr>
<tr class="separator:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacc58cdaf40c4b2c896cbaf2900a3d048"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">regina::DiscSetTetData&lt; T &gt;::DataPtr</a></td></tr>
<tr class="memdesc:gacc58cdaf40c4b2c896cbaf2900a3d048"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that is a pointer to the data stored with each disc.  <a href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">More...</a><br /></td></tr>
<tr class="separator:gacc58cdaf40c4b2c896cbaf2900a3d048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7f09ab89f375885be57b35504903f9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaea7f09ab89f375885be57b35504903f9">regina::NDiscSpec</a></td></tr>
<tr class="memdesc:gaea7f09ab89f375885be57b35504903f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gaea7f09ab89f375885be57b35504903f9">More...</a><br /></td></tr>
<tr class="separator:gaea7f09ab89f375885be57b35504903f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318507a759439c77b9434bb6850bdc7c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga318507a759439c77b9434bb6850bdc7c">regina::NDiscSetTet</a></td></tr>
<tr class="memdesc:ga318507a759439c77b9434bb6850bdc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga318507a759439c77b9434bb6850bdc7c">More...</a><br /></td></tr>
<tr class="separator:ga318507a759439c77b9434bb6850bdc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga36ba5f508fd4dc4737a800ec796cf8e6">regina::NDiscSetTetData</a> = <a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga36ba5f508fd4dc4737a800ec796cf8e6">More...</a><br /></td></tr>
<tr class="separator:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014be930b28c03042f107405114409d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga014be930b28c03042f107405114409d4">regina::NDiscSetSurface</a></td></tr>
<tr class="memdesc:ga014be930b28c03042f107405114409d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga014be930b28c03042f107405114409d4">More...</a><br /></td></tr>
<tr class="separator:ga014be930b28c03042f107405114409d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3d65b1cb926fb791d18597bfac6ce3b7">regina::NDiscSetSurfaceData</a> = <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga3d65b1cb926fb791d18597bfac6ce3b7">More...</a><br /></td></tr>
<tr class="separator:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2176828f10a7955938e520514257106a"><td class="memItemLeft" align="right" valign="top"><a id="ga2176828f10a7955938e520514257106a"></a>
typedef long&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::difference_type</b></td></tr>
<tr class="separator:ga2176828f10a7955938e520514257106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae4b71e322d2f5e21ad31b1a7ef299b"><td class="memItemLeft" align="right" valign="top"><a id="ga7ae4b71e322d2f5e21ad31b1a7ef299b"></a>
typedef const <a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::value_type</b></td></tr>
<tr class="separator:ga7ae4b71e322d2f5e21ad31b1a7ef299b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13975adf31a154fb608ecf939cb7f8f7"><td class="memItemLeft" align="right" valign="top"><a id="ga13975adf31a154fb608ecf939cb7f8f7"></a>
typedef const <a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::pointer</b></td></tr>
<tr class="separator:ga13975adf31a154fb608ecf939cb7f8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d140fcc5cf9997c9dc650bb6b4cc8a9"><td class="memItemLeft" align="right" valign="top"><a id="ga0d140fcc5cf9997c9dc650bb6b4cc8a9"></a>
typedef const <a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::reference</b></td></tr>
<tr class="separator:ga0d140fcc5cf9997c9dc650bb6b4cc8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d3e968559a5f3b076013effa9bbded"><td class="memItemLeft" align="right" valign="top"><a id="ga89d3e968559a5f3b076013effa9bbded"></a>
typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:ga89d3e968559a5f3b076013effa9bbded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef87df7daabeda40a127d961caedfc0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1DiscType.html">DiscType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1ef87df7daabeda40a127d961caedfc0">regina::NDiscType</a></td></tr>
<tr class="memdesc:ga1ef87df7daabeda40a127d961caedfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga1ef87df7daabeda40a127d961caedfc0">More...</a><br /></td></tr>
<tr class="separator:ga1ef87df7daabeda40a127d961caedfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; <a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">regina::NormalList</a></td></tr>
<tr class="memdesc:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal surface lists.  <a href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">More...</a><br /></td></tr>
<tr class="separator:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239df7c1e704457d116029fc144dc473"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; <a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">regina::NormalAlg</a></td></tr>
<tr class="memdesc:ga239df7c1e704457d116029fc144dc473"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal surface lists.  <a href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">More...</a><br /></td></tr>
<tr class="separator:ga239df7c1e704457d116029fc144dc473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e1de8b765f5bcd733cb5fe28063326"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga76e1de8b765f5bcd733cb5fe28063326">regina::NNormalSurfaceVector</a></td></tr>
<tr class="memdesc:ga76e1de8b765f5bcd733cb5fe28063326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga76e1de8b765f5bcd733cb5fe28063326">More...</a><br /></td></tr>
<tr class="separator:ga76e1de8b765f5bcd733cb5fe28063326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b1bb46b52686165041bff4d0936eda"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae6b1bb46b52686165041bff4d0936eda">regina::NNormalSurface</a></td></tr>
<tr class="memdesc:gae6b1bb46b52686165041bff4d0936eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gae6b1bb46b52686165041bff4d0936eda">More...</a><br /></td></tr>
<tr class="separator:gae6b1bb46b52686165041bff4d0936eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1651d8ca85f9e04cd7c4345e7660be7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac1651d8ca85f9e04cd7c4345e7660be7">regina::NNormalSurfaceList</a></td></tr>
<tr class="memdesc:gac1651d8ca85f9e04cd7c4345e7660be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gac1651d8ca85f9e04cd7c4345e7660be7">More...</a><br /></td></tr>
<tr class="separator:gac1651d8ca85f9e04cd7c4345e7660be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8962f2fc5b8ed3347b8157097de22f0f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorANStandard.html">NSVectorANStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8962f2fc5b8ed3347b8157097de22f0f">regina::NNormalSurfaceVectorANStandard</a></td></tr>
<tr class="memdesc:ga8962f2fc5b8ed3347b8157097de22f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga8962f2fc5b8ed3347b8157097de22f0f">More...</a><br /></td></tr>
<tr class="separator:ga8962f2fc5b8ed3347b8157097de22f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a007103e8da63d8e29f79a642df29c5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorMirrored.html">NSVectorMirrored</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3a007103e8da63d8e29f79a642df29c5">regina::NNormalSurfaceVectorMirrored</a></td></tr>
<tr class="memdesc:ga3a007103e8da63d8e29f79a642df29c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga3a007103e8da63d8e29f79a642df29c5">More...</a><br /></td></tr>
<tr class="separator:ga3a007103e8da63d8e29f79a642df29c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3d48602a97ee3e83d4407f341e6455"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorOriented.html">NSVectorOriented</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5b3d48602a97ee3e83d4407f341e6455">regina::NNormalSurfaceVectorOriented</a></td></tr>
<tr class="memdesc:ga5b3d48602a97ee3e83d4407f341e6455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga5b3d48602a97ee3e83d4407f341e6455">More...</a><br /></td></tr>
<tr class="separator:ga5b3d48602a97ee3e83d4407f341e6455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde6a7ffe1f773fa073d0bc33e4744f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorOrientedQuad.html">NSVectorOrientedQuad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaffde6a7ffe1f773fa073d0bc33e4744f">regina::NNormalSurfaceVectorOrientedQuad</a></td></tr>
<tr class="memdesc:gaffde6a7ffe1f773fa073d0bc33e4744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gaffde6a7ffe1f773fa073d0bc33e4744f">More...</a><br /></td></tr>
<tr class="separator:gaffde6a7ffe1f773fa073d0bc33e4744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc7349b11544a8b8d78c61e19daedc4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorQuad.html">NSVectorQuad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6dc7349b11544a8b8d78c61e19daedc4">regina::NNormalSurfaceVectorQuad</a></td></tr>
<tr class="memdesc:ga6dc7349b11544a8b8d78c61e19daedc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga6dc7349b11544a8b8d78c61e19daedc4">More...</a><br /></td></tr>
<tr class="separator:ga6dc7349b11544a8b8d78c61e19daedc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa7bc30d85d431385818f616ebc5004"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorQuadOct.html">NSVectorQuadOct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6aa7bc30d85d431385818f616ebc5004">regina::NNormalSurfaceVectorQuadOct</a></td></tr>
<tr class="memdesc:ga6aa7bc30d85d431385818f616ebc5004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga6aa7bc30d85d431385818f616ebc5004">More...</a><br /></td></tr>
<tr class="separator:ga6aa7bc30d85d431385818f616ebc5004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7bc8620edc82bec1339e1460e7b1e75"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorStandard.html">NSVectorStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad7bc8620edc82bec1339e1460e7b1e75">regina::NNormalSurfaceVectorStandard</a></td></tr>
<tr class="memdesc:gad7bc8620edc82bec1339e1460e7b1e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gad7bc8620edc82bec1339e1460e7b1e75">More...</a><br /></td></tr>
<tr class="separator:gad7bc8620edc82bec1339e1460e7b1e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc97e79a145070e73896ab2b7730415"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga0dc97e79a145070e73896ab2b7730415">regina::NPrismSpec</a></td></tr>
<tr class="memdesc:ga0dc97e79a145070e73896ab2b7730415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga0dc97e79a145070e73896ab2b7730415">More...</a><br /></td></tr>
<tr class="separator:ga0dc97e79a145070e73896ab2b7730415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de04b41af82d94b20738074da3f97a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6de04b41af82d94b20738074da3f97a3">regina::NSurfaceFilter</a></td></tr>
<tr class="memdesc:ga6de04b41af82d94b20738074da3f97a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga6de04b41af82d94b20738074da3f97a3">More...</a><br /></td></tr>
<tr class="separator:ga6de04b41af82d94b20738074da3f97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cdc257da3694fba7fb12daf605240ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3cdc257da3694fba7fb12daf605240ba">regina::NSurfaceFilterCombination</a></td></tr>
<tr class="memdesc:ga3cdc257da3694fba7fb12daf605240ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga3cdc257da3694fba7fb12daf605240ba">More...</a><br /></td></tr>
<tr class="separator:ga3cdc257da3694fba7fb12daf605240ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51eaf1ba4c64a4761d40dffc506a2344"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga51eaf1ba4c64a4761d40dffc506a2344">regina::NSurfaceFilterProperties</a></td></tr>
<tr class="memdesc:ga51eaf1ba4c64a4761d40dffc506a2344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga51eaf1ba4c64a4761d40dffc506a2344">More...</a><br /></td></tr>
<tr class="separator:ga51eaf1ba4c64a4761d40dffc506a2344"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a36273f97819ff462b10db091f8a93f75">regina::NS_STANDARD</a> = 0
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47af3d1b2ccecff610fdaae1e4f3dde0744">regina::NS_QUAD</a> = 1
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a676715b936f4d82fbf2cd2b66be3b5cf">regina::NS_QUAD_CLOSED</a> = 10
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47ad2d9d61fc90b31363ec5931b1a300aa8">regina::NS_AN_LEGACY</a> = 100
, <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a4a7e1fc6780905418e84cadf782dd82f">regina::NS_AN_QUAD_OCT</a> = 101
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a0de57480ceb39c23829e982e5bef7d84">regina::NS_AN_STANDARD</a> = 102
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a8ad2e142ae1dda418034657e42365d90">regina::NS_AN_QUAD_OCT_CLOSED</a> = 110
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae">regina::NS_EDGE_WEIGHT</a> = 200
, <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47ae8c39b9dd91ad81bf89ca633c8d9598f">regina::NS_TRIANGLE_ARCS</a> = 201
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a602873a7f7351b3822c37b075ba88c43">regina::NS_ORIENTED</a> = 300
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a205b46c71691c8092a5afa1d99ab556a">regina::NS_ORIENTED_QUAD</a> = 301
, <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a9f471af2d202b88f06ed65be82e5d7eb">regina::NS_ANGLE</a> = 400
<br />
 }</td></tr>
<tr class="memdesc:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different coordinate systems that can be used for enumerating and displaying normal surfaces.  <a href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">More...</a><br /></td></tr>
<tr class="separator:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff25e58607c49cca84049a1069c2cce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">regina::NormalListFlags</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">regina::NS_LIST_DEFAULT</a> = 0x0000
, <a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea41f7f2158c91f3f64f3354118f6a8761">regina::NS_EMBEDDED_ONLY</a> = 0x0001
, <a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea1e0c5bf3f4138d8ec4a88caeb5f87a61">regina::NS_IMMERSED_SINGULAR</a> = 0x0002
, <a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea38cd0d13c8afd0f688eda457d5ed550d">regina::NS_VERTEX</a> = 0x0004
, <br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea949286ba72f0deec9b6bbe2b8a23b39c">regina::NS_FUNDAMENTAL</a> = 0x0008
, <a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2cceaab119737dcff1409ff0f2071baee7e40">regina::NS_LEGACY</a> = 0x4000
, <a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea64cbdf1921e4a99c5943b4039dac2709">regina::NS_CUSTOM</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:gabff25e58607c49cca84049a1069c2cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation.  <a href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">More...</a><br /></td></tr>
<tr class="separator:gabff25e58607c49cca84049a1069c2cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">regina::NormalAlgFlags</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">regina::NS_ALG_DEFAULT</a> = 0x0000
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea4c4bfbfefa31e5c048a0d9e25abf9f89">regina::NS_VERTEX_VIA_REDUCED</a> = 0x0001
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea15bc7c42b8b986d93863600852d271c7">regina::NS_VERTEX_STD_DIRECT</a> = 0x0002
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea482b7e69b14c44d02b29055726b04830">regina::NS_VERTEX_TREE</a> = 0x0010
, <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeac988e037d6c164c645567750680c6e11">regina::NS_VERTEX_DD</a> = 0x0020
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea33ff9b1fafe5bc6aa4dbf851ec2b9ae6">regina::NS_HILBERT_PRIMAL</a> = 0x0100
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea77887211e55db67ba4ba10247cd159f3">regina::NS_HILBERT_DUAL</a> = 0x0200
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea1da3bc474ed341903ab0f043488e27c3">regina::NS_HILBERT_CD</a> = 0x0400
, <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea7d84f194dd4d881f2175acae85fa3742">regina::NS_HILBERT_FULLCONE</a> = 0x0800
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea61e5c6c91ab2a0c4ac8a6fca9cccd430">regina::NS_ALG_LEGACY</a> = 0x4000
, <a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea6d1833185860331a3be3d7f909b1323a">regina::NS_ALG_CUSTOM</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations.  <a href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">More...</a><br /></td></tr>
<tr class="separator:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae923c7c2fa692192d45bdf563f380918"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">regina::SurfaceExportFields</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a81408d5dd0f9deb210bf66ecee761c36">regina::surfaceExportName</a> = 0x0001
, <a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a131a23295ec061f83590561bba365de8">regina::surfaceExportEuler</a> = 0x0002
, <a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a153a815a9b0f7d3b3383f39c2d6f94ca">regina::surfaceExportOrient</a> = 0x0004
, <a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a60a48a7481d07261cf4a4051cffc3bc3">regina::surfaceExportSides</a> = 0x0008
, <br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918add63709fcbf9038110d4a3b232a466c2">regina::surfaceExportBdry</a> = 0x0010
, <a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a0832d74579319961e0c6f976e28b0356">regina::surfaceExportLink</a> = 0x0020
, <a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918acf49b97bd782901a7f6ee32bf9841b03">regina::surfaceExportType</a> = 0x0040
, <a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a9b7d4c6f39579e1711b203dcf8ed3824">regina::surfaceExportNone</a> = 0
, <br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a90da6f93fd64f642efa8b5862d7b4dac">regina::surfaceExportAllButName</a> = 0x007e
, <a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a> = 0x007f
<br />
 }</td></tr>
<tr class="memdesc:gae923c7c2fa692192d45bdf563f380918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.  <a href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">More...</a><br /></td></tr>
<tr class="separator:gae923c7c2fa692192d45bdf563f380918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ab803471723156fb2ecb24b7b1c859"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a> { <a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004">regina::NS_FILTER_DEFAULT</a> = 0
, <a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859abad02c85eeeda839925c60cd245fb478">regina::NS_FILTER_PROPERTIES</a> = 1
, <a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a53350ed09529a46c5ed4298a14d9c6a2">regina::NS_FILTER_COMBINATION</a> = 2
 }</td></tr>
<tr class="memdesc:ga38ab803471723156fb2ecb24b7b1c859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations.  <a href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">More...</a><br /></td></tr>
<tr class="separator:ga38ab803471723156fb2ecb24b7b1c859"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadd13f0c33b3131122ddb15804973fd56"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gadd13f0c33b3131122ddb15804973fd56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadd13f0c33b3131122ddb15804973fd56">regina::forCoords</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, FunctionObject &amp;&amp;func, typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gadd13f0c33b3131122ddb15804973fd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime.  <a href="group__surfaces.html#gadd13f0c33b3131122ddb15804973fd56">More...</a><br /></td></tr>
<tr class="separator:gadd13f0c33b3131122ddb15804973fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6bec1eb2ca5e5a7fd11bedfb1dee56f7">regina::forCoords</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, FunctionObject &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime.  <a href="group__surfaces.html#ga6bec1eb2ca5e5a7fd11bedfb1dee56f7">More...</a><br /></td></tr>
<tr class="separator:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d41a228f90e254a5707f175f55dfb39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9d41a228f90e254a5707f175f55dfb39">regina::DiscSpec::DiscSpec</a> ()</td></tr>
<tr class="memdesc:ga9d41a228f90e254a5707f175f55dfb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised disc specifier.  <a href="group__surfaces.html#ga9d41a228f90e254a5707f175f55dfb39">More...</a><br /></td></tr>
<tr class="separator:ga9d41a228f90e254a5707f175f55dfb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185aaf4b2430cf3089dba1a4ddb83930"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga185aaf4b2430cf3089dba1a4ddb83930">regina::DiscSpec::DiscSpec</a> (size_t newTetIndex, int newType, unsigned long newNumber)</td></tr>
<tr class="memdesc:ga185aaf4b2430cf3089dba1a4ddb83930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc specifier containing the given values.  <a href="group__surfaces.html#ga185aaf4b2430cf3089dba1a4ddb83930">More...</a><br /></td></tr>
<tr class="separator:ga185aaf4b2430cf3089dba1a4ddb83930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga660af5ac1a6ab75d34c6671f2cebfa3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga660af5ac1a6ab75d34c6671f2cebfa3b">regina::DiscSpec::DiscSpec</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga660af5ac1a6ab75d34c6671f2cebfa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc specifier that is a clone of the given specifier.  <a href="group__surfaces.html#ga660af5ac1a6ab75d34c6671f2cebfa3b">More...</a><br /></td></tr>
<tr class="separator:ga660af5ac1a6ab75d34c6671f2cebfa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d24cc1a1425473f871d57828db512df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3d24cc1a1425473f871d57828db512df">regina::DiscSpec::operator=</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga3d24cc1a1425473f871d57828db512df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the values from the given disc specifier into this specifier.  <a href="group__surfaces.html#ga3d24cc1a1425473f871d57828db512df">More...</a><br /></td></tr>
<tr class="separator:ga3d24cc1a1425473f871d57828db512df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b7d3518b9329fe520e02ecfb37ac19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae9b7d3518b9329fe520e02ecfb37ac19">regina::DiscSpec::operator==</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:gae9b7d3518b9329fe520e02ecfb37ac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given disc specifier contain identical information.  <a href="group__surfaces.html#gae9b7d3518b9329fe520e02ecfb37ac19">More...</a><br /></td></tr>
<tr class="separator:gae9b7d3518b9329fe520e02ecfb37ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ea5c54db51d400ded6ad224bbe5e2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga54ea5c54db51d400ded6ad224bbe5e2a">regina::DiscSpec::operator!=</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:ga54ea5c54db51d400ded6ad224bbe5e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given disc specifier contain different information.  <a href="group__surfaces.html#ga54ea5c54db51d400ded6ad224bbe5e2a">More...</a><br /></td></tr>
<tr class="separator:ga54ea5c54db51d400ded6ad224bbe5e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdd4772a47d25242a4afeaaef48aca4f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabdd4772a47d25242a4afeaaef48aca4f">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:gabdd4772a47d25242a4afeaaef48aca4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc specifier to the given output stream.  <a href="group__surfaces.html#gabdd4772a47d25242a4afeaaef48aca4f">More...</a><br /></td></tr>
<tr class="separator:gabdd4772a47d25242a4afeaaef48aca4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga17dfc1f57595cbc9ec5662a76d25c161">regina::numberDiscsAwayFromVertex</a> (int discType, int vertex)</td></tr>
<tr class="memdesc:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not normal discs of the given type are numbered away from the given vertex.  <a href="group__surfaces.html#ga17dfc1f57595cbc9ec5662a76d25c161">More...</a><br /></td></tr>
<tr class="separator:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc8d5800d8613931ff0483a8388308c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaacc8d5800d8613931ff0483a8388308c">regina::discOrientationFollowsEdge</a> (int discType, int vertex, int edgeStart, int edgeEnd)</td></tr>
<tr class="memdesc:gaacc8d5800d8613931ff0483a8388308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc.  <a href="group__surfaces.html#gaacc8d5800d8613931ff0483a8388308c">More...</a><br /></td></tr>
<tr class="separator:gaacc8d5800d8613931ff0483a8388308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe441060b0e0bf2334000a5a3deb33a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabe441060b0e0bf2334000a5a3deb33a2">regina::DiscSetTet::DiscSetTet</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, size_t tetIndex)</td></tr>
<tr class="memdesc:gabe441060b0e0bf2334000a5a3deb33a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal discs corresponding to the discs of the given normal surface that lie within the given tetrahedron.  <a href="group__surfaces.html#gabe441060b0e0bf2334000a5a3deb33a2">More...</a><br /></td></tr>
<tr class="separator:gabe441060b0e0bf2334000a5a3deb33a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7f0f6d8f893f8f8e7f971c6eff4b7c1b">regina::DiscSetTet::DiscSetTet</a> (unsigned long tri0, unsigned long tri1, unsigned long tri2, unsigned long tri3, unsigned long quad0, unsigned long quad1, unsigned long quad2, unsigned long oct0=0, unsigned long oct1=0, unsigned long oct2=0)</td></tr>
<tr class="memdesc:ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal discs where the number of discs of each type is explicitly given.  <a href="group__surfaces.html#ga7f0f6d8f893f8f8e7f971c6eff4b7c1b">More...</a><br /></td></tr>
<tr class="separator:ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70df6a9c427d5d3647407cfbb46052c7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga70df6a9c427d5d3647407cfbb46052c7">regina::DiscSetTet::~DiscSetTet</a> ()</td></tr>
<tr class="memdesc:ga70df6a9c427d5d3647407cfbb46052c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this disc set.  <a href="group__surfaces.html#ga70df6a9c427d5d3647407cfbb46052c7">More...</a><br /></td></tr>
<tr class="separator:ga70df6a9c427d5d3647407cfbb46052c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cc0ec5a7a3f45404ca2933f153a108"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga10cc0ec5a7a3f45404ca2933f153a108">regina::DiscSetTet::nDiscs</a> (int type) const</td></tr>
<tr class="memdesc:ga10cc0ec5a7a3f45404ca2933f153a108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of discs of the given type inside this tetrahedron.  <a href="group__surfaces.html#ga10cc0ec5a7a3f45404ca2933f153a108">More...</a><br /></td></tr>
<tr class="separator:ga10cc0ec5a7a3f45404ca2933f153a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccafa8884a778da2a68041bbc3c0f0f9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaccafa8884a778da2a68041bbc3c0f0f9">regina::DiscSetTet::arcFromDisc</a> (int arcFace, int arcVertex, int discType, unsigned long discNumber) const</td></tr>
<tr class="memdesc:gaccafa8884a778da2a68041bbc3c0f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which normal arc of a given type on a given face of this tetrahedron corresponds to the given normal disc.  <a href="group__surfaces.html#gaccafa8884a778da2a68041bbc3c0f0f9">More...</a><br /></td></tr>
<tr class="separator:gaccafa8884a778da2a68041bbc3c0f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga00a3f5bdb957c5b10c0b5ec9ebfbe94a">regina::DiscSetTet::discFromArc</a> (int arcFace, int arcVertex, unsigned long arcNumber, int &amp;discType, unsigned long &amp;discNumber) const</td></tr>
<tr class="memdesc:ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which normal disc in this tetrahedron meets the given normal arc on the given face.  <a href="group__surfaces.html#ga00a3f5bdb957c5b10c0b5ec9ebfbe94a">More...</a><br /></td></tr>
<tr class="separator:ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b82d38101ec729082b2a2e54180c27"><td class="memItemLeft" align="right" valign="top"><a id="ga97b82d38101ec729082b2a2e54180c27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTet::DiscSetTet</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga97b82d38101ec729082b2a2e54180c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga940c62e36c1949d49df9e0e445d5eeaa"><td class="memItemLeft" align="right" valign="top"><a id="ga940c62e36c1949d49df9e0e445d5eeaa"></a>
<a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTet::operator=</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga940c62e36c1949d49df9e0e445d5eeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4526a51c67f6cc9b10a4dad45a1f1686"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4526a51c67f6cc9b10a4dad45a1f1686">regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, size_t tetIndex)</td></tr>
<tr class="memdesc:ga4526a51c67f6cc9b10a4dad45a1f1686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron.  <a href="group__surfaces.html#ga4526a51c67f6cc9b10a4dad45a1f1686">More...</a><br /></td></tr>
<tr class="separator:ga4526a51c67f6cc9b10a4dad45a1f1686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe87cf10ed4fd6e10266bd92cabda4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8fe87cf10ed4fd6e10266bd92cabda4e">regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, size_t tetIndex, const T &amp;initValue)</td></tr>
<tr class="memdesc:ga8fe87cf10ed4fd6e10266bd92cabda4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron.  <a href="group__surfaces.html#ga8fe87cf10ed4fd6e10266bd92cabda4e">More...</a><br /></td></tr>
<tr class="separator:ga8fe87cf10ed4fd6e10266bd92cabda4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5875e05c90ed38f5384735bcac92d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6c5875e05c90ed38f5384735bcac92d8">regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</a> (unsigned long tri0, unsigned long tri1, unsigned long tri2, unsigned long tri3, unsigned long quad0, unsigned long quad1, unsigned long quad2, unsigned long oct0=0, unsigned long oct1=0, unsigned long oct2=0)</td></tr>
<tr class="memdesc:ga6c5875e05c90ed38f5384735bcac92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set where the number of discs of each type is explicitly given.  <a href="group__surfaces.html#ga6c5875e05c90ed38f5384735bcac92d8">More...</a><br /></td></tr>
<tr class="separator:ga6c5875e05c90ed38f5384735bcac92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce3172b88a1b68738f19ea48c734932"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadce3172b88a1b68738f19ea48c734932">regina::DiscSetTetData&lt; T &gt;::~DiscSetTetData</a> ()</td></tr>
<tr class="memdesc:gadce3172b88a1b68738f19ea48c734932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this disc set and deallocates all data arrays.  <a href="group__surfaces.html#gadce3172b88a1b68738f19ea48c734932">More...</a><br /></td></tr>
<tr class="separator:gadce3172b88a1b68738f19ea48c734932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b40482617d929f84c1f8eeb7e00ff92"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3b40482617d929f84c1f8eeb7e00ff92">regina::DiscSetTetData&lt; T &gt;::data</a> (int discType, unsigned long discNumber)</td></tr>
<tr class="memdesc:ga3b40482617d929f84c1f8eeb7e00ff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the data corresponding to the given normal disc.  <a href="group__surfaces.html#ga3b40482617d929f84c1f8eeb7e00ff92">More...</a><br /></td></tr>
<tr class="separator:ga3b40482617d929f84c1f8eeb7e00ff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275bdf9d54ac076e911bbc409cfa89ee"><td class="memItemLeft" align="right" valign="top"><a id="ga275bdf9d54ac076e911bbc409cfa89ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga275bdf9d54ac076e911bbc409cfa89ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3af2b04943dce588782cadc7441dfd"><td class="memItemLeft" align="right" valign="top"><a id="ga7b3af2b04943dce588782cadc7441dfd"></a>
<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTetData&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga7b3af2b04943dce588782cadc7441dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc5a059c5627c16967d7438dc742fca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9bc5a059c5627c16967d7438dc742fca">regina::DiscSetSurface::DiscSetSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, bool b)</td></tr>
<tr class="memdesc:ga9bc5a059c5627c16967d7438dc742fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="group__surfaces.html#ga9bc5a059c5627c16967d7438dc742fca">More...</a><br /></td></tr>
<tr class="separator:ga9bc5a059c5627c16967d7438dc742fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d4e0bcd28a1aba2869b9db72e6c48f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad7d4e0bcd28a1aba2869b9db72e6c48f">regina::DiscSetSurface::DiscSetSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface)</td></tr>
<tr class="memdesc:gad7d4e0bcd28a1aba2869b9db72e6c48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="group__surfaces.html#gad7d4e0bcd28a1aba2869b9db72e6c48f">More...</a><br /></td></tr>
<tr class="separator:gad7d4e0bcd28a1aba2869b9db72e6c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124a63e9a57ffc4fff0fef553fa2862c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga124a63e9a57ffc4fff0fef553fa2862c">regina::DiscSetSurface::~DiscSetSurface</a> ()</td></tr>
<tr class="memdesc:ga124a63e9a57ffc4fff0fef553fa2862c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this set of discs and deallocates all associated memory.  <a href="group__surfaces.html#ga124a63e9a57ffc4fff0fef553fa2862c">More...</a><br /></td></tr>
<tr class="separator:ga124a63e9a57ffc4fff0fef553fa2862c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4244895ae54265d8c0544ee65370483"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac4244895ae54265d8c0544ee65370483">regina::DiscSetSurface::nTets</a> () const</td></tr>
<tr class="memdesc:gac4244895ae54265d8c0544ee65370483"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in the underlying triangulation.  <a href="group__surfaces.html#gac4244895ae54265d8c0544ee65370483">More...</a><br /></td></tr>
<tr class="separator:gac4244895ae54265d8c0544ee65370483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf48dd20fe6cfdd7e9f41e919b577b8b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacf48dd20fe6cfdd7e9f41e919b577b8b">regina::DiscSetSurface::nDiscs</a> (size_t tetIndex, int type) const</td></tr>
<tr class="memdesc:gacf48dd20fe6cfdd7e9f41e919b577b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of discs of the given type inside the given tetrahedron.  <a href="group__surfaces.html#gacf48dd20fe6cfdd7e9f41e919b577b8b">More...</a><br /></td></tr>
<tr class="separator:gacf48dd20fe6cfdd7e9f41e919b577b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6318837e6c80c4648a7971e038db9d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6318837e6c80c4648a7971e038db9d6f">regina::DiscSetSurface::tetDiscs</a> (size_t tetIndex) const</td></tr>
<tr class="memdesc:ga6318837e6c80c4648a7971e038db9d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific set of discs living inside the given tetrahedron.  <a href="group__surfaces.html#ga6318837e6c80c4648a7971e038db9d6f">More...</a><br /></td></tr>
<tr class="separator:ga6318837e6c80c4648a7971e038db9d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14859baec94b6d792d0234fa2c4def8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga14859baec94b6d792d0234fa2c4def8e">regina::DiscSetSurface::adjacentDisc</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;disc, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; arc, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; &amp;adjArc) const</td></tr>
<tr class="memdesc:ga14859baec94b6d792d0234fa2c4def8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which normal disc is adjacent to the given normal disc along the given directed normal arc in the surface described by this disc set.  <a href="group__surfaces.html#ga14859baec94b6d792d0234fa2c4def8e">More...</a><br /></td></tr>
<tr class="separator:ga14859baec94b6d792d0234fa2c4def8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bcb320960af2e96d587cc40549a48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c">regina::DiscSetSurface::begin</a> () const</td></tr>
<tr class="memdesc:gaf1bcb320960af2e96d587cc40549a48c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of all normal discs in the underlying normal surface.  <a href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c">More...</a><br /></td></tr>
<tr class="separator:gaf1bcb320960af2e96d587cc40549a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26003982483e680a1c073ab250702d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae26003982483e680a1c073ab250702d2">regina::DiscSetSurface::end</a> () const</td></tr>
<tr class="memdesc:gae26003982483e680a1c073ab250702d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of all normal discs in the underlying normal surface.  <a href="group__surfaces.html#gae26003982483e680a1c073ab250702d2">More...</a><br /></td></tr>
<tr class="separator:gae26003982483e680a1c073ab250702d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa98fc1d32bd109ee9a706f82647f98c2"><td class="memItemLeft" align="right" valign="top"><a id="gaa98fc1d32bd109ee9a706f82647f98c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurface::DiscSetSurface</b> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;)=delete</td></tr>
<tr class="separator:gaa98fc1d32bd109ee9a706f82647f98c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb651be00fdccfe7832199490356c459"><td class="memItemLeft" align="right" valign="top"><a id="gafb651be00fdccfe7832199490356c459"></a>
<a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurface::operator=</b> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;)=delete</td></tr>
<tr class="separator:gafb651be00fdccfe7832199490356c459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351ff55619cc35b42f37ddb369e0fcc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga351ff55619cc35b42f37ddb369e0fcc9">regina::DiscSetSurfaceData&lt; T &gt;::DiscSetSurfaceData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface)</td></tr>
<tr class="memdesc:ga351ff55619cc35b42f37ddb369e0fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="group__surfaces.html#ga351ff55619cc35b42f37ddb369e0fcc9">More...</a><br /></td></tr>
<tr class="separator:ga351ff55619cc35b42f37ddb369e0fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c7e00d669bca83a672de12e45f627c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga97c7e00d669bca83a672de12e45f627c">regina::DiscSetSurfaceData&lt; T &gt;::DiscSetSurfaceData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, const T &amp;initValue)</td></tr>
<tr class="memdesc:ga97c7e00d669bca83a672de12e45f627c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="group__surfaces.html#ga97c7e00d669bca83a672de12e45f627c">More...</a><br /></td></tr>
<tr class="separator:ga97c7e00d669bca83a672de12e45f627c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab688229f8a6ef82f631b8e77e82def0"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaab688229f8a6ef82f631b8e77e82def0">regina::DiscSetSurfaceData&lt; T &gt;::data</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;disc)</td></tr>
<tr class="memdesc:gaab688229f8a6ef82f631b8e77e82def0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the data corresponding to the given normal disc.  <a href="group__surfaces.html#gaab688229f8a6ef82f631b8e77e82def0">More...</a><br /></td></tr>
<tr class="separator:gaab688229f8a6ef82f631b8e77e82def0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccbb0096eb72d35f6db6481943b7eefe"><td class="memItemLeft" align="right" valign="top"><a id="gaccbb0096eb72d35f6db6481943b7eefe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurfaceData&lt; T &gt;::DiscSetSurfaceData</b> (const <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> &amp;)=delete</td></tr>
<tr class="separator:gaccbb0096eb72d35f6db6481943b7eefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e02b86250fd6eb7a88a1acc6c16293"><td class="memItemLeft" align="right" valign="top"><a id="gac4e02b86250fd6eb7a88a1acc6c16293"></a>
<a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurfaceData&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> &amp;)=delete</td></tr>
<tr class="separator:gac4e02b86250fd6eb7a88a1acc6c16293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e169fff6424f1acf397c42bca638b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa9e169fff6424f1acf397c42bca638b7">regina::DiscSpecIterator::DiscSpecIterator</a> ()</td></tr>
<tr class="memdesc:gaa9e169fff6424f1acf397c42bca638b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised iterator.  <a href="group__surfaces.html#gaa9e169fff6424f1acf397c42bca638b7">More...</a><br /></td></tr>
<tr class="separator:gaa9e169fff6424f1acf397c42bca638b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a16a72e475679372711d2a9c8ce32c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac2a16a72e475679372711d2a9c8ce32c">regina::DiscSpecIterator::DiscSpecIterator</a> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;discSet)</td></tr>
<tr class="memdesc:gac2a16a72e475679372711d2a9c8ce32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the first disc in the given disc set.  <a href="group__surfaces.html#gac2a16a72e475679372711d2a9c8ce32c">More...</a><br /></td></tr>
<tr class="separator:gac2a16a72e475679372711d2a9c8ce32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a02ea41beef23675e3133af8eea0bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga21a02ea41beef23675e3133af8eea0bc">regina::DiscSpecIterator::DiscSpecIterator</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga21a02ea41beef23675e3133af8eea0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="group__surfaces.html#ga21a02ea41beef23675e3133af8eea0bc">More...</a><br /></td></tr>
<tr class="separator:ga21a02ea41beef23675e3133af8eea0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f9987a917198b7fbe777fdb37c3511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad2f9987a917198b7fbe777fdb37c3511">regina::DiscSpecIterator::init</a> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;discSet)</td></tr>
<tr class="memdesc:gad2f9987a917198b7fbe777fdb37c3511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points this iterator to the first disc in the given disc set.  <a href="group__surfaces.html#gad2f9987a917198b7fbe777fdb37c3511">More...</a><br /></td></tr>
<tr class="separator:gad2f9987a917198b7fbe777fdb37c3511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6e86b724a23f0be60c43ffdae7c037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaeb6e86b724a23f0be60c43ffdae7c037">regina::DiscSpecIterator::operator=</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gaeb6e86b724a23f0be60c43ffdae7c037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="group__surfaces.html#gaeb6e86b724a23f0be60c43ffdae7c037">More...</a><br /></td></tr>
<tr class="separator:gaeb6e86b724a23f0be60c43ffdae7c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ea429f2da590de2bb9552562a1fa22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga47ea429f2da590de2bb9552562a1fa22">regina::DiscSpecIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga47ea429f2da590de2bb9552562a1fa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="group__surfaces.html#ga47ea429f2da590de2bb9552562a1fa22">More...</a><br /></td></tr>
<tr class="separator:ga47ea429f2da590de2bb9552562a1fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f06d8171f9e775f0a80889c0501ba65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9f06d8171f9e775f0a80889c0501ba65">regina::DiscSpecIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:ga9f06d8171f9e775f0a80889c0501ba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="group__surfaces.html#ga9f06d8171f9e775f0a80889c0501ba65">More...</a><br /></td></tr>
<tr class="separator:ga9f06d8171f9e775f0a80889c0501ba65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ec50711cb56ec28b708d16ac21031a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae7ec50711cb56ec28b708d16ac21031a">regina::DiscSpecIterator::operator*</a> () const</td></tr>
<tr class="memdesc:gae7ec50711cb56ec28b708d16ac21031a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the disc pointed to by this iterator.  <a href="group__surfaces.html#gae7ec50711cb56ec28b708d16ac21031a">More...</a><br /></td></tr>
<tr class="separator:gae7ec50711cb56ec28b708d16ac21031a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2e60e17d1ef726a70b9393638f09fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1d2e60e17d1ef726a70b9393638f09fa">regina::DiscSpecIterator::done</a> () const</td></tr>
<tr class="memdesc:ga1d2e60e17d1ef726a70b9393638f09fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this iterator is past-the-end.  <a href="group__surfaces.html#ga1d2e60e17d1ef726a70b9393638f09fa">More...</a><br /></td></tr>
<tr class="separator:ga1d2e60e17d1ef726a70b9393638f09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad214e90993b4a051e3029c7e75c7d83a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad214e90993b4a051e3029c7e75c7d83a">regina::DiscSpecIterator::operator==</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:gad214e90993b4a051e3029c7e75c7d83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given iterator are equal.  <a href="group__surfaces.html#gad214e90993b4a051e3029c7e75c7d83a">More...</a><br /></td></tr>
<tr class="separator:gad214e90993b4a051e3029c7e75c7d83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e800bb0b3fcdd93f4eca3404de1635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga11e800bb0b3fcdd93f4eca3404de1635">regina::DiscSpecIterator::operator!=</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:ga11e800bb0b3fcdd93f4eca3404de1635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given iterator are different.  <a href="group__surfaces.html#ga11e800bb0b3fcdd93f4eca3404de1635">More...</a><br /></td></tr>
<tr class="separator:ga11e800bb0b3fcdd93f4eca3404de1635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e0a3373b5079e42b4742c589752f39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga87e0a3373b5079e42b4742c589752f39">regina::DiscType::DiscType</a> ()</td></tr>
<tr class="memdesc:ga87e0a3373b5079e42b4742c589752f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc type initialised to NONE.  <a href="group__surfaces.html#ga87e0a3373b5079e42b4742c589752f39">More...</a><br /></td></tr>
<tr class="separator:ga87e0a3373b5079e42b4742c589752f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab795c9663ce281fc8ce8a647e3405d89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab795c9663ce281fc8ce8a647e3405d89">regina::DiscType::DiscType</a> (size_t newTetIndex, int newType)</td></tr>
<tr class="memdesc:gab795c9663ce281fc8ce8a647e3405d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc type initialised with the given values.  <a href="group__surfaces.html#gab795c9663ce281fc8ce8a647e3405d89">More...</a><br /></td></tr>
<tr class="separator:gab795c9663ce281fc8ce8a647e3405d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73770e3cb29de3677ae7d35211097455"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga73770e3cb29de3677ae7d35211097455">regina::DiscType::DiscType</a> (const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga73770e3cb29de3677ae7d35211097455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given disc type.  <a href="group__surfaces.html#ga73770e3cb29de3677ae7d35211097455">More...</a><br /></td></tr>
<tr class="separator:ga73770e3cb29de3677ae7d35211097455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfba8d154f25fd7b6507594fd429c8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabbfba8d154f25fd7b6507594fd429c8f">regina::DiscType::operator=</a> (const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gabbfba8d154f25fd7b6507594fd429c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this to a copy of the given disc type.  <a href="group__surfaces.html#gabbfba8d154f25fd7b6507594fd429c8f">More...</a><br /></td></tr>
<tr class="separator:gabbfba8d154f25fd7b6507594fd429c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c537efe1a738b4695f29f8bacf74632"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6c537efe1a738b4695f29f8bacf74632">regina::DiscType::operator==</a> (const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga6c537efe1a738b4695f29f8bacf74632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given disc type are identical.  <a href="group__surfaces.html#ga6c537efe1a738b4695f29f8bacf74632">More...</a><br /></td></tr>
<tr class="separator:ga6c537efe1a738b4695f29f8bacf74632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c765ad77977e5cd119e6bcab9de6b7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4c765ad77977e5cd119e6bcab9de6b7f">regina::DiscType::operator!=</a> (const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;compare) const</td></tr>
<tr class="memdesc:ga4c765ad77977e5cd119e6bcab9de6b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given disc type are different.  <a href="group__surfaces.html#ga4c765ad77977e5cd119e6bcab9de6b7f">More...</a><br /></td></tr>
<tr class="separator:ga4c765ad77977e5cd119e6bcab9de6b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa824ef83e3899d71862bd423bb3e5e67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa824ef83e3899d71862bd423bb3e5e67">regina::DiscType::operator&lt;</a> (const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;compare) const</td></tr>
<tr class="memdesc:gaa824ef83e3899d71862bd423bb3e5e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an ordering of disc types.  <a href="group__surfaces.html#gaa824ef83e3899d71862bd423bb3e5e67">More...</a><br /></td></tr>
<tr class="separator:gaa824ef83e3899d71862bd423bb3e5e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4d42ed9b68e522ff445b5d3e777176f4">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;type)</td></tr>
<tr class="memdesc:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc type to the given output stream.  <a href="group__surfaces.html#ga4d42ed9b68e522ff445b5d3e777176f4">More...</a><br /></td></tr>
<tr class="separator:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfcdfb4006b01269d80720b647e1dc37"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gadfcdfb4006b01269d80720b647e1dc37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37">regina::forFilter</a> (<a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filter, FunctionObject &amp;&amp;func, typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gadfcdfb4006b01269d80720b647e1dc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime.  <a href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37">More...</a><br /></td></tr>
<tr class="separator:gadfcdfb4006b01269d80720b647e1dc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5af9e496cbc7b631780b88a04e7e04b0">regina::forFilter</a> (<a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filter, FunctionObject &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime.  <a href="group__surfaces.html#ga5af9e496cbc7b631780b88a04e7e04b0">More...</a><br /></td></tr>
<tr class="separator:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92f3f038eac514d3e599ff3d92d8485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae92f3f038eac514d3e599ff3d92d8485">regina::operator|</a> (<a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a> lhs, <a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a> rhs)</td></tr>
<tr class="memdesc:gae92f3f038eac514d3e599ff3d92d8485"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="group__surfaces.html#gae92f3f038eac514d3e599ff3d92d8485">More...</a><br /></td></tr>
<tr class="separator:gae92f3f038eac514d3e599ff3d92d8485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4428e0ba8bfcc8083b37e9e3e2220c96">regina::operator|</a> (<a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a> lhs, <a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a> rhs)</td></tr>
<tr class="memdesc:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="group__surfaces.html#ga4428e0ba8bfcc8083b37e9e3e2220c96">More...</a><br /></td></tr>
<tr class="separator:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6da8adb1ae136adf220689fcf75886d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6da8adb1ae136adf220689fcf75886d8">regina::NormalSurfaceVector::NormalSurfaceVector</a> (size_t length)</td></tr>
<tr class="memdesc:ga6da8adb1ae136adf220689fcf75886d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#ga6da8adb1ae136adf220689fcf75886d8">More...</a><br /></td></tr>
<tr class="separator:ga6da8adb1ae136adf220689fcf75886d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1dffade0cc17f3caeebdc004ad7295b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa1dffade0cc17f3caeebdc004ad7295b">regina::NormalSurfaceVector::NormalSurfaceVector</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gaa1dffade0cc17f3caeebdc004ad7295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#gaa1dffade0cc17f3caeebdc004ad7295b">More...</a><br /></td></tr>
<tr class="separator:gaa1dffade0cc17f3caeebdc004ad7295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae178badf17e45e41a5da7eabf8005e22"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae178badf17e45e41a5da7eabf8005e22">regina::NormalSurfaceVector::~NormalSurfaceVector</a> ()</td></tr>
<tr class="memdesc:gae178badf17e45e41a5da7eabf8005e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">A virtual destructor.  <a href="group__surfaces.html#gae178badf17e45e41a5da7eabf8005e22">More...</a><br /></td></tr>
<tr class="separator:gae178badf17e45e41a5da7eabf8005e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf64145ed248bd3b24af3d65a7500aadb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf64145ed248bd3b24af3d65a7500aadb">regina::NormalSurfaceVector::coords</a> () const</td></tr>
<tr class="memdesc:gaf64145ed248bd3b24af3d65a7500aadb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the underlying vector of coordinates.  <a href="group__surfaces.html#gaf64145ed248bd3b24af3d65a7500aadb">More...</a><br /></td></tr>
<tr class="separator:gaf64145ed248bd3b24af3d65a7500aadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga919f098d3c43f1e68a5dc3ba9c9da227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga919f098d3c43f1e68a5dc3ba9c9da227">regina::NormalSurfaceVector::clone</a> () const =0</td></tr>
<tr class="memdesc:ga919f098d3c43f1e68a5dc3ba9c9da227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="group__surfaces.html#ga919f098d3c43f1e68a5dc3ba9c9da227">More...</a><br /></td></tr>
<tr class="separator:ga919f098d3c43f1e68a5dc3ba9c9da227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680b7b7ac5f45b6404644ee9fb1afb85"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga680b7b7ac5f45b6404644ee9fb1afb85">regina::NormalSurfaceVector::size</a> () const</td></tr>
<tr class="memdesc:ga680b7b7ac5f45b6404644ee9fb1afb85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector.  <a href="group__surfaces.html#ga680b7b7ac5f45b6404644ee9fb1afb85">More...</a><br /></td></tr>
<tr class="separator:ga680b7b7ac5f45b6404644ee9fb1afb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga589b3a30d37df7adbd44ff523d3ec19c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga589b3a30d37df7adbd44ff523d3ec19c">regina::NormalSurfaceVector::operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:ga589b3a30d37df7adbd44ff523d3ec19c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector.  <a href="group__surfaces.html#ga589b3a30d37df7adbd44ff523d3ec19c">More...</a><br /></td></tr>
<tr class="separator:ga589b3a30d37df7adbd44ff523d3ec19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c548a7bcd676dceef9b01ec96ab8da"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga24c548a7bcd676dceef9b01ec96ab8da">regina::NormalSurfaceVector::setElement</a> (size_t index, const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;value)</td></tr>
<tr class="memdesc:ga24c548a7bcd676dceef9b01ec96ab8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given normal coordinate to the given value.  <a href="group__surfaces.html#ga24c548a7bcd676dceef9b01ec96ab8da">More...</a><br /></td></tr>
<tr class="separator:ga24c548a7bcd676dceef9b01ec96ab8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bf86f895cf3f97281cf98c6e9ac8ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga87bf86f895cf3f97281cf98c6e9ac8ef">regina::NormalSurfaceVector::operator+=</a> (const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;other)</td></tr>
<tr class="memdesc:ga87bf86f895cf3f97281cf98c6e9ac8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="group__surfaces.html#ga87bf86f895cf3f97281cf98c6e9ac8ef">More...</a><br /></td></tr>
<tr class="separator:ga87bf86f895cf3f97281cf98c6e9ac8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f95b5cc7d6e00e85cd78283227fb17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga19f95b5cc7d6e00e85cd78283227fb17">regina::NormalSurfaceVector::scaleDown</a> ()</td></tr>
<tr class="memdesc:ga19f95b5cc7d6e00e85cd78283227fb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="group__surfaces.html#ga19f95b5cc7d6e00e85cd78283227fb17">More...</a><br /></td></tr>
<tr class="separator:ga19f95b5cc7d6e00e85cd78283227fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b5594a67c7a695ab21adaa862a8d38"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga44b5594a67c7a695ab21adaa862a8d38">regina::NormalSurfaceVector::allowsAlmostNormal</a> () const =0</td></tr>
<tr class="memdesc:ga44b5594a67c7a695ab21adaa862a8d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="group__surfaces.html#ga44b5594a67c7a695ab21adaa862a8d38">More...</a><br /></td></tr>
<tr class="separator:ga44b5594a67c7a695ab21adaa862a8d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07d54c737adf4198657a237f31d8851"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab07d54c737adf4198657a237f31d8851">regina::NormalSurfaceVector::allowsSpun</a> () const =0</td></tr>
<tr class="memdesc:gab07d54c737adf4198657a237f31d8851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles.  <a href="group__surfaces.html#gab07d54c737adf4198657a237f31d8851">More...</a><br /></td></tr>
<tr class="separator:gab07d54c737adf4198657a237f31d8851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8c2541a7dcdecfafd908ad50d98cd9d1">regina::NormalSurfaceVector::allowsOriented</a> () const =0</td></tr>
<tr class="memdesc:ga8c2541a7dcdecfafd908ad50d98cd9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces.  <a href="group__surfaces.html#ga8c2541a7dcdecfafd908ad50d98cd9d1">More...</a><br /></td></tr>
<tr class="separator:ga8c2541a7dcdecfafd908ad50d98cd9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga207ab6ce67f8c4f322f64fd0494e3a88"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga207ab6ce67f8c4f322f64fd0494e3a88">regina::NormalSurfaceVector::hasMultipleOctDiscs</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ga207ab6ce67f8c4f322f64fd0494e3a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface has more than one octagonal disc.  <a href="group__surfaces.html#ga207ab6ce67f8c4f322f64fd0494e3a88">More...</a><br /></td></tr>
<tr class="separator:ga207ab6ce67f8c4f322f64fd0494e3a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3f3ccef51ec75544ee6cc6875a6cda"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gace3f3ccef51ec75544ee6cc6875a6cda">regina::NormalSurfaceVector::isCompact</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:gace3f3ccef51ec75544ee6cc6875a6cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is compact (has finitely many discs).  <a href="group__surfaces.html#gace3f3ccef51ec75544ee6cc6875a6cda">More...</a><br /></td></tr>
<tr class="separator:gace3f3ccef51ec75544ee6cc6875a6cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf49b14b890535f0deee9d8db62dc4c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaecf49b14b890535f0deee9d8db62dc4c">regina::NormalSurfaceVector::isVertexLinking</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:gaecf49b14b890535f0deee9d8db62dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is vertex linking.  <a href="group__surfaces.html#gaecf49b14b890535f0deee9d8db62dc4c">More...</a><br /></td></tr>
<tr class="separator:gaecf49b14b890535f0deee9d8db62dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f860e909873a8ab2449f36c7d3cfb3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga48f860e909873a8ab2449f36c7d3cfb3">regina::NormalSurfaceVector::isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ga48f860e909873a8ab2449f36c7d3cfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="group__surfaces.html#ga48f860e909873a8ab2449f36c7d3cfb3">More...</a><br /></td></tr>
<tr class="separator:ga48f860e909873a8ab2449f36c7d3cfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07535a32a2da710490b864bb23f93ea1"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga07535a32a2da710490b864bb23f93ea1">regina::NormalSurfaceVector::isThinEdgeLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ga07535a32a2da710490b864bb23f93ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the thin link of a single edge.  <a href="group__surfaces.html#ga07535a32a2da710490b864bb23f93ea1">More...</a><br /></td></tr>
<tr class="separator:ga07535a32a2da710490b864bb23f93ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4da454072e9b44e9ccbf23523006dae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae4da454072e9b44e9ccbf23523006dae">regina::NormalSurfaceVector::isSplitting</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:gae4da454072e9b44e9ccbf23523006dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a splitting surface in the given triangulation.  <a href="group__surfaces.html#gae4da454072e9b44e9ccbf23523006dae">More...</a><br /></td></tr>
<tr class="separator:gae4da454072e9b44e9ccbf23523006dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f211dde81cc1505e475d48da6f1aafa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7f211dde81cc1505e475d48da6f1aafa">regina::NormalSurfaceVector::isCentral</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const</td></tr>
<tr class="memdesc:ga7f211dde81cc1505e475d48da6f1aafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a central surface in the given triangulation.  <a href="group__surfaces.html#ga7f211dde81cc1505e475d48da6f1aafa">More...</a><br /></td></tr>
<tr class="separator:ga7f211dde81cc1505e475d48da6f1aafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea2312f446f4f7b1c3066925d7f1e2c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3ea2312f446f4f7b1c3066925d7f1e2c">regina::NormalSurfaceVector::triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:ga3ea2312f446f4f7b1c3066925d7f1e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#ga3ea2312f446f4f7b1c3066925d7f1e2c">More...</a><br /></td></tr>
<tr class="separator:ga3ea2312f446f4f7b1c3066925d7f1e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce2cc2fbd8b46b97d8ea787535282d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2ce2cc2fbd8b46b97d8ea787535282d0">regina::NormalSurfaceVector::orientedTriangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const</td></tr>
<tr class="memdesc:ga2ce2cc2fbd8b46b97d8ea787535282d0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#ga2ce2cc2fbd8b46b97d8ea787535282d0">More...</a><br /></td></tr>
<tr class="separator:ga2ce2cc2fbd8b46b97d8ea787535282d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga570ee5188151835875872bb11c5849da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga570ee5188151835875872bb11c5849da">regina::NormalSurfaceVector::quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:ga570ee5188151835875872bb11c5849da"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga570ee5188151835875872bb11c5849da">More...</a><br /></td></tr>
<tr class="separator:ga570ee5188151835875872bb11c5849da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6d15dfef9d0dca32bc66c8ac506d196"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad6d15dfef9d0dca32bc66c8ac506d196">regina::NormalSurfaceVector::orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const</td></tr>
<tr class="memdesc:gad6d15dfef9d0dca32bc66c8ac506d196"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#gad6d15dfef9d0dca32bc66c8ac506d196">More...</a><br /></td></tr>
<tr class="separator:gad6d15dfef9d0dca32bc66c8ac506d196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab042b630da0605dfc10845cb4eab2955"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab042b630da0605dfc10845cb4eab2955">regina::NormalSurfaceVector::octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:gab042b630da0605dfc10845cb4eab2955"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#gab042b630da0605dfc10845cb4eab2955">More...</a><br /></td></tr>
<tr class="separator:gab042b630da0605dfc10845cb4eab2955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bc14138b82130ad79e60d8585aea3c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5bc14138b82130ad79e60d8585aea3c5">regina::NormalSurfaceVector::edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:ga5bc14138b82130ad79e60d8585aea3c5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="group__surfaces.html#ga5bc14138b82130ad79e60d8585aea3c5">More...</a><br /></td></tr>
<tr class="separator:ga5bc14138b82130ad79e60d8585aea3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e760f7358e5ab934afca94fcd57138"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad3e760f7358e5ab934afca94fcd57138">regina::NormalSurfaceVector::arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:gad3e760f7358e5ab934afca94fcd57138"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="group__surfaces.html#gad3e760f7358e5ab934afca94fcd57138">More...</a><br /></td></tr>
<tr class="separator:gad3e760f7358e5ab934afca94fcd57138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2208bc38293ec2a64359c2f582868a2f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2208bc38293ec2a64359c2f582868a2f">regina::NormalSurfaceVector::makeZeroVector</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:ga2208bc38293ec2a64359c2f582868a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.  <a href="group__surfaces.html#ga2208bc38293ec2a64359c2f582868a2f">More...</a><br /></td></tr>
<tr class="separator:ga2208bc38293ec2a64359c2f582868a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda04c126a8ff0c247429cf4acabdc60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gafda04c126a8ff0c247429cf4acabdc60">regina::NormalSurfaceVector::makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:gafda04c126a8ff0c247429cf4acabdc60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal surface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.  <a href="group__surfaces.html#gafda04c126a8ff0c247429cf4acabdc60">More...</a><br /></td></tr>
<tr class="separator:gafda04c126a8ff0c247429cf4acabdc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0abea602d297abf6cc61d1281169a4e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa0abea602d297abf6cc61d1281169a4e">regina::NormalSurfaceVector::makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="memdesc:gaa0abea602d297abf6cc61d1281169a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal surfaces be embedded.  <a href="group__surfaces.html#gaa0abea602d297abf6cc61d1281169a4e">More...</a><br /></td></tr>
<tr class="separator:gaa0abea602d297abf6cc61d1281169a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d91874b24ad5b85e3883a46b580f291"><td class="memItemLeft" align="right" valign="top"><a id="ga3d91874b24ad5b85e3883a46b580f291"></a>
<a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurfaceVector::operator=</b> (const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;)=delete</td></tr>
<tr class="separator:ga3d91874b24ad5b85e3883a46b580f291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga311cdd4d11c01e88da4f5c12031e89e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga311cdd4d11c01e88da4f5c12031e89e3">regina::NormalSurface::NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *newVector)</td></tr>
<tr class="memdesc:ga311cdd4d11c01e88da4f5c12031e89e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface inside the given triangulation with the given coordinate vector.  <a href="group__surfaces.html#ga311cdd4d11c01e88da4f5c12031e89e3">More...</a><br /></td></tr>
<tr class="separator:ga311cdd4d11c01e88da4f5c12031e89e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d249fdec933b17b2dd7a7157061100f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6d249fdec933b17b2dd7a7157061100f">regina::NormalSurface::NormalSurface</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coordSystem, List allCoords)</td></tr>
<tr class="memdesc:ga6d249fdec933b17b2dd7a7157061100f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Python-only routine that creates a new normal surface inside the given triangulation with the given coordinate vector.  <a href="group__surfaces.html#ga6d249fdec933b17b2dd7a7157061100f">More...</a><br /></td></tr>
<tr class="separator:ga6d249fdec933b17b2dd7a7157061100f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2dc2b6c49ccae3b357fbfa8902800f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf2dc2b6c49ccae3b357fbfa8902800f1">regina::NormalSurface::~NormalSurface</a> ()</td></tr>
<tr class="memdesc:gaf2dc2b6c49ccae3b357fbfa8902800f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this normal surface.  <a href="group__surfaces.html#gaf2dc2b6c49ccae3b357fbfa8902800f1">More...</a><br /></td></tr>
<tr class="separator:gaf2dc2b6c49ccae3b357fbfa8902800f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f5b4c6b7ac6ae63df0efece67fef06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa8f5b4c6b7ac6ae63df0efece67fef06">regina::NormalSurface::clone</a> () const</td></tr>
<tr class="memdesc:gaa8f5b4c6b7ac6ae63df0efece67fef06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this normal surface.  <a href="group__surfaces.html#gaa8f5b4c6b7ac6ae63df0efece67fef06">More...</a><br /></td></tr>
<tr class="separator:gaa8f5b4c6b7ac6ae63df0efece67fef06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62b05e3ae22fb0c59bb08c28f88ccdbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga62b05e3ae22fb0c59bb08c28f88ccdbc">regina::NormalSurface::doubleSurface</a> () const</td></tr>
<tr class="memdesc:ga62b05e3ae22fb0c59bb08c28f88ccdbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated surface that is the double of this surface.  <a href="group__surfaces.html#ga62b05e3ae22fb0c59bb08c28f88ccdbc">More...</a><br /></td></tr>
<tr class="separator:ga62b05e3ae22fb0c59bb08c28f88ccdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8">regina::NormalSurface::triangles</a> (size_t tetIndex, int vertex) const</td></tr>
<tr class="memdesc:gaa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8">More...</a><br /></td></tr>
<tr class="separator:gaa25f8c4dad5d3efcfe3f01aeca20c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga778a22958ed66c5118c06e8fc861b5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga778a22958ed66c5118c06e8fc861b5b7">regina::NormalSurface::orientedTriangles</a> (size_t tetIndex, int vertex, bool orientation) const</td></tr>
<tr class="memdesc:ga778a22958ed66c5118c06e8fc861b5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#ga778a22958ed66c5118c06e8fc861b5b7">More...</a><br /></td></tr>
<tr class="separator:ga778a22958ed66c5118c06e8fc861b5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8380567805860ecdbde4bde09a5fc9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c">regina::NormalSurface::quads</a> (size_t tetIndex, int quadType) const</td></tr>
<tr class="memdesc:gac8380567805860ecdbde4bde09a5fc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c">More...</a><br /></td></tr>
<tr class="separator:gac8380567805860ecdbde4bde09a5fc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1782b65da2df0fe8921002d28139938e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1782b65da2df0fe8921002d28139938e">regina::NormalSurface::orientedQuads</a> (size_t tetIndex, int quadType, bool orientation) const</td></tr>
<tr class="memdesc:ga1782b65da2df0fe8921002d28139938e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga1782b65da2df0fe8921002d28139938e">More...</a><br /></td></tr>
<tr class="separator:ga1782b65da2df0fe8921002d28139938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabae51e35ce30784d586dfca6576243ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee">regina::NormalSurface::octs</a> (size_t tetIndex, int octType) const</td></tr>
<tr class="memdesc:gabae51e35ce30784d586dfca6576243ee"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee">More...</a><br /></td></tr>
<tr class="separator:gabae51e35ce30784d586dfca6576243ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0471c5364a23009d61817fa084cdcc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab0471c5364a23009d61817fa084cdcc9">regina::NormalSurface::edgeWeight</a> (size_t edgeIndex) const</td></tr>
<tr class="memdesc:gab0471c5364a23009d61817fa084cdcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="group__surfaces.html#gab0471c5364a23009d61817fa084cdcc9">More...</a><br /></td></tr>
<tr class="separator:gab0471c5364a23009d61817fa084cdcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a0872585e068bfc47cfdc417c63dd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga00a0872585e068bfc47cfdc417c63dd0">regina::NormalSurface::arcs</a> (size_t triIndex, int triVertex) const</td></tr>
<tr class="memdesc:ga00a0872585e068bfc47cfdc417c63dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="group__surfaces.html#ga00a0872585e068bfc47cfdc417c63dd0">More...</a><br /></td></tr>
<tr class="separator:ga00a0872585e068bfc47cfdc417c63dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a06c1a51568cc60c9699b083876a16c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscType.html">DiscType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1a06c1a51568cc60c9699b083876a16c">regina::NormalSurface::octPosition</a> () const</td></tr>
<tr class="memdesc:ga1a06c1a51568cc60c9699b083876a16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first coordinate position at which this surface has a non-zero octagonal coordinate.  <a href="group__surfaces.html#ga1a06c1a51568cc60c9699b083876a16c">More...</a><br /></td></tr>
<tr class="separator:ga1a06c1a51568cc60c9699b083876a16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3c32deec0eb7a70975316c73614dcca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac3c32deec0eb7a70975316c73614dcca">regina::NormalSurface::countCoords</a> () const</td></tr>
<tr class="memdesc:gac3c32deec0eb7a70975316c73614dcca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used.  <a href="group__surfaces.html#gac3c32deec0eb7a70975316c73614dcca">More...</a><br /></td></tr>
<tr class="separator:gac3c32deec0eb7a70975316c73614dcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78737ee6d2d74ef5b7b5d9748a0daa10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga78737ee6d2d74ef5b7b5d9748a0daa10">regina::NormalSurface::triangulation</a> () const</td></tr>
<tr class="memdesc:ga78737ee6d2d74ef5b7b5d9748a0daa10"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal surface resides.  <a href="group__surfaces.html#ga78737ee6d2d74ef5b7b5d9748a0daa10">More...</a><br /></td></tr>
<tr class="separator:ga78737ee6d2d74ef5b7b5d9748a0daa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b66f7c42869115a48a9260432252e4b"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1b66f7c42869115a48a9260432252e4b">regina::NormalSurface::name</a> () const</td></tr>
<tr class="memdesc:ga1b66f7c42869115a48a9260432252e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal surface.  <a href="group__surfaces.html#ga1b66f7c42869115a48a9260432252e4b">More...</a><br /></td></tr>
<tr class="separator:ga1b66f7c42869115a48a9260432252e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5317f117563f37bd5486fed52b6cf81e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5317f117563f37bd5486fed52b6cf81e">regina::NormalSurface::setName</a> (const std::string &amp;newName)</td></tr>
<tr class="memdesc:ga5317f117563f37bd5486fed52b6cf81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name associated with this normal surface.  <a href="group__surfaces.html#ga5317f117563f37bd5486fed52b6cf81e">More...</a><br /></td></tr>
<tr class="separator:ga5317f117563f37bd5486fed52b6cf81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b1867108288341c2706866539106fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga81b1867108288341c2706866539106fa">regina::NormalSurface::writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga81b1867108288341c2706866539106fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes this surface to the given output stream, using standard triangle-quad-oct coordinates.  <a href="group__surfaces.html#ga81b1867108288341c2706866539106fa">More...</a><br /></td></tr>
<tr class="separator:ga81b1867108288341c2706866539106fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c634e7cf69ee372834d25107d8b1d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7c634e7cf69ee372834d25107d8b1d69">regina::NormalSurface::writeRawVector</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga7c634e7cf69ee372834d25107d8b1d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the underlying coordinate vector to the given output stream in text format.  <a href="group__surfaces.html#ga7c634e7cf69ee372834d25107d8b1d69">More...</a><br /></td></tr>
<tr class="separator:ga7c634e7cf69ee372834d25107d8b1d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab649c72e89a76adcddbe5afb8ceae23b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab649c72e89a76adcddbe5afb8ceae23b">regina::NormalSurface::writeXMLData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:gab649c72e89a76adcddbe5afb8ceae23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing this normal surface and all of its properties.  <a href="group__surfaces.html#gab649c72e89a76adcddbe5afb8ceae23b">More...</a><br /></td></tr>
<tr class="separator:gab649c72e89a76adcddbe5afb8ceae23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad24929a9b7ed24295c1010b205179b2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad24929a9b7ed24295c1010b205179b2c">regina::NormalSurface::isEmpty</a> () const</td></tr>
<tr class="memdesc:gad24929a9b7ed24295c1010b205179b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface is empty (has no discs whatsoever).  <a href="group__surfaces.html#gad24929a9b7ed24295c1010b205179b2c">More...</a><br /></td></tr>
<tr class="separator:gad24929a9b7ed24295c1010b205179b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40abc1a8ab16f13d8108df83290ec013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga40abc1a8ab16f13d8108df83290ec013">regina::NormalSurface::isCompact</a> () const</td></tr>
<tr class="memdesc:ga40abc1a8ab16f13d8108df83290ec013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface is compact (has finitely many discs).  <a href="group__surfaces.html#ga40abc1a8ab16f13d8108df83290ec013">More...</a><br /></td></tr>
<tr class="separator:ga40abc1a8ab16f13d8108df83290ec013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa553c0aff30c704a13d4833f84263c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa553c0aff30c704a13d4833f84263c7a">regina::NormalSurface::eulerChar</a> () const</td></tr>
<tr class="memdesc:gaa553c0aff30c704a13d4833f84263c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this surface.  <a href="group__surfaces.html#gaa553c0aff30c704a13d4833f84263c7a">More...</a><br /></td></tr>
<tr class="separator:gaa553c0aff30c704a13d4833f84263c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58653ebccb7decb1d64d1ac20f87ea5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga58653ebccb7decb1d64d1ac20f87ea5f">regina::NormalSurface::isOrientable</a> () const</td></tr>
<tr class="memdesc:ga58653ebccb7decb1d64d1ac20f87ea5f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is orientable.  <a href="group__surfaces.html#ga58653ebccb7decb1d64d1ac20f87ea5f">More...</a><br /></td></tr>
<tr class="separator:ga58653ebccb7decb1d64d1ac20f87ea5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga116c8925b42deeee786f3d4642b5bfd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga116c8925b42deeee786f3d4642b5bfd7">regina::NormalSurface::isTwoSided</a> () const</td></tr>
<tr class="memdesc:ga116c8925b42deeee786f3d4642b5bfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is two-sided.  <a href="group__surfaces.html#ga116c8925b42deeee786f3d4642b5bfd7">More...</a><br /></td></tr>
<tr class="separator:ga116c8925b42deeee786f3d4642b5bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de9cd3d6628242dff5c7248c5bcb62c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8de9cd3d6628242dff5c7248c5bcb62c">regina::NormalSurface::isConnected</a> () const</td></tr>
<tr class="memdesc:ga8de9cd3d6628242dff5c7248c5bcb62c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is connected.  <a href="group__surfaces.html#ga8de9cd3d6628242dff5c7248c5bcb62c">More...</a><br /></td></tr>
<tr class="separator:ga8de9cd3d6628242dff5c7248c5bcb62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0015d445ca92c0e77a8f8638ac9e562a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga0015d445ca92c0e77a8f8638ac9e562a">regina::NormalSurface::hasRealBoundary</a> () const</td></tr>
<tr class="memdesc:ga0015d445ca92c0e77a8f8638ac9e562a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this surface has any real boundary, that is, whether it meets any boundary triangles of the triangulation.  <a href="group__surfaces.html#ga0015d445ca92c0e77a8f8638ac9e562a">More...</a><br /></td></tr>
<tr class="separator:ga0015d445ca92c0e77a8f8638ac9e562a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ab8b0a34b4c8a0847aba54974f1c009"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8ab8b0a34b4c8a0847aba54974f1c009">regina::NormalSurface::isVertexLinking</a> () const</td></tr>
<tr class="memdesc:ga8ab8b0a34b4c8a0847aba54974f1c009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is vertex linking.  <a href="group__surfaces.html#ga8ab8b0a34b4c8a0847aba54974f1c009">More...</a><br /></td></tr>
<tr class="separator:ga8ab8b0a34b4c8a0847aba54974f1c009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf98616d2b0b270a6a427133d3cd88cae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf98616d2b0b270a6a427133d3cd88cae">regina::NormalSurface::isVertexLink</a> () const</td></tr>
<tr class="memdesc:gaf98616d2b0b270a6a427133d3cd88cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this surface is the link of a single vertex.  <a href="group__surfaces.html#gaf98616d2b0b270a6a427133d3cd88cae">More...</a><br /></td></tr>
<tr class="separator:gaf98616d2b0b270a6a427133d3cd88cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82721dfe41b187548593091b7274e6e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab82721dfe41b187548593091b7274e6e">regina::NormalSurface::isThinEdgeLink</a> () const</td></tr>
<tr class="memdesc:gab82721dfe41b187548593091b7274e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not a rational multiple of this surface is the thin link of a single edge.  <a href="group__surfaces.html#gab82721dfe41b187548593091b7274e6e">More...</a><br /></td></tr>
<tr class="separator:gab82721dfe41b187548593091b7274e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga330f08b68053b89d2545c0027bbc3405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga330f08b68053b89d2545c0027bbc3405">regina::NormalSurface::isSplitting</a> () const</td></tr>
<tr class="memdesc:ga330f08b68053b89d2545c0027bbc3405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is a splitting surface.  <a href="group__surfaces.html#ga330f08b68053b89d2545c0027bbc3405">More...</a><br /></td></tr>
<tr class="separator:ga330f08b68053b89d2545c0027bbc3405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189f95fd5f3a632adb38a0fc6139cd81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga189f95fd5f3a632adb38a0fc6139cd81">regina::NormalSurface::isCentral</a> () const</td></tr>
<tr class="memdesc:ga189f95fd5f3a632adb38a0fc6139cd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not this surface is a central surface.  <a href="group__surfaces.html#ga189f95fd5f3a632adb38a0fc6139cd81">More...</a><br /></td></tr>
<tr class="separator:ga189f95fd5f3a632adb38a0fc6139cd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8ccd5e4c57c74080dcc2b2e37a75eeb0">regina::NormalSurface::countBoundaries</a> () const</td></tr>
<tr class="memdesc:ga8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of disjoint boundary curves on this surface.  <a href="group__surfaces.html#ga8ccd5e4c57c74080dcc2b2e37a75eeb0">More...</a><br /></td></tr>
<tr class="separator:ga8ccd5e4c57c74080dcc2b2e37a75eeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793261174b6628c83659b523b84ab943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga793261174b6628c83659b523b84ab943">regina::NormalSurface::isCompressingDisc</a> (bool knownConnected=false) const</td></tr>
<tr class="memdesc:ga793261174b6628c83659b523b84ab943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface represents a compressing disc in the underlying 3-manifold.  <a href="group__surfaces.html#ga793261174b6628c83659b523b84ab943">More...</a><br /></td></tr>
<tr class="separator:ga793261174b6628c83659b523b84ab943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40448875fc5e68801492acfd10dc680b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga40448875fc5e68801492acfd10dc680b">regina::NormalSurface::isIncompressible</a> () const</td></tr>
<tr class="memdesc:ga40448875fc5e68801492acfd10dc680b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is an incompressible surface within the surrounding 3-manifold.  <a href="group__surfaces.html#ga40448875fc5e68801492acfd10dc680b">More...</a><br /></td></tr>
<tr class="separator:ga40448875fc5e68801492acfd10dc680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32842aede0b65c4e3c80c73e3216cdb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga32842aede0b65c4e3c80c73e3216cdb4">regina::NormalSurface::cutAlong</a> () const</td></tr>
<tr class="memdesc:ga32842aede0b65c4e3c80c73e3216cdb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts the associated triangulation along this surface and returns a newly created resulting triangulation.  <a href="group__surfaces.html#ga32842aede0b65c4e3c80c73e3216cdb4">More...</a><br /></td></tr>
<tr class="separator:ga32842aede0b65c4e3c80c73e3216cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54bd5ac2fff434e5124b15ecc6c25b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga54bd5ac2fff434e5124b15ecc6c25b79">regina::NormalSurface::crush</a> () const</td></tr>
<tr class="memdesc:ga54bd5ac2fff434e5124b15ecc6c25b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crushes this surface to a point in the associated triangulation and returns a newly created resulting triangulation.  <a href="group__surfaces.html#ga54bd5ac2fff434e5124b15ecc6c25b79">More...</a><br /></td></tr>
<tr class="separator:ga54bd5ac2fff434e5124b15ecc6c25b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga042f4e0908964b3cec8fcf336f147f22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga042f4e0908964b3cec8fcf336f147f22">regina::NormalSurface::sameSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:ga042f4e0908964b3cec8fcf336f147f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface in fact represent the same normal (or almost normal) surface.  <a href="group__surfaces.html#ga042f4e0908964b3cec8fcf336f147f22">More...</a><br /></td></tr>
<tr class="separator:ga042f4e0908964b3cec8fcf336f147f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8803a3a19f5a6f7db0c2ae0e18499bfa">regina::NormalSurface::normal</a> () const</td></tr>
<tr class="memdesc:ga8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface contains only triangle and/or quadrilateral discs.  <a href="group__surfaces.html#ga8803a3a19f5a6f7db0c2ae0e18499bfa">More...</a><br /></td></tr>
<tr class="separator:ga8803a3a19f5a6f7db0c2ae0e18499bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcf349ea8b66bf635454d805af45bc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacfcf349ea8b66bf635454d805af45bc9">regina::NormalSurface::embedded</a> () const</td></tr>
<tr class="memdesc:gacfcf349ea8b66bf635454d805af45bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this surface is embedded.  <a href="group__surfaces.html#gacfcf349ea8b66bf635454d805af45bc9">More...</a><br /></td></tr>
<tr class="separator:gacfcf349ea8b66bf635454d805af45bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa1aa3f944bc8cd084d2a00aadc0f0eb2">regina::NormalSurface::locallyCompatible</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:gaa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface are locally compatible.  <a href="group__surfaces.html#gaa1aa3f944bc8cd084d2a00aadc0f0eb2">More...</a><br /></td></tr>
<tr class="separator:gaa1aa3f944bc8cd084d2a00aadc0f0eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bda2f060aca3d7228ce8758f67eefeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7bda2f060aca3d7228ce8758f67eefeb">regina::NormalSurface::disjoint</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;other) const</td></tr>
<tr class="memdesc:ga7bda2f060aca3d7228ce8758f67eefeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this and the given surface can be placed within the surrounding triangulation so that they do not intersect anywhere at all, without changing either normal isotopy class.  <a href="group__surfaces.html#ga7bda2f060aca3d7228ce8758f67eefeb">More...</a><br /></td></tr>
<tr class="separator:ga7bda2f060aca3d7228ce8758f67eefeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6b0e73ae35e166dc07e3ac1cd54cae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga0b6b0e73ae35e166dc07e3ac1cd54cae">regina::NormalSurface::boundaryIntersections</a> () const</td></tr>
<tr class="memdesc:ga0b6b0e73ae35e166dc07e3ac1cd54cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the information about the boundary slopes of this surface at each cusp of the triangulation.  <a href="group__surfaces.html#ga0b6b0e73ae35e166dc07e3ac1cd54cae">More...</a><br /></td></tr>
<tr class="separator:ga0b6b0e73ae35e166dc07e3ac1cd54cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b0d740fe1591e8aa622a3c6d5eeab6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga09b0d740fe1591e8aa622a3c6d5eeab6">regina::NormalSurface::rawVector</a> () const</td></tr>
<tr class="memdesc:ga09b0d740fe1591e8aa622a3c6d5eeab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives read-only access to the raw vector that sits beneath this normal surface.  <a href="group__surfaces.html#ga09b0d740fe1591e8aa622a3c6d5eeab6">More...</a><br /></td></tr>
<tr class="separator:ga09b0d740fe1591e8aa622a3c6d5eeab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca77e328a62cce379c0ab4815caffd8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaca77e328a62cce379c0ab4815caffd8d">regina::NormalSurface::systemAllowsAlmostNormal</a> () const</td></tr>
<tr class="memdesc:gaca77e328a62cce379c0ab4815caffd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the underlying coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="group__surfaces.html#gaca77e328a62cce379c0ab4815caffd8d">More...</a><br /></td></tr>
<tr class="separator:gaca77e328a62cce379c0ab4815caffd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1599fbfed6929c341d4be8aa502f2346"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1599fbfed6929c341d4be8aa502f2346">regina::NormalSurface::systemAllowsSpun</a> () const</td></tr>
<tr class="memdesc:ga1599fbfed6929c341d4be8aa502f2346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the underlying coordinate system being used allows for spun normal surfaces.  <a href="group__surfaces.html#ga1599fbfed6929c341d4be8aa502f2346">More...</a><br /></td></tr>
<tr class="separator:ga1599fbfed6929c341d4be8aa502f2346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8041fb1a328bbea67533be9ba597f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadc8041fb1a328bbea67533be9ba597f3">regina::NormalSurface::systemAllowsOriented</a> () const</td></tr>
<tr class="memdesc:gadc8041fb1a328bbea67533be9ba597f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the underlying coordinate system being used allows for transversely oriented normal surfaces.  <a href="group__surfaces.html#gadc8041fb1a328bbea67533be9ba597f3">More...</a><br /></td></tr>
<tr class="separator:gadc8041fb1a328bbea67533be9ba597f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa619d75e08df3c56a4ceb6e03122af7a"><td class="memItemLeft" align="right" valign="top"><a id="gaa619d75e08df3c56a4ceb6e03122af7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurface::NormalSurface</b> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;)=delete</td></tr>
<tr class="separator:gaa619d75e08df3c56a4ceb6e03122af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e2b9201704d6db18a95de6689440523"><td class="memItemLeft" align="right" valign="top"><a id="ga1e2b9201704d6db18a95de6689440523"></a>
<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurface::operator=</b> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;)=delete</td></tr>
<tr class="separator:ga1e2b9201704d6db18a95de6689440523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cfc95271eee926bea070c37f12d94bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6cfc95271eee926bea070c37f12d94bc">regina::NormalSurface::calculateOctPosition</a> () const</td></tr>
<tr class="memdesc:ga6cfc95271eee926bea070c37f12d94bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the position of the first non-zero octagon coordinate and stores it as a property.  <a href="group__surfaces.html#ga6cfc95271eee926bea070c37f12d94bc">More...</a><br /></td></tr>
<tr class="separator:ga6cfc95271eee926bea070c37f12d94bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9e3815b9c61458d68bb7bf195ca21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2c9e3815b9c61458d68bb7bf195ca21a">regina::NormalSurface::calculateEulerChar</a> () const</td></tr>
<tr class="memdesc:ga2c9e3815b9c61458d68bb7bf195ca21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Euler characteristic of this surface and stores it as a property.  <a href="group__surfaces.html#ga2c9e3815b9c61458d68bb7bf195ca21a">More...</a><br /></td></tr>
<tr class="separator:ga2c9e3815b9c61458d68bb7bf195ca21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ca0dcbd2425783033c88d4082b8c247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5ca0dcbd2425783033c88d4082b8c247">regina::NormalSurface::calculateOrientable</a> () const</td></tr>
<tr class="memdesc:ga5ca0dcbd2425783033c88d4082b8c247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates whether this surface is orientable and/or two-sided and stores the results as properties.  <a href="group__surfaces.html#ga5ca0dcbd2425783033c88d4082b8c247">More...</a><br /></td></tr>
<tr class="separator:ga5ca0dcbd2425783033c88d4082b8c247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ea8973551e9dc69d3e321f6d05ec4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae3ea8973551e9dc69d3e321f6d05ec4d">regina::NormalSurface::calculateRealBoundary</a> () const</td></tr>
<tr class="memdesc:gae3ea8973551e9dc69d3e321f6d05ec4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates whether this surface has any real boundary and stores the result as a property.  <a href="group__surfaces.html#gae3ea8973551e9dc69d3e321f6d05ec4d">More...</a><br /></td></tr>
<tr class="separator:gae3ea8973551e9dc69d3e321f6d05ec4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b5766df28d3440415fb1e055fa47be5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8b5766df28d3440415fb1e055fa47be5">regina::NormalSurface::calculateBoundaries</a> () const</td></tr>
<tr class="memdesc:ga8b5766df28d3440415fb1e055fa47be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the number of disjoint boundary curves and stores the result as a property.  <a href="group__surfaces.html#ga8b5766df28d3440415fb1e055fa47be5">More...</a><br /></td></tr>
<tr class="separator:ga8b5766df28d3440415fb1e055fa47be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275289f18f2ae608d8f2d573967f63bb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga275289f18f2ae608d8f2d573967f63bb">regina::NormalSurfaces::~NormalSurfaces</a> ()</td></tr>
<tr class="memdesc:ga275289f18f2ae608d8f2d573967f63bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this list and all the surfaces within.  <a href="group__surfaces.html#ga275289f18f2ae608d8f2d573967f63bb">More...</a><br /></td></tr>
<tr class="separator:ga275289f18f2ae608d8f2d573967f63bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64309eac6ce681355dfc352c53299535"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535">regina::NormalSurfaces::enumerate</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *owner, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="group__surfaces.html#gada70246d67b766fd35a224bd561ee071">coords</a>, <a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> <a class="el" href="group__surfaces.html#ga2a12326b8c6dfebfefe97b34b15920c7">which</a>=<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">NS_LIST_DEFAULT</a>, <a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> algHints=<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">NS_ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:ga64309eac6ce681355dfc352c53299535"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unified routine for enumerating various classes of normal surfaces within a given triangulation.  <a href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535">More...</a><br /></td></tr>
<tr class="separator:ga64309eac6ce681355dfc352c53299535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada70246d67b766fd35a224bd561ee071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gada70246d67b766fd35a224bd561ee071">regina::NormalSurfaces::coords</a> () const</td></tr>
<tr class="memdesc:gada70246d67b766fd35a224bd561ee071"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system being used by the surfaces stored in this set.  <a href="group__surfaces.html#gada70246d67b766fd35a224bd561ee071">More...</a><br /></td></tr>
<tr class="separator:gada70246d67b766fd35a224bd561ee071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a12326b8c6dfebfefe97b34b15920c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2a12326b8c6dfebfefe97b34b15920c7">regina::NormalSurfaces::which</a> () const</td></tr>
<tr class="memdesc:ga2a12326b8c6dfebfefe97b34b15920c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of which normal surfaces this list represents within the underlying triangulation.  <a href="group__surfaces.html#ga2a12326b8c6dfebfefe97b34b15920c7">More...</a><br /></td></tr>
<tr class="separator:ga2a12326b8c6dfebfefe97b34b15920c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb828ac80eb4538f156dfd63b4c30f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9fb828ac80eb4538f156dfd63b4c30f9">regina::NormalSurfaces::algorithm</a> () const</td></tr>
<tr class="memdesc:ga9fb828ac80eb4538f156dfd63b4c30f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the algorithm that was used to enumerate this list.  <a href="group__surfaces.html#ga9fb828ac80eb4538f156dfd63b4c30f9">More...</a><br /></td></tr>
<tr class="separator:ga9fb828ac80eb4538f156dfd63b4c30f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga286441732edb4692736f33e769489dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga286441732edb4692736f33e769489dde">regina::NormalSurfaces::allowsAlmostNormal</a> () const</td></tr>
<tr class="memdesc:ga286441732edb4692736f33e769489dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="group__surfaces.html#ga286441732edb4692736f33e769489dde">More...</a><br /></td></tr>
<tr class="separator:ga286441732edb4692736f33e769489dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f3529c33550ecf08dcd6d7a33409a8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga0f3529c33550ecf08dcd6d7a33409a8b">regina::NormalSurfaces::allowsSpun</a> () const</td></tr>
<tr class="memdesc:ga0f3529c33550ecf08dcd6d7a33409a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system being used allows for spun normal surfaces.  <a href="group__surfaces.html#ga0f3529c33550ecf08dcd6d7a33409a8b">More...</a><br /></td></tr>
<tr class="separator:ga0f3529c33550ecf08dcd6d7a33409a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bbcbedabcb93d26a3cd50eee857f27f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4bbcbedabcb93d26a3cd50eee857f27f">regina::NormalSurfaces::allowsOriented</a> () const</td></tr>
<tr class="memdesc:ga4bbcbedabcb93d26a3cd50eee857f27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system being used allows for transversely oriented normal surfaces.  <a href="group__surfaces.html#ga4bbcbedabcb93d26a3cd50eee857f27f">More...</a><br /></td></tr>
<tr class="separator:ga4bbcbedabcb93d26a3cd50eee857f27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4235db32ccba3f9f49e8b668afb8ad85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4235db32ccba3f9f49e8b668afb8ad85">regina::NormalSurfaces::isEmbeddedOnly</a> () const</td></tr>
<tr class="memdesc:ga4235db32ccba3f9f49e8b668afb8ad85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was constructed to contain only properly embedded surfaces.  <a href="group__surfaces.html#ga4235db32ccba3f9f49e8b668afb8ad85">More...</a><br /></td></tr>
<tr class="separator:ga4235db32ccba3f9f49e8b668afb8ad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa808164e874f88896ac40703b6409c36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa808164e874f88896ac40703b6409c36">regina::NormalSurfaces::triangulation</a> () const</td></tr>
<tr class="memdesc:gaa808164e874f88896ac40703b6409c36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which these normal surfaces live.  <a href="group__surfaces.html#gaa808164e874f88896ac40703b6409c36">More...</a><br /></td></tr>
<tr class="separator:gaa808164e874f88896ac40703b6409c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aae88a4f82d88e1ed542f17d26904d7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga0aae88a4f82d88e1ed542f17d26904d7">regina::NormalSurfaces::size</a> () const</td></tr>
<tr class="memdesc:ga0aae88a4f82d88e1ed542f17d26904d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of surfaces stored in this list.  <a href="group__surfaces.html#ga0aae88a4f82d88e1ed542f17d26904d7">More...</a><br /></td></tr>
<tr class="separator:ga0aae88a4f82d88e1ed542f17d26904d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa75527d87d83254739c7e52175546acf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa75527d87d83254739c7e52175546acf">regina::NormalSurfaces::surface</a> (size_t index) const</td></tr>
<tr class="memdesc:gaa75527d87d83254739c7e52175546acf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the surface at the requested index in this set.  <a href="group__surfaces.html#gaa75527d87d83254739c7e52175546acf">More...</a><br /></td></tr>
<tr class="separator:gaa75527d87d83254739c7e52175546acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga564d43bd562cadba9bddbcd960d77596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga564d43bd562cadba9bddbcd960d77596">regina::NormalSurfaces::writeAllSurfaces</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga564d43bd562cadba9bddbcd960d77596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the number of surfaces in this set followed by the details of each surface to the given output stream.  <a href="group__surfaces.html#ga564d43bd562cadba9bddbcd960d77596">More...</a><br /></td></tr>
<tr class="separator:ga564d43bd562cadba9bddbcd960d77596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6801fb032b55c800bb82e89fce2bbe71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6801fb032b55c800bb82e89fce2bbe71">regina::NormalSurfaces::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga6801fb032b55c800bb82e89fce2bbe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__surfaces.html#ga6801fb032b55c800bb82e89fce2bbe71">More...</a><br /></td></tr>
<tr class="separator:ga6801fb032b55c800bb82e89fce2bbe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad07dcdec28b20348705f8cec15838957"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad07dcdec28b20348705f8cec15838957">regina::NormalSurfaces::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gad07dcdec28b20348705f8cec15838957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__surfaces.html#gad07dcdec28b20348705f8cec15838957">More...</a><br /></td></tr>
<tr class="separator:gad07dcdec28b20348705f8cec15838957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e8ee06f16ca9ceacc610b0e58c0d08"><td class="memItemLeft" align="right" valign="top"><a id="ga32e8ee06f16ca9ceacc610b0e58c0d08"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurfaces::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ga32e8ee06f16ca9ceacc610b0e58c0d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33634993b549ee12249b97a019fe002"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad33634993b549ee12249b97a019fe002">regina::NormalSurfaces::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:gad33634993b549ee12249b97a019fe002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__surfaces.html#gad33634993b549ee12249b97a019fe002">More...</a><br /></td></tr>
<tr class="separator:gad33634993b549ee12249b97a019fe002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga923d837b8eb709fd079d4ec8e5f30889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga923d837b8eb709fd079d4ec8e5f30889">regina::NormalSurfaces::quadToStandard</a> () const</td></tr>
<tr class="memdesc:ga923d837b8eb709fd079d4ec8e5f30889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embedded vertex normal surfaces in standard (tri-quad) space.  <a href="group__surfaces.html#ga923d837b8eb709fd079d4ec8e5f30889">More...</a><br /></td></tr>
<tr class="separator:ga923d837b8eb709fd079d4ec8e5f30889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e160a2b7934ad098ab2252adfd128db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8e160a2b7934ad098ab2252adfd128db">regina::NormalSurfaces::quadOctToStandardAN</a> () const</td></tr>
<tr class="memdesc:ga8e160a2b7934ad098ab2252adfd128db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space to the set of all embedded vertex almost normal surfaces in the standard tri-quad-oct space.  <a href="group__surfaces.html#ga8e160a2b7934ad098ab2252adfd128db">More...</a><br /></td></tr>
<tr class="separator:ga8e160a2b7934ad098ab2252adfd128db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ffe41e50f214351ee2086ef600661a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga92ffe41e50f214351ee2086ef600661a">regina::NormalSurfaces::standardToQuad</a> () const</td></tr>
<tr class="memdesc:ga92ffe41e50f214351ee2086ef600661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of all embedded vertex normal surfaces in quadrilateral space.  <a href="group__surfaces.html#ga92ffe41e50f214351ee2086ef600661a">More...</a><br /></td></tr>
<tr class="separator:ga92ffe41e50f214351ee2086ef600661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3212b3ec1451db0bcc98871c65d78937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3212b3ec1451db0bcc98871c65d78937">regina::NormalSurfaces::standardANToQuadOct</a> () const</td></tr>
<tr class="memdesc:ga3212b3ec1451db0bcc98871c65d78937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space to the set of all embedded vertex almost normal surfaces in the smaller quadrilateral-octagon space.  <a href="group__surfaces.html#ga3212b3ec1451db0bcc98871c65d78937">More...</a><br /></td></tr>
<tr class="separator:ga3212b3ec1451db0bcc98871c65d78937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2995d136dc8e575605230cec31dd8c9"><td class="memTemplParams" colspan="2">template&lt;typename Comparison &gt; </td></tr>
<tr class="memitem:gae2995d136dc8e575605230cec31dd8c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae2995d136dc8e575605230cec31dd8c9">regina::NormalSurfaces::sort</a> (Comparison &amp;&amp;comp)</td></tr>
<tr class="memdesc:gae2995d136dc8e575605230cec31dd8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the surfaces in this list according to the given criterion.  <a href="group__surfaces.html#gae2995d136dc8e575605230cec31dd8c9">More...</a><br /></td></tr>
<tr class="separator:gae2995d136dc8e575605230cec31dd8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8c9723cc44bf8da34f136eb7c27a835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae8c9723cc44bf8da34f136eb7c27a835">regina::NormalSurfaces::filterForLocallyCompatiblePairs</a> () const</td></tr>
<tr class="memdesc:gae8c9723cc44bf8da34f136eb7c27a835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list filled with the surfaces from this list that have at least one locally compatible partner.  <a href="group__surfaces.html#gae8c9723cc44bf8da34f136eb7c27a835">More...</a><br /></td></tr>
<tr class="separator:gae8c9723cc44bf8da34f136eb7c27a835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9324d55752c936e253e9c36cce704908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9324d55752c936e253e9c36cce704908">regina::NormalSurfaces::filterForDisjointPairs</a> () const</td></tr>
<tr class="memdesc:ga9324d55752c936e253e9c36cce704908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list filled with the surfaces from this list that have at least one disjoint partner.  <a href="group__surfaces.html#ga9324d55752c936e253e9c36cce704908">More...</a><br /></td></tr>
<tr class="separator:ga9324d55752c936e253e9c36cce704908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ed23bbdd0688519b1eb4a3077cec118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7ed23bbdd0688519b1eb4a3077cec118">regina::NormalSurfaces::filterForPotentiallyIncompressible</a> () const</td></tr>
<tr class="memdesc:ga7ed23bbdd0688519b1eb4a3077cec118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list filled with only the surfaces from this list that "might" represent two-sided incompressible surfaces.  <a href="group__surfaces.html#ga7ed23bbdd0688519b1eb4a3077cec118">More...</a><br /></td></tr>
<tr class="separator:ga7ed23bbdd0688519b1eb4a3077cec118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1959b9dcedd0e35e00320f0490eaf75c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1959b9dcedd0e35e00320f0490eaf75c">regina::NormalSurfaces::recreateMatchingEquations</a> () const</td></tr>
<tr class="memdesc:ga1959b9dcedd0e35e00320f0490eaf75c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created matrix containing the matching equations that were used to create this normal surface list.  <a href="group__surfaces.html#ga1959b9dcedd0e35e00320f0490eaf75c">More...</a><br /></td></tr>
<tr class="separator:ga1959b9dcedd0e35e00320f0490eaf75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b308eb9fd7a131b2c370a589b7e43c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2b308eb9fd7a131b2c370a589b7e43c6">regina::NormalSurfaces::saveCSVStandard</a> (const char *filename, int additionalFields=<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a>)</td></tr>
<tr class="memdesc:ga2b308eb9fd7a131b2c370a589b7e43c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this list of normal surfaces as a plain text CSV (comma-separated value) file, using standard coordinates.  <a href="group__surfaces.html#ga2b308eb9fd7a131b2c370a589b7e43c6">More...</a><br /></td></tr>
<tr class="separator:ga2b308eb9fd7a131b2c370a589b7e43c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2559f5cea6339eb69cdcc532f970409"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae2559f5cea6339eb69cdcc532f970409">regina::NormalSurfaces::saveCSVEdgeWeight</a> (const char *filename, int additionalFields=<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a>)</td></tr>
<tr class="memdesc:gae2559f5cea6339eb69cdcc532f970409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file, using edge weight coordinates.  <a href="group__surfaces.html#gae2559f5cea6339eb69cdcc532f970409">More...</a><br /></td></tr>
<tr class="separator:gae2559f5cea6339eb69cdcc532f970409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8da79103f921bee2f52e6fdb39eb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadb8da79103f921bee2f52e6fdb39eb2e">regina::NormalSurfaces::beginVectors</a> () const</td></tr>
<tr class="memdesc:gadb8da79103f921bee2f52e6fdb39eb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that gives access to the raw vectors for surfaces in this list, pointing to the beginning of this surface list.  <a href="group__surfaces.html#gadb8da79103f921bee2f52e6fdb39eb2e">More...</a><br /></td></tr>
<tr class="separator:gadb8da79103f921bee2f52e6fdb39eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga268c1848908924fc19644b83309beeba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga268c1848908924fc19644b83309beeba">regina::NormalSurfaces::endVectors</a> () const</td></tr>
<tr class="memdesc:ga268c1848908924fc19644b83309beeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that gives access to the raw vectors for surfaces in this list, pointing past the end of this surface list.  <a href="group__surfaces.html#ga268c1848908924fc19644b83309beeba">More...</a><br /></td></tr>
<tr class="separator:ga268c1848908924fc19644b83309beeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade510664f6841bdd0b58cd915c11973d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gade510664f6841bdd0b58cd915c11973d">regina::NormalSurfaces::VectorIterator::VectorIterator</a> ()</td></tr>
<tr class="memdesc:gade510664f6841bdd0b58cd915c11973d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised iterator.  <a href="group__surfaces.html#gade510664f6841bdd0b58cd915c11973d">More...</a><br /></td></tr>
<tr class="separator:gade510664f6841bdd0b58cd915c11973d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22405b33052439f4ebabe8976bb09a11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga22405b33052439f4ebabe8976bb09a11">regina::NormalSurfaces::VectorIterator::VectorIterator</a> (const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga22405b33052439f4ebabe8976bb09a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of the given iterator.  <a href="group__surfaces.html#ga22405b33052439f4ebabe8976bb09a11">More...</a><br /></td></tr>
<tr class="separator:ga22405b33052439f4ebabe8976bb09a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc514e989a1cda7e3b9c20c4fb8e47fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacc514e989a1cda7e3b9c20c4fb8e47fc">regina::NormalSurfaces::VectorIterator::operator=</a> (const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gacc514e989a1cda7e3b9c20c4fb8e47fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes this a copy of the given iterator.  <a href="group__surfaces.html#gacc514e989a1cda7e3b9c20c4fb8e47fc">More...</a><br /></td></tr>
<tr class="separator:gacc514e989a1cda7e3b9c20c4fb8e47fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad108577407a2ac094d75bf5049ee6283"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad108577407a2ac094d75bf5049ee6283">regina::NormalSurfaces::VectorIterator::operator==</a> (const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:gad108577407a2ac094d75bf5049ee6283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this with the given operator for equality.  <a href="group__surfaces.html#gad108577407a2ac094d75bf5049ee6283">More...</a><br /></td></tr>
<tr class="separator:gad108577407a2ac094d75bf5049ee6283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3b222d9111814ce53422650e674f2fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab3b222d9111814ce53422650e674f2fc">regina::NormalSurfaces::VectorIterator::operator!=</a> (const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:gab3b222d9111814ce53422650e674f2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares this with the given operator for inequality.  <a href="group__surfaces.html#gab3b222d9111814ce53422650e674f2fc">More...</a><br /></td></tr>
<tr class="separator:gab3b222d9111814ce53422650e674f2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3583f22c3ebd8e559905848cb376e4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4a3583f22c3ebd8e559905848cb376e4">regina::NormalSurfaces::VectorIterator::operator*</a> () const</td></tr>
<tr class="memdesc:ga4a3583f22c3ebd8e559905848cb376e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the raw vector for the normal surface that this iterator is currently pointing to.  <a href="group__surfaces.html#ga4a3583f22c3ebd8e559905848cb376e4">More...</a><br /></td></tr>
<tr class="separator:ga4a3583f22c3ebd8e559905848cb376e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ce2d083cec79ff7c832abfd83ebd083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8ce2d083cec79ff7c832abfd83ebd083">regina::NormalSurfaces::VectorIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga8ce2d083cec79ff7c832abfd83ebd083"><td class="mdescLeft">&#160;</td><td class="mdescRight">The preincrement operator.  <a href="group__surfaces.html#ga8ce2d083cec79ff7c832abfd83ebd083">More...</a><br /></td></tr>
<tr class="separator:ga8ce2d083cec79ff7c832abfd83ebd083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844efec467431256e547cf052cc9b96f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga844efec467431256e547cf052cc9b96f">regina::NormalSurfaces::VectorIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:ga844efec467431256e547cf052cc9b96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The postincrement operator.  <a href="group__surfaces.html#ga844efec467431256e547cf052cc9b96f">More...</a><br /></td></tr>
<tr class="separator:ga844efec467431256e547cf052cc9b96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc3d7940d6bd69b8e658e97cfbba3e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadc3d7940d6bd69b8e658e97cfbba3e28">regina::NormalSurfaces::VectorIterator::operator--</a> ()</td></tr>
<tr class="memdesc:gadc3d7940d6bd69b8e658e97cfbba3e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">The predecrement operator.  <a href="group__surfaces.html#gadc3d7940d6bd69b8e658e97cfbba3e28">More...</a><br /></td></tr>
<tr class="separator:gadc3d7940d6bd69b8e658e97cfbba3e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f35a5fe4dcc7f2eca37e0b6f19020bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5f35a5fe4dcc7f2eca37e0b6f19020bf">regina::NormalSurfaces::VectorIterator::operator--</a> (int)</td></tr>
<tr class="memdesc:ga5f35a5fe4dcc7f2eca37e0b6f19020bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The postdecrement operator.  <a href="group__surfaces.html#ga5f35a5fe4dcc7f2eca37e0b6f19020bf">More...</a><br /></td></tr>
<tr class="separator:ga5f35a5fe4dcc7f2eca37e0b6f19020bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f3147bd0d010d26972dc3230334ca7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga58f3147bd0d010d26972dc3230334ca7">regina::NormalSurfaces::NormalSurfaces</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="group__surfaces.html#gada70246d67b766fd35a224bd561ee071">coords</a>, <a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> <a class="el" href="group__surfaces.html#ga2a12326b8c6dfebfefe97b34b15920c7">which</a>, <a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> <a class="el" href="group__surfaces.html#ga9fb828ac80eb4538f156dfd63b4c30f9">algorithm</a>)</td></tr>
<tr class="memdesc:ga58f3147bd0d010d26972dc3230334ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty list of normal surfaces with the given parameters.  <a href="group__surfaces.html#ga58f3147bd0d010d26972dc3230334ca7">More...</a><br /></td></tr>
<tr class="separator:ga58f3147bd0d010d26972dc3230334ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0ab53ae8085a452393a764bd8d5b27"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadc0ab53ae8085a452393a764bd8d5b27">regina::NormalSurfaces::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:gadc0ab53ae8085a452393a764bd8d5b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__surfaces.html#gadc0ab53ae8085a452393a764bd8d5b27">More...</a><br /></td></tr>
<tr class="separator:gadc0ab53ae8085a452393a764bd8d5b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5539ec7f016ba2e9fca94f00971f4c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa5539ec7f016ba2e9fca94f00971f4c3">regina::NormalSurfaces::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaa5539ec7f016ba2e9fca94f00971f4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__surfaces.html#gaa5539ec7f016ba2e9fca94f00971f4c3">More...</a><br /></td></tr>
<tr class="separator:gaa5539ec7f016ba2e9fca94f00971f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72bee275132d1b11faa5dceaad9d8253"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga72bee275132d1b11faa5dceaad9d8253">regina::NormalSurfaces::SurfaceInserter::SurfaceInserter</a> (<a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;newList, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newOwner)</td></tr>
<tr class="memdesc:ga72bee275132d1b11faa5dceaad9d8253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new output iterator.  <a href="group__surfaces.html#ga72bee275132d1b11faa5dceaad9d8253">More...</a><br /></td></tr>
<tr class="separator:ga72bee275132d1b11faa5dceaad9d8253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53984bd01650b45aa679e8051833dfc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga53984bd01650b45aa679e8051833dfc6">regina::NormalSurfaces::SurfaceInserter::SurfaceInserter</a> (const <a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga53984bd01650b45aa679e8051833dfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new output iterator that is a clone of the given iterator.  <a href="group__surfaces.html#ga53984bd01650b45aa679e8051833dfc6">More...</a><br /></td></tr>
<tr class="separator:ga53984bd01650b45aa679e8051833dfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac456a1c11b62d5ca892f31ff03dc4efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac456a1c11b62d5ca892f31ff03dc4efa">regina::NormalSurfaces::SurfaceInserter::operator=</a> (const <a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:gac456a1c11b62d5ca892f31ff03dc4efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this iterator to be a clone of the given output iterator.  <a href="group__surfaces.html#gac456a1c11b62d5ca892f31ff03dc4efa">More...</a><br /></td></tr>
<tr class="separator:gac456a1c11b62d5ca892f31ff03dc4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga668ae3f49cca1cb82ba53e13f22959bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga668ae3f49cca1cb82ba53e13f22959bd">regina::NormalSurfaces::SurfaceInserter::operator=</a> (<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *<a class="el" href="group__surfaces.html#gaa75527d87d83254739c7e52175546acf">surface</a>)</td></tr>
<tr class="memdesc:ga668ae3f49cca1cb82ba53e13f22959bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a normal surface to the end of the appropriate surface list.  <a href="group__surfaces.html#ga668ae3f49cca1cb82ba53e13f22959bd">More...</a><br /></td></tr>
<tr class="separator:ga668ae3f49cca1cb82ba53e13f22959bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac16cb2e647d865aca197f52cb88c7f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac16cb2e647d865aca197f52cb88c7f51">regina::NormalSurfaces::SurfaceInserter::operator=</a> (<a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *vector)</td></tr>
<tr class="memdesc:gac16cb2e647d865aca197f52cb88c7f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the normal surface corresponding to the given vector to the end of the appropriate surface list.  <a href="group__surfaces.html#gac16cb2e647d865aca197f52cb88c7f51">More...</a><br /></td></tr>
<tr class="separator:gac16cb2e647d865aca197f52cb88c7f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12c73fd3750e32ce0500baad9fe086bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga12c73fd3750e32ce0500baad9fe086bd">regina::NormalSurfaces::SurfaceInserter::operator*</a> ()</td></tr>
<tr class="memdesc:ga12c73fd3750e32ce0500baad9fe086bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__surfaces.html#ga12c73fd3750e32ce0500baad9fe086bd">More...</a><br /></td></tr>
<tr class="separator:ga12c73fd3750e32ce0500baad9fe086bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69d745738697d97ede9c4d8a11ac980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad69d745738697d97ede9c4d8a11ac980">regina::NormalSurfaces::SurfaceInserter::operator++</a> ()</td></tr>
<tr class="memdesc:gad69d745738697d97ede9c4d8a11ac980"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__surfaces.html#gad69d745738697d97ede9c4d8a11ac980">More...</a><br /></td></tr>
<tr class="separator:gad69d745738697d97ede9c4d8a11ac980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac318da056fb4edb935e29edec27f8a2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac318da056fb4edb935e29edec27f8a2a">regina::NormalSurfaces::SurfaceInserter::operator++</a> (int)</td></tr>
<tr class="memdesc:gac318da056fb4edb935e29edec27f8a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator.  <a href="group__surfaces.html#gac318da056fb4edb935e29edec27f8a2a">More...</a><br /></td></tr>
<tr class="separator:gac318da056fb4edb935e29edec27f8a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga584d2cbe4d00ee3151255fb7203dac1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga584d2cbe4d00ee3151255fb7203dac1b">regina::NormalSurfaces::Enumerator::Enumerator</a> (<a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *list, <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *eqns, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker)</td></tr>
<tr class="memdesc:ga584d2cbe4d00ee3151255fb7203dac1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new functor with the given parameters.  <a href="group__surfaces.html#ga584d2cbe4d00ee3151255fb7203dac1b">More...</a><br /></td></tr>
<tr class="separator:ga584d2cbe4d00ee3151255fb7203dac1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace0f87e66a8977a5ee6606aebe5e2ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaace0f87e66a8977a5ee6606aebe5e2ee">regina::NormalSurfaces::Enumerator::Enumerator</a> (Enumerator &amp;&amp;)=default</td></tr>
<tr class="memdesc:gaace0f87e66a8977a5ee6606aebe5e2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move constructor.  <a href="group__surfaces.html#gaace0f87e66a8977a5ee6606aebe5e2ee">More...</a><br /></td></tr>
<tr class="separator:gaace0f87e66a8977a5ee6606aebe5e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c4da67377d53ce270dd18259140cca0"><td class="memTemplParams" colspan="2">template&lt;typename Coords &gt; </td></tr>
<tr class="memitem:ga5c4da67377d53ce270dd18259140cca0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5c4da67377d53ce270dd18259140cca0">regina::NormalSurfaces::Enumerator::operator()</a> ()</td></tr>
<tr class="memdesc:ga5c4da67377d53ce270dd18259140cca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the real enumeration work, in a setting where the underlying coordinate system is a compile-time constant.  <a href="group__surfaces.html#ga5c4da67377d53ce270dd18259140cca0">More...</a><br /></td></tr>
<tr class="separator:ga5c4da67377d53ce270dd18259140cca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc842bd420bc685b3cd154e938b7bc88"><td class="memItemLeft" align="right" valign="top"><a id="gadc842bd420bc685b3cd154e938b7bc88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurfaces::Enumerator::Enumerator</b> (const Enumerator &amp;)=delete</td></tr>
<tr class="separator:gadc842bd420bc685b3cd154e938b7bc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908351b50591a13c446f5790e68fb433"><td class="memItemLeft" align="right" valign="top"><a id="ga908351b50591a13c446f5790e68fb433"></a>
Enumerator &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurfaces::Enumerator::operator=</b> (const Enumerator &amp;)=delete</td></tr>
<tr class="separator:ga908351b50591a13c446f5790e68fb433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eda282781417dd21160e899db7d8bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2eda282781417dd21160e899db7d8bfb">regina::makeZeroVector</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga2eda282781417dd21160e899db7d8bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and the given coordinate system.  <a href="group__surfaces.html#ga2eda282781417dd21160e899db7d8bfb">More...</a><br /></td></tr>
<tr class="separator:ga2eda282781417dd21160e899db7d8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a886092529bcf35c5e6def77e18c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga15a886092529bcf35c5e6def77e18c64">regina::makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga15a886092529bcf35c5e6def77e18c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal surface matching equations for the given triangulation using the given coordinate system.  <a href="group__surfaces.html#ga15a886092529bcf35c5e6def77e18c64">More...</a><br /></td></tr>
<tr class="separator:ga15a886092529bcf35c5e6def77e18c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeffc85eaf2fc2c37cf1e6fb87f951b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaeeffc85eaf2fc2c37cf1e6fb87f951b9">regina::makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:gaeeffc85eaf2fc2c37cf1e6fb87f951b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal surfaces be embedded.  <a href="group__surfaces.html#gaeeffc85eaf2fc2c37cf1e6fb87f951b9">More...</a><br /></td></tr>
<tr class="separator:gaeeffc85eaf2fc2c37cf1e6fb87f951b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad31480b0b03f05adb5a6993ef6d0f236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad31480b0b03f05adb5a6993ef6d0f236">regina::NSVectorANStandard::NSVectorANStandard</a> (size_t length)</td></tr>
<tr class="memdesc:gad31480b0b03f05adb5a6993ef6d0f236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#gad31480b0b03f05adb5a6993ef6d0f236">More...</a><br /></td></tr>
<tr class="separator:gad31480b0b03f05adb5a6993ef6d0f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64cc2810501559c94a5d67ecd00e01a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa64cc2810501559c94a5d67ecd00e01a">regina::NSVectorANStandard::NSVectorANStandard</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gaa64cc2810501559c94a5d67ecd00e01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#gaa64cc2810501559c94a5d67ecd00e01a">More...</a><br /></td></tr>
<tr class="separator:gaa64cc2810501559c94a5d67ecd00e01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa883a0ec32b3a0d2440fbc4e3f41e167"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa883a0ec32b3a0d2440fbc4e3f41e167">regina::NSVectorANStandard::triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaa883a0ec32b3a0d2440fbc4e3f41e167"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#gaa883a0ec32b3a0d2440fbc4e3f41e167">More...</a><br /></td></tr>
<tr class="separator:gaa883a0ec32b3a0d2440fbc4e3f41e167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2062102f4e6bec5108ce42cbab04b692"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2062102f4e6bec5108ce42cbab04b692">regina::NSVectorANStandard::quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga2062102f4e6bec5108ce42cbab04b692"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga2062102f4e6bec5108ce42cbab04b692">More...</a><br /></td></tr>
<tr class="separator:ga2062102f4e6bec5108ce42cbab04b692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced4bb03e87c9d58dd826c2ac32728e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaced4bb03e87c9d58dd826c2ac32728e6">regina::NSVectorANStandard::octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaced4bb03e87c9d58dd826c2ac32728e6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#gaced4bb03e87c9d58dd826c2ac32728e6">More...</a><br /></td></tr>
<tr class="separator:gaced4bb03e87c9d58dd826c2ac32728e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1df7bce5940c31ba4888ca6b05f946"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaca1df7bce5940c31ba4888ca6b05f946">regina::NSVectorANStandard::edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaca1df7bce5940c31ba4888ca6b05f946"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="group__surfaces.html#gaca1df7bce5940c31ba4888ca6b05f946">More...</a><br /></td></tr>
<tr class="separator:gaca1df7bce5940c31ba4888ca6b05f946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98998d0a6b84b8cfb2dfd70a9c0f4359"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga98998d0a6b84b8cfb2dfd70a9c0f4359">regina::NSVectorANStandard::arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga98998d0a6b84b8cfb2dfd70a9c0f4359"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="group__surfaces.html#ga98998d0a6b84b8cfb2dfd70a9c0f4359">More...</a><br /></td></tr>
<tr class="separator:ga98998d0a6b84b8cfb2dfd70a9c0f4359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e11946d06e5cdff634aa5b02730fd7"><td class="memItemLeft" align="right" valign="top"><a id="ga91e11946d06e5cdff634aa5b02730fd7"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorANStandard::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga91e11946d06e5cdff634aa5b02730fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7a4d3c58052c1613d12fb06f8757da"><td class="memItemLeft" align="right" valign="top"><a id="ga6f7a4d3c58052c1613d12fb06f8757da"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorANStandard::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga6f7a4d3c58052c1613d12fb06f8757da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b95963798dcd9d11c348d0be324ef7"><td class="memItemLeft" align="right" valign="top"><a id="ga79b95963798dcd9d11c348d0be324ef7"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorANStandard::makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga79b95963798dcd9d11c348d0be324ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb0d76340736f73191d953e5f1f7147"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7fb0d76340736f73191d953e5f1f7147">regina::NSVectorMirrored::NSVectorMirrored</a> (size_t length)</td></tr>
<tr class="memdesc:ga7fb0d76340736f73191d953e5f1f7147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#ga7fb0d76340736f73191d953e5f1f7147">More...</a><br /></td></tr>
<tr class="separator:ga7fb0d76340736f73191d953e5f1f7147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced4af37a677777be8d7c2712100161d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaced4af37a677777be8d7c2712100161d">regina::NSVectorMirrored::NSVectorMirrored</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gaced4af37a677777be8d7c2712100161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#gaced4af37a677777be8d7c2712100161d">More...</a><br /></td></tr>
<tr class="separator:gaced4af37a677777be8d7c2712100161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b1bb4b4fe448098099f7a51f50bc7ba"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5b1bb4b4fe448098099f7a51f50bc7ba">regina::NSVectorMirrored::~NSVectorMirrored</a> ()</td></tr>
<tr class="memdesc:ga5b1bb4b4fe448098099f7a51f50bc7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this vector and its mirror if appropriate.  <a href="group__surfaces.html#ga5b1bb4b4fe448098099f7a51f50bc7ba">More...</a><br /></td></tr>
<tr class="separator:ga5b1bb4b4fe448098099f7a51f50bc7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dea78dbce6ae26d8f33fe26b568aba3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8dea78dbce6ae26d8f33fe26b568aba3">regina::NSVectorMirrored::makeMirror</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const =0</td></tr>
<tr class="memdesc:ga8dea78dbce6ae26d8f33fe26b568aba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mirror vector corresponding to this vector.  <a href="group__surfaces.html#ga8dea78dbce6ae26d8f33fe26b568aba3">More...</a><br /></td></tr>
<tr class="separator:ga8dea78dbce6ae26d8f33fe26b568aba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c70b9f732f6867adf218250d66271df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7c70b9f732f6867adf218250d66271df">regina::NSVectorMirrored::makeMirror</a> (const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;original, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang)</td></tr>
<tr class="memdesc:ga7c70b9f732f6867adf218250d66271df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mirror vector corresponding to the given vector.  <a href="group__surfaces.html#ga7c70b9f732f6867adf218250d66271df">More...</a><br /></td></tr>
<tr class="separator:ga7c70b9f732f6867adf218250d66271df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09f01421c3a687edc63fada1808c063f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga09f01421c3a687edc63fada1808c063f">regina::NSVectorMirrored::setElement</a> (size_t index, const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;value) override</td></tr>
<tr class="memdesc:ga09f01421c3a687edc63fada1808c063f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given normal coordinate to the given value.  <a href="group__surfaces.html#ga09f01421c3a687edc63fada1808c063f">More...</a><br /></td></tr>
<tr class="separator:ga09f01421c3a687edc63fada1808c063f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654e738a0d9768a39697c79c8b2e74b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga654e738a0d9768a39697c79c8b2e74b7">regina::NSVectorMirrored::operator+=</a> (const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;other) override</td></tr>
<tr class="memdesc:ga654e738a0d9768a39697c79c8b2e74b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="group__surfaces.html#ga654e738a0d9768a39697c79c8b2e74b7">More...</a><br /></td></tr>
<tr class="separator:ga654e738a0d9768a39697c79c8b2e74b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7607f80141d61419e9fc05bb2c266c97"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7607f80141d61419e9fc05bb2c266c97">regina::NSVectorMirrored::scaleDown</a> () override</td></tr>
<tr class="memdesc:ga7607f80141d61419e9fc05bb2c266c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="group__surfaces.html#ga7607f80141d61419e9fc05bb2c266c97">More...</a><br /></td></tr>
<tr class="separator:ga7607f80141d61419e9fc05bb2c266c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4904b81d01adbe8050c30feb4d0dcee9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4904b81d01adbe8050c30feb4d0dcee9">regina::NSVectorMirrored::triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga4904b81d01adbe8050c30feb4d0dcee9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#ga4904b81d01adbe8050c30feb4d0dcee9">More...</a><br /></td></tr>
<tr class="separator:ga4904b81d01adbe8050c30feb4d0dcee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2015a06ce4d730919cf5ac29a17936e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2015a06ce4d730919cf5ac29a17936e2">regina::NSVectorMirrored::orientedTriangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:ga2015a06ce4d730919cf5ac29a17936e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#ga2015a06ce4d730919cf5ac29a17936e2">More...</a><br /></td></tr>
<tr class="separator:ga2015a06ce4d730919cf5ac29a17936e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7212bf949dd892cacfaed8de64115b7a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7212bf949dd892cacfaed8de64115b7a">regina::NSVectorMirrored::quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga7212bf949dd892cacfaed8de64115b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga7212bf949dd892cacfaed8de64115b7a">More...</a><br /></td></tr>
<tr class="separator:ga7212bf949dd892cacfaed8de64115b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5318a2c38f37d22b56a05a31bec63592"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5318a2c38f37d22b56a05a31bec63592">regina::NSVectorMirrored::orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:ga5318a2c38f37d22b56a05a31bec63592"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga5318a2c38f37d22b56a05a31bec63592">More...</a><br /></td></tr>
<tr class="separator:ga5318a2c38f37d22b56a05a31bec63592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79f510cc1f1fd40f2152803491a3cbf7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga79f510cc1f1fd40f2152803491a3cbf7">regina::NSVectorMirrored::octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga79f510cc1f1fd40f2152803491a3cbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#ga79f510cc1f1fd40f2152803491a3cbf7">More...</a><br /></td></tr>
<tr class="separator:ga79f510cc1f1fd40f2152803491a3cbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef1074733d1aaa6de9ff8cd8b39ffaba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaef1074733d1aaa6de9ff8cd8b39ffaba">regina::NSVectorMirrored::edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaef1074733d1aaa6de9ff8cd8b39ffaba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="group__surfaces.html#gaef1074733d1aaa6de9ff8cd8b39ffaba">More...</a><br /></td></tr>
<tr class="separator:gaef1074733d1aaa6de9ff8cd8b39ffaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef4cdd091a72db9f5a7bbd37c0c1735"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacef4cdd091a72db9f5a7bbd37c0c1735">regina::NSVectorMirrored::arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gacef4cdd091a72db9f5a7bbd37c0c1735"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="group__surfaces.html#gacef4cdd091a72db9f5a7bbd37c0c1735">More...</a><br /></td></tr>
<tr class="separator:gacef4cdd091a72db9f5a7bbd37c0c1735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36acf25acf48e1228d0beba925325559"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga36acf25acf48e1228d0beba925325559">regina::NSVectorOriented::NSVectorOriented</a> (size_t length)</td></tr>
<tr class="memdesc:ga36acf25acf48e1228d0beba925325559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#ga36acf25acf48e1228d0beba925325559">More...</a><br /></td></tr>
<tr class="separator:ga36acf25acf48e1228d0beba925325559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga909b9351b2c46ce4cdbf3f5c2923b44b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga909b9351b2c46ce4cdbf3f5c2923b44b">regina::NSVectorOriented::NSVectorOriented</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga909b9351b2c46ce4cdbf3f5c2923b44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#ga909b9351b2c46ce4cdbf3f5c2923b44b">More...</a><br /></td></tr>
<tr class="separator:ga909b9351b2c46ce4cdbf3f5c2923b44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58437850c881385ebd4c4f5cf4e2e6b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae58437850c881385ebd4c4f5cf4e2e6b">regina::NSVectorOriented::triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gae58437850c881385ebd4c4f5cf4e2e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#gae58437850c881385ebd4c4f5cf4e2e6b">More...</a><br /></td></tr>
<tr class="separator:gae58437850c881385ebd4c4f5cf4e2e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5185cb4b3afd73b98e9a8c8a5eebcb6f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5185cb4b3afd73b98e9a8c8a5eebcb6f">regina::NSVectorOriented::quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga5185cb4b3afd73b98e9a8c8a5eebcb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga5185cb4b3afd73b98e9a8c8a5eebcb6f">More...</a><br /></td></tr>
<tr class="separator:ga5185cb4b3afd73b98e9a8c8a5eebcb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a4137d110e610a9ba8dfa5dbc1c4f1c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3a4137d110e610a9ba8dfa5dbc1c4f1c">regina::NSVectorOriented::orientedTriangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:ga3a4137d110e610a9ba8dfa5dbc1c4f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#ga3a4137d110e610a9ba8dfa5dbc1c4f1c">More...</a><br /></td></tr>
<tr class="separator:ga3a4137d110e610a9ba8dfa5dbc1c4f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6015659e0c8fee455cea5877c075c47a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6015659e0c8fee455cea5877c075c47a">regina::NSVectorOriented::orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:ga6015659e0c8fee455cea5877c075c47a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga6015659e0c8fee455cea5877c075c47a">More...</a><br /></td></tr>
<tr class="separator:ga6015659e0c8fee455cea5877c075c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf522a2ab69035a41dfde5bcc70ab7ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacf522a2ab69035a41dfde5bcc70ab7ea">regina::NSVectorOriented::octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gacf522a2ab69035a41dfde5bcc70ab7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#gacf522a2ab69035a41dfde5bcc70ab7ea">More...</a><br /></td></tr>
<tr class="separator:gacf522a2ab69035a41dfde5bcc70ab7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4108ca7175f0e6bd106c19373f3fcbf2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4108ca7175f0e6bd106c19373f3fcbf2">regina::NSVectorOriented::edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga4108ca7175f0e6bd106c19373f3fcbf2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="group__surfaces.html#ga4108ca7175f0e6bd106c19373f3fcbf2">More...</a><br /></td></tr>
<tr class="separator:ga4108ca7175f0e6bd106c19373f3fcbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5de36fdaeb65ecb4ce02fa95ec8fe30"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab5de36fdaeb65ecb4ce02fa95ec8fe30">regina::NSVectorOriented::arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gab5de36fdaeb65ecb4ce02fa95ec8fe30"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="group__surfaces.html#gab5de36fdaeb65ecb4ce02fa95ec8fe30">More...</a><br /></td></tr>
<tr class="separator:gab5de36fdaeb65ecb4ce02fa95ec8fe30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37bd4b605880d84a49c4def169ec43a8"><td class="memItemLeft" align="right" valign="top"><a id="ga37bd4b605880d84a49c4def169ec43a8"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorOriented::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga37bd4b605880d84a49c4def169ec43a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e649f29ba31fd83a8ec4b3494af521"><td class="memItemLeft" align="right" valign="top"><a id="ga53e649f29ba31fd83a8ec4b3494af521"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorOriented::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga53e649f29ba31fd83a8ec4b3494af521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac40a6bacf21e7c7829a7d213a1f7dc01"><td class="memItemLeft" align="right" valign="top"><a id="gac40a6bacf21e7c7829a7d213a1f7dc01"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorOriented::makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:gac40a6bacf21e7c7829a7d213a1f7dc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa659be9751519733724a1cb5a9194868"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa659be9751519733724a1cb5a9194868">regina::NSVectorOrientedQuad::NSVectorOrientedQuad</a> (size_t length)</td></tr>
<tr class="memdesc:gaa659be9751519733724a1cb5a9194868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#gaa659be9751519733724a1cb5a9194868">More...</a><br /></td></tr>
<tr class="separator:gaa659be9751519733724a1cb5a9194868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8d1e34e5e76de5db3663d784f6582b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8b8d1e34e5e76de5db3663d784f6582b">regina::NSVectorOrientedQuad::NSVectorOrientedQuad</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga8b8d1e34e5e76de5db3663d784f6582b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#ga8b8d1e34e5e76de5db3663d784f6582b">More...</a><br /></td></tr>
<tr class="separator:ga8b8d1e34e5e76de5db3663d784f6582b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa48957a954688ea18bfcbc698ca3d86"><td class="memItemLeft" align="right" valign="top"><a id="gaaa48957a954688ea18bfcbc698ca3d86"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorOrientedQuad::makeMirror</b> (const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;original, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang)</td></tr>
<tr class="separator:gaaa48957a954688ea18bfcbc698ca3d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5002d5519d11bae7249c551df2500f29"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5002d5519d11bae7249c551df2500f29">regina::NSVectorOrientedQuad::makeMirror</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga5002d5519d11bae7249c551df2500f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mirror vector corresponding to this vector.  <a href="group__surfaces.html#ga5002d5519d11bae7249c551df2500f29">More...</a><br /></td></tr>
<tr class="separator:ga5002d5519d11bae7249c551df2500f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98d612c1b934bd3d64908cbc42e4e81e"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga98d612c1b934bd3d64908cbc42e4e81e">regina::NSVectorOrientedQuad::isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga98d612c1b934bd3d64908cbc42e4e81e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="group__surfaces.html#ga98d612c1b934bd3d64908cbc42e4e81e">More...</a><br /></td></tr>
<tr class="separator:ga98d612c1b934bd3d64908cbc42e4e81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05acfe295661b31d74571b224b58712"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab05acfe295661b31d74571b224b58712">regina::NSVectorOrientedQuad::quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gab05acfe295661b31d74571b224b58712"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#gab05acfe295661b31d74571b224b58712">More...</a><br /></td></tr>
<tr class="separator:gab05acfe295661b31d74571b224b58712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e3f2307548c014fb23b2a511632a1d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa1e3f2307548c014fb23b2a511632a1d">regina::NSVectorOrientedQuad::orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang, bool orientation) const override</td></tr>
<tr class="memdesc:gaa1e3f2307548c014fb23b2a511632a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#gaa1e3f2307548c014fb23b2a511632a1d">More...</a><br /></td></tr>
<tr class="separator:gaa1e3f2307548c014fb23b2a511632a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd54cb95a976b0a3139f54b0296fa40"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3bd54cb95a976b0a3139f54b0296fa40">regina::NSVectorOrientedQuad::octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga3bd54cb95a976b0a3139f54b0296fa40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#ga3bd54cb95a976b0a3139f54b0296fa40">More...</a><br /></td></tr>
<tr class="separator:ga3bd54cb95a976b0a3139f54b0296fa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1592888bfb1424a00d1108cd9c33d8"><td class="memItemLeft" align="right" valign="top"><a id="ga6a1592888bfb1424a00d1108cd9c33d8"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorOrientedQuad::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga6a1592888bfb1424a00d1108cd9c33d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7abd091f834d55b774309b45420ddec"><td class="memItemLeft" align="right" valign="top"><a id="gaf7abd091f834d55b774309b45420ddec"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorOrientedQuad::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:gaf7abd091f834d55b774309b45420ddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0815b75a398d2743635dbd0531dd3d"><td class="memItemLeft" align="right" valign="top"><a id="ga3f0815b75a398d2743635dbd0531dd3d"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorOrientedQuad::makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga3f0815b75a398d2743635dbd0531dd3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52efede83a8235a1f0b5a27093066eea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga52efede83a8235a1f0b5a27093066eea">regina::NSVectorQuad::NSVectorQuad</a> (size_t length)</td></tr>
<tr class="memdesc:ga52efede83a8235a1f0b5a27093066eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#ga52efede83a8235a1f0b5a27093066eea">More...</a><br /></td></tr>
<tr class="separator:ga52efede83a8235a1f0b5a27093066eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57dc3344f37493c85756bd4e0e5345fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga57dc3344f37493c85756bd4e0e5345fb">regina::NSVectorQuad::NSVectorQuad</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga57dc3344f37493c85756bd4e0e5345fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#ga57dc3344f37493c85756bd4e0e5345fb">More...</a><br /></td></tr>
<tr class="separator:ga57dc3344f37493c85756bd4e0e5345fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47dd0f837275b304d6a183cae386436"><td class="memItemLeft" align="right" valign="top"><a id="gab47dd0f837275b304d6a183cae386436"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuad::makeMirror</b> (const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;original, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang)</td></tr>
<tr class="separator:gab47dd0f837275b304d6a183cae386436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb7de0ac36839c7c0d76c273e01e89a2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaeb7de0ac36839c7c0d76c273e01e89a2">regina::NSVectorQuad::makeMirror</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaeb7de0ac36839c7c0d76c273e01e89a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mirror vector corresponding to this vector.  <a href="group__surfaces.html#gaeb7de0ac36839c7c0d76c273e01e89a2">More...</a><br /></td></tr>
<tr class="separator:gaeb7de0ac36839c7c0d76c273e01e89a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b5ea3db1bb195bb2ac85d61c478c6a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf5b5ea3db1bb195bb2ac85d61c478c6a">regina::NSVectorQuad::isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaf5b5ea3db1bb195bb2ac85d61c478c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="group__surfaces.html#gaf5b5ea3db1bb195bb2ac85d61c478c6a">More...</a><br /></td></tr>
<tr class="separator:gaf5b5ea3db1bb195bb2ac85d61c478c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa12eb25640ae314520cdb1499d23b9e2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa12eb25640ae314520cdb1499d23b9e2">regina::NSVectorQuad::octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaa12eb25640ae314520cdb1499d23b9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#gaa12eb25640ae314520cdb1499d23b9e2">More...</a><br /></td></tr>
<tr class="separator:gaa12eb25640ae314520cdb1499d23b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga521c08b936357a73cf9c687e0b12f0c6"><td class="memItemLeft" align="right" valign="top"><a id="ga521c08b936357a73cf9c687e0b12f0c6"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuad::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga521c08b936357a73cf9c687e0b12f0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82f9501b471b431d781502b12675de63"><td class="memItemLeft" align="right" valign="top"><a id="ga82f9501b471b431d781502b12675de63"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuad::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga82f9501b471b431d781502b12675de63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf561e374625b8a917df136f070526e3"><td class="memItemLeft" align="right" valign="top"><a id="gabf561e374625b8a917df136f070526e3"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuad::makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:gabf561e374625b8a917df136f070526e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab357c3bbb71a6ed38c17de96588dc999"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab357c3bbb71a6ed38c17de96588dc999">regina::NSVectorQuadClosed::NSVectorQuadClosed</a> (size_t length)</td></tr>
<tr class="memdesc:gab357c3bbb71a6ed38c17de96588dc999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#gab357c3bbb71a6ed38c17de96588dc999">More...</a><br /></td></tr>
<tr class="separator:gab357c3bbb71a6ed38c17de96588dc999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f8bc2bfbdfb1f606ebb21520eaf9d28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3f8bc2bfbdfb1f606ebb21520eaf9d28">regina::NSVectorQuadClosed::NSVectorQuadClosed</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga3f8bc2bfbdfb1f606ebb21520eaf9d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#ga3f8bc2bfbdfb1f606ebb21520eaf9d28">More...</a><br /></td></tr>
<tr class="separator:ga3f8bc2bfbdfb1f606ebb21520eaf9d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae6cdcce629c0b07ea72239fb9e7022f"><td class="memItemLeft" align="right" valign="top"><a id="gaae6cdcce629c0b07ea72239fb9e7022f"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadClosed::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:gaae6cdcce629c0b07ea72239fb9e7022f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920b7612c39f1369b9d95c50033bb393"><td class="memItemLeft" align="right" valign="top"><a id="ga920b7612c39f1369b9d95c50033bb393"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadClosed::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga920b7612c39f1369b9d95c50033bb393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b93c5d5a7e1bfc5b4de87cff660625"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab7b93c5d5a7e1bfc5b4de87cff660625">regina::NSVectorQuadOct::NSVectorQuadOct</a> (size_t length)</td></tr>
<tr class="memdesc:gab7b93c5d5a7e1bfc5b4de87cff660625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#gab7b93c5d5a7e1bfc5b4de87cff660625">More...</a><br /></td></tr>
<tr class="separator:gab7b93c5d5a7e1bfc5b4de87cff660625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74408871c05b366e0b4b69bab33e9cf7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga74408871c05b366e0b4b69bab33e9cf7">regina::NSVectorQuadOct::NSVectorQuadOct</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga74408871c05b366e0b4b69bab33e9cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#ga74408871c05b366e0b4b69bab33e9cf7">More...</a><br /></td></tr>
<tr class="separator:ga74408871c05b366e0b4b69bab33e9cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8a54bc855dcfb007586e41b52b2ad72"><td class="memItemLeft" align="right" valign="top"><a id="gac8a54bc855dcfb007586e41b52b2ad72"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadOct::makeMirror</b> (const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;original, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang)</td></tr>
<tr class="separator:gac8a54bc855dcfb007586e41b52b2ad72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48fe8698ec9e687c84764347bbff2774"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga48fe8698ec9e687c84764347bbff2774">regina::NSVectorQuadOct::makeMirror</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga48fe8698ec9e687c84764347bbff2774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new mirror vector corresponding to this vector.  <a href="group__surfaces.html#ga48fe8698ec9e687c84764347bbff2774">More...</a><br /></td></tr>
<tr class="separator:ga48fe8698ec9e687c84764347bbff2774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34afa9a4f7444f2b985adb80aaf2054f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga34afa9a4f7444f2b985adb80aaf2054f">regina::NSVectorQuadOct::isVertexLink</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga34afa9a4f7444f2b985adb80aaf2054f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="group__surfaces.html#ga34afa9a4f7444f2b985adb80aaf2054f">More...</a><br /></td></tr>
<tr class="separator:ga34afa9a4f7444f2b985adb80aaf2054f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124ff781e57ac1cc0472da329b989342"><td class="memItemLeft" align="right" valign="top"><a id="ga124ff781e57ac1cc0472da329b989342"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadOct::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga124ff781e57ac1cc0472da329b989342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393794b6b52fa18e755b2cdeede31592"><td class="memItemLeft" align="right" valign="top"><a id="ga393794b6b52fa18e755b2cdeede31592"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadOct::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga393794b6b52fa18e755b2cdeede31592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b64b424d50b2667b98d420d74d3f4ad"><td class="memItemLeft" align="right" valign="top"><a id="ga4b64b424d50b2667b98d420d74d3f4ad"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadOct::makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga4b64b424d50b2667b98d420d74d3f4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8862ecd7107dc2fcc616244c4b2df281"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8862ecd7107dc2fcc616244c4b2df281">regina::NSVectorQuadOctClosed::NSVectorQuadOctClosed</a> (size_t length)</td></tr>
<tr class="memdesc:ga8862ecd7107dc2fcc616244c4b2df281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#ga8862ecd7107dc2fcc616244c4b2df281">More...</a><br /></td></tr>
<tr class="separator:ga8862ecd7107dc2fcc616244c4b2df281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6117da07794ffeb3e4ce9543e94550a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab6117da07794ffeb3e4ce9543e94550a">regina::NSVectorQuadOctClosed::NSVectorQuadOctClosed</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:gab6117da07794ffeb3e4ce9543e94550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#gab6117da07794ffeb3e4ce9543e94550a">More...</a><br /></td></tr>
<tr class="separator:gab6117da07794ffeb3e4ce9543e94550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85080aa62b6ddcf2e08f77efdff7deed"><td class="memItemLeft" align="right" valign="top"><a id="ga85080aa62b6ddcf2e08f77efdff7deed"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadOctClosed::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga85080aa62b6ddcf2e08f77efdff7deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade6d5ac482a5830e9965db67c3e63898"><td class="memItemLeft" align="right" valign="top"><a id="gade6d5ac482a5830e9965db67c3e63898"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorQuadOctClosed::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:gade6d5ac482a5830e9965db67c3e63898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d79a5f0aa7aa29fb7d26c670b81d087"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6d79a5f0aa7aa29fb7d26c670b81d087">regina::NSVectorStandard::NSVectorStandard</a> (size_t length)</td></tr>
<tr class="memdesc:ga6d79a5f0aa7aa29fb7d26c670b81d087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="group__surfaces.html#ga6d79a5f0aa7aa29fb7d26c670b81d087">More...</a><br /></td></tr>
<tr class="separator:ga6d79a5f0aa7aa29fb7d26c670b81d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c8ba19de0a2d586f9359548299abc7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8c8ba19de0a2d586f9359548299abc7b">regina::NSVectorStandard::NSVectorStandard</a> (const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:ga8c8ba19de0a2d586f9359548299abc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="group__surfaces.html#ga8c8ba19de0a2d586f9359548299abc7b">More...</a><br /></td></tr>
<tr class="separator:ga8c8ba19de0a2d586f9359548299abc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60aac772b74582662acbf6da924e2769"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga60aac772b74582662acbf6da924e2769">regina::NSVectorStandard::triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga60aac772b74582662acbf6da924e2769"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="group__surfaces.html#ga60aac772b74582662acbf6da924e2769">More...</a><br /></td></tr>
<tr class="separator:ga60aac772b74582662acbf6da924e2769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dd79b66600f3a0802175e1593fe6c96"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2dd79b66600f3a0802175e1593fe6c96">regina::NSVectorStandard::quads</a> (size_t tetIndex, int quadType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga2dd79b66600f3a0802175e1593fe6c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="group__surfaces.html#ga2dd79b66600f3a0802175e1593fe6c96">More...</a><br /></td></tr>
<tr class="separator:ga2dd79b66600f3a0802175e1593fe6c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa8de789bc534a5806e9b46f708c347"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaafa8de789bc534a5806e9b46f708c347">regina::NSVectorStandard::octs</a> (size_t tetIndex, int octType, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:gaafa8de789bc534a5806e9b46f708c347"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="group__surfaces.html#gaafa8de789bc534a5806e9b46f708c347">More...</a><br /></td></tr>
<tr class="separator:gaafa8de789bc534a5806e9b46f708c347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cd5eadbba63de6b6d001886ab96cef"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga59cd5eadbba63de6b6d001886ab96cef">regina::NSVectorStandard::edgeWeight</a> (size_t edgeIndex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga59cd5eadbba63de6b6d001886ab96cef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="group__surfaces.html#ga59cd5eadbba63de6b6d001886ab96cef">More...</a><br /></td></tr>
<tr class="separator:ga59cd5eadbba63de6b6d001886ab96cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25b92f75058a45943a976e08c595fb02"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga25b92f75058a45943a976e08c595fb02">regina::NSVectorStandard::arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triang) const override</td></tr>
<tr class="memdesc:ga25b92f75058a45943a976e08c595fb02"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="group__surfaces.html#ga25b92f75058a45943a976e08c595fb02">More...</a><br /></td></tr>
<tr class="separator:ga25b92f75058a45943a976e08c595fb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65c79ecdaab62b86684c02e0fe55eb34"><td class="memItemLeft" align="right" valign="top"><a id="ga65c79ecdaab62b86684c02e0fe55eb34"></a>
static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorStandard::makeZeroVector</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga65c79ecdaab62b86684c02e0fe55eb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga744822f8c5764d79e8371c8afadd2c9a"><td class="memItemLeft" align="right" valign="top"><a id="ga744822f8c5764d79e8371c8afadd2c9a"></a>
static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorStandard::makeMatchingEquations</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:ga744822f8c5764d79e8371c8afadd2c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0fd59239c065b5776109d8e9954eb2a"><td class="memItemLeft" align="right" valign="top"><a id="gae0fd59239c065b5776109d8e9954eb2a"></a>
static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NSVectorStandard::makeEmbeddedConstraints</b> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation)</td></tr>
<tr class="separator:gae0fd59239c065b5776109d8e9954eb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03921377951ebe00c97b08048df672f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga03921377951ebe00c97b08048df672f4">regina::PrismSpec::PrismSpec</a> ()</td></tr>
<tr class="memdesc:ga03921377951ebe00c97b08048df672f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised prism specifier.  <a href="group__surfaces.html#ga03921377951ebe00c97b08048df672f4">More...</a><br /></td></tr>
<tr class="separator:ga03921377951ebe00c97b08048df672f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad07d39b2403c38532be26daabc105af6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad07d39b2403c38532be26daabc105af6">regina::PrismSpec::PrismSpec</a> (size_t newTetIndex, int newEdge)</td></tr>
<tr class="memdesc:gad07d39b2403c38532be26daabc105af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new prism specifier containing the given values.  <a href="group__surfaces.html#gad07d39b2403c38532be26daabc105af6">More...</a><br /></td></tr>
<tr class="separator:gad07d39b2403c38532be26daabc105af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c1d2b61b7263c7837a5b8f00c44926"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga85c1d2b61b7263c7837a5b8f00c44926">regina::PrismSpec::PrismSpec</a> (const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga85c1d2b61b7263c7837a5b8f00c44926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new prism specifier that is a clone of the given specifier.  <a href="group__surfaces.html#ga85c1d2b61b7263c7837a5b8f00c44926">More...</a><br /></td></tr>
<tr class="separator:ga85c1d2b61b7263c7837a5b8f00c44926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ad5bd04d90fd7e5e3bcfce9542db788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7ad5bd04d90fd7e5e3bcfce9542db788">regina::PrismSpec::operator=</a> (const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga7ad5bd04d90fd7e5e3bcfce9542db788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the values from the given prism specifier into this specifier.  <a href="group__surfaces.html#ga7ad5bd04d90fd7e5e3bcfce9542db788">More...</a><br /></td></tr>
<tr class="separator:ga7ad5bd04d90fd7e5e3bcfce9542db788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1465273485851f908cb13c6f8d9e53e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa1465273485851f908cb13c6f8d9e53e">regina::PrismSpec::operator==</a> (const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:gaa1465273485851f908cb13c6f8d9e53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given prism specifier contain identical information.  <a href="group__surfaces.html#gaa1465273485851f908cb13c6f8d9e53e">More...</a><br /></td></tr>
<tr class="separator:gaa1465273485851f908cb13c6f8d9e53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7969159033595b4e24ec9823301c3bcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7969159033595b4e24ec9823301c3bcc">regina::PrismSpec::operator!=</a> (const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:ga7969159033595b4e24ec9823301c3bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given prism specifier contain different information.  <a href="group__surfaces.html#ga7969159033595b4e24ec9823301c3bcc">More...</a><br /></td></tr>
<tr class="separator:ga7969159033595b4e24ec9823301c3bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73fa623e9df3fbdffe981d730ced7f2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf73fa623e9df3fbdffe981d730ced7f2">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:gaf73fa623e9df3fbdffe981d730ced7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given prism specifier to the given output stream.  <a href="group__surfaces.html#gaf73fa623e9df3fbdffe981d730ced7f2">More...</a><br /></td></tr>
<tr class="separator:gaf73fa623e9df3fbdffe981d730ced7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eae67e1c98b4ed1946419ccb48b88c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4eae67e1c98b4ed1946419ccb48b88c4">regina::SurfaceFilter::SurfaceFilter</a> ()</td></tr>
<tr class="memdesc:ga4eae67e1c98b4ed1946419ccb48b88c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new default surface filter.  <a href="group__surfaces.html#ga4eae67e1c98b4ed1946419ccb48b88c4">More...</a><br /></td></tr>
<tr class="separator:ga4eae67e1c98b4ed1946419ccb48b88c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf850e0c4ab0a597395cc978dbc3c66ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf850e0c4ab0a597395cc978dbc3c66ef">regina::SurfaceFilter::SurfaceFilter</a> (const <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gaf850e0c4ab0a597395cc978dbc3c66ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new default surface filter.  <a href="group__surfaces.html#gaf850e0c4ab0a597395cc978dbc3c66ef">More...</a><br /></td></tr>
<tr class="separator:gaf850e0c4ab0a597395cc978dbc3c66ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b3388688a07f0e5ec4778da8f2bafb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf6b3388688a07f0e5ec4778da8f2bafb">regina::SurfaceFilter::~SurfaceFilter</a> ()</td></tr>
<tr class="memdesc:gaf6b3388688a07f0e5ec4778da8f2bafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this surface filter.  <a href="group__surfaces.html#gaf6b3388688a07f0e5ec4778da8f2bafb">More...</a><br /></td></tr>
<tr class="separator:gaf6b3388688a07f0e5ec4778da8f2bafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2048b5426c5f9a318d6c552612cbf680"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2048b5426c5f9a318d6c552612cbf680">regina::SurfaceFilter::accept</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface) const</td></tr>
<tr class="memdesc:ga2048b5426c5f9a318d6c552612cbf680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether or not the given normal surface is accepted by this filter.  <a href="group__surfaces.html#ga2048b5426c5f9a318d6c552612cbf680">More...</a><br /></td></tr>
<tr class="separator:ga2048b5426c5f9a318d6c552612cbf680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd94e21f97cf9a037e774f1959d6aeb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7bd94e21f97cf9a037e774f1959d6aeb">regina::SurfaceFilter::filterType</a> () const</td></tr>
<tr class="memdesc:ga7bd94e21f97cf9a037e774f1959d6aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID corresponding to the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>.  <a href="group__surfaces.html#ga7bd94e21f97cf9a037e774f1959d6aeb">More...</a><br /></td></tr>
<tr class="separator:ga7bd94e21f97cf9a037e774f1959d6aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e2e2cd5aa13fab78d5346752051b92e"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8e2e2cd5aa13fab78d5346752051b92e">regina::SurfaceFilter::filterTypeName</a> () const</td></tr>
<tr class="memdesc:ga8e2e2cd5aa13fab78d5346752051b92e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a string description of the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>.  <a href="group__surfaces.html#ga8e2e2cd5aa13fab78d5346752051b92e">More...</a><br /></td></tr>
<tr class="separator:ga8e2e2cd5aa13fab78d5346752051b92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36e9f40c6efcc5f41302129542b56c36"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1XMLFilterReader.html">XMLFilterReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga36e9f40c6efcc5f41302129542b56c36">regina::SurfaceFilter::xmlFilterReader</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>)</td></tr>
<tr class="memdesc:ga36e9f40c6efcc5f41302129542b56c36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created XML filter reader that will read the details of a particular type of surface filter.  <a href="group__surfaces.html#ga36e9f40c6efcc5f41302129542b56c36">More...</a><br /></td></tr>
<tr class="separator:ga36e9f40c6efcc5f41302129542b56c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ec7fe3b0c83880fc4d8bde58853cae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf9ec7fe3b0c83880fc4d8bde58853cae">regina::SurfaceFilter::writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gaf9ec7fe3b0c83880fc4d8bde58853cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="group__surfaces.html#gaf9ec7fe3b0c83880fc4d8bde58853cae">More...</a><br /></td></tr>
<tr class="separator:gaf9ec7fe3b0c83880fc4d8bde58853cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3625915789141465d6c29922a52452d2"><td class="memItemLeft" align="right" valign="top"><a id="ga3625915789141465d6c29922a52452d2"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SurfaceFilter::xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ga3625915789141465d6c29922a52452d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbf1c1dc39ca6a9792124e129ab54b4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2cbf1c1dc39ca6a9792124e129ab54b4">regina::SurfaceFilter::dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ga2cbf1c1dc39ca6a9792124e129ab54b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="group__surfaces.html#ga2cbf1c1dc39ca6a9792124e129ab54b4">More...</a><br /></td></tr>
<tr class="separator:ga2cbf1c1dc39ca6a9792124e129ab54b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6403f0651303e220eca2f291850011"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3b6403f0651303e220eca2f291850011">regina::SurfaceFilter::writeXMLFilterData</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga3b6403f0651303e220eca2f291850011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the details of this filter.  <a href="group__surfaces.html#ga3b6403f0651303e220eca2f291850011">More...</a><br /></td></tr>
<tr class="separator:ga3b6403f0651303e220eca2f291850011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb8bd5f5aaa07c895c1ff7b457056c80"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacb8bd5f5aaa07c895c1ff7b457056c80">regina::SurfaceFilter::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:gacb8bd5f5aaa07c895c1ff7b457056c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__surfaces.html#gacb8bd5f5aaa07c895c1ff7b457056c80">More...</a><br /></td></tr>
<tr class="separator:gacb8bd5f5aaa07c895c1ff7b457056c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94055c65c176f663111268c8f8de9d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae94055c65c176f663111268c8f8de9d4">regina::SurfaceFilter::writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gae94055c65c176f663111268c8f8de9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="group__surfaces.html#gae94055c65c176f663111268c8f8de9d4">More...</a><br /></td></tr>
<tr class="separator:gae94055c65c176f663111268c8f8de9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4ad9349ccc905e2b0b398cff7b7e2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8d4ad9349ccc905e2b0b398cff7b7e2d">regina::SurfaceFilterCombination::SurfaceFilterCombination</a> ()</td></tr>
<tr class="memdesc:ga8d4ad9349ccc905e2b0b398cff7b7e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new surface filter that accepts all normal surfaces.  <a href="group__surfaces.html#ga8d4ad9349ccc905e2b0b398cff7b7e2d">More...</a><br /></td></tr>
<tr class="separator:ga8d4ad9349ccc905e2b0b398cff7b7e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2ba13964e5ef3d54c2d764e21b12cef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad2ba13964e5ef3d54c2d764e21b12cef">regina::SurfaceFilterCombination::SurfaceFilterCombination</a> (const <a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:gad2ba13964e5ef3d54c2d764e21b12cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new surface filter that is a clone of the given surface filter.  <a href="group__surfaces.html#gad2ba13964e5ef3d54c2d764e21b12cef">More...</a><br /></td></tr>
<tr class="separator:gad2ba13964e5ef3d54c2d764e21b12cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c38e1ac8c4662a8adc084b86b54658"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab7c38e1ac8c4662a8adc084b86b54658">regina::SurfaceFilterCombination::usesAnd</a> () const</td></tr>
<tr class="memdesc:gab7c38e1ac8c4662a8adc084b86b54658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this is an <em>and</em> or an <em>or</em> combination.  <a href="group__surfaces.html#gab7c38e1ac8c4662a8adc084b86b54658">More...</a><br /></td></tr>
<tr class="separator:gab7c38e1ac8c4662a8adc084b86b54658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3241911ff87de29c6bf78d78675fbcc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3241911ff87de29c6bf78d78675fbcc2">regina::SurfaceFilterCombination::setUsesAnd</a> (bool value)</td></tr>
<tr class="memdesc:ga3241911ff87de29c6bf78d78675fbcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this is an <em>and</em> or an <em>or</em> combination.  <a href="group__surfaces.html#ga3241911ff87de29c6bf78d78675fbcc2">More...</a><br /></td></tr>
<tr class="separator:ga3241911ff87de29c6bf78d78675fbcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3231f51146222c24aa9375683842383b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3231f51146222c24aa9375683842383b">regina::SurfaceFilterCombination::accept</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface) const override</td></tr>
<tr class="memdesc:ga3231f51146222c24aa9375683842383b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether or not the given normal surface is accepted by this filter.  <a href="group__surfaces.html#ga3231f51146222c24aa9375683842383b">More...</a><br /></td></tr>
<tr class="separator:ga3231f51146222c24aa9375683842383b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga151cff12a4c85a04fd8e5d7f617a90f0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga151cff12a4c85a04fd8e5d7f617a90f0">regina::SurfaceFilterCombination::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga151cff12a4c85a04fd8e5d7f617a90f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__surfaces.html#ga151cff12a4c85a04fd8e5d7f617a90f0">More...</a><br /></td></tr>
<tr class="separator:ga151cff12a4c85a04fd8e5d7f617a90f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7c3a5257b402a9562e3e43dafb7ad60"><td class="memItemLeft" align="right" valign="top"><a id="gaf7c3a5257b402a9562e3e43dafb7ad60"></a>
static <a class="el" href="classregina_1_1XMLFilterReader.html">XMLFilterReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SurfaceFilterCombination::xmlFilterReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>)</td></tr>
<tr class="separator:gaf7c3a5257b402a9562e3e43dafb7ad60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233c06d9abc90d0d78e7505e330ace46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga233c06d9abc90d0d78e7505e330ace46">regina::SurfaceFilterCombination::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:ga233c06d9abc90d0d78e7505e330ace46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__surfaces.html#ga233c06d9abc90d0d78e7505e330ace46">More...</a><br /></td></tr>
<tr class="separator:ga233c06d9abc90d0d78e7505e330ace46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac520984f91f3dcb0f94149d3fe59c802"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac520984f91f3dcb0f94149d3fe59c802">regina::SurfaceFilterCombination::writeXMLFilterData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:gac520984f91f3dcb0f94149d3fe59c802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the details of this filter.  <a href="group__surfaces.html#gac520984f91f3dcb0f94149d3fe59c802">More...</a><br /></td></tr>
<tr class="separator:gac520984f91f3dcb0f94149d3fe59c802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de0952456f0ac9d4e5c1cce1cc64b52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5de0952456f0ac9d4e5c1cce1cc64b52">regina::SurfaceFilterProperties::SurfaceFilterProperties</a> ()</td></tr>
<tr class="memdesc:ga5de0952456f0ac9d4e5c1cce1cc64b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new surface filter that accepts all normal surfaces.  <a href="group__surfaces.html#ga5de0952456f0ac9d4e5c1cce1cc64b52">More...</a><br /></td></tr>
<tr class="separator:ga5de0952456f0ac9d4e5c1cce1cc64b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81cb3db20848b8330b3fed8872985799"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga81cb3db20848b8330b3fed8872985799">regina::SurfaceFilterProperties::SurfaceFilterProperties</a> (const <a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> &amp;cloneMe)</td></tr>
<tr class="memdesc:ga81cb3db20848b8330b3fed8872985799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new surface filter that is a clone of the given surface filter.  <a href="group__surfaces.html#ga81cb3db20848b8330b3fed8872985799">More...</a><br /></td></tr>
<tr class="separator:ga81cb3db20848b8330b3fed8872985799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae121058acca2e36eb07fe7973c0e2353"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353">regina::SurfaceFilterProperties::eulerChars</a> () const</td></tr>
<tr class="memdesc:gae121058acca2e36eb07fe7973c0e2353"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable Euler characteristics.  <a href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353">More...</a><br /></td></tr>
<tr class="separator:gae121058acca2e36eb07fe7973c0e2353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05bc0467c5b5dcc6e66f5e64c5732b82"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga05bc0467c5b5dcc6e66f5e64c5732b82">regina::SurfaceFilterProperties::countEulerChars</a> () const</td></tr>
<tr class="memdesc:ga05bc0467c5b5dcc6e66f5e64c5732b82"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of allowable Euler characteristics.  <a href="group__surfaces.html#ga05bc0467c5b5dcc6e66f5e64c5732b82">More...</a><br /></td></tr>
<tr class="separator:ga05bc0467c5b5dcc6e66f5e64c5732b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a022c7e93e384f63d5b702c9059fe19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3a022c7e93e384f63d5b702c9059fe19">regina::SurfaceFilterProperties::eulerChar</a> (size_t index) const</td></tr>
<tr class="memdesc:ga3a022c7e93e384f63d5b702c9059fe19"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the allowable Euler characteristic at the given index in the set.  <a href="group__surfaces.html#ga3a022c7e93e384f63d5b702c9059fe19">More...</a><br /></td></tr>
<tr class="separator:ga3a022c7e93e384f63d5b702c9059fe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8d7cd88fdd4d0f22a11b8b2a0ad5093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad8d7cd88fdd4d0f22a11b8b2a0ad5093">regina::SurfaceFilterProperties::orientability</a> () const</td></tr>
<tr class="memdesc:gad8d7cd88fdd4d0f22a11b8b2a0ad5093"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable orientabilities.  <a href="group__surfaces.html#gad8d7cd88fdd4d0f22a11b8b2a0ad5093">More...</a><br /></td></tr>
<tr class="separator:gad8d7cd88fdd4d0f22a11b8b2a0ad5093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b6a0f2fcdf9294d92b2eaed6afcdd75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6b6a0f2fcdf9294d92b2eaed6afcdd75">regina::SurfaceFilterProperties::compactness</a> () const</td></tr>
<tr class="memdesc:ga6b6a0f2fcdf9294d92b2eaed6afcdd75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable compactness properties.  <a href="group__surfaces.html#ga6b6a0f2fcdf9294d92b2eaed6afcdd75">More...</a><br /></td></tr>
<tr class="separator:ga6b6a0f2fcdf9294d92b2eaed6afcdd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867a48662548c9d040fb2e4124bb7c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga867a48662548c9d040fb2e4124bb7c8c">regina::SurfaceFilterProperties::realBoundary</a> () const</td></tr>
<tr class="memdesc:ga867a48662548c9d040fb2e4124bb7c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable has-real-boundary properties.  <a href="group__surfaces.html#ga867a48662548c9d040fb2e4124bb7c8c">More...</a><br /></td></tr>
<tr class="separator:ga867a48662548c9d040fb2e4124bb7c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c9a382b0f84bf5f2b66bfeb5a7104f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae3c9a382b0f84bf5f2b66bfeb5a7104f">regina::SurfaceFilterProperties::setEulerChars</a> (const std::set&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;s)</td></tr>
<tr class="memdesc:gae3c9a382b0f84bf5f2b66bfeb5a7104f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the allowable Euler characteristics to the given set.  <a href="group__surfaces.html#gae3c9a382b0f84bf5f2b66bfeb5a7104f">More...</a><br /></td></tr>
<tr class="separator:gae3c9a382b0f84bf5f2b66bfeb5a7104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4844071549bd65aa4835a39c6ceafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7c4844071549bd65aa4835a39c6ceafe">regina::SurfaceFilterProperties::addEulerChar</a> (const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;ec)</td></tr>
<tr class="memdesc:ga7c4844071549bd65aa4835a39c6ceafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given Euler characteristic to the set of allowable Euler characteristics.  <a href="group__surfaces.html#ga7c4844071549bd65aa4835a39c6ceafe">More...</a><br /></td></tr>
<tr class="separator:ga7c4844071549bd65aa4835a39c6ceafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca33e3e9bfa57066fee46defbb141552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaca33e3e9bfa57066fee46defbb141552">regina::SurfaceFilterProperties::removeEulerChar</a> (const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;ec)</td></tr>
<tr class="memdesc:gaca33e3e9bfa57066fee46defbb141552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given Euler characteristic from the set of allowable Euler characteristics.  <a href="group__surfaces.html#gaca33e3e9bfa57066fee46defbb141552">More...</a><br /></td></tr>
<tr class="separator:gaca33e3e9bfa57066fee46defbb141552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d189ba0309c3ebde448022b7cd5935f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3d189ba0309c3ebde448022b7cd5935f">regina::SurfaceFilterProperties::removeAllEulerChars</a> ()</td></tr>
<tr class="memdesc:ga3d189ba0309c3ebde448022b7cd5935f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empties the set of allowable Euler characteristics.  <a href="group__surfaces.html#ga3d189ba0309c3ebde448022b7cd5935f">More...</a><br /></td></tr>
<tr class="separator:ga3d189ba0309c3ebde448022b7cd5935f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06adfa97f986d51b34a21e62a5d7583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf06adfa97f986d51b34a21e62a5d7583">regina::SurfaceFilterProperties::setOrientability</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;value)</td></tr>
<tr class="memdesc:gaf06adfa97f986d51b34a21e62a5d7583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the set of allowable orientabilities.  <a href="group__surfaces.html#gaf06adfa97f986d51b34a21e62a5d7583">More...</a><br /></td></tr>
<tr class="separator:gaf06adfa97f986d51b34a21e62a5d7583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad87049b21b9ab51c289a81d2c14d45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gafad87049b21b9ab51c289a81d2c14d45">regina::SurfaceFilterProperties::setCompactness</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;value)</td></tr>
<tr class="memdesc:gafad87049b21b9ab51c289a81d2c14d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the set of allowable compactness properties.  <a href="group__surfaces.html#gafad87049b21b9ab51c289a81d2c14d45">More...</a><br /></td></tr>
<tr class="separator:gafad87049b21b9ab51c289a81d2c14d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7cfeba32b91c05b26bb29d640e81ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5c7cfeba32b91c05b26bb29d640e81ef">regina::SurfaceFilterProperties::setRealBoundary</a> (const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;value)</td></tr>
<tr class="memdesc:ga5c7cfeba32b91c05b26bb29d640e81ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the set of allowable has-real-boundary properties.  <a href="group__surfaces.html#ga5c7cfeba32b91c05b26bb29d640e81ef">More...</a><br /></td></tr>
<tr class="separator:ga5c7cfeba32b91c05b26bb29d640e81ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178a15af1e2f97372ae3c653de8406af"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga178a15af1e2f97372ae3c653de8406af">regina::SurfaceFilterProperties::accept</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface) const override</td></tr>
<tr class="memdesc:ga178a15af1e2f97372ae3c653de8406af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether or not the given normal surface is accepted by this filter.  <a href="group__surfaces.html#ga178a15af1e2f97372ae3c653de8406af">More...</a><br /></td></tr>
<tr class="separator:ga178a15af1e2f97372ae3c653de8406af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c50e18076483d95864ad345650d2888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7c50e18076483d95864ad345650d2888">regina::SurfaceFilterProperties::writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga7c50e18076483d95864ad345650d2888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="group__surfaces.html#ga7c50e18076483d95864ad345650d2888">More...</a><br /></td></tr>
<tr class="separator:ga7c50e18076483d95864ad345650d2888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab993f1731b3cbfafb19a6ddc977fac19"><td class="memItemLeft" align="right" valign="top"><a id="gab993f1731b3cbfafb19a6ddc977fac19"></a>
static <a class="el" href="classregina_1_1XMLFilterReader.html">XMLFilterReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>regina::SurfaceFilterProperties::xmlFilterReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>)</td></tr>
<tr class="separator:gab993f1731b3cbfafb19a6ddc977fac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ec5eeb4810c80741c71380d47315334"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7ec5eeb4810c80741c71380d47315334">regina::SurfaceFilterProperties::internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:ga7ec5eeb4810c80741c71380d47315334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="group__surfaces.html#ga7ec5eeb4810c80741c71380d47315334">More...</a><br /></td></tr>
<tr class="separator:ga7ec5eeb4810c80741c71380d47315334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cfee88459afd4aee4a34feb3bf5c71b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1cfee88459afd4aee4a34feb3bf5c71b">regina::SurfaceFilterProperties::writeXMLFilterData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ga1cfee88459afd4aee4a34feb3bf5c71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the details of this filter.  <a href="group__surfaces.html#ga1cfee88459afd4aee4a34feb3bf5c71b">More...</a><br /></td></tr>
<tr class="separator:ga1cfee88459afd4aee4a34feb3bf5c71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga251720a7663a27f1d22a72cf549fbed2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga251720a7663a27f1d22a72cf549fbed2">regina::XMLFilterReader::XMLFilterReader</a> ()</td></tr>
<tr class="memdesc:ga251720a7663a27f1d22a72cf549fbed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new filter element reader.  <a href="group__surfaces.html#ga251720a7663a27f1d22a72cf549fbed2">More...</a><br /></td></tr>
<tr class="separator:ga251720a7663a27f1d22a72cf549fbed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga870d8e89f2ed895e8176e263b9b7845b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga870d8e89f2ed895e8176e263b9b7845b">regina::XMLFilterReader::filter</a> ()</td></tr>
<tr class="memdesc:ga870d8e89f2ed895e8176e263b9b7845b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated filter that has been read by this element reader.  <a href="group__surfaces.html#ga870d8e89f2ed895e8176e263b9b7845b">More...</a><br /></td></tr>
<tr class="separator:ga870d8e89f2ed895e8176e263b9b7845b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b05e56eefdcc42c0050b45ed7ff6a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa5b05e56eefdcc42c0050b45ed7ff6a6">regina::XMLFilterPacketReader::XMLFilterPacketReader</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:gaa5b05e56eefdcc42c0050b45ed7ff6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new surface filter packet reader.  <a href="group__surfaces.html#gaa5b05e56eefdcc42c0050b45ed7ff6a6">More...</a><br /></td></tr>
<tr class="separator:gaa5b05e56eefdcc42c0050b45ed7ff6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9864adf21187883e54e04b8e2d86379a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9864adf21187883e54e04b8e2d86379a">regina::XMLFilterPacketReader::packet</a> () override</td></tr>
<tr class="memdesc:ga9864adf21187883e54e04b8e2d86379a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__surfaces.html#ga9864adf21187883e54e04b8e2d86379a">More...</a><br /></td></tr>
<tr class="separator:ga9864adf21187883e54e04b8e2d86379a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47377e99609a1ed88175aa5aee16f3ca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga47377e99609a1ed88175aa5aee16f3ca">regina::XMLFilterPacketReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga47377e99609a1ed88175aa5aee16f3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__surfaces.html#ga47377e99609a1ed88175aa5aee16f3ca">More...</a><br /></td></tr>
<tr class="separator:ga47377e99609a1ed88175aa5aee16f3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc7352000f92ad00fa8debb700163ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2bc7352000f92ad00fa8debb700163ab">regina::XMLFilterPacketReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:ga2bc7352000f92ad00fa8debb700163ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__surfaces.html#ga2bc7352000f92ad00fa8debb700163ab">More...</a><br /></td></tr>
<tr class="separator:ga2bc7352000f92ad00fa8debb700163ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c7ae61641d37abad5b3d756d9db9ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga78c7ae61641d37abad5b3d756d9db9ac">regina::XMLNormalSurfaceReader::XMLNormalSurfaceReader</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> newCoords)</td></tr>
<tr class="memdesc:ga78c7ae61641d37abad5b3d756d9db9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface reader.  <a href="group__surfaces.html#ga78c7ae61641d37abad5b3d756d9db9ac">More...</a><br /></td></tr>
<tr class="separator:ga78c7ae61641d37abad5b3d756d9db9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630965501c7321d504b1243732e62d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga630965501c7321d504b1243732e62d95">regina::XMLNormalSurfaceReader::surface</a> ()</td></tr>
<tr class="memdesc:ga630965501c7321d504b1243732e62d95"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the normal surface that has been read.  <a href="group__surfaces.html#ga630965501c7321d504b1243732e62d95">More...</a><br /></td></tr>
<tr class="separator:ga630965501c7321d504b1243732e62d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92daff1b64a5dfdd5fb4dc0b92170d6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga92daff1b64a5dfdd5fb4dc0b92170d6b">regina::XMLNormalSurfaceReader::startElement</a> (const std::string &amp;tagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;tagProps, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *parentReader) override</td></tr>
<tr class="memdesc:ga92daff1b64a5dfdd5fb4dc0b92170d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that parsing of this XML element is beginning.  <a href="group__surfaces.html#ga92daff1b64a5dfdd5fb4dc0b92170d6b">More...</a><br /></td></tr>
<tr class="separator:ga92daff1b64a5dfdd5fb4dc0b92170d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6492f396c24203b815c113bcf7e5b69c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6492f396c24203b815c113bcf7e5b69c">regina::XMLNormalSurfaceReader::initialChars</a> (const std::string &amp;chars) override</td></tr>
<tr class="memdesc:ga6492f396c24203b815c113bcf7e5b69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that the initial text belonging to this XML element has been read.  <a href="group__surfaces.html#ga6492f396c24203b815c113bcf7e5b69c">More...</a><br /></td></tr>
<tr class="separator:ga6492f396c24203b815c113bcf7e5b69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6304f8bb96452208b66e53ba684708e0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6304f8bb96452208b66e53ba684708e0">regina::XMLNormalSurfaceReader::startSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:ga6304f8bb96452208b66e53ba684708e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signifies that a subelement of this XML element is about to be parsed.  <a href="group__surfaces.html#ga6304f8bb96452208b66e53ba684708e0">More...</a><br /></td></tr>
<tr class="separator:ga6304f8bb96452208b66e53ba684708e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83ea492ba3c9be45c04b927b8ac22adf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga83ea492ba3c9be45c04b927b8ac22adf">regina::XMLNormalSurfacesReader::XMLNormalSurfacesReader</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *newTri, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="memdesc:ga83ea492ba3c9be45c04b927b8ac22adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new normal surface list reader.  <a href="group__surfaces.html#ga83ea492ba3c9be45c04b927b8ac22adf">More...</a><br /></td></tr>
<tr class="separator:ga83ea492ba3c9be45c04b927b8ac22adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9372bff59f5fe548909a8717bdefb992"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9372bff59f5fe548909a8717bdefb992">regina::XMLNormalSurfacesReader::packet</a> () override</td></tr>
<tr class="memdesc:ga9372bff59f5fe548909a8717bdefb992"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader.  <a href="group__surfaces.html#ga9372bff59f5fe548909a8717bdefb992">More...</a><br /></td></tr>
<tr class="separator:ga9372bff59f5fe548909a8717bdefb992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3356c94debf7c1128136248f54a953"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaae3356c94debf7c1128136248f54a953">regina::XMLNormalSurfacesReader::startContentSubElement</a> (const std::string &amp;subTagName, const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;subTagProps) override</td></tr>
<tr class="memdesc:gaae3356c94debf7c1128136248f54a953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__surfaces.html#gaae3356c94debf7c1128136248f54a953">More...</a><br /></td></tr>
<tr class="separator:gaae3356c94debf7c1128136248f54a953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa118509bfc5ec2f4192b94aa0c4dd35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gafa118509bfc5ec2f4192b94aa0c4dd35">regina::XMLNormalSurfacesReader::endContentSubElement</a> (const std::string &amp;subTagName, <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *subReader) override</td></tr>
<tr class="memdesc:gafa118509bfc5ec2f4192b94aa0c4dd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags.  <a href="group__surfaces.html#gafa118509bfc5ec2f4192b94aa0c4dd35">More...</a><br /></td></tr>
<tr class="separator:gafa118509bfc5ec2f4192b94aa0c4dd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac5261f157c24a778410b72973a29d8f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac5261f157c24a778410b72973a29d8f4">regina::DiscSpec::tetIndex</a></td></tr>
<tr class="memdesc:gac5261f157c24a778410b72973a29d8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index in the triangulation of the tetrahedron containing the disc.  <a href="group__surfaces.html#gac5261f157c24a778410b72973a29d8f4">More...</a><br /></td></tr>
<tr class="separator:gac5261f157c24a778410b72973a29d8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65724d286ef5ccb7750731c6661d3ed8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga65724d286ef5ccb7750731c6661d3ed8">regina::DiscSpec::type</a></td></tr>
<tr class="memdesc:ga65724d286ef5ccb7750731c6661d3ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc type; this is between 0 and 9 inclusive, as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes.  <a href="group__surfaces.html#ga65724d286ef5ccb7750731c6661d3ed8">More...</a><br /></td></tr>
<tr class="separator:ga65724d286ef5ccb7750731c6661d3ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a135b6871de3392dd31f8da6eda4fb"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa6a135b6871de3392dd31f8da6eda4fb">regina::DiscSpec::number</a></td></tr>
<tr class="memdesc:gaa6a135b6871de3392dd31f8da6eda4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies which disc of the particular type in the particular tetrahedron is being referred to; discs are numbered as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes.  <a href="group__surfaces.html#gaa6a135b6871de3392dd31f8da6eda4fb">More...</a><br /></td></tr>
<tr class="separator:gaa6a135b6871de3392dd31f8da6eda4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb5afac6d75ceab81eaaea50673d44a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gafbb5afac6d75ceab81eaaea50673d44a">regina::DiscSetTet::internalNDiscs</a> [10]</td></tr>
<tr class="memdesc:gafbb5afac6d75ceab81eaaea50673d44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of discs of each type.  <a href="group__surfaces.html#gafbb5afac6d75ceab81eaaea50673d44a">More...</a><br /></td></tr>
<tr class="separator:gafbb5afac6d75ceab81eaaea50673d44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca315fbe07e6aee27bf13647db6aa6b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">DataPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaca315fbe07e6aee27bf13647db6aa6b6">regina::DiscSetTetData&lt; T &gt;::internalData</a> [10]</td></tr>
<tr class="memdesc:gaca315fbe07e6aee27bf13647db6aa6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the data corresponding to each normal disc.  <a href="group__surfaces.html#gaca315fbe07e6aee27bf13647db6aa6b6">More...</a><br /></td></tr>
<tr class="separator:gaca315fbe07e6aee27bf13647db6aa6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0f57cc02ce279ec26f660c6afe1748a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad0f57cc02ce279ec26f660c6afe1748a">regina::DiscSetSurface::discSets</a></td></tr>
<tr class="memdesc:gad0f57cc02ce279ec26f660c6afe1748a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc sets corresponding to each tetrahedron.  <a href="group__surfaces.html#gad0f57cc02ce279ec26f660c6afe1748a">More...</a><br /></td></tr>
<tr class="separator:gad0f57cc02ce279ec26f660c6afe1748a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a22ab75ad4c87286476a25ca1c8e5a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2a22ab75ad4c87286476a25ca1c8e5a7">regina::DiscSetSurface::triangulation</a></td></tr>
<tr class="memdesc:ga2a22ab75ad4c87286476a25ca1c8e5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which the normal surface lives.  <a href="group__surfaces.html#ga2a22ab75ad4c87286476a25ca1c8e5a7">More...</a><br /></td></tr>
<tr class="separator:ga2a22ab75ad4c87286476a25ca1c8e5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343e081f5dee36db898b93f087de6b2e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga343e081f5dee36db898b93f087de6b2e">regina::DiscSpecIterator::internalDiscSet</a></td></tr>
<tr class="memdesc:ga343e081f5dee36db898b93f087de6b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc set through which we are iterating.  <a href="group__surfaces.html#ga343e081f5dee36db898b93f087de6b2e">More...</a><br /></td></tr>
<tr class="separator:ga343e081f5dee36db898b93f087de6b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07af029fdcbe831f24700d44be47231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf07af029fdcbe831f24700d44be47231">regina::DiscSpecIterator::current</a></td></tr>
<tr class="memdesc:gaf07af029fdcbe831f24700d44be47231"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc currently pointed to.  <a href="group__surfaces.html#gaf07af029fdcbe831f24700d44be47231">More...</a><br /></td></tr>
<tr class="separator:gaf07af029fdcbe831f24700d44be47231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aeb5de1a5c338b5917e1ec4c94bfe17"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structregina_1_1DiscType.html">DiscType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4aeb5de1a5c338b5917e1ec4c94bfe17">regina::DiscType::NONE</a></td></tr>
<tr class="memdesc:ga4aeb5de1a5c338b5917e1ec4c94bfe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a "null" disc type.  <a href="group__surfaces.html#ga4aeb5de1a5c338b5917e1ec4c94bfe17">More...</a><br /></td></tr>
<tr class="separator:ga4aeb5de1a5c338b5917e1ec4c94bfe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f4058af6ddb05f5c866741f2631a37"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa8f4058af6ddb05f5c866741f2631a37">regina::DiscType::tetIndex</a></td></tr>
<tr class="memdesc:gaa8f4058af6ddb05f5c866741f2631a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index within the triangulation of the tetrahedron containing this disc type.  <a href="group__surfaces.html#gaa8f4058af6ddb05f5c866741f2631a37">More...</a><br /></td></tr>
<tr class="separator:gaa8f4058af6ddb05f5c866741f2631a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71893afaab0f7e789f19c4b566e95fd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga71893afaab0f7e789f19c4b566e95fd2">regina::DiscType::type</a></td></tr>
<tr class="memdesc:ga71893afaab0f7e789f19c4b566e95fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the disc type within the specified tetrahedron.  <a href="group__surfaces.html#ga71893afaab0f7e789f19c4b566e95fd2">More...</a><br /></td></tr>
<tr class="separator:ga71893afaab0f7e789f19c4b566e95fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac514ed78842ca859a43dcd7a973db246"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246">regina::quadSeparating</a> [4][4]</td></tr>
<tr class="memdesc:gac514ed78842ca859a43dcd7a973db246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.  <a href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246">More...</a><br /></td></tr>
<tr class="separator:gac514ed78842ca859a43dcd7a973db246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dd2a65f964363e8b619487011a4805"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga07dd2a65f964363e8b619487011a4805">regina::quadMeeting</a> [4][4][2]</td></tr>
<tr class="memdesc:ga07dd2a65f964363e8b619487011a4805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types meet which edges in a tetrahedron.  <a href="group__surfaces.html#ga07dd2a65f964363e8b619487011a4805">More...</a><br /></td></tr>
<tr class="separator:ga07dd2a65f964363e8b619487011a4805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8920a1e646a768ea0eb9c40f904813fd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8920a1e646a768ea0eb9c40f904813fd">regina::quadDefn</a> [3][4]</td></tr>
<tr class="memdesc:ga8920a1e646a768ea0eb9c40f904813fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which vertices each quadrilateral type separates in a tetrahedron.  <a href="group__surfaces.html#ga8920a1e646a768ea0eb9c40f904813fd">More...</a><br /></td></tr>
<tr class="separator:ga8920a1e646a768ea0eb9c40f904813fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06d9e3981cbce33198558cb05246502"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac06d9e3981cbce33198558cb05246502">regina::quadPartner</a> [3][4]</td></tr>
<tr class="memdesc:gac06d9e3981cbce33198558cb05246502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron.  <a href="group__surfaces.html#gac06d9e3981cbce33198558cb05246502">More...</a><br /></td></tr>
<tr class="separator:gac06d9e3981cbce33198558cb05246502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4061f33eff68ee48a6acc372a53676b1"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4061f33eff68ee48a6acc372a53676b1">regina::quadString</a> [3][6]</td></tr>
<tr class="memdesc:ga4061f33eff68ee48a6acc372a53676b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains strings that can be used to represent each quadrilateral type in a tetrahedron.  <a href="group__surfaces.html#ga4061f33eff68ee48a6acc372a53676b1">More...</a><br /></td></tr>
<tr class="separator:ga4061f33eff68ee48a6acc372a53676b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed7e2568c2e6085550dec8b1ff5eeb1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1ed7e2568c2e6085550dec8b1ff5eeb1">regina::triDiscArcs</a> [4][3]</td></tr>
<tr class="memdesc:ga1ed7e2568c2e6085550dec8b1ff5eeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc.  <a href="group__surfaces.html#ga1ed7e2568c2e6085550dec8b1ff5eeb1">More...</a><br /></td></tr>
<tr class="separator:ga1ed7e2568c2e6085550dec8b1ff5eeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315832a821efcad8d12ee4d0158a0bbd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga315832a821efcad8d12ee4d0158a0bbd">regina::quadDiscArcs</a> [3][4]</td></tr>
<tr class="memdesc:ga315832a821efcad8d12ee4d0158a0bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc.  <a href="group__surfaces.html#ga315832a821efcad8d12ee4d0158a0bbd">More...</a><br /></td></tr>
<tr class="separator:ga315832a821efcad8d12ee4d0158a0bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d5fc76b76881cf4851d177f1adb912"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae3d5fc76b76881cf4851d177f1adb912">regina::octDiscArcs</a> [3][8]</td></tr>
<tr class="memdesc:gae3d5fc76b76881cf4851d177f1adb912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc.  <a href="group__surfaces.html#gae3d5fc76b76881cf4851d177f1adb912">More...</a><br /></td></tr>
<tr class="separator:gae3d5fc76b76881cf4851d177f1adb912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed283d890443594e39ba1ea13c81046d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Ray.html">Ray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaed283d890443594e39ba1ea13c81046d">regina::NormalSurfaceVector::coords_</a></td></tr>
<tr class="memdesc:gaed283d890443594e39ba1ea13c81046d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw vector of normal coordinates.  <a href="group__surfaces.html#gaed283d890443594e39ba1ea13c81046d">More...</a><br /></td></tr>
<tr class="separator:gaed283d890443594e39ba1ea13c81046d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898d6149eef5330881b0318305a0f910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga898d6149eef5330881b0318305a0f910">regina::NormalSurface::vector</a></td></tr>
<tr class="memdesc:ga898d6149eef5330881b0318305a0f910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the coordinates of the normal surface in whichever space is appropriate.  <a href="group__surfaces.html#ga898d6149eef5330881b0318305a0f910">More...</a><br /></td></tr>
<tr class="separator:ga898d6149eef5330881b0318305a0f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb9ec018706c2e5b2d12d6a1d5a0c63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2bb9ec018706c2e5b2d12d6a1d5a0c63">regina::NormalSurface::triangulation_</a></td></tr>
<tr class="memdesc:ga2bb9ec018706c2e5b2d12d6a1d5a0c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which this normal surface resides.  <a href="group__surfaces.html#ga2bb9ec018706c2e5b2d12d6a1d5a0c63">More...</a><br /></td></tr>
<tr class="separator:ga2bb9ec018706c2e5b2d12d6a1d5a0c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f559575a99f46ef3bf189016d2eee0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga78f559575a99f46ef3bf189016d2eee0">regina::NormalSurface::name_</a></td></tr>
<tr class="memdesc:ga78f559575a99f46ef3bf189016d2eee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional name associated with this surface.  <a href="group__surfaces.html#ga78f559575a99f46ef3bf189016d2eee0">More...</a><br /></td></tr>
<tr class="separator:ga78f559575a99f46ef3bf189016d2eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33abf9e1043c41decc8730cc38685f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga33abf9e1043c41decc8730cc38685f51">regina::NormalSurface::octPosition_</a></td></tr>
<tr class="memdesc:ga33abf9e1043c41decc8730cc38685f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The position of the first non-zero octagonal coordinate, or <a class="el" href="group__surfaces.html#ga4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> if there is no non-zero octagonal coordinate.  <a href="group__surfaces.html#ga33abf9e1043c41decc8730cc38685f51">More...</a><br /></td></tr>
<tr class="separator:ga33abf9e1043c41decc8730cc38685f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9556b33e656f0b26e2ba6d10d265045a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9556b33e656f0b26e2ba6d10d265045a">regina::NormalSurface::eulerChar_</a></td></tr>
<tr class="memdesc:ga9556b33e656f0b26e2ba6d10d265045a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Euler characteristic of this surface.  <a href="group__surfaces.html#ga9556b33e656f0b26e2ba6d10d265045a">More...</a><br /></td></tr>
<tr class="separator:ga9556b33e656f0b26e2ba6d10d265045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga010b5302c8fdcb68d24f52d0f9ce85ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga010b5302c8fdcb68d24f52d0f9ce85ac">regina::NormalSurface::boundaries_</a></td></tr>
<tr class="memdesc:ga010b5302c8fdcb68d24f52d0f9ce85ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of disjoint boundary curves on this surface.  <a href="group__surfaces.html#ga010b5302c8fdcb68d24f52d0f9ce85ac">More...</a><br /></td></tr>
<tr class="separator:ga010b5302c8fdcb68d24f52d0f9ce85ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda9da8ad3e4daf0aac417ad63d08e31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabda9da8ad3e4daf0aac417ad63d08e31">regina::NormalSurface::orientable</a></td></tr>
<tr class="memdesc:gabda9da8ad3e4daf0aac417ad63d08e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface orientable?  <a href="group__surfaces.html#gabda9da8ad3e4daf0aac417ad63d08e31">More...</a><br /></td></tr>
<tr class="separator:gabda9da8ad3e4daf0aac417ad63d08e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc009a0545d1feba9ecb90777e8aa37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6fc009a0545d1feba9ecb90777e8aa37">regina::NormalSurface::twoSided</a></td></tr>
<tr class="memdesc:ga6fc009a0545d1feba9ecb90777e8aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface two-sided?  <a href="group__surfaces.html#ga6fc009a0545d1feba9ecb90777e8aa37">More...</a><br /></td></tr>
<tr class="separator:ga6fc009a0545d1feba9ecb90777e8aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12fe97e906c4ee7b1522508769457844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga12fe97e906c4ee7b1522508769457844">regina::NormalSurface::connected</a></td></tr>
<tr class="memdesc:ga12fe97e906c4ee7b1522508769457844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface connected?  <a href="group__surfaces.html#ga12fe97e906c4ee7b1522508769457844">More...</a><br /></td></tr>
<tr class="separator:ga12fe97e906c4ee7b1522508769457844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1a6145fd6eb987cb0320a8b498d6c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab1a6145fd6eb987cb0320a8b498d6c59">regina::NormalSurface::realBoundary</a></td></tr>
<tr class="memdesc:gab1a6145fd6eb987cb0320a8b498d6c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this surface have real boundary (i.e.  <a href="group__surfaces.html#gab1a6145fd6eb987cb0320a8b498d6c59">More...</a><br /></td></tr>
<tr class="separator:gab1a6145fd6eb987cb0320a8b498d6c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2e3ed674b668351b758b1cf7f3a67b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Property.html">Property</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4c2e3ed674b668351b758b1cf7f3a67b">regina::NormalSurface::compact</a></td></tr>
<tr class="memdesc:ga4c2e3ed674b668351b758b1cf7f3a67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this surface compact (i.e.  <a href="group__surfaces.html#ga4c2e3ed674b668351b758b1cf7f3a67b">More...</a><br /></td></tr>
<tr class="separator:ga4c2e3ed674b668351b758b1cf7f3a67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30f9f73eb24a005ad31dc5d07e7f4c93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga30f9f73eb24a005ad31dc5d07e7f4c93">regina::NormalSurfaces::surfaces</a></td></tr>
<tr class="memdesc:ga30f9f73eb24a005ad31dc5d07e7f4c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the normal surfaces stored in this packet.  <a href="group__surfaces.html#ga30f9f73eb24a005ad31dc5d07e7f4c93">More...</a><br /></td></tr>
<tr class="separator:ga30f9f73eb24a005ad31dc5d07e7f4c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga317370303ab0e90b1367b33d57a92e83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga317370303ab0e90b1367b33d57a92e83">regina::NormalSurfaces::coords_</a></td></tr>
<tr class="memdesc:ga317370303ab0e90b1367b33d57a92e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores which coordinate system is being used by the normal surfaces in this packet.  <a href="group__surfaces.html#ga317370303ab0e90b1367b33d57a92e83">More...</a><br /></td></tr>
<tr class="separator:ga317370303ab0e90b1367b33d57a92e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ffe4301bf296b37ea8253f242167660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6ffe4301bf296b37ea8253f242167660">regina::NormalSurfaces::which_</a></td></tr>
<tr class="memdesc:ga6ffe4301bf296b37ea8253f242167660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normal surfaces these represent within the underlying triangulation.  <a href="group__surfaces.html#ga6ffe4301bf296b37ea8253f242167660">More...</a><br /></td></tr>
<tr class="separator:ga6ffe4301bf296b37ea8253f242167660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e72355f8511a648f728fc452ba850a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa0e72355f8511a648f728fc452ba850a">regina::NormalSurfaces::algorithm_</a></td></tr>
<tr class="memdesc:gaa0e72355f8511a648f728fc452ba850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the details of the enumeration algorithm that was used to generate this list.  <a href="group__surfaces.html#gaa0e72355f8511a648f728fc452ba850a">More...</a><br /></td></tr>
<tr class="separator:gaa0e72355f8511a648f728fc452ba850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5720a48a189a07227c44360dd73b1470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5720a48a189a07227c44360dd73b1470">regina::NormalSurfaces::SurfaceInserter::list</a></td></tr>
<tr class="memdesc:ga5720a48a189a07227c44360dd73b1470"><td class="mdescLeft">&#160;</td><td class="mdescRight">The list into which surfaces will be inserted.  <a href="group__surfaces.html#ga5720a48a189a07227c44360dd73b1470">More...</a><br /></td></tr>
<tr class="separator:ga5720a48a189a07227c44360dd73b1470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b49fb05f98c3f222092ba3d2c2eb84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga08b49fb05f98c3f222092ba3d2c2eb84">regina::NormalSurfaces::SurfaceInserter::owner</a></td></tr>
<tr class="memdesc:ga08b49fb05f98c3f222092ba3d2c2eb84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which the surfaces to be inserted are contained.  <a href="group__surfaces.html#ga08b49fb05f98c3f222092ba3d2c2eb84">More...</a><br /></td></tr>
<tr class="separator:ga08b49fb05f98c3f222092ba3d2c2eb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf119f5649806dbb536addfc01ad9051e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf119f5649806dbb536addfc01ad9051e">regina::PrismSpec::tetIndex</a></td></tr>
<tr class="memdesc:gaf119f5649806dbb536addfc01ad9051e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index in the triangulation of the tetrahedron containing the prism.  <a href="group__surfaces.html#gaf119f5649806dbb536addfc01ad9051e">More...</a><br /></td></tr>
<tr class="separator:gaf119f5649806dbb536addfc01ad9051e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e77846f2d6b4563c06048e496b1a5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga69e77846f2d6b4563c06048e496b1a5b">regina::PrismSpec::edge</a></td></tr>
<tr class="memdesc:ga69e77846f2d6b4563c06048e496b1a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The edge of the tetrahedron that is contained in this prism.  <a href="group__surfaces.html#ga69e77846f2d6b4563c06048e496b1a5b">More...</a><br /></td></tr>
<tr class="separator:ga69e77846f2d6b4563c06048e496b1a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c465f0835e7dd73e18e653d8d01908"><td class="memItemLeft" align="right" valign="top">static constexpr const <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa6c465f0835e7dd73e18e653d8d01908">regina::SurfaceFilter::filterTypeID</a></td></tr>
<tr class="memdesc:gaa6c465f0835e7dd73e18e653d8d01908"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time constant that identifies this type of surface filter.  <a href="group__surfaces.html#gaa6c465f0835e7dd73e18e653d8d01908">More...</a><br /></td></tr>
<tr class="separator:gaa6c465f0835e7dd73e18e653d8d01908"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga4e45dad662fb0b7b4a52ae8711c11801"><td class="memItemLeft" align="right" valign="top"><a id="ga4e45dad662fb0b7b4a52ae8711c11801"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSpecIterator::DiscSetSurface</b></td></tr>
<tr class="separator:ga4e45dad662fb0b7b4a52ae8711c11801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04f8801fb7fded49eac81613912fd32e"><td class="memItemLeft" align="right" valign="top"><a id="ga04f8801fb7fded49eac81613912fd32e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurface::XMLNormalSurfaceReader</b></td></tr>
<tr class="separator:ga04f8801fb7fded49eac81613912fd32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f8ed2925502037d24b7481c71d8206"><td class="memItemLeft" align="right" valign="top"><a id="ga43f8ed2925502037d24b7481c71d8206"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurfaces::VectorIterator::NormalSurfaces</b></td></tr>
<tr class="separator:ga43f8ed2925502037d24b7481c71d8206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9b961cf5afa19151031bc345822f39e"><td class="memItemLeft" align="right" valign="top"><a id="gab9b961cf5afa19151031bc345822f39e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::NormalSurfaces::XMLNormalSurfacesReader</b></td></tr>
<tr class="separator:gab9b961cf5afa19151031bc345822f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dafddbd2002f15da2be17a09289f05e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7dafddbd2002f15da2be17a09289f05e">regina::DiscSpec::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:ga7dafddbd2002f15da2be17a09289f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc specifier to the given output stream.  <a href="group__surfaces.html#ga7dafddbd2002f15da2be17a09289f05e">More...</a><br /></td></tr>
<tr class="separator:ga7dafddbd2002f15da2be17a09289f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf368816cac7120fc7e63a5601ac98496"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf368816cac7120fc7e63a5601ac98496">regina::PrismSpec::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:gaf368816cac7120fc7e63a5601ac98496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given prism specifier to the given output stream.  <a href="group__surfaces.html#gaf368816cac7120fc7e63a5601ac98496">More...</a><br /></td></tr>
<tr class="separator:gaf368816cac7120fc7e63a5601ac98496"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Normal surfaces in 3-manifold triangulations. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga28d182dc4885f0c9045d90e6e7c259ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d182dc4885f0c9045d90e6e7c259ad">&#9670;&nbsp;</a></span>REGINA_NORMAL_SURFACE_FLAVOUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_NORMAL_SURFACE_FLAVOUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">superclass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">public</span>: \</div>
<div class="line">        typedef NormalInfo&lt;id&gt; Info; \</div>
<div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coordsID = id; \</div>
<div class="line">        inline class_(<span class="keyword">const</span> class_&amp; cloneMe) : \</div>
<div class="line">                superclass(cloneMe.coords()) {} \</div>
<div class="line">        inline <span class="keyword">virtual</span> NormalSurfaceVector* clone()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return <span class="keyword">new</span> class_(*<span class="keyword">this</span>); \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsAlmostNormal()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return Info::almostNormal; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsSpun()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return Info::spun; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsOriented()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return Info::oriented; \</div>
<div class="line">        }</div>
<div class="ttc" id="agroup__surfaces_html_ga9817fc7125c53daea4e3f3cbfe987a47"><div class="ttname"><a href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a></div><div class="ttdeci">NormalCoords</div><div class="ttdoc">Represents different coordinate systems that can be used for enumerating and displaying normal surfac...</div><div class="ttdef"><b>Definition:</b> normalcoords.h:59</div></div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a subclass of NormalSurfaceVector. </p>
<p>Every subclass of NormalSurfaceVector <em>must</em> include REGINA_NORMAL_SURFACE_FLAVOUR at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>coordsID</em> that is equal to the corresponding NormalCoords constant;</li>
<li>a typedef <em>Info</em>, which refers to the corresponding specialisation of the NormalInfo&lt;&gt; template;</li>
<li>a copy constructor that takes a vector of the same subclass;</li>
<li>declarations and implementations of the virtual functions NormalSurfaceVector::clone(), NormalSurfaceVector::allowsAlmostNormal(), NormalSurfaceVector::allowsSpun(), and NormalSurfaceVector::allowsOriented().</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this subclass of NormalSurfaceVector. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding NNormalCoords constant. </td></tr>
    <tr><td class="paramname">superclass</td><td>the vector class from which <em>class_</em> is derived. This is typically NormalSurfaceVector, though in some cases it may be different (e.g., NSVectorMirrored). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga665eac8de6a24d68bddbfa631bcca6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665eac8de6a24d68bddbfa631bcca6c9">&#9670;&nbsp;</a></span>REGINA_SURFACE_FILTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_SURFACE_FILTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">public</span>: \</div>
<div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filterTypeID = id; \</div>
<div class="line">        inline <span class="keyword">virtual</span> <a class="code" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filterType()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return id; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> std::string filterTypeName()<span class="keyword"> const override </span>{ \</div>
<div class="line">            return SurfaceFilterInfo&lt;id&gt;::name(); \</div>
<div class="line">        }</div>
<div class="ttc" id="agroup__surfaces_html_ga38ab803471723156fb2ecb24b7b1c859"><div class="ttname"><a href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a></div><div class="ttdeci">SurfaceFilterType</div><div class="ttdoc">Represents different types of filter classes that can be used to filter lists of normal surfaces in 3...</div><div class="ttdef"><b>Definition:</b> surfacefiltertype.h:58</div></div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a descendant class of SurfaceFilter. </p>
<p>Every descendant class of SurfaceFilter <em>must</em> include REGINA_SURFACE_FILTER at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>filterTypeID</em>, which is equal to the corresponding SurfaceFilterType constant;</li>
<li>declarations and implementations of the virtual functions SurfaceFilter::filterType() and SurfaceFilter::filterTypeName();</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this descendant class of SurfaceFilter. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding SurfaceFilterType constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gacc58cdaf40c4b2c896cbaf2900a3d048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc58cdaf40c4b2c896cbaf2900a3d048">&#9670;&nbsp;</a></span>DataPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">DataPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type that is a pointer to the data stored with each disc. </p>

</div>
</div>
<a id="ga014be930b28c03042f107405114409d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga014be930b28c03042f107405114409d4">&#9670;&nbsp;</a></span>NDiscSetSurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> <a class="el" href="group__surfaces.html#ga014be930b28c03042f107405114409d4">regina::NDiscSetSurface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000156">Deprecated:</a></b></dt><dd>The class NDiscSetSurface has now been renamed to <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a>. </dd></dl>

</div>
</div>
<a id="ga3d65b1cb926fb791d18597bfac6ce3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d65b1cb926fb791d18597bfac6ce3b7">&#9670;&nbsp;</a></span>NDiscSetSurfaceData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__surfaces.html#ga3d65b1cb926fb791d18597bfac6ce3b7">regina::NDiscSetSurfaceData</a> = typedef <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000157">Deprecated:</a></b></dt><dd>The class NDiscSetSurfaceData has now been renamed to <a class="el" href="classregina_1_1DiscSetSurfaceData.html" title="Stores data of type T for every normal disc within a particular normal surface.">DiscSetSurfaceData</a>. </dd></dl>

</div>
</div>
<a id="ga318507a759439c77b9434bb6850bdc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318507a759439c77b9434bb6850bdc7c">&#9670;&nbsp;</a></span>NDiscSetTet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> <a class="el" href="group__surfaces.html#ga318507a759439c77b9434bb6850bdc7c">regina::NDiscSetTet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000154">Deprecated:</a></b></dt><dd>The class NDiscSetTet has now been renamed to <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a>. </dd></dl>

</div>
</div>
<a id="ga36ba5f508fd4dc4737a800ec796cf8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36ba5f508fd4dc4737a800ec796cf8e6">&#9670;&nbsp;</a></span>NDiscSetTetData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__surfaces.html#ga36ba5f508fd4dc4737a800ec796cf8e6">regina::NDiscSetTetData</a> = typedef <a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000155">Deprecated:</a></b></dt><dd>The class NDiscSetTetData has now been renamed to <a class="el" href="classregina_1_1DiscSetTetData.html" title="Stores data of type T for every normal disc inside a single tetrahedron.">DiscSetTetData</a>. </dd></dl>

</div>
</div>
<a id="gaea7f09ab89f375885be57b35504903f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea7f09ab89f375885be57b35504903f9">&#9670;&nbsp;</a></span>NDiscSpec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> <a class="el" href="group__surfaces.html#gaea7f09ab89f375885be57b35504903f9">regina::NDiscSpec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000153">Deprecated:</a></b></dt><dd>The class NDiscSpec has now been renamed to <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a>. </dd></dl>

</div>
</div>
<a id="ga1ef87df7daabeda40a127d961caedfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ef87df7daabeda40a127d961caedfc0">&#9670;&nbsp;</a></span>NDiscType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1DiscType.html">DiscType</a> <a class="el" href="group__surfaces.html#ga1ef87df7daabeda40a127d961caedfc0">regina::NDiscType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000158">Deprecated:</a></b></dt><dd>The class NDiscType has now been renamed to <a class="el" href="structregina_1_1DiscType.html" title="Identifies a single normal or almost normal disc type within a triangulation.">DiscType</a>. </dd></dl>

</div>
</div>
<a id="gae6b1bb46b52686165041bff4d0936eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b1bb46b52686165041bff4d0936eda">&#9670;&nbsp;</a></span>NNormalSurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> <a class="el" href="group__surfaces.html#gae6b1bb46b52686165041bff4d0936eda">regina::NNormalSurface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000160">Deprecated:</a></b></dt><dd>The class NNormalSurface has now been renamed to <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold.">NormalSurface</a>. </dd></dl>

</div>
</div>
<a id="gac1651d8ca85f9e04cd7c4345e7660be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1651d8ca85f9e04cd7c4345e7660be7">&#9670;&nbsp;</a></span>NNormalSurfaceList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> <a class="el" href="group__surfaces.html#gac1651d8ca85f9e04cd7c4345e7660be7">regina::NNormalSurfaceList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000161">Deprecated:</a></b></dt><dd>The class NNormalSurfaceList has now been renamed to <a class="el" href="classregina_1_1NormalSurfaces.html" title="A packet representing a collection of normal surfaces in a 3-manifold.">NormalSurfaces</a>. </dd></dl>

</div>
</div>
<a id="ga76e1de8b765f5bcd733cb5fe28063326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e1de8b765f5bcd733cb5fe28063326">&#9670;&nbsp;</a></span>NNormalSurfaceVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> <a class="el" href="group__surfaces.html#ga76e1de8b765f5bcd733cb5fe28063326">regina::NNormalSurfaceVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000159">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVector has now been renamed to <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </dd></dl>

</div>
</div>
<a id="ga8962f2fc5b8ed3347b8157097de22f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8962f2fc5b8ed3347b8157097de22f0f">&#9670;&nbsp;</a></span>NNormalSurfaceVectorANStandard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorANStandard.html">NSVectorANStandard</a> <a class="el" href="group__surfaces.html#ga8962f2fc5b8ed3347b8157097de22f0f">regina::NNormalSurfaceVectorANStandard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000162">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorANStandard has now been renamed to <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a>. </dd></dl>

</div>
</div>
<a id="ga3a007103e8da63d8e29f79a642df29c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a007103e8da63d8e29f79a642df29c5">&#9670;&nbsp;</a></span>NNormalSurfaceVectorMirrored</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorMirrored.html">NSVectorMirrored</a> <a class="el" href="group__surfaces.html#ga3a007103e8da63d8e29f79a642df29c5">regina::NNormalSurfaceVectorMirrored</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000163">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorMirrored has now been renamed to <a class="el" href="classregina_1_1NSVectorMirrored.html" title="A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calcu...">NSVectorMirrored</a>. </dd></dl>

</div>
</div>
<a id="ga5b3d48602a97ee3e83d4407f341e6455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b3d48602a97ee3e83d4407f341e6455">&#9670;&nbsp;</a></span>NNormalSurfaceVectorOriented</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorOriented.html">NSVectorOriented</a> <a class="el" href="group__surfaces.html#ga5b3d48602a97ee3e83d4407f341e6455">regina::NNormalSurfaceVectorOriented</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000164">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorOriented has now been renamed to <a class="el" href="classregina_1_1NSVectorOriented.html" title="A normal surface vector using transversely oriented standard (triangle-quad) coordinates.">NSVectorOriented</a>. </dd></dl>

</div>
</div>
<a id="gaffde6a7ffe1f773fa073d0bc33e4744f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde6a7ffe1f773fa073d0bc33e4744f">&#9670;&nbsp;</a></span>NNormalSurfaceVectorOrientedQuad</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorOrientedQuad.html">NSVectorOrientedQuad</a> <a class="el" href="group__surfaces.html#gaffde6a7ffe1f773fa073d0bc33e4744f">regina::NNormalSurfaceVectorOrientedQuad</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000165">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorOrientedQuad has now been renamed to <a class="el" href="classregina_1_1NSVectorOrientedQuad.html" title="A normal surface vector using transversely oriented quadrilateral coordinates.">NSVectorOrientedQuad</a>. </dd></dl>

</div>
</div>
<a id="ga6dc7349b11544a8b8d78c61e19daedc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dc7349b11544a8b8d78c61e19daedc4">&#9670;&nbsp;</a></span>NNormalSurfaceVectorQuad</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorQuad.html">NSVectorQuad</a> <a class="el" href="group__surfaces.html#ga6dc7349b11544a8b8d78c61e19daedc4">regina::NNormalSurfaceVectorQuad</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000166">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorQuad has now been renamed to <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>. </dd></dl>

</div>
</div>
<a id="ga6aa7bc30d85d431385818f616ebc5004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa7bc30d85d431385818f616ebc5004">&#9670;&nbsp;</a></span>NNormalSurfaceVectorQuadOct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorQuadOct.html">NSVectorQuadOct</a> <a class="el" href="group__surfaces.html#ga6aa7bc30d85d431385818f616ebc5004">regina::NNormalSurfaceVectorQuadOct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000167">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorQuadOct has now been renamed to <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>. </dd></dl>

</div>
</div>
<a id="gad7bc8620edc82bec1339e1460e7b1e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7bc8620edc82bec1339e1460e7b1e75">&#9670;&nbsp;</a></span>NNormalSurfaceVectorStandard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorStandard.html">NSVectorStandard</a> <a class="el" href="group__surfaces.html#gad7bc8620edc82bec1339e1460e7b1e75">regina::NNormalSurfaceVectorStandard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000168">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorStandard has now been renamed to <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a>. </dd></dl>

</div>
</div>
<a id="ga239df7c1e704457d116029fc144dc473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239df7c1e704457d116029fc144dc473">&#9670;&nbsp;</a></span>NormalAlg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;<a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a>&gt; <a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">regina::NormalAlg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal surface lists. </p>
<dl class="section user"><dt>Python</dt><dd>This is present, and all values in the NormalAlgFlags enumeration type are treated as members of this NormalAlg class. </dd></dl>

</div>
</div>
<a id="ga10adc2dfa823f4b97db64abccdc7f73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10adc2dfa823f4b97db64abccdc7f73d">&#9670;&nbsp;</a></span>NormalList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;<a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a>&gt; <a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">regina::NormalList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal surface lists. </p>
<dl class="section user"><dt>Python</dt><dd>This is present, and all values in the NormalListFlags enumeration type are treated as members of this NormalList class. </dd></dl>

</div>
</div>
<a id="ga0dc97e79a145070e73896ab2b7730415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc97e79a145070e73896ab2b7730415">&#9670;&nbsp;</a></span>NPrismSpec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> <a class="el" href="group__surfaces.html#ga0dc97e79a145070e73896ab2b7730415">regina::NPrismSpec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000169">Deprecated:</a></b></dt><dd>The class NPrismSpec has now been renamed to <a class="el" href="structregina_1_1PrismSpec.html" title="Specifies a single triangular prism in a tetrahedron.">PrismSpec</a>. </dd></dl>

</div>
</div>
<a id="ga6de04b41af82d94b20738074da3f97a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6de04b41af82d94b20738074da3f97a3">&#9670;&nbsp;</a></span>NSurfaceFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> <a class="el" href="group__surfaces.html#ga6de04b41af82d94b20738074da3f97a3">regina::NSurfaceFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000170">Deprecated:</a></b></dt><dd>The class NSurfaceFilter has now been renamed to <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>. </dd></dl>

</div>
</div>
<a id="ga3cdc257da3694fba7fb12daf605240ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cdc257da3694fba7fb12daf605240ba">&#9670;&nbsp;</a></span>NSurfaceFilterCombination</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> <a class="el" href="group__surfaces.html#ga3cdc257da3694fba7fb12daf605240ba">regina::NSurfaceFilterCombination</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000171">Deprecated:</a></b></dt><dd>The class NSurfaceFilterCombination has now been renamed to <a class="el" href="classregina_1_1SurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters.">SurfaceFilterCombination</a>. </dd></dl>

</div>
</div>
<a id="ga51eaf1ba4c64a4761d40dffc506a2344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51eaf1ba4c64a4761d40dffc506a2344">&#9670;&nbsp;</a></span>NSurfaceFilterProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> <a class="el" href="group__surfaces.html#ga51eaf1ba4c64a4761d40dffc506a2344">regina::NSurfaceFilterProperties</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000172">Deprecated:</a></b></dt><dd>The class NSurfaceFilterProperties has now been renamed to <a class="el" href="classregina_1_1SurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface.">SurfaceFilterProperties</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3c4cfc5de652a5beaadaaee0cacdeede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4cfc5de652a5beaadaaee0cacdeede">&#9670;&nbsp;</a></span>NormalAlgFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">regina::NormalAlgFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations. </p>
<p>These options are typically combined in a bitwise fashion using the NormalAlg type, and then passed to enumeration routines such as <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">NormalSurfaces::enumerate()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>The values in this enumeration type are present, but they are treated by Python as NormalList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b"></a>NS_ALG_DEFAULT&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea4c4bfbfefa31e5c048a0d9e25abf9f89"></a>NS_VERTEX_VIA_REDUCED&#160;</td><td class="fielddoc"><p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should first enumerate in quadrilateral or quadrilateral-octagon coordinates, and then expand this "reduced" solution set to the (typically larger) "standard" solution set. </p>
<p>This is typically much faster than a direct enumeration in standard normal or almost normal coordinates, and enumeration routines will use this option where possible unless explicitly requested not to (via the flag NS_VERTEX_STD_DIRECT).</p>
<p>For an explanation of this procedure, see B. A. Burton, "Converting between quadrilateral and standard solution sets in
normal surface theory", Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>This flag is incompatible with NS_VERTEX_STD_DIRECT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea15bc7c42b8b986d93863600852d271c7"></a>NS_VERTEX_STD_DIRECT&#160;</td><td class="fielddoc"><p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should work directly in that coordinate system, and should not go via the "reduced" (quadrilateral or quadrilateral-octagon) coordinate system. </p>
<p>This is typically <em>much</em> slower than going via the reduced system, and users should only request this if they have a specialised need. See NS_VERTEX_VIA_REDUCED for further information.</p>
<p>This flag is incompatible with NS_VERTEX_VIA_REDUCED. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea482b7e69b14c44d02b29055726b04830"></a>NS_VERTEX_TREE&#160;</td><td class="fielddoc"><p>When enumerating vertex normal surfaces, this flag indicates that the tree traversal algorithm should be used. </p>
<p>This algorithm is based on linear and integer programming techniques, and has many desirable properties including a relatively low overhead. Enumeration algorithms will use it if possible unless a different method is explicitly requested.</p>
<p>For details on the tree traversal algorithm, see B. A. Burton and M. Ozlen, "A tree traversal algorithm for decision problems in
knot theory and 3-manifold topology", Algorithmica 65 (2013), pp. 772-801.</p>
<p>This flag is incompatible with NS_VERTEX_DD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedeac988e037d6c164c645567750680c6e11"></a>NS_VERTEX_DD&#160;</td><td class="fielddoc"><p>When enumerating vertex normal surfaces, this flag indicates that a modified double description method should be used. </p>
<p>This algorithm can suffer from a combinatorial explosion with larger problems, leading to extremely large time and memory footprints. Users should only request this if they have some specialised need.</p>
<p>For details on the modified double description method, see B. A. Burton, "Optimizing the double description method for
normal surface enumeration", Mathematics of Computation 79 (2010), pp. 453-484.</p>
<p>This flag is incompatible with NS_VERTEX_TREE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea33ff9b1fafe5bc6aa4dbf851ec2b9ae6"></a>NS_HILBERT_PRIMAL&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that the primal method should be used for enumerating a Hilbert basis. </p>
<p>The primal method is recommended, and enumeration algorithms will use it if possible unless a different method is explicitly requested. This method uses code from Normaliz for parts of its processing.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_DUAL, NS_HILBERT_CD and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea77887211e55db67ba4ba10247cd159f3"></a>NS_HILBERT_DUAL&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that the dual method should be used for enumerating a Hilbert basis. </p>
<p>The dual method is fast (like the primal method), but its performance is highly variable; for this reason the primal method is recommended instead. This method does not make use of Normaliz, and is the recommended method for situations in which Normaliz is not available for some reason.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_CD and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea1da3bc474ed341903ab0f043488e27c3"></a>NS_HILBERT_CD&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that a modified Contejean-Devie procedure should be used for enumerating a Hilbert basis. </p>
<p>The Contejean-Devie procedure is typically <em>much</em> slower than either the primal or dual method, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_DUAL and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea7d84f194dd4d881f2175acae85fa3742"></a>NS_HILBERT_FULLCONE&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that a Hilbert basis for the full solution cone should be constructed, and additional combinatorial constraints (such as the quadrilateral constraints) should only be enforced as the final step. </p>
<p>If you are only enumerating properly embedded surfaces then this procedure <em>extremely</em> slow, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_DUAL and NS_HILBERT_CD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea61e5c6c91ab2a0c4ac8a6fca9cccd430"></a>NS_ALG_LEGACY&#160;</td><td class="fielddoc"><p>Indicates that a normal surface list was enumerated using an older version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of the algorithm used to build each list, and so in such cases no further algorithmic information is available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea6d1833185860331a3be3d7f909b1323a"></a>NS_ALG_CUSTOM&#160;</td><td class="fielddoc"><p>Indicates that a normal surface list was built using a customised algorithm. </p>
<p>In such cases, no further details on the algorithm are available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9817fc7125c53daea4e3f3cbfe987a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9817fc7125c53daea4e3f3cbfe987a47">&#9670;&nbsp;</a></span>NormalCoords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different coordinate systems that can be used for enumerating and displaying normal surfaces. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own coordinate system, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a36273f97819ff462b10db091f8a93f75"></a>NS_STANDARD&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral coordinates for normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47af3d1b2ccecff610fdaae1e4f3dde0744"></a>NS_QUAD&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates for normal surfaces. </p>
<p>For details, see "Normal surface Q-theory", Jeffrey L. Tollefson, Pacific J. Math. 183 (1998), no. 2, 359&ndash;374. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a676715b936f4d82fbf2cd2b66be3b5cf"></a>NS_QUAD_CLOSED&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates in ideal triangulations for enumerating closed surfaces only (thus excluding spun-normal surfaces). </p>
<p>The coordinates themselves are identical to quadrilateral coordinates, as described by NS_QUAD; however, the enumeration procedure introduces additional constraints. The resulting solution space is the space Q_0 as described in "Computing closed
essential surfaces in knot complements", by Burton, Coward and Tillmann, in SCG ’13: Proceedings of the 29th Annual Symposium on Computational Geometry, ACM, 2013, pp. 405–414.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Regina can only create matching equations in this coordinate system for a limited class of triangulations. Currently, such triangulations <em>must</em> be oriented and ideal, with precisely one torus cusp and no other boundary components or internal vertices. Moreover, SnapPea must be able to work with them without retriangulating (though this should follow from the other constraints). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ad2d9d61fc90b31363ec5931b1a300aa8"></a>NS_AN_LEGACY&#160;</td><td class="fielddoc"><p>Indicates that a list of almost normal surfaces was created using Regina 4.5.1 or earlier, where surfaces with more than one octagon of the same type were stripped out of the final solution set. </p>
<p>As of Regina 4.6 such surfaces are now included in the solution set, since we need them if we wish to enumerate <em>all</em> almost normal surfaces (not just the <em>vertex</em> almost normal surfaces).</p>
<p>This coordinate system is only used with legacy data files; new vectors and lists cannot be created in this coordinate system. The underlying coordinates are identical to those of NS_AN_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a4a7e1fc6780905418e84cadf782dd82f"></a>NS_AN_QUAD_OCT&#160;</td><td class="fielddoc"><p>Represents quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
<p>For details, see "Quadrilateral-octagon coordinates for almost normal surfaces", Benjamin A. Burton, Experiment. Math. 19 (2010), 285-315. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a0de57480ceb39c23829e982e5bef7d84"></a>NS_AN_STANDARD&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a8ad2e142ae1dda418034657e42365d90"></a>NS_AN_QUAD_OCT_CLOSED&#160;</td><td class="fielddoc"><p>Represents quadrilateral-octagon coordinates in ideal triangulations for enumerating closed surfaces only (thus excluding spun-almost normal surfaces). </p>
<p>The coordinates themselves are identical to quadrilateral-octagon coordinates, as described by NS_AN_QUAD_OCT; however, the enumeration procedure introduces additional constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Regina can only create matching equations in this coordinate system for a limited class of triangulations. Currently, such triangulations <em>must</em> be oriented and ideal, with precisely one torus cusp and no other boundary components or internal vertices. Moreover, SnapPea must be able to work with them without retriangulating (though this should follow from the other constraints). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae"></a>NS_EDGE_WEIGHT&#160;</td><td class="fielddoc"><p>Represents edge weight coordinates for normal surfaces. </p>
<p>This coordinate system is for display only; surface vectors and lists cannot be created in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ae8c39b9dd91ad81bf89ca633c8d9598f"></a>NS_TRIANGLE_ARCS&#160;</td><td class="fielddoc"><p>Represents triangle arc coordinates for normal surfaces. </p>
<p>This coordinate system is for display only; surface vectors and lists cannot be created in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a602873a7f7351b3822c37b075ba88c43"></a>NS_ORIENTED&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral coordinates for transversely oriented normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a205b46c71691c8092a5afa1d99ab556a"></a>NS_ORIENTED_QUAD&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates for transversely oriented normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a9f471af2d202b88f06ed65be82e5d7eb"></a>NS_ANGLE&#160;</td><td class="fielddoc"><p>Represents angle structure coordinates. </p>
<p>This coordinate system is <em>not</em> for use with normal surfaces: it cannot be used either to display them or enumerate them. Instead it is for use with angle structures on triangulations. Because the combinatorics and linear algebra of angle strutures are tightly related to those of normal surfaces, we include NS_ANGLE here so that angle structure routines can make use of some of Regina's existing normal surface machinery.</p>
<p>For a triangulation with <em>n</em> tetrahedra, this system has 3<em>n</em>+1 coordinates. The first 3<em>n</em> are analogous to quadrilateral coordinates (specifically, for each quadrilateral type <em>Q</em>, the corresponding angle structure coordinate represents the pair of angles in the same tetrahedron that <em>Q</em> does not meet). The final coordinate is a scaling coordinate, used to projectivise the angle structure polytope so that it becomes a polyhedral cone that is invariant under (positive) scaling. If the final scaling coordinate is <em>s</em>, then a rational value of <em>x</em> in any other coordinate position should be interpreted as the angle <em>x</em>.&pi;/<em>s</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This coordinate system must not be used with any of Regina's routines unless they explicitly declare that NS_ANGLE is allowed. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="gabff25e58607c49cca84049a1069c2cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff25e58607c49cca84049a1069c2cce">&#9670;&nbsp;</a></span>NormalListFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">regina::NormalListFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation. </p>
<p>The NormalList enumeration refers to the <em>contents</em> of the list, whereas the NormalAlgFlags enumeration refers to the <em>algorithm</em> used to build it.</p>
<dl class="section user"><dt>Python</dt><dd>The values in this enumeration type are present, but they are treated by Python as NormalList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864"></a>NS_LIST_DEFAULT&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea41f7f2158c91f3f64f3354118f6a8761"></a>NS_EMBEDDED_ONLY&#160;</td><td class="fielddoc"><p>Indicates that this list is restricted to properly embedded surfaces only. </p>
<p>This flag is incompatible with NS_IMMERSED_SINGULAR. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea1e0c5bf3f4138d8ec4a88caeb5f87a61"></a>NS_IMMERSED_SINGULAR&#160;</td><td class="fielddoc"><p>Indicates that the scope of this list includes not just properly embedded surfaces, but also immersed and/or branched surfaces. </p>
<p>This is no guarantee that the list <em>contains</em> immersed and/or branched surfaces; it merely states that such surfaces have not been explicitly excluded (in particular, the quadrilateral constraints have not been enforced).</p>
<p>This flag is incompatible with NS_EMBEDDED_ONLY. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea38cd0d13c8afd0f688eda457d5ed550d"></a>NS_VERTEX&#160;</td><td class="fielddoc"><p>Indicates a list of all vertex normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with NS_FUNDAMENTAL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea949286ba72f0deec9b6bbe2b8a23b39c"></a>NS_FUNDAMENTAL&#160;</td><td class="fielddoc"><p>Indicates a list of all fundamental normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with NS_VERTEX. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2cceaab119737dcff1409ff0f2071baee7e40"></a>NS_LEGACY&#160;</td><td class="fielddoc"><p>Indicates a list that was constructed using an old version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of how each list was constructed, beyond whether immersed and/or singular surfaces were included. Therefore no information is available for such lists, other than the presence or absence of the NS_EMBEDDED_ONLY and/or NS_IMMERSED_SINGULAR flags.</p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea64cbdf1921e4a99c5943b4039dac2709"></a>NS_CUSTOM&#160;</td><td class="fielddoc"><p>Indicates some other type of list, typically hand-crafted by the user or built by some customised algorithm. </p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae923c7c2fa692192d45bdf563f380918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae923c7c2fa692192d45bdf563f380918">&#9670;&nbsp;</a></span>SurfaceExportFields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">regina::SurfaceExportFields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to describe a field, or a set of fields, that can be exported alongside a normal surface list. </p>
<p>This enumeration type is used with export routines such as <a class="el" href="group__surfaces.html#ga2b308eb9fd7a131b2c370a589b7e43c6" title="Exports this list of normal surfaces as a plain text CSV (comma-separated value) file,...">NormalSurfaces::saveCSVStandard()</a> or <a class="el" href="group__surfaces.html#gae2559f5cea6339eb69cdcc532f970409" title="Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file,...">NormalSurfaces::saveCSVEdgeWeight()</a>.</p>
<p>This type describes fields in addition to normal coordinates, not the normal coordinates themselves (which are always exported). Each field describes some property of a single normal surface, and corresponds to a single column in a table of normal surfaces.</p>
<p>This type should be treated as a bitmask: you can describe a set of fields by combining the values for individual fields using bitwise <em>or</em>.</p>
<p>The list of available fields may grow with future releases of Regina. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a81408d5dd0f9deb210bf66ecee761c36"></a>surfaceExportName&#160;</td><td class="fielddoc"><p>Represents the user-assigned surface name. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a131a23295ec061f83590561bba365de8"></a>surfaceExportEuler&#160;</td><td class="fielddoc"><p>Represents the calculated Euler characteristic of a surface. </p>
<p>This will be an integer, and will be left empty if the Euler characteristic cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a153a815a9b0f7d3b3383f39c2d6f94ca"></a>surfaceExportOrient&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is orientable. </p>
<p>This will be the string <code>TRUE</code> or <code>FALSE</code>, or will be left empty if the orientability cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a60a48a7481d07261cf4a4051cffc3bc3"></a>surfaceExportSides&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is one-sided or two-sided. </p>
<p>This will be the integer 1 or 2, or will be left empty if the "sidedness" cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918add63709fcbf9038110d4a3b232a466c2"></a>surfaceExportBdry&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is bounded. </p>
<p>In most cases, this will be one of the strings "closed", "real bdry" or "infinite" (where "infinite" indicates a surface with infinitely many discs). For spun-normal surfaces in certain ideal triangulations, this string will be followed by the boundary slopes of the surface at the cusps: these written as a list of pairs (<em>p</em>, <em>q</em>), one for each cusp, indicating that the boundary curves of the surface run <em>p</em> times around the meridian and <em>q</em> times around the longitude. See <a class="el" href="group__surfaces.html#ga0b6b0e73ae35e166dc07e3ac1cd54cae" title="Computes the information about the boundary slopes of this surface at each cusp of the triangulation.">NormalSurface::boundaryIntersections()</a> for further information on interpreting these values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a0832d74579319961e0c6f976e28b0356"></a>surfaceExportLink&#160;</td><td class="fielddoc"><p>Represents whether a surface is a single vertex link or a thin edge link. </p>
<p>See <a class="el" href="group__surfaces.html#gaf98616d2b0b270a6a427133d3cd88cae" title="Determines whether or not a rational multiple of this surface is the link of a single vertex.">NormalSurface::isVertexLink()</a> and <a class="el" href="group__surfaces.html#gab82721dfe41b187548593091b7274e6e" title="Determines whether or not a rational multiple of this surface is the thin link of a single edge.">NormalSurface::isThinEdgeLink()</a> for details. This will be written as a human-readable string. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918acf49b97bd782901a7f6ee32bf9841b03"></a>surfaceExportType&#160;</td><td class="fielddoc"><p>Represents any additional high-level properties of a surface, such as whether it is a splitting surface or a central surface. </p>
<p>This will be written as a human-readable string. This field is somewhat arbitrary, and the precise properties it describes are subject to change in future releases of Regina. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a9b7d4c6f39579e1711b203dcf8ed3824"></a>surfaceExportNone&#160;</td><td class="fielddoc"><p>Indicates that no additional fields should be exported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a90da6f93fd64f642efa8b5862d7b4dac"></a>surfaceExportAllButName&#160;</td><td class="fielddoc"><p>Indicates that all available fields should be exported, except for the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64"></a>surfaceExportAll&#160;</td><td class="fielddoc"><p>Indicates that all available fields should be exported, including the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga38ab803471723156fb2ecb24b7b1c859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ab803471723156fb2ecb24b7b1c859">&#9670;&nbsp;</a></span>SurfaceFilterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own filter class, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004"></a>NS_FILTER_DEFAULT&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a> class: a do-nothing filter that accepts any normal surface. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859abad02c85eeeda839925c60cd245fb478"></a>NS_FILTER_PROPERTIES&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface.">SurfaceFilterProperties</a> subclass: a filter that examines simple properties of a normal surface. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859a53350ed09529a46c5ed4298a14d9c6a2"></a>NS_FILTER_COMBINATION&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters.">SurfaceFilterCombination</a> subclass: a filter that combines other filters using boolean AND or OR. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2048b5426c5f9a318d6c552612cbf680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2048b5426c5f9a318d6c552612cbf680">&#9670;&nbsp;</a></span>accept() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SurfaceFilter::accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides whether or not the given normal surface is accepted by this filter. </p>
<p>The default implementation simply returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given surface is accepted by this filter. </dd></dl>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga178a15af1e2f97372ae3c653de8406af">regina::SurfaceFilterProperties</a>, and <a class="el" href="group__surfaces.html#ga3231f51146222c24aa9375683842383b">regina::SurfaceFilterCombination</a>.</p>

</div>
</div>
<a id="ga3231f51146222c24aa9375683842383b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3231f51146222c24aa9375683842383b">&#9670;&nbsp;</a></span>accept() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::SurfaceFilterCombination::accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides whether or not the given normal surface is accepted by this filter. </p>
<p>The default implementation simply returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given surface is accepted by this filter. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga2048b5426c5f9a318d6c552612cbf680">regina::SurfaceFilter</a>.</p>

</div>
</div>
<a id="ga178a15af1e2f97372ae3c653de8406af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga178a15af1e2f97372ae3c653de8406af">&#9670;&nbsp;</a></span>accept() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::SurfaceFilterProperties::accept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides whether or not the given normal surface is accepted by this filter. </p>
<p>The default implementation simply returns <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface under investigation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given surface is accepted by this filter. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga2048b5426c5f9a318d6c552612cbf680">regina::SurfaceFilter</a>.</p>

</div>
</div>
<a id="ga7c4844071549bd65aa4835a39c6ceafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c4844071549bd65aa4835a39c6ceafe">&#9670;&nbsp;</a></span>addEulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterProperties::addEulerChar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given Euler characteristic to the set of allowable Euler characteristics. </p>
<p>See <a class="el" href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353" title="Returns the set of allowable Euler characteristics.">eulerChars()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>the new allowable Euler characteristic. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga14859baec94b6d792d0234fa2c4def8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14859baec94b6d792d0234fa2c4def8e">&#9670;&nbsp;</a></span>adjacentDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>* regina::DiscSetSurface::adjacentDisc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>disc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjArc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which normal disc is adjacent to the given normal disc along the given directed normal arc in the surface described by this disc set. </p>
<p>A directed normal arc will be specified by a permutation <em>p</em>, where the arc runs around vertex <code>p[0]</code> parallel to the directed edge from vertex <code>p[1]</code> to <code>p[2]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disc</td><td>the given normal disc; this must be a disc in this disc set. </td></tr>
    <tr><td class="paramname">arc</td><td>the given normal arc; this must actually be an arc on the boundary of the given normal disc (although it may run in either direction). </td></tr>
    <tr><td class="paramname">adjArc</td><td>returns the same directed normal arc that was passed, but expressed in terms of the vertices of the adjacent tetrahedron. Any value may be initially passed. If there is no adjacent disc/tetrahedron, this permutation will remain unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal disc adjacent to the given disc along the given arc, or 0 if there is no adjacent disc. This disc specifier will be newly created, and it is up to the caller of this routine to dispose of it. </dd></dl>

</div>
</div>
<a id="ga9fb828ac80eb4538f156dfd63b4c30f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fb828ac80eb4538f156dfd63b4c30f9">&#9670;&nbsp;</a></span>algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> regina::NormalSurfaces::algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the algorithm that was used to enumerate this list. </p>
<p>These may not be the same NormalAlg flags that were passed to <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>. In particular, default values will have been explicitly filled in, invalid and/or redundant values will have been removed, and unavailable and/or unsupported combinations of algorithm flags will be replaced with whatever algorithm was actually used.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the algorithm used to enumerate this list. </dd></dl>

</div>
</div>
<a id="ga286441732edb4692736f33e769489dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga286441732edb4692736f33e769489dde">&#9670;&nbsp;</a></span>allowsAlmostNormal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="ga44b5594a67c7a695ab21adaa862a8d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b5594a67c7a695ab21adaa862a8d38">&#9670;&nbsp;</a></span>allowsAlmostNormal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> octagonal discs.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="ga4bbcbedabcb93d26a3cd50eee857f27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4bbcbedabcb93d26a3cd50eee857f27f">&#9670;&nbsp;</a></span>allowsOriented() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the coordinate system being used allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported. </dd></dl>

</div>
</div>
<a id="ga8c2541a7dcdecfafd908ad50d98cd9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c2541a7dcdecfafd908ad50d98cd9d1">&#9670;&nbsp;</a></span>allowsOriented() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported. </dd></dl>

</div>
</div>
<a id="ga0f3529c33550ecf08dcd6d7a33409a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f3529c33550ecf08dcd6d7a33409a8b">&#9670;&nbsp;</a></span>allowsSpun() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the coordinate system being used allows for spun normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun normal surface are supported. </dd></dl>

</div>
</div>
<a id="gab07d54c737adf4198657a237f31d8851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab07d54c737adf4198657a237f31d8851">&#9670;&nbsp;</a></span>allowsSpun() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::allowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> infinitely many triangles.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun-normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="gaccafa8884a778da2a68041bbc3c0f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccafa8884a778da2a68041bbc3c0f0f9">&#9670;&nbsp;</a></span>arcFromDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetTet::arcFromDisc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>discNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which normal arc of a given type on a given face of this tetrahedron corresponds to the given normal disc. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal disc actually meets a normal arc of the given type on the given face.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arcFace</td><td>the face of this tetrahedron containing the normal arc (between 0 and 3 inclusive). </td></tr>
    <tr><td class="paramname">arcVertex</td><td>the vertex of this tetrahedron about which the normal arc runs (between 0 and 3 inclusive); <em>arcFace</em> and <em>arcVertex</em> should not be the same. </td></tr>
    <tr><td class="paramname">discType</td><td>the disc type of the given normal disc; this should be between 0 and 9 inclusive, as described in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">discNumber</td><td>indicates which normal disc of the given disc type is referred to (between 0 and <code>nDiscs(discType)-1</code> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the normal arc of the given type that belongs to the given normal disc. Arcs of a given type (where <em>arcFace</em> and <em>arcVertex</em> together define the arc type) are numbered starting at 0 from the tetrahedron vertex outwards. </dd></dl>

</div>
</div>
<a id="ga00a0872585e068bfc47cfdc417c63dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a0872585e068bfc47cfdc417c63dd0">&#9670;&nbsp;</a></span>arcs() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

</div>
</div>
<a id="gad3e760f7358e5ab934afca94fcd57138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3e760f7358e5ab934afca94fcd57138">&#9670;&nbsp;</a></span>arcs() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="group__surfaces.html#ga00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implemented in <a class="el" href="group__surfaces.html#ga25b92f75058a45943a976e08c595fb02">regina::NSVectorStandard</a>, <a class="el" href="group__surfaces.html#gab5de36fdaeb65ecb4ce02fa95ec8fe30">regina::NSVectorOriented</a>, <a class="el" href="group__surfaces.html#gacef4cdd091a72db9f5a7bbd37c0c1735">regina::NSVectorMirrored</a>, and <a class="el" href="group__surfaces.html#ga98998d0a6b84b8cfb2dfd70a9c0f4359">regina::NSVectorANStandard</a>.</p>

</div>
</div>
<a id="ga98998d0a6b84b8cfb2dfd70a9c0f4359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98998d0a6b84b8cfb2dfd70a9c0f4359">&#9670;&nbsp;</a></span>arcs() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorANStandard::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="group__surfaces.html#ga00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gad3e760f7358e5ab934afca94fcd57138">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gacef4cdd091a72db9f5a7bbd37c0c1735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef4cdd091a72db9f5a7bbd37c0c1735">&#9670;&nbsp;</a></span>arcs() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="group__surfaces.html#ga00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gad3e760f7358e5ab934afca94fcd57138">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gab5de36fdaeb65ecb4ce02fa95ec8fe30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5de36fdaeb65ecb4ce02fa95ec8fe30">&#9670;&nbsp;</a></span>arcs() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="group__surfaces.html#ga00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gad3e760f7358e5ab934afca94fcd57138">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga25b92f75058a45943a976e08c595fb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25b92f75058a45943a976e08c595fb02">&#9670;&nbsp;</a></span>arcs() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorStandard::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="group__surfaces.html#ga00a0872585e068bfc47cfdc417c63dd0" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gad3e760f7358e5ab934afca94fcd57138">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gaf1bcb320960af2e96d587cc40549a48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1bcb320960af2e96d587cc40549a48c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> regina::DiscSetSurface::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of all normal discs in the underlying normal surface. </p>
<p>These <a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c" title="Returns an iterator at the beginning of the range of all normal discs in the underlying normal surfac...">begin()</a> and <a class="el" href="group__surfaces.html#gae26003982483e680a1c073ab250702d2" title="Returns an iterator at the end of the range of all normal discs in the underlying normal surface.">end()</a> routines allow you to iterate through all normal discs using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__surfaces.html#ga9bc5a059c5627c16967d7438dc742fca">DiscSetSurface</a>* discs = ...;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> DiscSpec&amp; s : *discs) { ... }</div>
<div class="ttc" id="agroup__surfaces_html_ga9bc5a059c5627c16967d7438dc742fca"><div class="ttname"><a href="group__surfaces.html#ga9bc5a059c5627c16967d7438dc742fca">regina::DiscSetSurface::DiscSetSurface</a></div><div class="ttdeci">DiscSetSurface(const NormalSurface &amp;surface, bool b)</div><div class="ttdoc">Creates a new disc set corresponding to the discs of the given normal surface.</div></div>
</div><!-- fragment --><p>In Python, a <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> can be treated as an iterable object, again iterating through all normal discs:</p>
<div class="fragment"><div class="line">discs = ...</div>
<div class="line"><span class="keywordflow">for</span> s <span class="keywordflow">in</span> discs:</div>
<div class="line">    ...</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of the range of all normal discs. </dd></dl>

</div>
</div>
<a id="gadb8da79103f921bee2f52e6fdb39eb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb8da79103f921bee2f52e6fdb39eb2e">&#9670;&nbsp;</a></span>beginVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::beginVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator that gives access to the raw vectors for surfaces in this list, pointing to the beginning of this surface list. </p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this surface list. </dd></dl>

</div>
</div>
<a id="ga0b6b0e73ae35e166dc07e3ac1cd54cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6b0e73ae35e166dc07e3ac1cd54cae">&#9670;&nbsp;</a></span>boundaryIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalSurface::boundaryIntersections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the information about the boundary slopes of this surface at each cusp of the triangulation. </p>
<p>This is for use with spun-normal surfaces (since for closed surfaces all boundary slopes are zero).</p>
<p>This routine is only available for use with SnapPea triangulations, since it needs to know the specific meridian and longitude on each cusp. This information is <em>only</em> available through the SnapPea kernel, since Regina does not use or store peripheral curves for its own <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html" title="Represents a 3-dimensional triangulation, typically of a 3-manifold.">Triangulation&lt;3&gt;</a> class. Therefore, if the underlying triangulation (as returned by <a class="el" href="group__surfaces.html#ga78737ee6d2d74ef5b7b5d9748a0daa10" title="Returns the triangulation in which this normal surface resides.">triangulation()</a>) is not of the subclass <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, this routine will simply return 0.</p>
<p>All cusps are treated as complete. That is, any Dehn fillings stored in the SnapPea triangulation will be ignored.</p>
<p>The results are returned in a matrix with <em>V</em> rows and two columns, where <em>V</em> is the number of vertices in the triangulation. If row <em>i</em> of the matrix contains the integers <em>M</em> and <em>L</em>, this indicates that at the <em>i</em>th cusp, the boundary curves have algebraic intersection number <em>M</em> with the meridian and <em>L</em> with the longitude. Equivalently, the boundary curves pass <em>L</em> times around the meridian and <em>-M</em> times around the longitude. The rational boundary slope is therefore <code>-L/M</code>, and there are <code>gcd(L,M)</code> boundary curves with this slope.</p>
<p>The orientations of the boundary curves of a spun-normal surface are chosen so that <em>if</em> meridian and longitude are a positive basis as vieved from the cusp, then as one travels along an oriented boundary curve, the spun-normal surface spirals into the cusp to one's right and down into the manifold to one's left.</p>
<p>If the triangulation contains more than one vertex, the rows in the resulting matrix are ordered by cusp index (as stored by SnapPea). You can call SnapPeaTriangulation::cuspVertex() to map these to Regina's vertex indices if needed.</p>
<p>At present, Regina can only compute boundary slopes if the triangulation is oriented, if every vertex link in the triangulation is a torus, and if the underlying coordinate system is for normal surfaces (not almost normal surfaces). If these conditions are not met, this routine will return 0.</p>
<dl class="section author"><dt>Author</dt><dd>William Pettersson and Stephan Tillmann</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated matrix with <em>number_of_vertices</em> rows and two columns as described above, or 0 if the boundary slopes cannot be computed (e.g., if the underlying triangulation is not of type <a class="el" href="classregina_1_1SnapPeaTriangulation.html" title="Offers direct access to the SnapPea kernel from within Regina.">SnapPeaTriangulation</a>, or if it fails to meet the preconditions outlined above). </dd></dl>

</div>
</div>
<a id="ga8b5766df28d3440415fb1e055fa47be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b5766df28d3440415fb1e055fa47be5">&#9670;&nbsp;</a></span>calculateBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateBoundaries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the number of disjoint boundary curves and stores the result as a property. </p>

</div>
</div>
<a id="ga2c9e3815b9c61458d68bb7bf195ca21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9e3815b9c61458d68bb7bf195ca21a">&#9670;&nbsp;</a></span>calculateEulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateEulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the Euler characteristic of this surface and stores it as a property. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact (has finitely many discs). </dd></dl>

</div>
</div>
<a id="ga6cfc95271eee926bea070c37f12d94bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cfc95271eee926bea070c37f12d94bc">&#9670;&nbsp;</a></span>calculateOctPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateOctPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the position of the first non-zero octagon coordinate and stores it as a property. </p>

</div>
</div>
<a id="ga5ca0dcbd2425783033c88d4082b8c247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ca0dcbd2425783033c88d4082b8c247">&#9670;&nbsp;</a></span>calculateOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates whether this surface is orientable and/or two-sided and stores the results as properties. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs). </dd></dl>

</div>
</div>
<a id="gae3ea8973551e9dc69d3e321f6d05ec4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ea8973551e9dc69d3e321f6d05ec4d">&#9670;&nbsp;</a></span>calculateRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::calculateRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates whether this surface has any real boundary and stores the result as a property. </p>

</div>
</div>
<a id="gaa8f5b4c6b7ac6ae63df0efece67fef06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f5b4c6b7ac6ae63df0efece67fef06">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>* regina::NormalSurface::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this normal surface. </p>
<p>The name of the normal surface will <em>not</em> be copied to the clone; instead the clone will have an empty name.</p>
<dl class="section return"><dt>Returns</dt><dd>a clone of this normal surface. </dd></dl>

</div>
</div>
<a id="ga919f098d3c43f1e68a5dc3ba9c9da227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga919f098d3c43f1e68a5dc3ba9c9da227">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> as this vector. </p>

</div>
</div>
<a id="ga6b6a0f2fcdf9294d92b2eaed6afcdd75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b6a0f2fcdf9294d92b2eaed6afcdd75">&#9670;&nbsp;</a></span>compactness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::SurfaceFilterProperties::compactness </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable compactness properties. </p>
<p>Note that this is a subset of <code>{ true, false }</code>. Any surface whose compactness property is not in this set will not be accepted by this filter.</p>
<dl class="section return"><dt>Returns</dt><dd>the set of allowable compactness properties. </dd></dl>

</div>
</div>
<a id="gaf64145ed248bd3b24af3d65a7500aadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf64145ed248bd3b24af3d65a7500aadb">&#9670;&nbsp;</a></span>coords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalSurfaceVector::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the underlying vector of coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector of coordinates. </dd></dl>

</div>
</div>
<a id="gada70246d67b766fd35a224bd561ee071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada70246d67b766fd35a224bd561ee071">&#9670;&nbsp;</a></span>coords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> regina::NormalSurfaces::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system being used by the surfaces stored in this set. </p>
<dl class="section return"><dt>Returns</dt><dd>the coordinate system used. </dd></dl>

</div>
</div>
<a id="ga8ccd5e4c57c74080dcc2b2e37a75eeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ccd5e4c57c74080dcc2b2e37a75eeb0">&#9670;&nbsp;</a></span>countBoundaries()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurface::countBoundaries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of disjoint boundary curves on this surface. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal arcs on the boundary. If the normal coordinates are extremely large, (in particular, of a similar order of magnitude as the largest possible long integer), then the behaviour of this routine is undefined.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Alex He</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of disjoint boundary curves. </dd></dl>

</div>
</div>
<a id="gac3c32deec0eb7a70975316c73614dcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3c32deec0eb7a70975316c73614dcca">&#9670;&nbsp;</a></span>countCoords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurface::countCoords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the specific underlying coordinate system being used. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="ga05bc0467c5b5dcc6e66f5e64c5732b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05bc0467c5b5dcc6e66f5e64c5732b82">&#9670;&nbsp;</a></span>countEulerChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::SurfaceFilterProperties::countEulerChars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of allowable Euler characteristics. </p>
<p>See <a class="el" href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353" title="Returns the set of allowable Euler characteristics.">eulerChars()</a> for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of allowable Euler characteristics. </dd></dl>

</div>
</div>
<a id="ga54bd5ac2fff434e5124b15ecc6c25b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54bd5ac2fff434e5124b15ecc6c25b79">&#9670;&nbsp;</a></span>crush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurface::crush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crushes this surface to a point in the associated triangulation and returns a newly created resulting triangulation. </p>
<p>The original triangulation is not changed.</p>
<p>Crushing the surface will produce a number of tetrahedra, triangular pillows and/or footballs. The pillows and footballs will then be flattened to triangles and edges respectively (resulting in the possible changes mentioned below) to produce a proper triangulation.</p>
<p>Note that the new triangulation will have at most the same number of tetrahedra as the old triangulation, and will have strictly fewer tetrahedra if this surface is not vertex linking.</p>
<p>The act of flattening pillows and footballs as described above can lead to unintended topological side-effects, beyond the effects of merely cutting along this surface and identifying the new boundary surface(s) to points. Examples of these unintended side-effects can include connected sum decompositions, removal of 3-spheres and small Lens spaces and so on; a full list of possible changes is beyond the scope of this API documentation.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine can have unintended topological side-effects, as described above. </dd>
<dd>
In exceptional cases with non-orientable 3-manifolds, these side-effects might lead to invalid edges (edges whose midpoints are projective plane cusps).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated resulting triangulation. </dd></dl>

</div>
</div>
<a id="ga32842aede0b65c4e3c80c73e3216cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32842aede0b65c4e3c80c73e3216cdb4">&#9670;&nbsp;</a></span>cutAlong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurface::cutAlong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cuts the associated triangulation along this surface and returns a newly created resulting triangulation. </p>
<p>The original triangulation is not changed.</p>
<p>Note that, unlike crushing a surface to a point, this operation will not change the topology of the underlying 3-manifold beyond simply slicing along this surface.</p>
<dl class="section warning"><dt>Warning</dt><dd>The number of tetrahedra in the new triangulation can be <em>very</em> large.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly allocated resulting triangulation. </dd></dl>

</div>
</div>
<a id="gaab688229f8a6ef82f631b8e77e82def0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab688229f8a6ef82f631b8e77e82def0">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>disc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the data corresponding to the given normal disc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disc</td><td>the disc whose data we require; this must refer to a disc within this disc set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the data corresponding to the given normal disc. </dd></dl>

</div>
</div>
<a id="ga3b40482617d929f84c1f8eeb7e00ff92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b40482617d929f84c1f8eeb7e00ff92">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>discNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the data corresponding to the given normal disc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the disc type of the given normal disc; this should be between 0 and 9 inclusive, as described in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">discNumber</td><td>indicates which normal disc of the given disc type is referred to; this should be between 0 and <code>nDiscs(discType)-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the data corresponding to the given normal disc. </dd></dl>

</div>
</div>
<a id="gad33634993b549ee12249b97a019fe002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad33634993b549ee12249b97a019fe002">&#9670;&nbsp;</a></span>dependsOnParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga2cbf1c1dc39ca6a9792124e129ab54b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cbf1c1dc39ca6a9792124e129ab54b4">&#9670;&nbsp;</a></span>dependsOnParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SurfaceFilter::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a3f5bdb957c5b10c0b5ec9ebfbe94a">&#9670;&nbsp;</a></span>discFromArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::DiscSetTet::discFromArc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arcNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>discNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which normal disc in this tetrahedron meets the given normal arc on the given face. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal arc actually exists in the normal surface with which this <em><a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a></em> object was created.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arcFace</td><td>the face of this tetrahedron containing the normal arc (between 0 and 3 inclusive). </td></tr>
    <tr><td class="paramname">arcVertex</td><td>the vertex of this tetrahedron about which the normal arc runs (between 0 and 3 inclusive); <em>arcFace</em> and <em>arcVertex</em> should not be the same. </td></tr>
    <tr><td class="paramname">arcNumber</td><td>indicates which normal arc of the given type is referred to. Arcs of a given type (where <em>arcFace</em> and <em>arcVertex</em> together define the arc type) are numbered starting at 0 from the tetrahedron vertex outwards. </td></tr>
    <tr><td class="paramname">discType</td><td>returns the disc type of the normal disc that meets the given normal arc; this will be between 0 and 9 inclusive, as described in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. Any value may be initially passed. </td></tr>
    <tr><td class="paramname">discNumber</td><td>returns a number that indicates which normal disc of the returned disc type (<code>discType</code>) meets the given normal arc; this will be between 0 and <code>nDiscs(discType)-1</code> inclusive. Any value may be initially passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacc8d5800d8613931ff0483a8388308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc8d5800d8613931ff0483a8388308c">&#9670;&nbsp;</a></span>discOrientationFollowsEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::discOrientationFollowsEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc. </p>
<p>Natural boundary orientation is defined by arrays <a class="el" href="group__surfaces.html#ga1ed7e2568c2e6085550dec8b1ff5eeb1" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular...">regina::triDiscArcs</a>, <a class="el" href="group__surfaces.html#ga315832a821efcad8d12ee4d0158a0bbd" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilate...">regina::quadDiscArcs</a> and <a class="el" href="group__surfaces.html#gae3d5fc76b76881cf4851d177f1adb912" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal ...">regina::octDiscArcs</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal arc lies on a normal disc of the given type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex about which the normal arc runs. </td></tr>
    <tr><td class="paramname">edgeStart</td><td>the start vertex of the edge to which the normal arc is parallel. </td></tr>
    <tr><td class="paramname">edgeEnd</td><td>the end vertex of the edge to which the normal arc is parallel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7d4e0bcd28a1aba2869b9db72e6c48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7d4e0bcd28a1aba2869b9db72e6c48f">&#9670;&nbsp;</a></span>DiscSetSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetSurface::DiscSetSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9bc5a059c5627c16967d7438dc742fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bc5a059c5627c16967d7438dc742fca">&#9670;&nbsp;</a></span>DiscSetSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetSurface::DiscSetSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<p>The array of tetrahedron disc set pointers will be created but the <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a> objects themselves will <b>not</b> be created.</p>
<p>This constructor should be called from constructors of subclasses who wish to use objects of a subclass of <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a>, which this constructor allows them to create for themselves.</p>
<dl class="section warning"><dt>Warning</dt><dd>After calling this constructor, each <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a> object in the <em>discSets</em> array <b>must</b> be created, since the <em><a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a></em> destructor will attempt to destroy them! The <em>discSets</em> array will have size <code>surface.triangulation()-&gt;size()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">b</td><td>this parameter is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga351ff55619cc35b42f37ddb369e0fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga351ff55619cc35b42f37ddb369e0fcc9">&#9670;&nbsp;</a></span>DiscSetSurfaceData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<p>The data for each disc will remain uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97c7e00d669bca83a672de12e45f627c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97c7e00d669bca83a672de12e45f627c">&#9670;&nbsp;</a></span>DiscSetSurfaceData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<p>The data for each disc will be initialised to the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">initValue</td><td>the value with which to initialise the data corresponding to each disc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe441060b0e0bf2334000a5a3deb33a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe441060b0e0bf2334000a5a3deb33a2">&#9670;&nbsp;</a></span>DiscSetTet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetTet::DiscSetTet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal discs corresponding to the discs of the given normal surface that lie within the given tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron that our discs must lie in; this must be between 0 and <code>tri.size()-1</code> inclusive, where <code>tri</code> is the triangulation containing the given normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f0f6d8f893f8f8e7f971c6eff4b7c1b">&#9670;&nbsp;</a></span>DiscSetTet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetTet::DiscSetTet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal discs where the number of discs of each type is explicitly given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri0</td><td>the number of triangular discs surrounding vertex 0. </td></tr>
    <tr><td class="paramname">tri1</td><td>the number of triangular discs surrounding vertex 1. </td></tr>
    <tr><td class="paramname">tri2</td><td>the number of triangular discs surrounding vertex 2. </td></tr>
    <tr><td class="paramname">tri3</td><td>the number of triangular discs surrounding vertex 3. </td></tr>
    <tr><td class="paramname">quad0</td><td>the number of quadrilateral discs of type 0. </td></tr>
    <tr><td class="paramname">quad1</td><td>the number of quadrilateral discs of type 1. </td></tr>
    <tr><td class="paramname">quad2</td><td>the number of quadrilateral discs of type 2. </td></tr>
    <tr><td class="paramname">oct0</td><td>the number of octahedral discs of type 0. </td></tr>
    <tr><td class="paramname">oct1</td><td>the number of octahedral discs of type 1. </td></tr>
    <tr><td class="paramname">oct2</td><td>the number of octahedral discs of type 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4526a51c67f6cc9b10a4dad45a1f1686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4526a51c67f6cc9b10a4dad45a1f1686">&#9670;&nbsp;</a></span>DiscSetTetData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron. </p>
<p>The data for each disc will remain uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron that our discs must lie in; this must be between 0 and <code>tri.size()-1</code> inclusive, where <code>tri</code> is the triangulation containing the given normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8fe87cf10ed4fd6e10266bd92cabda4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fe87cf10ed4fd6e10266bd92cabda4e">&#9670;&nbsp;</a></span>DiscSetTetData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron. </p>
<p>The data for each disc will be initialised to the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron that our discs must lie in; this must be between 0 and <code>tri.size()-1</code> inclusive, where <code>tri</code> is the triangulation containing the given normal surface. </td></tr>
    <tr><td class="paramname">initValue</td><td>the value with which to initialise the data corresponding to each disc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c5875e05c90ed38f5384735bcac92d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c5875e05c90ed38f5384735bcac92d8">&#9670;&nbsp;</a></span>DiscSetTetData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set where the number of discs of each type is explicitly given. </p>
<p>The data for each disc will remain uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri0</td><td>the number of triangular discs surrounding vertex 0. </td></tr>
    <tr><td class="paramname">tri1</td><td>the number of triangular discs surrounding vertex 1. </td></tr>
    <tr><td class="paramname">tri2</td><td>the number of triangular discs surrounding vertex 2. </td></tr>
    <tr><td class="paramname">tri3</td><td>the number of triangular discs surrounding vertex 3. </td></tr>
    <tr><td class="paramname">quad0</td><td>the number of quadrilateral discs of type 0. </td></tr>
    <tr><td class="paramname">quad1</td><td>the number of quadrilateral discs of type 1. </td></tr>
    <tr><td class="paramname">quad2</td><td>the number of quadrilateral discs of type 2. </td></tr>
    <tr><td class="paramname">oct0</td><td>the number of octahedral discs of type 0. </td></tr>
    <tr><td class="paramname">oct1</td><td>the number of octahedral discs of type 1. </td></tr>
    <tr><td class="paramname">oct2</td><td>the number of octahedral discs of type 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d41a228f90e254a5707f175f55dfb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d41a228f90e254a5707f175f55dfb39">&#9670;&nbsp;</a></span>DiscSpec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpec::DiscSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised disc specifier. </p>

</div>
</div>
<a id="ga660af5ac1a6ab75d34c6671f2cebfa3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga660af5ac1a6ab75d34c6671f2cebfa3b">&#9670;&nbsp;</a></span>DiscSpec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpec::DiscSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc specifier that is a clone of the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the disc specifier to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga185aaf4b2430cf3089dba1a4ddb83930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185aaf4b2430cf3089dba1a4ddb83930">&#9670;&nbsp;</a></span>DiscSpec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpec::DiscSpec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newTetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc specifier containing the given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTetIndex</td><td>the index in the triangulation of the tetrahedron containing the disc. </td></tr>
    <tr><td class="paramname">newType</td><td>the disc type; this is between 0 and 9 inclusive, as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </td></tr>
    <tr><td class="paramname">newNumber</td><td>specifies which disc of the particular type in the particular tetrahedron is being referred to; discs are numbered as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9e169fff6424f1acf397c42bca638b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e169fff6424f1acf397c42bca638b7">&#9670;&nbsp;</a></span>DiscSpecIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpecIterator::DiscSpecIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised iterator. </p>
<p>This iterator cannot be used or queried until either <a class="el" href="group__surfaces.html#gad2f9987a917198b7fbe777fdb37c3511" title="Points this iterator to the first disc in the given disc set.">init()</a> or the assignmemnt operator is called. </p>

</div>
</div>
<a id="gac2a16a72e475679372711d2a9c8ce32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a16a72e475679372711d2a9c8ce32c">&#9670;&nbsp;</a></span>DiscSpecIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpecIterator::DiscSpecIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>discSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the first disc in the given disc set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discSet</td><td>the disc set used to initialise this iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21a02ea41beef23675e3133af8eea0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a02ea41beef23675e3133af8eea0bc">&#9670;&nbsp;</a></span>DiscSpecIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpecIterator::DiscSpecIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="ga87e0a3373b5079e42b4742c589752f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e0a3373b5079e42b4742c589752f39">&#9670;&nbsp;</a></span>DiscType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscType::DiscType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc type initialised to NONE. </p>

</div>
</div>
<a id="ga73770e3cb29de3677ae7d35211097455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73770e3cb29de3677ae7d35211097455">&#9670;&nbsp;</a></span>DiscType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscType::DiscType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given disc type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the disc type to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab795c9663ce281fc8ce8a647e3405d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab795c9663ce281fc8ce8a647e3405d89">&#9670;&nbsp;</a></span>DiscType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscType::DiscType </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newTetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc type initialised with the given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTetIndex</td><td>the index within the triangulation of the tetrahedron containing this disc type. </td></tr>
    <tr><td class="paramname">newType</td><td>the specific disc type within the given tetrahedron; see the class notes for the meaning of this field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bda2f060aca3d7228ce8758f67eefeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bda2f060aca3d7228ce8758f67eefeb">&#9670;&nbsp;</a></span>disjoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::disjoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface can be placed within the surrounding triangulation so that they do not intersect anywhere at all, without changing either normal isotopy class. </p>
<p>This is a global constraint, and therefore gives a stronger test than <a class="el" href="group__surfaces.html#gaa1aa3f944bc8cd084d2a00aadc0f0eb2" title="Determines whether this and the given surface are locally compatible.">locallyCompatible()</a>. However, this global constraint is also much slower to test; the running time is proportional to the total number of normal discs in both surfaces.</p>
<p>Note that this routine has a number of preconditions. Most importantly, it will only work if both this and the given surface use the <em>same</em> coordinate system. Running this test over two surfaces with different coordinate systems could give unpredictable results, and might crash the program entirely.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation. </dd>
<dd>
Both this and the given normal surface are stored using the same coordinate system (i.e., the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>). </dd>
<dd>
Both this and the given surface are compact (have finitely many discs), embedded, non-empty and connected.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other surface to test alongside this surface for potential intersections. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both surfaces can be embedded without intersecting anywhere, or <code>false</code> if this and the given surface are forced to intersect at some point. </dd></dl>

</div>
</div>
<a id="ga1d2e60e17d1ef726a70b9393638f09fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d2e60e17d1ef726a70b9393638f09fa">&#9670;&nbsp;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpecIterator::done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this iterator is past-the-end. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this iterator is past-the-end. </dd></dl>

</div>
</div>
<a id="ga62b05e3ae22fb0c59bb08c28f88ccdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62b05e3ae22fb0c59bb08c28f88ccdbc">&#9670;&nbsp;</a></span>doubleSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>* regina::NormalSurface::doubleSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a newly allocated surface that is the double of this surface. </p>
<dl class="section return"><dt>Returns</dt><dd>the double of this normal surface. </dd></dl>

</div>
</div>
<a id="gab0471c5364a23009d61817fa084cdcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0471c5364a23009d61817fa084cdcc9">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

</div>
</div>
<a id="ga5bc14138b82130ad79e60d8585aea3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bc14138b82130ad79e60d8585aea3c5">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="group__surfaces.html#gab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implemented in <a class="el" href="group__surfaces.html#ga59cd5eadbba63de6b6d001886ab96cef">regina::NSVectorStandard</a>, <a class="el" href="group__surfaces.html#ga4108ca7175f0e6bd106c19373f3fcbf2">regina::NSVectorOriented</a>, <a class="el" href="group__surfaces.html#gaef1074733d1aaa6de9ff8cd8b39ffaba">regina::NSVectorMirrored</a>, and <a class="el" href="group__surfaces.html#gaca1df7bce5940c31ba4888ca6b05f946">regina::NSVectorANStandard</a>.</p>

</div>
</div>
<a id="gaca1df7bce5940c31ba4888ca6b05f946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1df7bce5940c31ba4888ca6b05f946">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorANStandard::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="group__surfaces.html#gab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga5bc14138b82130ad79e60d8585aea3c5">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gaef1074733d1aaa6de9ff8cd8b39ffaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef1074733d1aaa6de9ff8cd8b39ffaba">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="group__surfaces.html#gab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga5bc14138b82130ad79e60d8585aea3c5">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga4108ca7175f0e6bd106c19373f3fcbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4108ca7175f0e6bd106c19373f3fcbf2">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="group__surfaces.html#gab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga5bc14138b82130ad79e60d8585aea3c5">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga59cd5eadbba63de6b6d001886ab96cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59cd5eadbba63de6b6d001886ab96cef">&#9670;&nbsp;</a></span>edgeWeight() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorStandard::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="group__surfaces.html#gab0471c5364a23009d61817fa084cdcc9" title="Returns the number of times this normal surface crosses the given edge.">NormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and Triangulation&lt;3&gt;::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga5bc14138b82130ad79e60d8585aea3c5">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gacfcf349ea8b66bf635454d805af45bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfcf349ea8b66bf635454d805af45bc9">&#9670;&nbsp;</a></span>embedded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::embedded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this surface is embedded. </p>
<p>This is true if and only if the surface contains no conflicting quadrilateral and/or octagon types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface is embedded. </dd></dl>

</div>
</div>
<a id="gae26003982483e680a1c073ab250702d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26003982483e680a1c073ab250702d2">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> regina::DiscSetSurface::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of all normal discs in the underlying normal surface. </p>
<p>In C++, the <a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c" title="Returns an iterator at the beginning of the range of all normal discs in the underlying normal surfac...">begin()</a> and <a class="el" href="group__surfaces.html#gae26003982483e680a1c073ab250702d2" title="Returns an iterator at the end of the range of all normal discs in the underlying normal surface.">end()</a> routines allow you to iterate through all normal discs using C++11 range-based <code>for</code> loops. In Python, a <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> can be treated as an iterable object.</p>
<p>See the <a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c" title="Returns an iterator at the beginning of the range of all normal discs in the underlying normal surfac...">begin()</a> documentation for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the end of the range of all normal discs. </dd></dl>

</div>
</div>
<a id="ga2bc7352000f92ad00fa8debb700163ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc7352000f92ad00fa8debb700163ab">&#9670;&nbsp;</a></span>endContentSubElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLFilterPacketReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__surfaces.html#ga47377e99609a1ed88175aa5aee16f3ca" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gafa118509bfc5ec2f4192b94aa0c4dd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa118509bfc5ec2f4192b94aa0c4dd35">&#9670;&nbsp;</a></span>endContentSubElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLNormalSurfacesReader::endContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>subReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">endSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement closing tag. </td></tr>
    <tr><td class="paramname">subReader</td><td>the child reader that was used to parse the subelement (this is the reader that was returned by the corresponding <a class="el" href="group__surfaces.html#gaae3356c94debf7c1128136248f54a953" title="Used instead of startSubElement() for XML subelements that are not child packets or packet tags.">startContentSubElement()</a> call). It is guaranteed that <a class="el" href="group__file.html#ga55033a0561bb5b38ec08a1cdb9af8bd1" title="Signifies that parsing of this XML element is finished.">endElement()</a> has already been called upon this child reader and that the child reader has not yet been destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gac9df4d0a5ff0a96c001094ee6b67f5b0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga268c1848908924fc19644b83309beeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga268c1848908924fc19644b83309beeba">&#9670;&nbsp;</a></span>endVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::endVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator that gives access to the raw vectors for surfaces in this list, pointing past the end of this surface list. </p>
<p>This iterator is not dereferenceable.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator past the end of this surface list. </dd></dl>

</div>
</div>
<a id="ga64309eac6ce681355dfc352c53299535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64309eac6ce681355dfc352c53299535">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td>
          <td class="paramname"><em>which</em> = <code><a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">NS_LIST_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td>
          <td class="paramname"><em>algHints</em> = <code><a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">NS_ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unified routine for enumerating various classes of normal surfaces within a given triangulation. </p>
<p>The NormalCoords argument allows you to specify an underlying coordinate system (e.g., standard coordinates, quadrilateral coordinates or almost normal coordinates).</p>
<p>The NormalList argument is a combination of flags that allows you to specify exactly which normal surfaces you require. This includes (i) whether you want all vertex surfaces or all fundamental surfaces, which defaults to NS_VERTEX if you specify neither or both; and (ii) whether you want only properly embedded surfaces or you also wish to include immersed and/or singular surfaces, which defaults to NS_EMBEDDED_ONLY if you specify neither or both.</p>
<p>The NormalAlg argument is a combination of flags that allows you to control the underlying enumeration algorithm. These flags are treated as hints only: if your selection of algorithm is invalid, unavailable or unsupported then Regina will choose something more appropriate. Unless you have some specialised need, the default NS_ALG_DEFAULT (which makes no hints at all) will allow Regina to choose what it thinks will be the most efficient method.</p>
<p>The enumerated surfaces will be stored in a new normal surface list, and their representations will be scaled down to use the smallest possible integer coordinates. This normal surface list will be inserted into the packet tree as the last child of the given triangulation. This triangulation <b>must</b> remain the parent of this normal surface list, and must not change while this normal surface list remains in existence.</p>
<p>If a progress tracker is passed, the normal surface enumeration will take place in a new thread and this routine will return immediately. If the user cancels the operation from another thread, then the normal surface list will <em>not</em> be inserted into the packet tree (but the caller of this routine will still need to delete it). Regarding progress tracking, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p>If no progress tracker is passed, the enumeration will run in the current thread and this routine will return only when the enumeration is complete. Note that this enumeration can be extremely slow for larger triangulations.</p>
<p>If an error occurs, then this routine will return <code>null</code>, no normal surface list will be created, and the progress tracker (if passed) will be marked as finished. Errors can occur in the following scenarios:</p>
<ul>
<li>Regina could not create the matching equations for the given triangulation in the given coordinate system. This is only possible in certain coordinate systems, and all such coordinate systems are marked as such in the NormalCoords enum documentation.</li>
<li>A progress tracker is passed but a new thread could not be started.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the triangulation upon which this list of normal surfaces will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal surfaces should be enumerated. </td></tr>
    <tr><td class="paramname">algHints</td><td>passes requests to Regina for which specific enumeration algorithm should be used. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created normal surface list. Note that if a progress tracker is passed then this list may not be completely filled when this routine returns. If an error occurs (as described above) then this routine will return <code>null</code> instead. </dd></dl>

</div>
</div>
<a id="gaace0f87e66a8977a5ee6606aebe5e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaace0f87e66a8977a5ee6606aebe5e2ee">&#9670;&nbsp;</a></span>Enumerator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::Enumerator::Enumerator </td>
          <td>(</td>
          <td class="paramtype">Enumerator &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move constructor. </p>

</div>
</div>
<a id="ga584d2cbe4d00ee3151255fb7203dac1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga584d2cbe4d00ee3151255fb7203dac1b">&#9670;&nbsp;</a></span>Enumerator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::Enumerator::Enumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td>
          <td class="paramname"><em>eqns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new functor with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>the surface list to be filled. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which these surfaces lie. </td></tr>
    <tr><td class="paramname">eqns</td><td>the matching equations for the given triangulation in the coordinate system corresopnding to <em>list</em>. This object will take ownership of <em>eqns</em>, and the bracket operator will delete it once the enumeration has finished. This pointer <em>must</em> be non-null, i.e., Regina must have been able to construct the matching equations. </td></tr>
    <tr><td class="paramname">tracker</td><td>the progress tracker to use for progress reporting and cancellation polling, or <code>null</code> if these capabilities are not required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa553c0aff30c704a13d4833f84263c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa553c0aff30c704a13d4833f84263c7a">&#9670;&nbsp;</a></span>eulerChar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::eulerChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the Euler characteristic of this surface. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the Euler characteristic. </dd></dl>

</div>
</div>
<a id="ga3a022c7e93e384f63d5b702c9059fe19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a022c7e93e384f63d5b702c9059fe19">&#9670;&nbsp;</a></span>eulerChar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::SurfaceFilterProperties::eulerChar </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the allowable Euler characteristic at the given index in the set. </p>
<p>See <a class="el" href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353" title="Returns the set of allowable Euler characteristics.">eulerChars()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index in the set of allowable Euler characteristics; this must be between 0 and <a class="el" href="group__surfaces.html#ga05bc0467c5b5dcc6e66f5e64c5732b82" title="Returns the number of allowable Euler characteristics.">countEulerChars()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested allowable Euler characteristic. </dd></dl>

</div>
</div>
<a id="gae121058acca2e36eb07fe7973c0e2353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae121058acca2e36eb07fe7973c0e2353">&#9670;&nbsp;</a></span>eulerChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp; regina::SurfaceFilterProperties::eulerChars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable Euler characteristics. </p>
<p>Any surface whose Euler characteristic is not in this set will not be accepted by this filter. The set will be given in ascending order with no element repeated.</p>
<p>If this set is empty, all Euler characteristics will be accepted.</p>
<dl class="section return"><dt>Returns</dt><dd>the set of allowable Euler characteristics. </dd></dl>

</div>
</div>
<a id="ga870d8e89f2ed895e8176e263b9b7845b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga870d8e89f2ed895e8176e263b9b7845b">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> * regina::XMLFilterReader::filter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated filter that has been read by this element reader. </p>
<p>Deallocation of this new filter is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the filter that has been read, or 0 if filter reading is incomplete, the filter should be ignored or an error occurred. </dd></dl>

</div>
</div>
<a id="ga9324d55752c936e253e9c36cce704908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9324d55752c936e253e9c36cce704908">&#9670;&nbsp;</a></span>filterForDisjointPairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::filterForDisjointPairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new list filled with the surfaces from this list that have at least one disjoint partner. </p>
<p>In other words, a surface <em>S</em> from this list will be placed in the new list if and only if there is some other surface <em>T</em> in this list for which <em>S</em> and <em>T</em> can be made to intersect nowhere at all, without changing either normal isotopy class. See <a class="el" href="group__surfaces.html#ga7bda2f060aca3d7228ce8758f67eefeb" title="Determines whether this and the given surface can be placed within the surrounding triangulation so t...">NormalSurface::disjoint()</a> for further details on disjointness testing.</p>
<p>This routine cannot deal with empty, disconnected or non-compact surfaces. Such surfaces will be silently ignored, and will not be used in any disjointness tests (in particular, they will never be considered as a "disjoint partner" for any other surface).</p>
<p>The new list will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the new list will also be returned from this routine.</p>
<p>This original list is not altered in any way. Likewise, the surfaces in the new list are deep copies of the originals (so they can be altered without affecting the original surfaces).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This list contains only embedded normal surfaces. More precisely, <a class="el" href="group__surfaces.html#ga4235db32ccba3f9f49e8b668afb8ad85" title="Returns whether this list was constructed to contain only properly embedded surfaces.">isEmbeddedOnly()</a> must return <code>true</code>. </dd>
<dd>
All surfaces within this list are stored using the same coordinate system (i.e., the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this list contains a vertex link (plus at least one other surface), then the new list will be identical to the old (i.e., every surface will be copied across).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000042">Todo:</a></b></dt><dd>Deal properly with surfaces that are too large to handle.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new list, which will also have been inserted as a new child packet of the underlying triangulation. </dd></dl>

</div>
</div>
<a id="gae8c9723cc44bf8da34f136eb7c27a835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8c9723cc44bf8da34f136eb7c27a835">&#9670;&nbsp;</a></span>filterForLocallyCompatiblePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::filterForLocallyCompatiblePairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new list filled with the surfaces from this list that have at least one locally compatible partner. </p>
<p>In other words, a surface <em>S</em> from this list will be placed in the new list if and only if there is some other surface <em>T</em> in this list for which <em>S</em> and <em>T</em> are locally compatible. See <a class="el" href="group__surfaces.html#gaa1aa3f944bc8cd084d2a00aadc0f0eb2" title="Determines whether this and the given surface are locally compatible.">NormalSurface::locallyCompatible()</a> for further details on compatibility testing.</p>
<p>The new list will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the new list will also be returned from this routine.</p>
<p>This original list is not altered in any way. Likewise, the surfaces in the new list are deep copies of the originals (so they can be altered without affecting the original surfaces).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This list contains only embedded normal surfaces. More precisely, <a class="el" href="group__surfaces.html#ga4235db32ccba3f9f49e8b668afb8ad85" title="Returns whether this list was constructed to contain only properly embedded surfaces.">isEmbeddedOnly()</a> must return <code>true</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this list contains a vertex link (plus at least one other surface), then the new list will be identical to the old (i.e., every surface will be copied across).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new list, which will also have been inserted as a new child packet of the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ga7ed23bbdd0688519b1eb4a3077cec118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ed23bbdd0688519b1eb4a3077cec118">&#9670;&nbsp;</a></span>filterForPotentiallyIncompressible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::filterForPotentiallyIncompressible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new list filled with only the surfaces from this list that "might" represent two-sided incompressible surfaces. </p>
<p>More precisely, we consider all two-sided surfaces in this list, as well as the two-sided double covers of all one-sided surfaces in this list (see below for details on how one-sided surfaces are handled). Each of these surfaces is examined using relatively fast heuristic tests for incompressibility. Any surface that is definitely <em>not</em> incompressible is thrown away, and all other surfaces are placed in the new list.</p>
<p>Therefore, it is guaranteed that every incompressible surface from the old list will be placed in the new list. However, it is not known whether any given surface in the new list is indeed incompressible.</p>
<p>See <a class="el" href="group__surfaces.html#ga40448875fc5e68801492acfd10dc680b" title="Determines whether this is an incompressible surface within the surrounding 3-manifold.">NormalSurface::isIncompressible()</a> for the definition of incompressibility that is used here. Note in particular that spheres are <em>never</em> considered incompressible.</p>
<p>As indicated above, this filter works exclusively with two-sided surfaces. If a surface in this list is one-sided, the heuristic incompressibility tests will be run on its two-sided double cover. Nevertheless, if the tests pass, the original one-sided surface (not the double cover) will be added to the new list.</p>
<p>The new list will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the new list will also be returned from this routine.</p>
<p>This original list is not altered in any way. Likewise, the surfaces in the new list are deep copies of the originals (so they can be altered without affecting the original surfaces).</p>
<p>Currently the heuristic tests include (i) throwing away all vertex links and thin edge links, and then (ii) cutting along the remaining surfaces and running <a class="el" href="group__dim3.html#ga31d8cba1fae2b39de379ff6c8df4d61c" title="Searches for a &quot;simple&quot; compressing disc inside this triangulation.">Triangulation&lt;3&gt;::hasSimpleCompressingDisc()</a> on the resulting bounded triangulations. For more details on these tests see "The Weber-Seifert dodecahedral space is non-Haken", Benjamin A. Burton, J. Hyam Rubinstein and Stephan Tillmann, Trans. Amer. Math. Soc. 364:2 (2012), pp. 911-932.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold triangulation is valid and closed. In particular, it has no ideal vertices. </dd>
<dd>
This list contains only embedded normal surfaces. More precisely, <a class="el" href="group__surfaces.html#ga4235db32ccba3f9f49e8b668afb8ad85" title="Returns whether this list was constructed to contain only properly embedded surfaces.">isEmbeddedOnly()</a> must return <code>true</code>. </dd>
<dd>
This list contains only compact, connected normal surfaces. </dd>
<dd>
No surfaces in this list contain any octagonal discs.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine is subject to change in future versions of Regina, since additional tests may be added to improve the power of this filtering.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000043">Todo:</a></b></dt><dd>Add progress tracking.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new list, which will also have been inserted as a new child packet of the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ga7bd94e21f97cf9a037e774f1959d6aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bd94e21f97cf9a037e774f1959d6aeb">&#9670;&nbsp;</a></span>filterType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> regina::SurfaceFilter::filterType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID corresponding to the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the unique integer filtering method ID. </dd></dl>

</div>
</div>
<a id="ga8e2e2cd5aa13fab78d5346752051b92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e2e2cd5aa13fab78d5346752051b92e">&#9670;&nbsp;</a></span>filterTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::SurfaceFilter::filterTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a string description of the filtering method that is this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>a string description of this filtering method. </dd></dl>

</div>
</div>
<a id="ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bec1eb2ca5e5a7fd11bedfb1dee56f7">&#9670;&nbsp;</a></span>forCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::Void regina::forCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal surfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;NormalInfo&lt;c&gt;&gt;(...)</code> is defined for any valid NormalCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, ...)</code>, this routine will call <code>func.operator()&lt;NormalInfo&lt;coords&gt;&gt;(...)</code> in turn. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em>. (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a NormalInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a id="gadd13f0c33b3131122ddb15804973fd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd13f0c33b3131122ddb15804973fd56">&#9670;&nbsp;</a></span>forCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::ReturnType regina::forCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal surfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;NormalInfo&lt;c&gt;&gt;(...)</code> is defined for any valid NormalCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;NormalInfo&lt;coords&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from Returns&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a NormalInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given coordinate system is invalid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given coordinate system is invalid. </dd></dl>

</div>
</div>
<a id="ga5af9e496cbc7b631780b88a04e7e04b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5af9e496cbc7b631780b88a04e7e04b0">&#9670;&nbsp;</a></span>forFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::Void regina::forFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible normal surface filter types.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new filter type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;SurfaceFilterInfo&lt;t&gt;&gt;(...)</code> is defined for any valid SurfaceFilterType enum value <em>t</em>. Then, when the user calls <code>forFilter(filter, func, ...)</code>, this routine will call <code>func.operator()&lt;SurfaceFilterInfo&lt;filter&gt;&gt;(...)</code> in turn. If <em>filter</em> does not denote a valid filter type, then <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em> (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>the given type of normal surface filter. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a SurfaceFilterInfo&lt;filter&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap then in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a id="gadfcdfb4006b01269d80720b647e1dc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfcdfb4006b01269d80720b647e1dc37">&#9670;&nbsp;</a></span>forFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::ReturnType regina::forFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible normal surface filter types.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new filter type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;SurfaceFilterInfo&lt;t&gt;&gt;(...)</code> is defined for any valid SurfaceFilterType enum value <em>t</em>. Then, when the user calls <code>forFilter(filter, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;SurfaceFilterInfo&lt;filter&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>filter</em> does not denote a valid filter type, then <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from Returns&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>the given type of normal surface filter. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a SurfaceFilterInfo&lt;filter&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given filter type is not valid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap then in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given filter type is not valid. </dd></dl>

</div>
</div>
<a id="ga207ab6ce67f8c4f322f64fd0494e3a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga207ab6ce67f8c4f322f64fd0494e3a88">&#9670;&nbsp;</a></span>hasMultipleOctDiscs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::hasMultipleOctDiscs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface has more than one octagonal disc. </p>
<p>It may be assumed that at most one octagonal disc <em>type</em> exists in this surface. This routine will return <code>true</code> if an octagonal type does exist and its coordinate is greater than one.</p>
<p>The default implementation for this routine simply calculates all the octagonal coordinates and returns as soon as a positive or negative result can be established. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<p>If a subclass does not allow for almost normal surfaces, this routine will never be called and thus does not need to be overwritten.</p>
<dl class="section pre"><dt>Precondition</dt><dd>At most one octagonal disc <em>type</em> exists in this surface. </dd>
<dd>
This normal surface vector is using a coordinate system that allows for almost normal surfaces.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is an octagonal disc type present and its coordinate is greater than one. </dd></dl>

</div>
</div>
<a id="ga0015d445ca92c0e77a8f8638ac9e562a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0015d445ca92c0e77a8f8638ac9e562a">&#9670;&nbsp;</a></span>hasRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::hasRealBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this surface has any real boundary, that is, whether it meets any boundary triangles of the triangulation. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface has real boundary. </dd></dl>

</div>
</div>
<a id="gad2f9987a917198b7fbe777fdb37c3511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f9987a917198b7fbe777fdb37c3511">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::DiscSpecIterator::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>discSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Points this iterator to the first disc in the given disc set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discSet</td><td>the disc set used to reinitialise this iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6492f396c24203b815c113bcf7e5b69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6492f396c24203b815c113bcf7e5b69c">&#9670;&nbsp;</a></span>initialChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLNormalSurfaceReader::initialChars </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>chars</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that the initial text belonging to this XML element has been read. </p>
<p>The initial text is everything between the opening tag and the first subelement or closing tag.</p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chars</td><td>the initial text for this element. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga2a8cff0d68cb41e64fd931d0e3f6bf4c">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="gadc0ab53ae8085a452393a764bd8d5b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc0ab53ae8085a452393a764bd8d5b27">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::NormalSurfaces::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="gacb8bd5f5aaa07c895c1ff7b457056c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb8bd5f5aaa07c895c1ff7b457056c80">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::SurfaceFilter::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga7ec5eeb4810c80741c71380d47315334">regina::SurfaceFilterProperties</a>, and <a class="el" href="group__surfaces.html#ga233c06d9abc90d0d78e7505e330ace46">regina::SurfaceFilterCombination</a>.</p>

</div>
</div>
<a id="ga233c06d9abc90d0d78e7505e330ace46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga233c06d9abc90d0d78e7505e330ace46">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::SurfaceFilterCombination::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#gacb8bd5f5aaa07c895c1ff7b457056c80">regina::SurfaceFilter</a>.</p>

</div>
</div>
<a id="ga7ec5eeb4810c80741c71380d47315334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ec5eeb4810c80741c71380d47315334">&#9670;&nbsp;</a></span>internalClonePacket() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::SurfaceFilterProperties::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#gacb8bd5f5aaa07c895c1ff7b457056c80">regina::SurfaceFilter</a>.</p>

</div>
</div>
<a id="ga189f95fd5f3a632adb38a0fc6139cd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga189f95fd5f3a632adb38a0fc6139cd81">&#9670;&nbsp;</a></span>isCentral() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::isCentral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this surface is a central surface. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If this surface is central, the number of tetrahedra that it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000039">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that this surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a id="ga7f211dde81cc1505e475d48da6f1aafa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f211dde81cc1505e475d48da6f1aafa">&#9670;&nbsp;</a></span>isCentral() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::isCentral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a central surface in the given triangulation. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If the surface is central, the number of tetrahedra it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that the surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a id="ga40abc1a8ab16f13d8108df83290ec013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40abc1a8ab16f13d8108df83290ec013">&#9670;&nbsp;</a></span>isCompact() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isCompact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface is compact (has finitely many discs). </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this normal surface is compact. </dd></dl>

</div>
</div>
<a id="gace3f3ccef51ec75544ee6cc6875a6cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace3f3ccef51ec75544ee6cc6875a6cda">&#9670;&nbsp;</a></span>isCompact() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is compact (has finitely many discs). </p>
<p>The default implementation for this routine simply runs through every disc type until a disc type with infinite disc count is found or all disc types have been examined. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is compact. </dd></dl>

</div>
</div>
<a id="ga793261174b6628c83659b523b84ab943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga793261174b6628c83659b523b84ab943">&#9670;&nbsp;</a></span>isCompressingDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isCompressingDisc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>knownConnected</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this surface represents a compressing disc in the underlying 3-manifold. </p>
<p>Let this surface be <em>D</em> and let the underlying 3-manifold be <em>M</em> with boundary <em>B</em>. To be a compressing disc, <em>D</em> must be a properly embedded disc in <em>M</em>, and the boundary of <em>D</em> must not bound a disc in <em>B</em>.</p>
<p>The implementation of this routine is somewhat inefficient at present, since it cuts along the disc, retriangulates and then examines the resulting boundary components.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is compact and embedded. </dd>
<dd>
This normal surface contains no octagonal discs.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd><p class="startdd"><em>Optimise:</em> Reimplement this to avoid cutting along surfaces. </p>
<p class="enddd"><em>Bug:</em> Check for absurdly large numbers of discs and bail accordingly.</p>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine might cut along the surface and retriangulate, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">knownConnected</td><td><code>true</code> if this normal surface is already known to be connected (for instance, if it came from an enumeration of vertex normal surfaces), or <code>false</code> if we should not assume any such information about this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is a compressing disc, or <code>false</code> if this surface is not a compressing disc. </dd></dl>

</div>
</div>
<a id="ga8de9cd3d6628242dff5c7248c5bcb62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8de9cd3d6628242dff5c7248c5bcb62c">&#9670;&nbsp;</a></span>isConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is connected. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is connected, or <code>false</code> if this surface is disconnected. </dd></dl>

</div>
</div>
<a id="ga4235db32ccba3f9f49e8b668afb8ad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4235db32ccba3f9f49e8b668afb8ad85">&#9670;&nbsp;</a></span>isEmbeddedOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::isEmbeddedOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was constructed to contain only properly embedded surfaces. </p>
<p>If this returns <code>false</code>, it does not guarantee that immersed and/or singular surfaces are present; it merely indicates that they were not deliberately excluded (for instance, the quadrilateral constraints were not enforced).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was constructed to contain only properly embedded surfaces, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="gad24929a9b7ed24295c1010b205179b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad24929a9b7ed24295c1010b205179b2c">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this normal surface is empty (has no discs whatsoever). </p>

</div>
</div>
<a id="ga40448875fc5e68801492acfd10dc680b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40448875fc5e68801492acfd10dc680b">&#9670;&nbsp;</a></span>isIncompressible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isIncompressible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this is an incompressible surface within the surrounding 3-manifold. </p>
<p>At present, this routine is only implemented for surfaces embedded within <em>closed</em> and <em>irreducible</em> 3-manifold triangulations.</p>
<p>Let <em>D</em> be some disc embedded in the underlying 3-manifold, and let <em>B</em> be the boundary of <em>D</em>. We call <em>D</em> a <em>compressing disc</em> for this surface if (i) the intersection of <em>D</em> with this surface is the boundary <em>B</em>, and (ii) although <em>B</em> bounds a disc within the 3-manifold, it does not bound a disc within this surface.</p>
<p>We declare this surface to be <em>incompressible</em> if there are no such compressing discs. For our purposes, spheres are never considered incompressible (so if this surface is a sphere then this routine will always return <code>false</code>).</p>
<p>This test is designed exclusively for two-sided surfaces. If this surface is one-sided, the incompressibility test will be run on its two-sided double cover.</p>
<dl class="section warning"><dt>Warning</dt><dd>This routine may in some circumstances be extremely slow. This is because the underlying algorithm cuts along this surface, retriangulates (possibly using a very large number of tetrahedra), and then searches for a normal compressing disc in each component of the cut-open triangulation.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation is valid and closed, and represents an irreducible 3-manifold. </dd>
<dd>
This normal surface is compact, embedded and connected, and contains no octagonal discs.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is incompressible, or <code>false</code> if this surface is not incompressible (or if it is a sphere). </dd></dl>

</div>
</div>
<a id="ga58653ebccb7decb1d64d1ac20f87ea5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58653ebccb7decb1d64d1ac20f87ea5f">&#9670;&nbsp;</a></span>isOrientable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isOrientable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is orientable. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is orientable, or <code>false</code> if this surface is non-orientable. </dd></dl>

</div>
</div>
<a id="ga330f08b68053b89d2545c0027bbc3405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga330f08b68053b89d2545c0027bbc3405">&#9670;&nbsp;</a></span>isSplitting() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isSplitting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this surface is a splitting surface. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this is a splitting surface. </dd></dl>

</div>
</div>
<a id="gae4da454072e9b44e9ccbf23523006dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4da454072e9b44e9ccbf23523006dae">&#9670;&nbsp;</a></span>isSplitting() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isSplitting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a splitting surface in the given triangulation. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is a splitting surface. </dd></dl>

</div>
</div>
<a id="gab82721dfe41b187548593091b7274e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab82721dfe41b187548593091b7274e6e">&#9670;&nbsp;</a></span>isThinEdgeLink() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; * &gt; regina::NormalSurface::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this surface is the thin link of a single edge. </p>
<p>If there are two different edges <em>e1</em> and <em>e2</em> for which this surface could be expressed as the thin link of either <em>e1</em> or <em>e2</em>, the pair (<em>e1</em>,<em>e2</em>) will be returned. If this surface is the thin link of only one edge <em>e</em>, the pair (<em>e</em>,0) will be returned. If this surface is not the thin link of any edges, the pair (0,0) will be returned.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine returns a tuple of size 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by this surface, as described above. </dd></dl>

</div>
</div>
<a id="ga07535a32a2da710490b864bb23f93ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07535a32a2da710490b864bb23f93ea1">&#9670;&nbsp;</a></span>isThinEdgeLink() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*, const <a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt;3&gt;*&gt; regina::NormalSurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the thin link of a single edge. </p>
<p>If there are two different edges <em>e1</em> and <em>e2</em> for which the surface could be expressed as the thin link of either <em>e1</em> or <em>e2</em>, the pair (<em>e1</em>,<em>e2</em>) will be returned. If the surface is the thin link of only one edge <em>e</em>, the pair (<em>e</em>,0) will be returned. If the surface is not the thin link of any edges, the pair (0,0) will be returned.</p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by this surface, as described above. </dd></dl>

</div>
</div>
<a id="ga116c8925b42deeee786f3d4642b5bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga116c8925b42deeee786f3d4642b5bfd7">&#9670;&nbsp;</a></span>isTwoSided()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isTwoSided </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether or not this surface is two-sided. </p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This normal surface is embedded (not singular or immersed). </dd>
<dd>
This normal surface is compact (has finitely many discs).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This routine explicitly builds the normal discs, and so may run out of memory if the normal coordinates are extremely large.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this surface is two-sided, or <code>false</code> if this surface is one-sided. </dd></dl>

</div>
</div>
<a id="gaf98616d2b0b270a6a427133d3cd88cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf98616d2b0b270a6a427133d3cd88cae">&#9670;&nbsp;</a></span>isVertexLink() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; * regina::NormalSurface::isVertexLink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not a rational multiple of this surface is the link of a single vertex. </p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

</div>
</div>
<a id="ga48f860e909873a8ab2449f36c7d3cfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48f860e909873a8ab2449f36c7d3cfb3">&#9670;&nbsp;</a></span>isVertexLink() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt;3&gt;* regina::NormalSurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga34afa9a4f7444f2b985adb80aaf2054f">regina::NSVectorQuadOct</a>, <a class="el" href="group__surfaces.html#gaf5b5ea3db1bb195bb2ac85d61c478c6a">regina::NSVectorQuad</a>, and <a class="el" href="group__surfaces.html#ga98d612c1b934bd3d64908cbc42e4e81e">regina::NSVectorOrientedQuad</a>.</p>

</div>
</div>
<a id="ga98d612c1b934bd3d64908cbc42e4e81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d612c1b934bd3d64908cbc42e4e81e">&#9670;&nbsp;</a></span>isVertexLink() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; * regina::NSVectorOrientedQuad::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga48f860e909873a8ab2449f36c7d3cfb3">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gaf5b5ea3db1bb195bb2ac85d61c478c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5b5ea3db1bb195bb2ac85d61c478c6a">&#9670;&nbsp;</a></span>isVertexLink() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; * regina::NSVectorQuad::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga48f860e909873a8ab2449f36c7d3cfb3">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga34afa9a4f7444f2b985adb80aaf2054f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34afa9a4f7444f2b985adb80aaf2054f">&#9670;&nbsp;</a></span>isVertexLink() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__generic.html#ga275f76603ae79c86d0d45cc954449ba7">Vertex</a>&lt; 3 &gt; * regina::NSVectorQuadOct::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga48f860e909873a8ab2449f36c7d3cfb3">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga8ab8b0a34b4c8a0847aba54974f1c009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ab8b0a34b4c8a0847aba54974f1c009">&#9670;&nbsp;</a></span>isVertexLinking() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::isVertexLinking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not this surface is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>Note that the results of this routine are not cached. Thus the results will be reevaluated every time this routine is called.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd><em>Optimise:</em> Cache results.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface is vertex linking. </dd></dl>

</div>
</div>
<a id="gaecf49b14b890535f0deee9d8db62dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecf49b14b890535f0deee9d8db62dc4c">&#9670;&nbsp;</a></span>isVertexLinking() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NormalSurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>The default implementation for this routine simply runs through every non-triangular disc type ensuring that each has no corresponding discs. Subclasses of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is vertex linking. </dd></dl>

</div>
</div>
<a id="gaa1aa3f944bc8cd084d2a00aadc0f0eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1aa3f944bc8cd084d2a00aadc0f0eb2">&#9670;&nbsp;</a></span>locallyCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::locallyCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface are locally compatible. </p>
<p>Local compatibility means that, within each individual tetrahedron of the triangulation, it is possible to arrange the normal discs of both surfaces so that none intersect.</p>
<p>This is a local constraint, not a global constraint. That is, we do not insist that we can avoid intersections within all tetrahedra <em>simultaneously</em>. To test the global constraint, see the (much slower) routine <a class="el" href="group__surfaces.html#ga7bda2f060aca3d7228ce8758f67eefeb" title="Determines whether this and the given surface can be placed within the surrounding triangulation so t...">disjoint()</a> instead.</p>
<p>Local compatibility can be formulated in terms of normal disc types. Two normal (or almost normal) surfaces are locally compatible if and only if they together have at most one quadrilateral or octagonal disc type per tetrahedron.</p>
<p>Note again that this is a local constraint only. In particular, for almost normal surfaces, it does <em>not</em> insist that there is at most one octagonal disc type anywhere within the triangulation.</p>
<p>If one of the two surfaces breaks the local compatibility constraints on its own (for instance, it contains two different quadrilateral disc types within the same tetrahedron), then this routine will return <code>false</code> regardless of what the other surface contains.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other surface to test for local compatibility with this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the two surfaces are locally compatible, or <code>false</code> if they are not. </dd></dl>

</div>
</div>
<a id="gaa0abea602d297abf6cc61d1281169a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0abea602d297abf6cc61d1281169a4e">&#9670;&nbsp;</a></span>makeEmbeddedConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>* regina::NormalSurfaceVector::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal surfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a id="gaeeffc85eaf2fc2c37cf1e6fb87f951b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeffc85eaf2fc2c37cf1e6fb87f951b9">&#9670;&nbsp;</a></span>makeEmbeddedConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>* regina::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal surfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the given coordinate system.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a id="gafda04c126a8ff0c247429cf4acabdc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda04c126a8ff0c247429cf4acabdc60">&#9670;&nbsp;</a></span>makeMatchingEquations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalSurfaceVector::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new set of normal surface matching equations for the given triangulation using the coordinate system corresponding to this particular subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </p>
<p>See <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">regina::makeMatchingEquations()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations. </dd></dl>

</div>
</div>
<a id="ga15a886092529bcf35c5e6def77e18c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a886092529bcf35c5e6def77e18c64">&#9670;&nbsp;</a></span>makeMatchingEquations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal surface matching equations for the given triangulation using the given coordinate system. </p>
<p>The returned matrix will be newly allocated and its destruction will be the responsibility of the caller of this routine.</p>
<p>Each equation will be represented as a row of the matrix. Each column of the matrix represents a coordinate in the given coordinate system.</p>
<p>For some coordinate systems, Regina may not be able to create matching equations for all triangulations (these coordinate systems are explicitly mentioned as such in the NormalCoords enum documentation). If Regina cannot create the matching equations as requested, this routine will return <code>null</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations, or <code>null</code> if Regina is not able to construct them for the given combination of triangulation and coordinate system. </dd></dl>

</div>
</div>
<a id="ga7c70b9f732f6867adf218250d66271df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c70b9f732f6867adf218250d66271df">&#9670;&nbsp;</a></span>makeMirror() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NSVectorMirrored::makeMirror </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mirror vector corresponding to the given vector. </p>
<p>This function should be implemented by each subclass of <a class="el" href="classregina_1_1NSVectorMirrored.html" title="A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calcu...">NSVectorMirrored</a>.</p>
<p>This function must return a newly created vector that describes the given normal surface in a different coordinate system:</p>
<ul>
<li>The given vector must be in the coordinate system described by the subclass in which this function is implemented.</li>
<li>The return vector must be in the corresponding "standard" coordinate system (i.e., <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>, or <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>, and so on.)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original</td><td>a vector in the coordinate system corresponding to the subclass in which this function is implemented. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which the corresponding normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created vector that describes the same normal surface in a "standard" coordinate system, as described above. </dd></dl>

</div>
</div>
<a id="ga8dea78dbce6ae26d8f33fe26b568aba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8dea78dbce6ae26d8f33fe26b568aba3">&#9670;&nbsp;</a></span>makeMirror() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NSVectorMirrored::makeMirror </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mirror vector corresponding to this vector. </p>
<p>This function must return a newly created vector that describes this normal surface in the corresponding "standard" coordinate system (i.e., <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>, or <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>, and so on.)</p>
<p>Typically subclasses should implement this function by calling the corresponding static <a class="el" href="group__surfaces.html#ga8dea78dbce6ae26d8f33fe26b568aba3" title="Creates a new mirror vector corresponding to this vector.">makeMirror()</a> function, which does the real work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created vector that describes the same normal surface in a "standard" coordinate system, as described above. </dd></dl>

<p>Implemented in <a class="el" href="group__surfaces.html#ga48fe8698ec9e687c84764347bbff2774">regina::NSVectorQuadOct</a>, <a class="el" href="group__surfaces.html#gaeb7de0ac36839c7c0d76c273e01e89a2">regina::NSVectorQuad</a>, and <a class="el" href="group__surfaces.html#ga5002d5519d11bae7249c551df2500f29">regina::NSVectorOrientedQuad</a>.</p>

</div>
</div>
<a id="ga5002d5519d11bae7249c551df2500f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5002d5519d11bae7249c551df2500f29">&#9670;&nbsp;</a></span>makeMirror() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> * regina::NSVectorOrientedQuad::makeMirror </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mirror vector corresponding to this vector. </p>
<p>This function must return a newly created vector that describes this normal surface in the corresponding "standard" coordinate system (i.e., <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>, or <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>, and so on.)</p>
<p>Typically subclasses should implement this function by calling the corresponding static makeMirror() function, which does the real work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created vector that describes the same normal surface in a "standard" coordinate system, as described above. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga8dea78dbce6ae26d8f33fe26b568aba3">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="gaeb7de0ac36839c7c0d76c273e01e89a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb7de0ac36839c7c0d76c273e01e89a2">&#9670;&nbsp;</a></span>makeMirror() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> * regina::NSVectorQuad::makeMirror </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mirror vector corresponding to this vector. </p>
<p>This function must return a newly created vector that describes this normal surface in the corresponding "standard" coordinate system (i.e., <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>, or <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>, and so on.)</p>
<p>Typically subclasses should implement this function by calling the corresponding static makeMirror() function, which does the real work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created vector that describes the same normal surface in a "standard" coordinate system, as described above. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga8dea78dbce6ae26d8f33fe26b568aba3">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga48fe8698ec9e687c84764347bbff2774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48fe8698ec9e687c84764347bbff2774">&#9670;&nbsp;</a></span>makeMirror() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> * regina::NSVectorQuadOct::makeMirror </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new mirror vector corresponding to this vector. </p>
<p>This function must return a newly created vector that describes this normal surface in the corresponding "standard" coordinate system (i.e., <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>, or <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a> if this subclass is <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>, and so on.)</p>
<p>Typically subclasses should implement this function by calling the corresponding static makeMirror() function, which does the real work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created vector that describes the same normal surface in a "standard" coordinate system, as described above. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga8dea78dbce6ae26d8f33fe26b568aba3">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga2208bc38293ec2a64359c2f582868a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2208bc38293ec2a64359c2f582868a2f">&#9670;&nbsp;</a></span>makeZeroVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurfaceVector::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and for the coordinate system corresponding to this subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </p>
<p>All elements of the new vector will be initialised to zero.</p>
<p>See <a class="el" href="group__hypersurface.html#ga062b6a0fcecd8d05a2193bb98feb8b29" title="Returns a new normal hypersurface vector of the appropriate length for the given triangulation and th...">regina::makeZeroVector()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a id="ga2eda282781417dd21160e899db7d8bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eda282781417dd21160e899db7d8bfb">&#9670;&nbsp;</a></span>makeZeroVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and the given coordinate system. </p>
<p>All elements of this vector will be initialised to zero.</p>
<p>The new vector will be of the subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> corresponding to the given coordinate system. The caller of this routine is responsible for destroying the new vector.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a id="ga1b66f7c42869115a48a9260432252e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b66f7c42869115a48a9260432252e4b">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NormalSurface::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name associated with this normal surface. </p>
<p>Names are optional and need not be unique. The default name for a surface is the empty string.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of associated with this surface. </dd></dl>

</div>
</div>
<a id="ga10cc0ec5a7a3f45404ca2933f153a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10cc0ec5a7a3f45404ca2933f153a108">&#9670;&nbsp;</a></span>nDiscs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetTet::nDiscs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of discs of the given type inside this tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the disc type to examine; this should be between 0 and 9 inclusive. Disc types are outlined in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of discs of the given type inside this tetrahedron. </dd></dl>

</div>
</div>
<a id="gacf48dd20fe6cfdd7e9f41e919b577b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf48dd20fe6cfdd7e9f41e919b577b8b">&#9670;&nbsp;</a></span>nDiscs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetSurface::nDiscs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of discs of the given type inside the given tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron to examine. </td></tr>
    <tr><td class="paramname">type</td><td>the disc type to examine; this should be between 0 and 9 inclusive. Disc types are outlined in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of discs of the given type inside the given tetrahedron. </dd></dl>

</div>
</div>
<a id="ga8803a3a19f5a6f7db0c2ae0e18499bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8803a3a19f5a6f7db0c2ae0e18499bfa">&#9670;&nbsp;</a></span>normal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::normal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this surface contains only triangle and/or quadrilateral discs. </p>
<p>This is to distinguish normal surfaces from more general surfaces such as almost normal surfaces (which also contain octagonal pieces).</p>
<p>Even if the underlying coordinate system supports other disc types (such as octagons), this routine will still return <code>true</code> if this particular surface does not use them. This is in contrast to the routine <a class="el" href="group__surfaces.html#ga286441732edb4692736f33e769489dde" title="Determines if the coordinate system being used allows for almost normal surfaces, that is,...">NormalSurfaces::allowsAlmostNormal()</a>, which only examines the underlying coordinate system.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this surface contains only triangles and/or quadrilaterals. </dd></dl>

</div>
</div>
<a id="ga6d249fdec933b17b2dd7a7157061100f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d249fdec933b17b2dd7a7157061100f">&#9670;&nbsp;</a></span>NormalSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coordSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List&#160;</td>
          <td class="paramname"><em>allCoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A Python-only routine that creates a new normal surface inside the given triangulation with the given coordinate vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate system is one in which Regina is able to enumerate and store normal surfaces (not a system like <a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae" title="Represents edge weight coordinates for normal surfaces.">regina::NS_EDGE_WEIGHT</a>, which is for viewing purposes only). </dd>
<dd>
The given coordinate vector represents a normal surface inside the given triangulation (in particular, it satisfies the relevant system of matching equations). This will not be checked, and things <em>will</em> go wrong if you break it.</dd></dl>
<dl class="section user"><dt>C++</dt><dd>Not available; this routine is for Python only.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">coordSystem</td><td>the coordinate system used by this normal surface. </td></tr>
    <tr><td class="paramname">allCoords</td><td>the corresponding vector of normal coordinates, expressed as a Python list. The list elements will be converted internally to LargeInteger objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga311cdd4d11c01e88da4f5c12031e89e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga311cdd4d11c01e88da4f5c12031e89e3">&#9670;&nbsp;</a></span>NormalSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::NormalSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td>
          <td class="paramname"><em>newVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new normal surface inside the given triangulation with the given coordinate vector. </p>
<p>This normal surface will claim ownership of the given vector (i.e., you should not change or delete the vector yourself afterwards).</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given coordinate vector represents a normal surface inside the given triangulation. </dd>
<dd>
The given coordinate vector cannot be the null pointer.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface resides. </td></tr>
    <tr><td class="paramname">newVector</td><td>a vector containing the coordinates of the normal surface in whichever space is appropriate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58f3147bd0d010d26972dc3230334ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f3147bd0d010d26972dc3230334ca7">&#9670;&nbsp;</a></span>NormalSurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty list of normal surfaces with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the coordinate system to be used for filling this list. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal surfaces these will represent within the underlying triangulation. </td></tr>
    <tr><td class="paramname">algorithm</td><td>details of the enumeration algorithm that will be used to fill this list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1dffade0cc17f3caeebdc004ad7295b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1dffade0cc17f3caeebdc004ad7295b">&#9670;&nbsp;</a></span>NormalSurfaceVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaceVector::NormalSurfaceVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6da8adb1ae136adf220689fcf75886d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6da8adb1ae136adf220689fcf75886d8">&#9670;&nbsp;</a></span>NormalSurfaceVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaceVector::NormalSurfaceVector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa64cc2810501559c94a5d67ecd00e01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa64cc2810501559c94a5d67ecd00e01a">&#9670;&nbsp;</a></span>NSVectorANStandard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorANStandard::NSVectorANStandard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad31480b0b03f05adb5a6993ef6d0f236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad31480b0b03f05adb5a6993ef6d0f236">&#9670;&nbsp;</a></span>NSVectorANStandard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorANStandard::NSVectorANStandard </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaced4af37a677777be8d7c2712100161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced4af37a677777be8d7c2712100161d">&#9670;&nbsp;</a></span>NSVectorMirrored() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorMirrored::NSVectorMirrored </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7fb0d76340736f73191d953e5f1f7147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb0d76340736f73191d953e5f1f7147">&#9670;&nbsp;</a></span>NSVectorMirrored() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorMirrored::NSVectorMirrored </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga909b9351b2c46ce4cdbf3f5c2923b44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga909b9351b2c46ce4cdbf3f5c2923b44b">&#9670;&nbsp;</a></span>NSVectorOriented() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorOriented::NSVectorOriented </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36acf25acf48e1228d0beba925325559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36acf25acf48e1228d0beba925325559">&#9670;&nbsp;</a></span>NSVectorOriented() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorOriented::NSVectorOriented </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b8d1e34e5e76de5db3663d784f6582b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b8d1e34e5e76de5db3663d784f6582b">&#9670;&nbsp;</a></span>NSVectorOrientedQuad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorOrientedQuad::NSVectorOrientedQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa659be9751519733724a1cb5a9194868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa659be9751519733724a1cb5a9194868">&#9670;&nbsp;</a></span>NSVectorOrientedQuad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorOrientedQuad::NSVectorOrientedQuad </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57dc3344f37493c85756bd4e0e5345fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57dc3344f37493c85756bd4e0e5345fb">&#9670;&nbsp;</a></span>NSVectorQuad() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuad::NSVectorQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52efede83a8235a1f0b5a27093066eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52efede83a8235a1f0b5a27093066eea">&#9670;&nbsp;</a></span>NSVectorQuad() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuad::NSVectorQuad </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f8bc2bfbdfb1f606ebb21520eaf9d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f8bc2bfbdfb1f606ebb21520eaf9d28">&#9670;&nbsp;</a></span>NSVectorQuadClosed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuadClosed::NSVectorQuadClosed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab357c3bbb71a6ed38c17de96588dc999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab357c3bbb71a6ed38c17de96588dc999">&#9670;&nbsp;</a></span>NSVectorQuadClosed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuadClosed::NSVectorQuadClosed </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74408871c05b366e0b4b69bab33e9cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74408871c05b366e0b4b69bab33e9cf7">&#9670;&nbsp;</a></span>NSVectorQuadOct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuadOct::NSVectorQuadOct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7b93c5d5a7e1bfc5b4de87cff660625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7b93c5d5a7e1bfc5b4de87cff660625">&#9670;&nbsp;</a></span>NSVectorQuadOct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuadOct::NSVectorQuadOct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6117da07794ffeb3e4ce9543e94550a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6117da07794ffeb3e4ce9543e94550a">&#9670;&nbsp;</a></span>NSVectorQuadOctClosed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuadOctClosed::NSVectorQuadOctClosed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8862ecd7107dc2fcc616244c4b2df281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8862ecd7107dc2fcc616244c4b2df281">&#9670;&nbsp;</a></span>NSVectorQuadOctClosed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorQuadOctClosed::NSVectorQuadOctClosed </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c8ba19de0a2d586f9359548299abc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c8ba19de0a2d586f9359548299abc7b">&#9670;&nbsp;</a></span>NSVectorStandard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorStandard::NSVectorStandard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Vector.html">Vector</a>&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d79a5f0aa7aa29fb7d26c670b81d087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d79a5f0aa7aa29fb7d26c670b81d087">&#9670;&nbsp;</a></span>NSVectorStandard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorStandard::NSVectorStandard </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4244895ae54265d8c0544ee65370483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4244895ae54265d8c0544ee65370483">&#9670;&nbsp;</a></span>nTets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::DiscSetSurface::nTets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in the underlying triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra. </dd></dl>

</div>
</div>
<a id="ga17dfc1f57595cbc9ec5662a76d25c161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17dfc1f57595cbc9ec5662a76d25c161">&#9670;&nbsp;</a></span>numberDiscsAwayFromVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::numberDiscsAwayFromVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not normal discs of the given type are numbered away from the given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex under consideration; this should be between 0 and 3 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if normal discs of the given type are numbered away from the given vertex, or <code>false</code> if they are numbered towards the given vertex. </dd></dl>

</div>
</div>
<a id="ga1a06c1a51568cc60c9699b083876a16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a06c1a51568cc60c9699b083876a16c">&#9670;&nbsp;</a></span>octPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscType.html">DiscType</a> regina::NormalSurface::octPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first coordinate position at which this surface has a non-zero octagonal coordinate. </p>
<p>In other words, if this routine returns the disc type <em>t</em>, then the octagonal coordinate returned by octs(t.tetIndex, t.type) is non-zero. Here <a class="el" href="group__surfaces.html#ga71893afaab0f7e789f19c4b566e95fd2" title="Identifies the disc type within the specified tetrahedron.">DiscType::type</a> represents an octagon type within a tetrahedron, and takes values between 0 and 2 inclusive.</p>
<p>If this surface does not contain any octagons, this routine returns <a class="el" href="group__surfaces.html#ga4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> instead.</p>
<p>This routine caches its results, which means that once it has been called for a particular surface, subsequent calls return the answer immediately. Moreover, if the underlying coordinate system does not support almost normal surfaces, then even the first call is fast (it returns <a class="el" href="group__surfaces.html#ga4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> immediately).</p>
<dl class="section return"><dt>Returns</dt><dd>the position of the first non-zero octagonal coordinate, or <a class="el" href="group__surfaces.html#ga4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> if there is no such coordinate. </dd></dl>

</div>
</div>
<a id="gabae51e35ce30784d586dfca6576243ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabae51e35ce30784d586dfca6576243ee">&#9670;&nbsp;</a></span>octs() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>In each tetrahedron, there are three types of octagons, defined by how they separate the four tetrahedron vertices into two pairs. Octagon type <em>i</em> (for <em>i</em> = 0, 1 or 2) is defined to intersect edges <em>i</em> and (5-<em>i</em>) of the tetrahedron twice each, and to intersect the remaining edges once each. This means:</p>
<ul>
<li>type 0 separates vertices 0,1 of the tetrahedron from vertices 2,3;</li>
<li>type 1 separates vertices 0,2 of the tetrahedron from vertices 1,3;</li>
<li>type 2 separates vertices 0,3 of the tetrahedron from vertices 1,2.</li>
</ul>
<p>If you are using a coordinate system that adorns discs with additional information (such as orientation), this routine returns the <em>total</em> number of octagons in the given tetrahedron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

</div>
</div>
<a id="gab042b630da0605dfc10845cb4eab2955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab042b630da0605dfc10845cb4eab2955">&#9670;&nbsp;</a></span>octs() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implemented in <a class="el" href="group__surfaces.html#gaafa8de789bc534a5806e9b46f708c347">regina::NSVectorStandard</a>, <a class="el" href="group__surfaces.html#gaa12eb25640ae314520cdb1499d23b9e2">regina::NSVectorQuad</a>, <a class="el" href="group__surfaces.html#ga3bd54cb95a976b0a3139f54b0296fa40">regina::NSVectorOrientedQuad</a>, <a class="el" href="group__surfaces.html#gacf522a2ab69035a41dfde5bcc70ab7ea">regina::NSVectorOriented</a>, <a class="el" href="group__surfaces.html#ga79f510cc1f1fd40f2152803491a3cbf7">regina::NSVectorMirrored</a>, and <a class="el" href="group__surfaces.html#gaced4bb03e87c9d58dd826c2ac32728e6">regina::NSVectorANStandard</a>.</p>

</div>
</div>
<a id="gaced4bb03e87c9d58dd826c2ac32728e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced4bb03e87c9d58dd826c2ac32728e6">&#9670;&nbsp;</a></span>octs() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorANStandard::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gab042b630da0605dfc10845cb4eab2955">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga79f510cc1f1fd40f2152803491a3cbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79f510cc1f1fd40f2152803491a3cbf7">&#9670;&nbsp;</a></span>octs() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gab042b630da0605dfc10845cb4eab2955">regina::NormalSurfaceVector</a>.</p>

<p>Reimplemented in <a class="el" href="group__surfaces.html#gaa12eb25640ae314520cdb1499d23b9e2">regina::NSVectorQuad</a>, and <a class="el" href="group__surfaces.html#ga3bd54cb95a976b0a3139f54b0296fa40">regina::NSVectorOrientedQuad</a>.</p>

</div>
</div>
<a id="gacf522a2ab69035a41dfde5bcc70ab7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf522a2ab69035a41dfde5bcc70ab7ea">&#9670;&nbsp;</a></span>octs() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gab042b630da0605dfc10845cb4eab2955">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga3bd54cb95a976b0a3139f54b0296fa40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bd54cb95a976b0a3139f54b0296fa40">&#9670;&nbsp;</a></span>octs() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOrientedQuad::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga79f510cc1f1fd40f2152803491a3cbf7">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="gaa12eb25640ae314520cdb1499d23b9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa12eb25640ae314520cdb1499d23b9e2">&#9670;&nbsp;</a></span>octs() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorQuad::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga79f510cc1f1fd40f2152803491a3cbf7">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="gaafa8de789bc534a5806e9b46f708c347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa8de789bc534a5806e9b46f708c347">&#9670;&nbsp;</a></span>octs() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorStandard::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#gab042b630da0605dfc10845cb4eab2955">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga54ea5c54db51d400ded6ad224bbe5e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54ea5c54db51d400ded6ad224bbe5e2a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpec::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given disc specifier contain different information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the disc specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given disc specifier contain different information. </dd></dl>

</div>
</div>
<a id="ga11e800bb0b3fcdd93f4eca3404de1635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e800bb0b3fcdd93f4eca3404de1635">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpecIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given iterator are different. </p>
<p>Two iterators are considered equal if (i) they were constructed from the same <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> object (not two different <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> objects with identical contents), and (ii) they point to the same disc of the same tetrahedron.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given iterator are equal. </dd></dl>

</div>
</div>
<a id="ga4c765ad77977e5cd119e6bcab9de6b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c765ad77977e5cd119e6bcab9de6b7f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscType::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given disc type are different. </p>
<p>This is the negation of the equality test; see operator == for further details.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given disc type are different, or <code>false</code> if they are identical. </dd></dl>

</div>
</div>
<a id="ga7969159033595b4e24ec9823301c3bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7969159033595b4e24ec9823301c3bcc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PrismSpec::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given prism specifier contain different information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the prism specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given prism specifier contain different information. </dd></dl>

</div>
</div>
<a id="gab3b222d9111814ce53422650e674f2fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3b222d9111814ce53422650e674f2fc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::VectorIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this with the given operator for inequality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>false</code> if the iterators point to the same element of the same normal surface list, or <code>true</code> if they do not. </dd></dl>

</div>
</div>
<a id="ga5c4da67377d53ce270dd18259140cca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c4da67377d53ce270dd18259140cca0">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coords &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::Enumerator::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the real enumeration work, in a setting where the underlying coordinate system is a compile-time constant. </p>
<p>We assume here that neither list_-&gt;which_ nor list_-&gt;algorithm_ have been sanity-checked.</p>
<p>This routine fills <em>list_</em> with surfaces, and then once this is finished it inserts <em>list_</em> into the packet tree as a child of <em>triang_</em>.</p>
<p>The matching equation matrix <em>eqns_</em> will be deleted during this routine.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coords</td><td>an instance of the NormalInfo&lt;&gt; template class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga12c73fd3750e32ce0500baad9fe086bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12c73fd3750e32ce0500baad9fe086bd">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">NormalSurfaces::SurfaceInserter</a> &amp; regina::NormalSurfaces::SurfaceInserter::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="gae7ec50711cb56ec28b708d16ac21031a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7ec50711cb56ec28b708d16ac21031a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp; regina::DiscSpecIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the disc pointed to by this iterator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>This routine is called deref(), since Python does not support the dereference operator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the disc pointed to by this iterator. </dd></dl>

</div>
</div>
<a id="ga4a3583f22c3ebd8e559905848cb376e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3583f22c3ebd8e559905848cb376e4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalSurfaces::VectorIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the raw vector for the normal surface that this iterator is currently pointing to. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is dereferenceable (in particular, it is not past-the-end).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding normal surface vector. </dd></dl>

</div>
</div>
<a id="ga47ea429f2da590de2bb9552562a1fa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47ea429f2da590de2bb9552562a1fa22">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp; regina::DiscSpecIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="ga8ce2d083cec79ff7c832abfd83ebd083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce2d083cec79ff7c832abfd83ebd083">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> &amp; regina::NormalSurfaces::VectorIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The preincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator after the increment. </dd></dl>

</div>
</div>
<a id="gad69d745738697d97ede9c4d8a11ac980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69d745738697d97ede9c4d8a11ac980">&#9670;&nbsp;</a></span>operator++() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">NormalSurfaces::SurfaceInserter</a> &amp; regina::NormalSurfaces::SurfaceInserter::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga9f06d8171f9e775f0a80889c0501ba65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f06d8171f9e775f0a80889c0501ba65">&#9670;&nbsp;</a></span>operator++() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> regina::DiscSpecIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present; instead this class implements <code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="ga844efec467431256e547cf052cc9b96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga844efec467431256e547cf052cc9b96f">&#9670;&nbsp;</a></span>operator++() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::VectorIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The postincrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before the increment took place. </dd></dl>

</div>
</div>
<a id="gac318da056fb4edb935e29edec27f8a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac318da056fb4edb935e29edec27f8a2a">&#9670;&nbsp;</a></span>operator++() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">NormalSurfaces::SurfaceInserter</a> &amp; regina::NormalSurfaces::SurfaceInserter::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to this output iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="ga87bf86f895cf3f97281cf98c6e9ac8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87bf86f895cf3f97281cf98c6e9ac8ef">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p>This behaves correctly in the case where <em>other</em> is <em>this</em>.</p>
<p>The default implementation simply adds the coordinates of the underlying vectors. Subclasses should reimplement this if they carry any additional information that also needs adjusting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector represent normal surfaces in the same triangulation, and use the same normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga654e738a0d9768a39697c79c8b2e74b7">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga654e738a0d9768a39697c79c8b2e74b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga654e738a0d9768a39697c79c8b2e74b7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSVectorMirrored::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<p>This behaves correctly in the case where <em>other</em> is <em>this</em>.</p>
<p>The default implementation simply adds the coordinates of the underlying vectors. Subclasses should reimplement this if they carry any additional information that also needs adjusting.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector represent normal surfaces in the same triangulation, and use the same normal coordinate system.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga87bf86f895cf3f97281cf98c6e9ac8ef">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gadc3d7940d6bd69b8e658e97cfbba3e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc3d7940d6bd69b8e658e97cfbba3e28">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> &amp; regina::NormalSurfaces::VectorIterator::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The predecrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator after the decrement. </dd></dl>

</div>
</div>
<a id="ga5f35a5fe4dcc7f2eca37e0b6f19020bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f35a5fe4dcc7f2eca37e0b6f19020bf">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::VectorIterator::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The postdecrement operator. </p>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before the decrement took place. </dd></dl>

</div>
</div>
<a id="gaa824ef83e3899d71862bd423bb3e5e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa824ef83e3899d71862bd423bb3e5e67">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscType::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides an ordering of disc types. </p>
<p>Types are ordered first by <em>tetrahedron</em> and then by <em>type</em>. NONE is considered less than all "meaningful" disc types.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this disc type appears before the given disc type in the ordering, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="gabdd4772a47d25242a4afeaaef48aca4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdd4772a47d25242a4afeaaef48aca4f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given disc specifier to the given output stream. </p>
<p>The disc specifier will be written as a triple <code>(tetIndex, type, number)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the disc specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga4d42ed9b68e522ff445b5d3e777176f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d42ed9b68e522ff445b5d3e777176f4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given disc type to the given output stream. </p>
<p>The disc type will be written as a pair <code>(tetIndex, type)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">type</td><td>the disc type to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gaf73fa623e9df3fbdffe981d730ced7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf73fa623e9df3fbdffe981d730ced7f2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given prism specifier to the given output stream. </p>
<p>The prism specifier will be written as a pair <code>(tetIndex, edge)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the prism specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga3d24cc1a1425473f871d57828db512df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d24cc1a1425473f871d57828db512df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>&amp; regina::DiscSpec::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the values from the given disc specifier into this specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the disc specifier whose values should be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this disc specifier. </dd></dl>

</div>
</div>
<a id="gaeb6e86b724a23f0be60c43ffdae7c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb6e86b724a23f0be60c43ffdae7c037">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&amp; regina::DiscSpecIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>

</div>
</div>
<a id="gabbfba8d154f25fd7b6507594fd429c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbfba8d154f25fd7b6507594fd429c8f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscType.html">DiscType</a>&amp; regina::DiscType::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this to a copy of the given disc type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the disc type to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this disc type. </dd></dl>

</div>
</div>
<a id="ga7ad5bd04d90fd7e5e3bcfce9542db788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ad5bd04d90fd7e5e3bcfce9542db788">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a>&amp; regina::PrismSpec::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the values from the given prism specifier into this specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the prism specifier whose values should be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this prism specifier. </dd></dl>

</div>
</div>
<a id="gac456a1c11b62d5ca892f31ff03dc4efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac456a1c11b62d5ca892f31ff03dc4efa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a>&amp; regina::NormalSurfaces::SurfaceInserter::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this iterator to be a clone of the given output iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the output iterator to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="gacc514e989a1cda7e3b9c20c4fb8e47fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc514e989a1cda7e3b9c20c4fb8e47fc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&amp; regina::NormalSurfaces::VectorIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes this a copy of the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the iterator to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="ga668ae3f49cca1cb82ba53e13f22959bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga668ae3f49cca1cb82ba53e13f22959bd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">NormalSurfaces::SurfaceInserter</a> &amp; regina::NormalSurfaces::SurfaceInserter::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a normal surface to the end of the appropriate surface list. </p>
<p>The given surface will be deallocated with the other surfaces in this list when the list is eventually destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="gac16cb2e647d865aca197f52cb88c7f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac16cb2e647d865aca197f52cb88c7f51">&#9670;&nbsp;</a></span>operator=() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">NormalSurfaces::SurfaceInserter</a> &amp; regina::NormalSurfaces::SurfaceInserter::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends the normal surface corresponding to the given vector to the end of the appropriate surface list. </p>
<p>The given vector will be owned by the newly created normal surface and will be deallocated with the other surfaces in this list when the list is eventually destroyed.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine has changed! As of Regina 4.6, this routine no longer checks for multiple octagonal discs. See the <a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html" title="An output iterator used to insert surfaces into an NormalSurfaces.">SurfaceInserter</a> class notes for details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>the vector of the normal surface to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this output iterator. </dd></dl>

</div>
</div>
<a id="gae9b7d3518b9329fe520e02ecfb37ac19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9b7d3518b9329fe520e02ecfb37ac19">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpec::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given disc specifier contain identical information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the disc specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given disc specifier contain identical information. </dd></dl>

</div>
</div>
<a id="gad214e90993b4a051e3029c7e75c7d83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad214e90993b4a051e3029c7e75c7d83a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpecIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given iterator are equal. </p>
<p>Two iterators are considered equal if (i) they were constructed from the same <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> object (not two different <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> objects with identical contents), and (ii) they point to the same disc of the same tetrahedron.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given iterator are equal. </dd></dl>

</div>
</div>
<a id="ga6c537efe1a738b4695f29f8bacf74632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c537efe1a738b4695f29f8bacf74632">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscType::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given disc type are identical. </p>
<p>Note that NONE is considered identical to NONE, and that NONE will not be equal to any "meaningful" disc type (specifically, a disc type for which <em>type</em> is non-negative).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this and the given disc type are identical, or <code>false</code> if they are different. </dd></dl>

</div>
</div>
<a id="gaa1465273485851f908cb13c6f8d9e53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1465273485851f908cb13c6f8d9e53e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::PrismSpec::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given prism specifier contain identical information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the prism specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given prism specifier contain identical information. </dd></dl>

</div>
</div>
<a id="gad108577407a2ac094d75bf5049ee6283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad108577407a2ac094d75bf5049ee6283">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::VectorIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares this with the given operator for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare this with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the iterators point to the same element of the same normal surface list, or <code>false</code> if they do not. </dd></dl>

</div>
</div>
<a id="ga589b3a30d37df7adbd44ff523d3ec19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga589b3a30d37df7adbd44ff523d3ec19c">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp; regina::NormalSurfaceVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the given coordinate from the underlying vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to retrieve; this must be between 0 and <a class="el" href="group__surfaces.html#ga680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinate at the given index. </dd></dl>

</div>
</div>
<a id="ga4428e0ba8bfcc8083b37e9e3e2220c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4428e0ba8bfcc8083b37e9e3e2220c96">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="gae92f3f038eac514d3e599ff3d92d8485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92f3f038eac514d3e599ff3d92d8485">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="gad8d7cd88fdd4d0f22a11b8b2a0ad5093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8d7cd88fdd4d0f22a11b8b2a0ad5093">&#9670;&nbsp;</a></span>orientability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::SurfaceFilterProperties::orientability </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable orientabilities. </p>
<p>Note that this is a subset of <code>{ true, false }</code>. Any surface whose orientability is not in this set will not be accepted by this filter.</p>
<dl class="section return"><dt>Returns</dt><dd>the set of allowable orientabilities. </dd></dl>

</div>
</div>
<a id="ga1782b65da2df0fe8921002d28139938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1782b65da2df0fe8921002d28139938e">&#9670;&nbsp;</a></span>orientedQuads() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>This routine is for coordinate systems that support transversely oriented normal surfaces; for details see "The Thurston norm via normal surfaces", Stephan Tillmann and Daryl Cooper, Pacific Journal of Mathematics 239 (2009), 1-15.</p>
<p>An oriented quadrilateral disc type is identified by specifying a tetrahedron, a quadrilateral type (0, 1 or 2) as described in <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">quads()</a>, and a boolean orientation. The <code>true</code> orientation indicates a transverse orientation pointing to the edge containing vertex 0 of the tetrahedron, and the <code>false</code> orientation indicates a transverse orientation pointing to the opposite edge.</p>
<p>If the underlying coordinate system does not support transverse orientation, this routine will simply return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the quadrilateral disc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

</div>
</div>
<a id="gad6d15dfef9d0dca32bc66c8ac506d196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6d15dfef9d0dca32bc66c8ac506d196">&#9670;&nbsp;</a></span>orientedQuads() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga1782b65da2df0fe8921002d28139938e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">NormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented in <a class="el" href="group__surfaces.html#gaa1e3f2307548c014fb23b2a511632a1d">regina::NSVectorOrientedQuad</a>, <a class="el" href="group__surfaces.html#ga6015659e0c8fee455cea5877c075c47a">regina::NSVectorOriented</a>, and <a class="el" href="group__surfaces.html#ga5318a2c38f37d22b56a05a31bec63592">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga5318a2c38f37d22b56a05a31bec63592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5318a2c38f37d22b56a05a31bec63592">&#9670;&nbsp;</a></span>orientedQuads() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga1782b65da2df0fe8921002d28139938e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">NormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#gad6d15dfef9d0dca32bc66c8ac506d196">regina::NormalSurfaceVector</a>.</p>

<p>Reimplemented in <a class="el" href="group__surfaces.html#gaa1e3f2307548c014fb23b2a511632a1d">regina::NSVectorOrientedQuad</a>.</p>

</div>
</div>
<a id="ga6015659e0c8fee455cea5877c075c47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6015659e0c8fee455cea5877c075c47a">&#9670;&nbsp;</a></span>orientedQuads() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga1782b65da2df0fe8921002d28139938e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">NormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#gad6d15dfef9d0dca32bc66c8ac506d196">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gaa1e3f2307548c014fb23b2a511632a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1e3f2307548c014fb23b2a511632a1d">&#9670;&nbsp;</a></span>orientedQuads() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOrientedQuad::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga1782b65da2df0fe8921002d28139938e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface.">NormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga5318a2c38f37d22b56a05a31bec63592">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga778a22958ed66c5118c06e8fc861b5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga778a22958ed66c5118c06e8fc861b5b7">&#9670;&nbsp;</a></span>orientedTriangles() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>This routine is for coordinate systems that support transversely oriented normal surfaces; for details see "The Thurston norm via normal surfaces", Stephan Tillmann and Daryl Cooper, Pacific Journal of Mathematics 239 (2009), 1-15.</p>
<p>An oriented triangular disc type is identified by specifying a tetrahedron, a vertex of that tetrahedron that the triangle surrounds, and a boolean orientation. The <code>true</code> orientation indicates a transverse orientation pointing to the nearby vertex, and the <code>false</code> orientation indicates a transverse orientation pointing to the opposite face.</p>
<p>If the underlying coordinate system does not support transverse orientation, this routine will simply return zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

</div>
</div>
<a id="ga2ce2cc2fbd8b46b97d8ea787535282d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce2cc2fbd8b46b97d8ea787535282d0">&#9670;&nbsp;</a></span>orientedTriangles() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga778a22958ed66c5118c06e8fc861b5b7" title="Returns the number of oriented triangular discs of the given type in this normal surface.">NormalSurface::orientedTriangles()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga3a4137d110e610a9ba8dfa5dbc1c4f1c">regina::NSVectorOriented</a>, and <a class="el" href="group__surfaces.html#ga2015a06ce4d730919cf5ac29a17936e2">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga2015a06ce4d730919cf5ac29a17936e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2015a06ce4d730919cf5ac29a17936e2">&#9670;&nbsp;</a></span>orientedTriangles() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga778a22958ed66c5118c06e8fc861b5b7" title="Returns the number of oriented triangular discs of the given type in this normal surface.">NormalSurface::orientedTriangles()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga2ce2cc2fbd8b46b97d8ea787535282d0">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga3a4137d110e610a9ba8dfa5dbc1c4f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a4137d110e610a9ba8dfa5dbc1c4f1c">&#9670;&nbsp;</a></span>orientedTriangles() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#ga778a22958ed66c5118c06e8fc861b5b7" title="Returns the number of oriented triangular discs of the given type in this normal surface.">NormalSurface::orientedTriangles()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga2ce2cc2fbd8b46b97d8ea787535282d0">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga9864adf21187883e54e04b8e2d86379a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9864adf21187883e54e04b8e2d86379a">&#9670;&nbsp;</a></span>packet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLFilterPacketReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga9372bff59f5fe548909a8717bdefb992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9372bff59f5fe548909a8717bdefb992">&#9670;&nbsp;</a></span>packet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Packet.html">Packet</a> * regina::XMLNormalSurfacesReader::packet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the newly allocated packet that has been read by this element reader. </p>
<p>Deallocation of this new packet is not the responsibility of this class. Once this routine gives a non-zero return value, it should continue to give the same non-zero return value from this point onwards.</p>
<p>If this routine is ever to give a non-zero return value, it <em>must</em> be giving that non-zero return value by the time the first child packet or packet tag is encountered; otherwise child packets will not be inserted into the packet tree and/or packet tags will not be added.</p>
<p>The newly allocated packet should not be given a packet label. This will be done by <a class="el" href="group__packet.html#ga8326fbf3c5e5fe26fa9d3dca2a86ce7d" title="Signifies that parsing has finished for a subelement of this XML element.">XMLPacketReader::endSubElement()</a>.</p>
<p>The newly allocated packet may or may not be inserted in the packet tree structure; this does not matter (although if it is inserted it must be inserted in the correct place).</p>
<p>The newly allocated packet should not be given any associated packet tags. This will be done by <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">XMLPacketReader::startSubElement()</a>.</p>
<p>The default implementation returns 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet that has been read, or 0 if packet reading is incomplete, the packet should be ignored or an error occurred. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#gacde072f143d7c1ecc8e4916e52ceb1d0">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga03921377951ebe00c97b08048df672f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03921377951ebe00c97b08048df672f4">&#9670;&nbsp;</a></span>PrismSpec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PrismSpec::PrismSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised prism specifier. </p>

</div>
</div>
<a id="ga85c1d2b61b7263c7837a5b8f00c44926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85c1d2b61b7263c7837a5b8f00c44926">&#9670;&nbsp;</a></span>PrismSpec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PrismSpec::PrismSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new prism specifier that is a clone of the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the prism specifier to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad07d39b2403c38532be26daabc105af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad07d39b2403c38532be26daabc105af6">&#9670;&nbsp;</a></span>PrismSpec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::PrismSpec::PrismSpec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newTetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new prism specifier containing the given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTetIndex</td><td>the index in the triangulation of the tetrahedron containing the prism. </td></tr>
    <tr><td class="paramname">newEdge</td><td>the edge of the tetrahedron that is contained in this prism; this must be between 0 and 5 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e160a2b7934ad098ab2252adfd128db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e160a2b7934ad098ab2252adfd128db">&#9670;&nbsp;</a></span>quadOctToStandardAN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::quadOctToStandardAN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space to the set of all embedded vertex almost normal surfaces in the standard tri-quad-oct space. </p>
<p>This routine is the almost normal analogue to the <a class="el" href="group__surfaces.html#ga923d837b8eb709fd079d4ec8e5f30889" title="Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embe...">quadToStandard()</a> conversion routine; see the <a class="el" href="group__surfaces.html#ga923d837b8eb709fd079d4ec8e5f30889" title="Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embe...">quadToStandard()</a> documentation for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This surface list is precisely the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space; no more, no less. Moreover, these vectors are stored using quadrilateral-octagon coordinates. Typically this means that it was obtained through <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_AN_QUAD_OCT and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex almost normal surfaces in standard tri-quad-oct coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="gac8380567805860ecdbde4bde09a5fc9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8380567805860ecdbde4bde09a5fc9c">&#9670;&nbsp;</a></span>quads() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>In each tetrahedron, there are three types of quadrilaterals, defined by how they separate the four tetrahedron vertices into two pairs. Quadrilateral type <em>i</em> (for <em>i</em> = 0, 1 or 2) is defined to separate edge <em>i</em> of the tetrahedron from edge (5-<em>i</em>). That is:</p>
<ul>
<li>type 0 separates vertices 0,1 of the tetrahedron from vertices 2,3;</li>
<li>type 1 separates vertices 0,2 of the tetrahedron from vertices 1,3;</li>
<li>type 2 separates vertices 0,3 of the tetrahedron from vertices 1,2.</li>
</ul>
<p>If you are using a coordinate system that adorns discs with additional information (such as orientation), this routine returns the <em>total</em> number of quadrilaterals in the given tetrahedron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2, as described above. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

</div>
</div>
<a id="ga570ee5188151835875872bb11c5849da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga570ee5188151835875872bb11c5849da">&#9670;&nbsp;</a></span>quads() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implemented in <a class="el" href="group__surfaces.html#ga2dd79b66600f3a0802175e1593fe6c96">regina::NSVectorStandard</a>, <a class="el" href="group__surfaces.html#gab05acfe295661b31d74571b224b58712">regina::NSVectorOrientedQuad</a>, <a class="el" href="group__surfaces.html#ga5185cb4b3afd73b98e9a8c8a5eebcb6f">regina::NSVectorOriented</a>, <a class="el" href="group__surfaces.html#ga7212bf949dd892cacfaed8de64115b7a">regina::NSVectorMirrored</a>, and <a class="el" href="group__surfaces.html#ga2062102f4e6bec5108ce42cbab04b692">regina::NSVectorANStandard</a>.</p>

</div>
</div>
<a id="ga2062102f4e6bec5108ce42cbab04b692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2062102f4e6bec5108ce42cbab04b692">&#9670;&nbsp;</a></span>quads() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorANStandard::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga570ee5188151835875872bb11c5849da">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga7212bf949dd892cacfaed8de64115b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7212bf949dd892cacfaed8de64115b7a">&#9670;&nbsp;</a></span>quads() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga570ee5188151835875872bb11c5849da">regina::NormalSurfaceVector</a>.</p>

<p>Reimplemented in <a class="el" href="group__surfaces.html#gab05acfe295661b31d74571b224b58712">regina::NSVectorOrientedQuad</a>.</p>

</div>
</div>
<a id="ga5185cb4b3afd73b98e9a8c8a5eebcb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5185cb4b3afd73b98e9a8c8a5eebcb6f">&#9670;&nbsp;</a></span>quads() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga570ee5188151835875872bb11c5849da">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gab05acfe295661b31d74571b224b58712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab05acfe295661b31d74571b224b58712">&#9670;&nbsp;</a></span>quads() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOrientedQuad::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga7212bf949dd892cacfaed8de64115b7a">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga2dd79b66600f3a0802175e1593fe6c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dd79b66600f3a0802175e1593fe6c96">&#9670;&nbsp;</a></span>quads() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorStandard::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga570ee5188151835875872bb11c5849da">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga923d837b8eb709fd079d4ec8e5f30889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga923d837b8eb709fd079d4ec8e5f30889">&#9670;&nbsp;</a></span>quadToStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::quadToStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embedded vertex normal surfaces in standard (tri-quad) space. </p>
<p>The initial list in quadrilateral space is taken to be this normal surface list; the final list in standard space will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the final list will also be returned from this routine.</p>
<p>This routine can only be used with normal surfaces, not almost normal surfaces. For almost normal surfaces, see the similar routine <a class="el" href="group__surfaces.html#ga8e160a2b7934ad098ab2252adfd128db" title="Converts the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space to the ...">quadOctToStandardAN()</a>.</p>
<p>This procedure is available for any triangulation whose vertex links are all spheres and/or discs, and is <em>much</em> faster than enumerating surfaces directly in standard tri-quad coordinates. The underlying algorithm is described in detail in "Converting between quadrilateral and standard solution sets in normal surface theory", Benjamin A. Burton, Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>Typically users do not need to call this routine directly, since the standard <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a> routine will use it implicitly where possible. That is, when asked for standard vertex surfaces, <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a> will first find all <em>quadrilateral</em> vertex surfaces and then use this procedure to convert them to standard vertex surfaces; this is generally orders of magnitude faster than enumerating surfaces directly in standard coordinates.</p>
<p>Nevertheless, this standalone routine is provided as a convenience for users who already have a set of quadrilateral vertex surfaces, and who simply wish to convert them to a set of standard vertex surfaces without the cost of implicitly enumerating the quadrilateral vertex surfaces again.</p>
<p>It should be noted that this routine does <em>not</em> simply convert vectors from one form to another; instead it converts a full solution set of vertex surfaces in quadrilateral coordinates to a full solution set of vertex surfaces in standard coordinates. Typically there are many more vertex surfaces in standard coordinates (all of which this routine will find).</p>
<p>This routine will run some very basic sanity checks before starting. Specifically, it will check the validity and vertex links of the underlying triangulation, and will verify that the coordinate system and embedded-only flag are set to NS_QUAD and <code>true</code> respectively. If any of these checks fails, this routine will do nothing and return <code>null</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This normal surface list is precisely the set of all embedded vertex normal surfaces in quadrilateral space; no more, no less. Moreover, these vectors are stored using quadrilateral coordinates. Typically this means that it was obtained through <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_QUAD and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex normal surfaces in standard (tri-quad) coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="ga09b0d740fe1591e8aa622a3c6d5eeab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b0d740fe1591e8aa622a3c6d5eeab6">&#9670;&nbsp;</a></span>rawVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Ray.html">Ray</a> &amp; regina::NormalSurface::rawVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gives read-only access to the raw vector that sits beneath this normal surface. </p>
<p>Generally users should not need this function. However, it is provided here in case the need should arise (e.g., for reasons of efficiency).</p>
<dl class="section warning"><dt>Warning</dt><dd>A <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold.">NormalSurface</a> does not know what underlying coordinate system its raw vector uses. Unless you already know the coordinate system in advance (i.e., you created the surface yourself), it is best to keep to the coordinate-system-agnostic access functions such as <a class="el" href="group__surfaces.html#ga3ea2312f446f4f7b1c3066925d7f1e2c" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurfaceVector::triangles()</a> and <a class="el" href="group__surfaces.html#ga570ee5188151835875872bb11c5849da" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurfaceVector::quads()</a>.</dd></dl>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the underlying raw vector. </dd></dl>

</div>
</div>
<a id="ga867a48662548c9d040fb2e4124bb7c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga867a48662548c9d040fb2e4124bb7c8c">&#9670;&nbsp;</a></span>realBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> regina::SurfaceFilterProperties::realBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of allowable has-real-boundary properties. </p>
<p>Note that this is a subset of <code>{ true, false }</code>. Any surface whose has-real-boundary property is not in this set will not be accepted by this filter.</p>
<dl class="section return"><dt>Returns</dt><dd>the set of allowable has-real-boundary properties. </dd></dl>

</div>
</div>
<a id="ga1959b9dcedd0e35e00320f0490eaf75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1959b9dcedd0e35e00320f0490eaf75c">&#9670;&nbsp;</a></span>recreateMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalSurfaces::recreateMatchingEquations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created matrix containing the matching equations that were used to create this normal surface list. </p>
<p>The destruction of this matrix is the responsibility of the caller of this routine. Multiple calls to this routine will result in the construction of multiple matrices. This routine in fact merely calls <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> with the appropriate parameters.</p>
<p>The format of the matrix is identical to that returned by <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a>.</p>
<p>Note that there are situations in which <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> returns <code>null</code> (because the triangulation is not supported by the chosen coordinate system). However, this routine should never return <code>null</code>, because if <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> had returned <code>null</code> then this normal surface list would not have been created in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd>the matching equations used to create this normal surface list. </dd></dl>

</div>
</div>
<a id="ga3d189ba0309c3ebde448022b7cd5935f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d189ba0309c3ebde448022b7cd5935f">&#9670;&nbsp;</a></span>removeAllEulerChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterProperties::removeAllEulerChars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empties the set of allowable Euler characteristics. </p>
<p>See <a class="el" href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353" title="Returns the set of allowable Euler characteristics.">eulerChars()</a> for further details.</p>
<p>Note that this will mean that this filter will allow <em>any</em> Euler characteristic to pass. </p>

</div>
</div>
<a id="gaca33e3e9bfa57066fee46defbb141552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca33e3e9bfa57066fee46defbb141552">&#9670;&nbsp;</a></span>removeEulerChar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterProperties::removeEulerChar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the given Euler characteristic from the set of allowable Euler characteristics. </p>
<p>See <a class="el" href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353" title="Returns the set of allowable Euler characteristics.">eulerChars()</a> for further details.</p>
<p>Note that if the allowable set is completely emptied, this filter will allow <em>any</em> Euler characteristic to pass.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given Euler characteristic is currently in the allowable set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>the allowable Euler characteristic to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga042f4e0908964b3cec8fcf336f147f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga042f4e0908964b3cec8fcf336f147f22">&#9670;&nbsp;</a></span>sameSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::sameSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether this and the given surface in fact represent the same normal (or almost normal) surface. </p>
<p>Specifically, this routine examines (or computes) the number of normal or almost normal discs of each type, and returns <code>true</code> if and only if these counts are the same for both surfaces.</p>
<p>It does not matter what coordinate systems the two surfaces use. In particular, it does not matter if this and the given surface use different coordinate systems, and it does not matter if one surface uses an almost normal coordinate system and the other does not.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Both this and the given normal surface live within the same 3-manifold triangulation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the surface to be compared with this surface. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if both surfaces represent the same normal or almost normal surface, or <code>false</code> if not. </dd></dl>

</div>
</div>
<a id="gae2559f5cea6339eb69cdcc532f970409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2559f5cea6339eb69cdcc532f970409">&#9670;&nbsp;</a></span>saveCSVEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::saveCSVEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>additionalFields</em> = <code><a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file, using edge weight coordinates. </p>
<p>CSV files are human-readable and human-editable, and are suitable for importing into spreadsheets and databases.</p>
<p>The surfaces will be exported in edge weight coordinates. Thus there will be one coordinate for each edge of the underlying triangulation; each such coordinate will become a separate field in the CSV file.</p>
<p>As well as the normal surface coordinates, additional properties of the normal surfaces (such as Euler characteristic, orientability, and so on) can be included as extra fields in the export. Users can select precisely which properties to include by passing a bitmask, formed as a bitwise <em>or</em> combination of constants from the <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> enumeration type.</p>
<p>The CSV format used here begins with a header row, and uses commas as field separators. <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a> fields with arbitrary contents are placed inside double quotes, and the double quote character itself is represented by a pair of double quotes. Thus the string <code>my "normal" surface's name</code> would be stored as <code>"my ""normal"" surface's name"</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. Any user strings such as surface names will be written in UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the CSV file to export to. </td></tr>
    <tr><td class="paramname">additionalFields</td><td>a bitwise combination of constants from <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> indicating which additional properties of surfaces should be included in the export. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the export was successful, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga2b308eb9fd7a131b2c370a589b7e43c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b308eb9fd7a131b2c370a589b7e43c6">&#9670;&nbsp;</a></span>saveCSVStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::saveCSVStandard </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>additionalFields</em> = <code><a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this list of normal surfaces as a plain text CSV (comma-separated value) file, using standard coordinates. </p>
<p>CSV files are human-readable and human-editable, and are suitable for importing into spreadsheets and databases.</p>
<p>The surfaces will be exported in standard coordinates (tri-quad coordinates for normal surfaces, or tri-quad-oct coordinates for almost normal surfaces). Each coordinate will become a separate field in the CSV file.</p>
<p>As well as the normal surface coordinates, additional properties of the normal surfaces (such as Euler characteristic, orientability, and so on) can be included as extra fields in the export. Users can select precisely which properties to include by passing a bitmask, formed as a bitwise <em>or</em> combination of constants from the <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> enumeration type.</p>
<p>The CSV format used here begins with a header row, and uses commas as field separators. <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a> fields with arbitrary contents are placed inside double quotes, and the double quote character itself is represented by a pair of double quotes. Thus the string <code>my "normal" surface's name</code> would be stored as <code>"my ""normal"" surface's name"</code>.</p>
<dl class="section user"><dt>Internationalisation</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. Any user strings such as surface names will be written in UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the CSV file to export to. </td></tr>
    <tr><td class="paramname">additionalFields</td><td>a bitwise combination of constants from <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> indicating which additional properties of surfaces should be included in the export. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the export was successful, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ga19f95b5cc7d6e00e85cd78283227fb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19f95b5cc7d6e00e85cd78283227fb17">&#9670;&nbsp;</a></span>scaleDown() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p>The default implementation simply scales down the underlying vector. Subclasses should reimplement this if they carry any additional information that also needs adjusting. </p>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga7607f80141d61419e9fc05bb2c266c97">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga7607f80141d61419e9fc05bb2c266c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7607f80141d61419e9fc05bb2c266c97">&#9670;&nbsp;</a></span>scaleDown() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSVectorMirrored::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity.</p>
<p>The default implementation simply scales down the underlying vector. Subclasses should reimplement this if they carry any additional information that also needs adjusting. </p>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga19f95b5cc7d6e00e85cd78283227fb17">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gafad87049b21b9ab51c289a81d2c14d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafad87049b21b9ab51c289a81d2c14d45">&#9670;&nbsp;</a></span>setCompactness()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterProperties::setCompactness </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the set of allowable compactness properties. </p>
<p>See <a class="el" href="group__surfaces.html#ga6b6a0f2fcdf9294d92b2eaed6afcdd75" title="Returns the set of allowable compactness properties.">compactness()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the new set of allowable compactness properties. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24c548a7bcd676dceef9b01ec96ab8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24c548a7bcd676dceef9b01ec96ab8da">&#9670;&nbsp;</a></span>setElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaceVector::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given normal coordinate to the given value. </p>
<p>The default implementation simply sets the coordinate in the underlying vector. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to set; this must be between 0 and <a class="el" href="group__surfaces.html#ga680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the given coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga09f01421c3a687edc63fada1808c063f">regina::NSVectorMirrored</a>.</p>

</div>
</div>
<a id="ga09f01421c3a687edc63fada1808c063f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09f01421c3a687edc63fada1808c063f">&#9670;&nbsp;</a></span>setElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NSVectorMirrored::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given normal coordinate to the given value. </p>
<p>The default implementation simply sets the coordinate in the underlying vector. Subclasses should reimplement this if they carry any additional information that also need adjusting.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the coordinate to set; this must be between 0 and <a class="el" href="group__surfaces.html#ga680b7b7ac5f45b6404644ee9fb1afb85" title="Returns the number of coordinates in the underlying vector.">size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the given coordinate. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga24c548a7bcd676dceef9b01ec96ab8da">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gae3c9a382b0f84bf5f2b66bfeb5a7104f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3c9a382b0f84bf5f2b66bfeb5a7104f">&#9670;&nbsp;</a></span>setEulerChars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterProperties::setEulerChars </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the allowable Euler characteristics to the given set. </p>
<p>See <a class="el" href="group__surfaces.html#gae121058acca2e36eb07fe7973c0e2353" title="Returns the set of allowable Euler characteristics.">eulerChars()</a> for further details.</p>
<dl class="section user"><dt>Interfaces</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the new set of allowable Euler characteristics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5317f117563f37bd5486fed52b6cf81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5317f117563f37bd5486fed52b6cf81e">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name associated with this normal surface. </p>
<p>Names are optional and need not be unique. The default name for a surface is the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newName</td><td>the new name to associate with this surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf06adfa97f986d51b34a21e62a5d7583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf06adfa97f986d51b34a21e62a5d7583">&#9670;&nbsp;</a></span>setOrientability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterProperties::setOrientability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the set of allowable orientabilities. </p>
<p>See <a class="el" href="group__surfaces.html#gad8d7cd88fdd4d0f22a11b8b2a0ad5093" title="Returns the set of allowable orientabilities.">orientability()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the new set of allowable orientabilities. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c7cfeba32b91c05b26bb29d640e81ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c7cfeba32b91c05b26bb29d640e81ef">&#9670;&nbsp;</a></span>setRealBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterProperties::setRealBoundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1BoolSet.html">BoolSet</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the set of allowable has-real-boundary properties. </p>
<p>See <a class="el" href="group__surfaces.html#ga867a48662548c9d040fb2e4124bb7c8c" title="Returns the set of allowable has-real-boundary properties.">realBoundary()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the new set of allowable has-real-boundary properties. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3241911ff87de29c6bf78d78675fbcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3241911ff87de29c6bf78d78675fbcc2">&#9670;&nbsp;</a></span>setUsesAnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterCombination::setUsesAnd </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether this is an <em>and</em> or an <em>or</em> combination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if this is to be an <em>and</em> combination, or <code>false</code> if this is to be an <em>or</em> combination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga680b7b7ac5f45b6404644ee9fb1afb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680b7b7ac5f45b6404644ee9fb1afb85">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurfaceVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of coordinates in the underlying vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of coordinates. </dd></dl>

</div>
</div>
<a id="ga0aae88a4f82d88e1ed542f17d26904d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aae88a4f82d88e1ed542f17d26904d7">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurfaces::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of surfaces stored in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of surfaces. </dd></dl>

</div>
</div>
<a id="gae2995d136dc8e575605230cec31dd8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2995d136dc8e575605230cec31dd8c9">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::sort </td>
          <td>(</td>
          <td class="paramtype">Comparison &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the surfaces in this list according to the given criterion. </p>
<p>This sort is stable, i.e., surfaces that are equivalent under the given criterion will remain in the same relative order.</p>
<p>The implementation of this routine uses std::stable_sort.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>a binary function (or function object) that accepts two const <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold.">NormalSurface</a> pointers, and returns <code>true</code> if and only if the first surface should appear before the second in the sorted list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3212b3ec1451db0bcc98871c65d78937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3212b3ec1451db0bcc98871c65d78937">&#9670;&nbsp;</a></span>standardANToQuadOct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::standardANToQuadOct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space to the set of all embedded vertex almost normal surfaces in the smaller quadrilateral-octagon space. </p>
<p>This routine is the almost normal analogue to the <a class="el" href="group__surfaces.html#ga92ffe41e50f214351ee2086ef600661a" title="Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of al...">standardToQuad()</a> conversion routine; see the <a class="el" href="group__surfaces.html#ga92ffe41e50f214351ee2086ef600661a" title="Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of al...">standardToQuad()</a> documentation for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This normal surface list is precisely the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space; no more, no less. Typically this means that it was obtained through <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_AN_STANDARD and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex almost normal surfaces in quadrilateral-octagon coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="ga92ffe41e50f214351ee2086ef600661a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ffe41e50f214351ee2086ef600661a">&#9670;&nbsp;</a></span>standardToQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::standardToQuad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of all embedded vertex normal surfaces in quadrilateral space. </p>
<p>The initial list in standard space is taken to be this normal surface list; the final list in quadrilateral space will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the final list will also be returned from this routine.</p>
<p>This routine can only be used with normal surfaces, not almost normal surfaces. For almost normal surfaces, see the similar routine <a class="el" href="group__surfaces.html#ga3212b3ec1451db0bcc98871c65d78937" title="Converts the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space to the ...">standardANToQuadOct()</a>.</p>
<p>This procedure is available for any triangulation whose vertex links are all spheres and/or discs. The underlying algorithm is described in detail in "Converting between quadrilateral and
standard solution sets in normal surface theory", Benjamin A. Burton, Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>It should be noted that this routine does <em>not</em> simply convert vectors from one form to another; instead it converts a full solution set of vertex surfaces in standard coordinates to a full solution set of vertex surfaces in quadrilateral coordinates. Typically there are far fewer vertex surfaces in quadrilateral coordinates (all of which this routine will find).</p>
<p>This routine will run some very basic sanity checks before starting. Specifically, it will check the validity and vertex links of the underlying triangulation, and will verify that the coordinate system and embedded-only flag are set to NS_STANDARD and <code>true</code> respectively. If any of these checks fails, this routine will do nothing and return <code>null</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This normal surface list is precisely the set of all embedded vertex normal surfaces in standard (tri-quad) space; no more, no less. Moreover, these vectors are stored using standard coordinates. Typically this means that this list was obtained through <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_STANDARD and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex normal surfaces in quadrilateral coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="ga47377e99609a1ed88175aa5aee16f3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47377e99609a1ed88175aa5aee16f3ca">&#9670;&nbsp;</a></span>startContentSubElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLFilterPacketReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="gaae3356c94debf7c1128136248f54a953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae3356c94debf7c1128136248f54a953">&#9670;&nbsp;</a></span>startContentSubElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLNormalSurfacesReader::startContentSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used instead of <a class="el" href="group__packet.html#ga75cc7b21708011a1963811378edaf3ab" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> for XML subelements that are not child packets or packet tags. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga83b13f4e881390c9a02e3ae1848d8e6b">regina::XMLPacketReader</a>.</p>

</div>
</div>
<a id="ga92daff1b64a5dfdd5fb4dc0b92170d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92daff1b64a5dfdd5fb4dc0b92170d6b">&#9670;&nbsp;</a></span>startElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::XMLNormalSurfaceReader::startElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>tagProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a> *&#160;</td>
          <td class="paramname"><em>parentReader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that parsing of this XML element is beginning. </p>
<p>The default implementation does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tagName</td><td>the name of the opening tag for this element. </td></tr>
    <tr><td class="paramname">tagProps</td><td>the properties associated with the opening tag. </td></tr>
    <tr><td class="paramname">parentReader</td><td>the reader currently parsing the parent XML element, or 0 if this is the top-level element. If this paraneter is non-zero, it is guaranteed that <a class="el" href="group__surfaces.html#ga6304f8bb96452208b66e53ba684708e0" title="Signifies that a subelement of this XML element is about to be parsed.">startSubElement()</a> has already been called upon the parent reader. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga9bb765e35393c8ddf12e2348210c4e4e">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga6304f8bb96452208b66e53ba684708e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6304f8bb96452208b66e53ba684708e0">&#9670;&nbsp;</a></span>startSubElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1XMLElementReader.html">XMLElementReader</a>* regina::XMLNormalSurfaceReader::startSubElement </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>subTagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1xml_1_1XMLPropertyDict.html">regina::xml::XMLPropertyDict</a> &amp;&#160;</td>
          <td class="paramname"><em>subTagProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Signifies that a subelement of this XML element is about to be parsed. </p>
<p>The default implementation returns a new <a class="el" href="classregina_1_1XMLElementReader.html" title="Used to read the contents of a single XML element.">XMLElementReader</a> which can be used to ignore the subelement completely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subTagName</td><td>the name of the subelement opening tag. </td></tr>
    <tr><td class="paramname">subTagProps</td><td>the properties associated with the subelement opening tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly created element reader that will be used to parse the subelement. This class should <em>not</em> take care of the new reader's destruction; that will be done by the parser. </dd></dl>

<p>Reimplemented from <a class="el" href="group__file.html#ga16a3e05cc93447ee75489bad822feeb9">regina::XMLElementReader</a>.</p>

</div>
</div>
<a id="ga630965501c7321d504b1243732e62d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga630965501c7321d504b1243732e62d95">&#9670;&nbsp;</a></span>surface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> * regina::XMLNormalSurfaceReader::surface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the normal surface that has been read. </p>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated normal surface, or 0 if an error occurred. </dd></dl>

</div>
</div>
<a id="gaa75527d87d83254739c7e52175546acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa75527d87d83254739c7e52175546acf">&#9670;&nbsp;</a></span>surface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> * regina::NormalSurfaces::surface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the surface at the requested index in this set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested surface in this set; this must be between 0 and <a class="el" href="group__surfaces.html#ga0aae88a4f82d88e1ed542f17d26904d7" title="Returns the number of surfaces stored in this list.">size()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal surface at the requested index in this set. </dd></dl>

</div>
</div>
<a id="ga4eae67e1c98b4ed1946419ccb48b88c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eae67e1c98b4ed1946419ccb48b88c4">&#9670;&nbsp;</a></span>SurfaceFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilter::SurfaceFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new default surface filter. </p>
<p>This will simply accept all normal surfaces. </p>

</div>
</div>
<a id="gaf850e0c4ab0a597395cc978dbc3c66ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf850e0c4ab0a597395cc978dbc3c66ef">&#9670;&nbsp;</a></span>SurfaceFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilter::SurfaceFilter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new default surface filter. </p>
<p>This will simply accept all normal surfaces. Note that the given parameter is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>this parameter is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d4ad9349ccc905e2b0b398cff7b7e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d4ad9349ccc905e2b0b398cff7b7e2d">&#9670;&nbsp;</a></span>SurfaceFilterCombination() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilterCombination::SurfaceFilterCombination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new surface filter that accepts all normal surfaces. </p>
<p>This will be an <em>and</em> filter. </p>

</div>
</div>
<a id="gad2ba13964e5ef3d54c2d764e21b12cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2ba13964e5ef3d54c2d764e21b12cef">&#9670;&nbsp;</a></span>SurfaceFilterCombination() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilterCombination::SurfaceFilterCombination </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new surface filter that is a clone of the given surface filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the surface filter to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5de0952456f0ac9d4e5c1cce1cc64b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5de0952456f0ac9d4e5c1cce1cc64b52">&#9670;&nbsp;</a></span>SurfaceFilterProperties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilterProperties::SurfaceFilterProperties </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new surface filter that accepts all normal surfaces. </p>

</div>
</div>
<a id="ga81cb3db20848b8330b3fed8872985799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81cb3db20848b8330b3fed8872985799">&#9670;&nbsp;</a></span>SurfaceFilterProperties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilterProperties::SurfaceFilterProperties </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new surface filter that is a clone of the given surface filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the surface filter to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53984bd01650b45aa679e8051833dfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53984bd01650b45aa679e8051833dfc6">&#9670;&nbsp;</a></span>SurfaceInserter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::SurfaceInserter::SurfaceInserter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new output iterator that is a clone of the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the output iterator to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga72bee275132d1b11faa5dceaad9d8253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72bee275132d1b11faa5dceaad9d8253">&#9670;&nbsp;</a></span>SurfaceInserter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::SurfaceInserter::SurfaceInserter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> &amp;&#160;</td>
          <td class="paramname"><em>newList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newOwner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new output iterator. </p>
<p>The member variables of this iterator will be initialised according to the parameters passed to this constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newList</td><td>the list into which surfaces will be inserted. </td></tr>
    <tr><td class="paramname">newOwner</td><td>the triangulation in which the surfaces to be inserted are contained. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca77e328a62cce379c0ab4815caffd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca77e328a62cce379c0ab4815caffd8d">&#9670;&nbsp;</a></span>systemAllowsAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::systemAllowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the underlying coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<p>This is a property of the coordinate system in which this surface is natively stored, <em>not</em> a property of the surface itself. For example, if this surface has no octagons but is stored using standard almost normal coordinates, then this routine will return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed in the underlying coordinate system. </dd></dl>

</div>
</div>
<a id="gadc8041fb1a328bbea67533be9ba597f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc8041fb1a328bbea67533be9ba597f3">&#9670;&nbsp;</a></span>systemAllowsOriented()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::systemAllowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the underlying coordinate system being used allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported in the underlying coordinate system. </dd></dl>

</div>
</div>
<a id="ga1599fbfed6929c341d4be8aa502f2346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1599fbfed6929c341d4be8aa502f2346">&#9670;&nbsp;</a></span>systemAllowsSpun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurface::systemAllowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the underlying coordinate system being used allows for spun normal surfaces. </p>
<p>This is a property of the coordinate system in which this surface is natively stored, <em>not</em> a property of the surface itself. For example, if this surface is compact but is stored using quad coordinates, then this routine will return <code>true</code>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun normal surface are supported in the underlying coordinate system. </dd></dl>

</div>
</div>
<a id="ga6318837e6c80c4648a7971e038db9d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6318837e6c80c4648a7971e038db9d6f">&#9670;&nbsp;</a></span>tetDiscs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp; regina::DiscSetSurface::tetDiscs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific set of discs living inside the given tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the given tetrahedron. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of discs inside the given tetrahedron. </dd></dl>

</div>
</div>
<a id="gaa25f8c4dad5d3efcfe3f01aeca20c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa25f8c4dad5d3efcfe3f01aeca20c8a8">&#9670;&nbsp;</a></span>triangles() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurface::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>A triangular disc type is identified by specifying a tetrahedron and a vertex of that tetrahedron that the triangle surrounds.</p>
<p>If you are using a coordinate system that adorns discs with additional information (such as orientation), this routine returns the <em>total</em> number of triangles in the given tetrahedron of the given type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

</div>
</div>
<a id="ga3ea2312f446f4f7b1c3066925d7f1e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ea2312f446f4f7b1c3066925d7f1e2c">&#9670;&nbsp;</a></span>triangles() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NormalSurfaceVector::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implemented in <a class="el" href="group__surfaces.html#ga60aac772b74582662acbf6da924e2769">regina::NSVectorStandard</a>, <a class="el" href="group__surfaces.html#gae58437850c881385ebd4c4f5cf4e2e6b">regina::NSVectorOriented</a>, <a class="el" href="group__surfaces.html#ga4904b81d01adbe8050c30feb4d0dcee9">regina::NSVectorMirrored</a>, and <a class="el" href="group__surfaces.html#gaa883a0ec32b3a0d2440fbc4e3f41e167">regina::NSVectorANStandard</a>.</p>

</div>
</div>
<a id="gaa883a0ec32b3a0d2440fbc4e3f41e167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa883a0ec32b3a0d2440fbc4e3f41e167">&#9670;&nbsp;</a></span>triangles() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorANStandard::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga3ea2312f446f4f7b1c3066925d7f1e2c">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga4904b81d01adbe8050c30feb4d0dcee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4904b81d01adbe8050c30feb4d0dcee9">&#9670;&nbsp;</a></span>triangles() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorMirrored::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga3ea2312f446f4f7b1c3066925d7f1e2c">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="gae58437850c881385ebd4c4f5cf4e2e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae58437850c881385ebd4c4f5cf4e2e6b">&#9670;&nbsp;</a></span>triangles() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorOriented::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga3ea2312f446f4f7b1c3066925d7f1e2c">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga60aac772b74582662acbf6da924e2769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60aac772b74582662acbf6da924e2769">&#9670;&nbsp;</a></span>triangles() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a> regina::NSVectorStandard::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implements <a class="el" href="group__surfaces.html#ga3ea2312f446f4f7b1c3066925d7f1e2c">regina::NormalSurfaceVector</a>.</p>

</div>
</div>
<a id="ga78737ee6d2d74ef5b7b5d9748a0daa10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78737ee6d2d74ef5b7b5d9748a0daa10">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; * regina::NormalSurface::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which this normal surface resides. </p>
<dl class="section return"><dt>Returns</dt><dd>the underlying triangulation. </dd></dl>

</div>
</div>
<a id="gaa808164e874f88896ac40703b6409c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa808164e874f88896ac40703b6409c36">&#9670;&nbsp;</a></span>triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurfaces::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which these normal surfaces live. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation in which these surfaces live. </dd></dl>

</div>
</div>
<a id="gab7c38e1ac8c4662a8adc084b86b54658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7c38e1ac8c4662a8adc084b86b54658">&#9670;&nbsp;</a></span>usesAnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::SurfaceFilterCombination::usesAnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this is an <em>and</em> or an <em>or</em> combination. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this is an <em>and</em> combination, or <code>false</code> if this is an <em>or</em> combination. </dd></dl>

</div>
</div>
<a id="gade510664f6841bdd0b58cd915c11973d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade510664f6841bdd0b58cd915c11973d">&#9670;&nbsp;</a></span>VectorIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::VectorIterator::VectorIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised iterator. </p>

</div>
</div>
<a id="ga22405b33052439f4ebabe8976bb09a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22405b33052439f4ebabe8976bb09a11">&#9670;&nbsp;</a></span>VectorIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::VectorIterator::VectorIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the iterator to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a12326b8c6dfebfefe97b34b15920c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a12326b8c6dfebfefe97b34b15920c7">&#9670;&nbsp;</a></span>which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> regina::NormalSurfaces::which </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of which normal surfaces this list represents within the underlying triangulation. </p>
<p>This may not be the same NormalList that was passed to <a class="el" href="group__surfaces.html#ga64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>. In particular, default values will have been explicitly filled in (such as NS_VERTEX and/or NS_EMBEDDED_ONLY), and invalid and/or redundant values will have been removed.</p>
<dl class="section return"><dt>Returns</dt><dd>details of what this list represents. </dd></dl>

</div>
</div>
<a id="ga564d43bd562cadba9bddbcd960d77596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga564d43bd562cadba9bddbcd960d77596">&#9670;&nbsp;</a></span>writeAllSurfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::writeAllSurfaces </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the number of surfaces in this set followed by the details of each surface to the given output stream. </p>
<p><a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> will be over many lines.</p>
<dl class="section user"><dt>Python</dt><dd>Parameter <em>out</em> is not present and is assumed to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7c634e7cf69ee372834d25107d8b1d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c634e7cf69ee372834d25107d8b1d69">&#9670;&nbsp;</a></span>writeRawVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeRawVector </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the underlying coordinate vector to the given output stream in text format. </p>
<p>No indication will be given as to which coordinate system is being used or what each coordinate means. No newline will be written.</p>
<dl class="section user"><dt>Python</dt><dd>The paramater <em>out</em> does not exist, and is taken to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad07dcdec28b20348705f8cec15838957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad07dcdec28b20348705f8cec15838957">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalSurfaces::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="ga151cff12a4c85a04fd8e5d7f617a90f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga151cff12a4c85a04fd8e5d7f617a90f0">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilterCombination::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="ga7c50e18076483d95864ad345650d2888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c50e18076483d95864ad345650d2888">&#9670;&nbsp;</a></span>writeTextLong() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SurfaceFilterProperties::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="ga81b1867108288341c2706866539106fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81b1867108288341c2706866539106fa">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes this surface to the given output stream, using standard triangle-quad-oct coordinates. </p>
<p>Octagonal coordinates will only be written if the surface is stored using a coordinate system that supports almost normal surfaces.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6801fb032b55c800bb82e89fce2bbe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6801fb032b55c800bb82e89fce2bbe71">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalSurfaces::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="gaf9ec7fe3b0c83880fc4d8bde58853cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9ec7fe3b0c83880fc4d8bde58853cae">&#9670;&nbsp;</a></span>writeTextShort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilter::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="gab649c72e89a76adcddbe5afb8ceae23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab649c72e89a76adcddbe5afb8ceae23b">&#9670;&nbsp;</a></span>writeXMLData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurface::writeXMLData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing this normal surface and all of its properties. </p>
<p>This routine will be called from within <a class="el" href="group__surfaces.html#gaa5539ec7f016ba2e9fca94f00971f4c3" title="Writes a chunk of XML containing the data for this packet only.">NormalSurfaces::writeXMLPacketData()</a>.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b6403f0651303e220eca2f291850011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b6403f0651303e220eca2f291850011">&#9670;&nbsp;</a></span>writeXMLFilterData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::SurfaceFilter::writeXMLFilterData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the details of this filter. </p>
<p>You may assume that the filter opening tag (including the filter type) has already been written, and that the filter closing tag will be written immediately after this routine is called. This routine need only write the additional details corresponding to this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="group__surfaces.html#ga1cfee88459afd4aee4a34feb3bf5c71b">regina::SurfaceFilterProperties</a>, and <a class="el" href="group__surfaces.html#gac520984f91f3dcb0f94149d3fe59c802">regina::SurfaceFilterCombination</a>.</p>

</div>
</div>
<a id="gac520984f91f3dcb0f94149d3fe59c802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac520984f91f3dcb0f94149d3fe59c802">&#9670;&nbsp;</a></span>writeXMLFilterData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SurfaceFilterCombination::writeXMLFilterData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the details of this filter. </p>
<p>You may assume that the filter opening tag (including the filter type) has already been written, and that the filter closing tag will be written immediately after this routine is called. This routine need only write the additional details corresponding to this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga3b6403f0651303e220eca2f291850011">regina::SurfaceFilter</a>.</p>

</div>
</div>
<a id="ga1cfee88459afd4aee4a34feb3bf5c71b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cfee88459afd4aee4a34feb3bf5c71b">&#9670;&nbsp;</a></span>writeXMLFilterData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SurfaceFilterProperties::writeXMLFilterData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the details of this filter. </p>
<p>You may assume that the filter opening tag (including the filter type) has already been written, and that the filter closing tag will be written immediately after this routine is called. This routine need only write the additional details corresponding to this particular subclass of <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__surfaces.html#ga3b6403f0651303e220eca2f291850011">regina::SurfaceFilter</a>.</p>

</div>
</div>
<a id="gaa5539ec7f016ba2e9fca94f00971f4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5539ec7f016ba2e9fca94f00971f4c3">&#9670;&nbsp;</a></span>writeXMLPacketData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalSurfaces::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="gae94055c65c176f663111268c8f8de9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae94055c65c176f663111268c8f8de9d4">&#9670;&nbsp;</a></span>writeXMLPacketData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::SurfaceFilter::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<a id="gaa5b05e56eefdcc42c0050b45ed7ff6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b05e56eefdcc42c0050b45ed7ff6a6">&#9670;&nbsp;</a></span>XMLFilterPacketReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLFilterPacketReader::XMLFilterPacketReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>newParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new surface filter packet reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the parent packet of the filter to be read, or 0 if this filter is to be tree matriarch. </td></tr>
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga251720a7663a27f1d22a72cf549fbed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga251720a7663a27f1d22a72cf549fbed2">&#9670;&nbsp;</a></span>XMLFilterReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLFilterReader::XMLFilterReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new filter element reader. </p>

</div>
</div>
<a id="ga36e9f40c6efcc5f41302129542b56c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36e9f40c6efcc5f41302129542b56c36">&#9670;&nbsp;</a></span>xmlFilterReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1XMLFilterReader.html">XMLFilterReader</a>* regina::SurfaceFilter::xmlFilterReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created XML filter reader that will read the details of a particular type of surface filter. </p>
<p>You may assume that the filter to be read is of the same type as the class in which you are implementing this routine.</p>
<p>The XML filter reader should read exactly what <a class="el" href="group__surfaces.html#ga3b6403f0651303e220eca2f291850011" title="Writes a chunk of XML containing the details of this filter.">writeXMLFilterData()</a> writes, and vice versa.</p>
<p><em>parent</em> represents the packet which will become the new filter's parent in the tree structure. This information is for reference only, and need not be used. See the description of parameter <em>parent</em> in <a class="el" href="group__packet.html#ga6f48a115e3ad5912a038c8d00900eae1" title="Returns a newly created XML element reader that will read the contents of a single XML packet element...">Packet::xmlReader()</a> for further details.</p>
<dl class="section user"><dt>Python</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the packet which will become the new filter's parent in the tree structure, or 0 if the new filter is to be tree matriarch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created XML filter reader. </dd></dl>

</div>
</div>
<a id="ga78c7ae61641d37abad5b3d756d9db9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c7ae61641d37abad5b3d756d9db9ac">&#9670;&nbsp;</a></span>XMLNormalSurfaceReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLNormalSurfaceReader::XMLNormalSurfaceReader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>newCoords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTri</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">newCoords</td><td>the coordinate system used by this normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83ea492ba3c9be45c04b927b8ac22adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ea492ba3c9be45c04b927b8ac22adf">&#9670;&nbsp;</a></span>XMLNormalSurfacesReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::XMLNormalSurfacesReader::XMLNormalSurfacesReader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>newTri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new normal surface list reader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTri</td><td>the triangulation in which these normal surfaces live. </td></tr>
    <tr><td class="paramname">resolver</td><td>the master resolver that will be used to fix dangling packet references after the entire XML file has been read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga124a63e9a57ffc4fff0fef553fa2862c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga124a63e9a57ffc4fff0fef553fa2862c">&#9670;&nbsp;</a></span>~DiscSetSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::DiscSetSurface::~DiscSetSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this set of discs and deallocates all associated memory. </p>

</div>
</div>
<a id="ga70df6a9c427d5d3647407cfbb46052c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70df6a9c427d5d3647407cfbb46052c7">&#9670;&nbsp;</a></span>~DiscSetTet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetTet::~DiscSetTet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this disc set. </p>

</div>
</div>
<a id="gadce3172b88a1b68738f19ea48c734932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce3172b88a1b68738f19ea48c734932">&#9670;&nbsp;</a></span>~DiscSetTetData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::~<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this disc set and deallocates all data arrays. </p>
<p>Note that no assumption is made about type <code>T</code>, so if data elements are pointers to dynamically allocated objects, these will not be destroyed. </p>

</div>
</div>
<a id="gaf2dc2b6c49ccae3b357fbfa8902800f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2dc2b6c49ccae3b357fbfa8902800f1">&#9670;&nbsp;</a></span>~NormalSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurface::~NormalSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this normal surface. </p>
<p>The underlying vector of coordinates will also be deallocated. </p>

</div>
</div>
<a id="ga275289f18f2ae608d8f2d573967f63bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga275289f18f2ae608d8f2d573967f63bb">&#9670;&nbsp;</a></span>~NormalSurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::~NormalSurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this list and all the surfaces within. </p>

</div>
</div>
<a id="gae178badf17e45e41a5da7eabf8005e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae178badf17e45e41a5da7eabf8005e22">&#9670;&nbsp;</a></span>~NormalSurfaceVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaceVector::~NormalSurfaceVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A virtual destructor. </p>
<p>This is required because here we introduce virtual functions into the <a class="el" href="classregina_1_1Ray.html" title="A fast class for storing a ray rooted at the origin that passes through an integer point.">Ray</a> hierarchy. </p>

</div>
</div>
<a id="ga5b1bb4b4fe448098099f7a51f50bc7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b1bb4b4fe448098099f7a51f50bc7ba">&#9670;&nbsp;</a></span>~NSVectorMirrored()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NSVectorMirrored::~NSVectorMirrored </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this vector and its mirror if appropriate. </p>

</div>
</div>
<a id="gaf6b3388688a07f0e5ec4778da8f2bafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b3388688a07f0e5ec4778da8f2bafb">&#9670;&nbsp;</a></span>~SurfaceFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::SurfaceFilter::~SurfaceFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this surface filter. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaa0e72355f8511a648f728fc452ba850a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0e72355f8511a648f728fc452ba850a">&#9670;&nbsp;</a></span>algorithm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> regina::NormalSurfaces::algorithm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the details of the enumeration algorithm that was used to generate this list. </p>
<p>This might not be the same as the <em>algorithmHints</em> flag passed to the corresponding enumeration routine (e.g., if invalid or inappropriate flags were passed). </p>

</div>
</div>
<a id="ga010b5302c8fdcb68d24f52d0f9ce85ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga010b5302c8fdcb68d24f52d0f9ce85ac">&#9670;&nbsp;</a></span>boundaries_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;size_t&gt; regina::NormalSurface::boundaries_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of disjoint boundary curves on this surface. </p>

</div>
</div>
<a id="ga4c2e3ed674b668351b758b1cf7f3a67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c2e3ed674b668351b758b1cf7f3a67b">&#9670;&nbsp;</a></span>compact</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::compact</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface compact (i.e. </p>
<p>does it only contain finitely many discs)? </p>

</div>
</div>
<a id="ga12fe97e906c4ee7b1522508769457844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12fe97e906c4ee7b1522508769457844">&#9670;&nbsp;</a></span>connected</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::connected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface connected? </p>

</div>
</div>
<a id="gaed283d890443594e39ba1ea13c81046d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed283d890443594e39ba1ea13c81046d">&#9670;&nbsp;</a></span>coords_ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Ray.html">Ray</a> regina::NormalSurfaceVector::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The raw vector of normal coordinates. </p>

</div>
</div>
<a id="ga317370303ab0e90b1367b33d57a92e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga317370303ab0e90b1367b33d57a92e83">&#9670;&nbsp;</a></span>coords_ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> regina::NormalSurfaces::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores which coordinate system is being used by the normal surfaces in this packet. </p>

</div>
</div>
<a id="gaf07af029fdcbe831f24700d44be47231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf07af029fdcbe831f24700d44be47231">&#9670;&nbsp;</a></span>current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> regina::DiscSpecIterator::current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The disc currently pointed to. </p>

</div>
</div>
<a id="gad0f57cc02ce279ec26f660c6afe1748a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0f57cc02ce279ec26f660c6afe1748a">&#9670;&nbsp;</a></span>discSets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a>** regina::DiscSetSurface::discSets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The disc sets corresponding to each tetrahedron. </p>

</div>
</div>
<a id="ga69e77846f2d6b4563c06048e496b1a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69e77846f2d6b4563c06048e496b1a5b">&#9670;&nbsp;</a></span>edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::PrismSpec::edge</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The edge of the tetrahedron that is contained in this prism. </p>

</div>
</div>
<a id="ga9556b33e656f0b26e2ba6d10d265045a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9556b33e656f0b26e2ba6d10d265045a">&#9670;&nbsp;</a></span>eulerChar_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="group__maths.html#ga18ea11d844018068d2cffa934fe8ba39">LargeInteger</a>&gt; regina::NormalSurface::eulerChar_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Euler characteristic of this surface. </p>

</div>
</div>
<a id="gaa6c465f0835e7dd73e18e653d8d01908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6c465f0835e7dd73e18e653d8d01908">&#9670;&nbsp;</a></span>filterTypeID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> regina::SurfaceFilter::filterTypeID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            <a class="code" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004">NS_FILTER_DEFAULT</a></div>
<div class="ttc" id="agroup__surfaces_html_gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004"><div class="ttname"><a href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004">regina::NS_FILTER_DEFAULT</a></div><div class="ttdeci">@ NS_FILTER_DEFAULT</div><div class="ttdoc">Represents the SurfaceFilter class: a do-nothing filter that accepts any normal surface.</div><div class="ttdef"><b>Definition:</b> surfacefiltertype.h:63</div></div>
</div><!-- fragment -->
<p>A compile-time constant that identifies this type of surface filter. </p>

</div>
</div>
<a id="gaca315fbe07e6aee27bf13647db6aa6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca315fbe07e6aee27bf13647db6aa6b6">&#9670;&nbsp;</a></span>internalData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">DataPtr</a> <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::internalData[10]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the data corresponding to each normal disc. </p>

</div>
</div>
<a id="ga343e081f5dee36db898b93f087de6b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343e081f5dee36db898b93f087de6b2e">&#9670;&nbsp;</a></span>internalDiscSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a>* regina::DiscSpecIterator::internalDiscSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The disc set through which we are iterating. </p>

</div>
</div>
<a id="gafbb5afac6d75ceab81eaaea50673d44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb5afac6d75ceab81eaaea50673d44a">&#9670;&nbsp;</a></span>internalNDiscs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetTet::internalNDiscs[10]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of discs of each type. </p>

</div>
</div>
<a id="ga5720a48a189a07227c44360dd73b1470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5720a48a189a07227c44360dd73b1470">&#9670;&nbsp;</a></span>list</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::SurfaceInserter::list</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The list into which surfaces will be inserted. </p>

</div>
</div>
<a id="ga78f559575a99f46ef3bf189016d2eee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f559575a99f46ef3bf189016d2eee0">&#9670;&nbsp;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NormalSurface::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An optional name associated with this surface. </p>

</div>
</div>
<a id="ga4aeb5de1a5c338b5917e1ec4c94bfe17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aeb5de1a5c338b5917e1ec4c94bfe17">&#9670;&nbsp;</a></span>NONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> regina::DiscType::NONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents a "null" disc type. </p>
<p>Here the <em>type</em> member is negative, to distinguish it from "meaningful" disc types in which <em>type</em> is always zero or positive. </p>

</div>
</div>
<a id="gaa6a135b6871de3392dd31f8da6eda4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6a135b6871de3392dd31f8da6eda4fb">&#9670;&nbsp;</a></span>number</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSpec::number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies which disc of the particular type in the particular tetrahedron is being referred to; discs are numbered as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </p>

</div>
</div>
<a id="gae3d5fc76b76881cf4851d177f1adb912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3d5fc76b76881cf4851d177f1adb912">&#9670;&nbsp;</a></span>octDiscArcs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::octDiscArcs[3][8]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>octDiscArcs[i]</code> lists the boundary arcs of the octagonal disc of type <em>i</em>. See <a class="el" href="group__surfaces.html#gabae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<p>Note that permutation <code>octDiscArcs[i][j]</code> will be even precisely when <code>j</code> is 0, 1, 4 or 5.</p>
<dl class="section user"><dt>C++</dt><dd>This array is replaced by a macro <code>octDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a id="ga33abf9e1043c41decc8730cc38685f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33abf9e1043c41decc8730cc38685f51">&#9670;&nbsp;</a></span>octPosition_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;<a class="el" href="structregina_1_1DiscType.html">DiscType</a>&gt; regina::NormalSurface::octPosition_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The position of the first non-zero octagonal coordinate, or <a class="el" href="group__surfaces.html#ga4aeb5de1a5c338b5917e1ec4c94bfe17" title="Represents a &quot;null&quot; disc type.">DiscType::NONE</a> if there is no non-zero octagonal coordinate. </p>
<p>Here <a class="el" href="group__surfaces.html#ga71893afaab0f7e789f19c4b566e95fd2" title="Identifies the disc type within the specified tetrahedron.">DiscType::type</a> is an octagon type between 0 and 2 inclusive. </p>

</div>
</div>
<a id="gabda9da8ad3e4daf0aac417ad63d08e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabda9da8ad3e4daf0aac417ad63d08e31">&#9670;&nbsp;</a></span>orientable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::orientable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface orientable? </p>

</div>
</div>
<a id="ga08b49fb05f98c3f222092ba3d2c2eb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08b49fb05f98c3f222092ba3d2c2eb84">&#9670;&nbsp;</a></span>owner</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurfaces::SurfaceInserter::owner</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The triangulation in which the surfaces to be inserted are contained. </p>

</div>
</div>
<a id="ga8920a1e646a768ea0eb9c40f904813fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8920a1e646a768ea0eb9c40f904813fd">&#9670;&nbsp;</a></span>quadDefn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadDefn[3][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists which vertices each quadrilateral type separates in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> splits the vertex pairs <code>quadDefn[i][0,1]</code> and <code>quadDefn[i][2,3]</code>.</p>
<p>It is guaranteed that:</p>
<ul>
<li><code>quadDefn[i][0] &lt; quadDefn[i][1]</code>;</li>
<li><code>quadDefn[i][2] &lt; quadDefn[i][3]</code>;</li>
<li><code>quadDefn[i][0] &lt; quadDefn[i][2]</code>.</li>
</ul>
<p>This array contains similar information to the function Edge&lt;3&gt;::ordering(). Instead of quadDefn[<em>i</em>][<em>j</em>], you can call Edge&lt;3&gt;::ordering(<em>i</em>)[<em>j</em>]; this will give the same results for <em>j</em> = 0 and 1, but it might switch the results for <em>j</em> = 2 and 3. </p>

</div>
</div>
<a id="ga315832a821efcad8d12ee4d0158a0bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga315832a821efcad8d12ee4d0158a0bbd">&#9670;&nbsp;</a></span>quadDiscArcs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::quadDiscArcs[3][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>quadDiscArcs[i]</code> lists the boundary arcs of the quadrilateral disc of type <em>i</em>. See <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<p>Note that permutation <code>quadDiscArcs[i][j]</code> will be even precisely when <code>j</code> is even.</p>
<dl class="section user"><dt>C++</dt><dd>This array is replaced by a macro <code>quadDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a id="ga07dd2a65f964363e8b619487011a4805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07dd2a65f964363e8b619487011a4805">&#9670;&nbsp;</a></span>quadMeeting</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadMeeting[4][4][2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists which quadrilateral types meet which edges in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p><code>quadMeeting[i][j][0,1]</code> are the numbers of the two quadrilateral types that meet the edge joining tetrahedron vertices <code>i</code> and <code>j</code>. </p>

</div>
</div>
<a id="gac06d9e3981cbce33198558cb05246502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac06d9e3981cbce33198558cb05246502">&#9670;&nbsp;</a></span>quadPartner</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadPartner[3][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> pairs vertex <code>v</code> with vertex <code>quadPartner[i][v]</code>. </p>

</div>
</div>
<a id="gac514ed78842ca859a43dcd7a973db246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac514ed78842ca859a43dcd7a973db246">&#9670;&nbsp;</a></span>quadSeparating</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadSeparating[4][4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists which quadrilateral types separate which pairs of vertices in a tetrahedron. </p>
<p>As outlined in <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a>, there are three quadrilateral types in a tetrahedron, numbered 0, 1 and 2. Each quadrilateral type separates the four tetrahedron vertices 0,1,2,3 into two pairs. <code>quadSeparating[i][j]</code> is the number of the quadrilateral type that keeps vertices <code>i</code> and <code>j</code> together.</p>
<p>It is guaranteed that quadrilateral type <em>i</em> will keep the vertices of edge <em>i</em> together (and will therefore also keep the vertices of edge <em>5-i</em> together). </p>

</div>
</div>
<a id="ga4061f33eff68ee48a6acc372a53676b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4061f33eff68ee48a6acc372a53676b1">&#9670;&nbsp;</a></span>quadString</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::quadString[3][6]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains strings that can be used to represent each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="group__surfaces.html#gac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>The string describing quadrilateral type <code>i</code> is <code>quadString[i]</code> and is of the form <code>02/13</code>, which in this case is the quadrilateral type that splits vertices 0,2 from vertices 1,3. </p>

</div>
</div>
<a id="gab1a6145fd6eb987cb0320a8b498d6c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1a6145fd6eb987cb0320a8b498d6c59">&#9670;&nbsp;</a></span>realBoundary</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::realBoundary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this surface have real boundary (i.e. </p>
<p>does it meet any boundary triangles)? </p>

</div>
</div>
<a id="ga30f9f73eb24a005ad31dc5d07e7f4c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30f9f73eb24a005ad31dc5d07e7f4c93">&#9670;&nbsp;</a></span>surfaces</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>*&gt; regina::NormalSurfaces::surfaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the normal surfaces stored in this packet. </p>

</div>
</div>
<a id="gac5261f157c24a778410b72973a29d8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5261f157c24a778410b72973a29d8f4">&#9670;&nbsp;</a></span>tetIndex <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::DiscSpec::tetIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index in the triangulation of the tetrahedron containing the disc. </p>

</div>
</div>
<a id="gaa8f4058af6ddb05f5c866741f2631a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f4058af6ddb05f5c866741f2631a37">&#9670;&nbsp;</a></span>tetIndex <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::DiscType::tetIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index within the triangulation of the tetrahedron containing this disc type. </p>
<p>This must be between 0 and <a class="el" href="group__detail.html#ga3871caa1f02ccda957f22ebd9a646ff5" title="Returns the number of top-dimensional simplices in the triangulation.">Triangulation&lt;3&gt;::size()</a>-1 inclusive. </p>

</div>
</div>
<a id="gaf119f5649806dbb536addfc01ad9051e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf119f5649806dbb536addfc01ad9051e">&#9670;&nbsp;</a></span>tetIndex <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::PrismSpec::tetIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index in the triangulation of the tetrahedron containing the prism. </p>

</div>
</div>
<a id="ga2a22ab75ad4c87286476a25ca1c8e5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a22ab75ad4c87286476a25ca1c8e5a7">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::DiscSetSurface::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which the normal surface lives. </p>

</div>
</div>
<a id="ga2bb9ec018706c2e5b2d12d6a1d5a0c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb9ec018706c2e5b2d12d6a1d5a0c63">&#9670;&nbsp;</a></span>triangulation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurface::triangulation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which this normal surface resides. </p>

</div>
</div>
<a id="ga1ed7e2568c2e6085550dec8b1ff5eeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed7e2568c2e6085550dec8b1ff5eeb1">&#9670;&nbsp;</a></span>triDiscArcs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::triDiscArcs[4][3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>triDiscArcs[i]</code> lists the boundary arcs of the triangular disc of type <em>i</em>. See <a class="el" href="group__surfaces.html#gaa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<p>Note that every permutation in this array is even.</p>
<dl class="section user"><dt>C++</dt><dd>This array is replaced by a macro <code>triDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a id="ga6fc009a0545d1feba9ecb90777e8aa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc009a0545d1feba9ecb90777e8aa37">&#9670;&nbsp;</a></span>twoSided</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Property.html">Property</a>&lt;bool&gt; regina::NormalSurface::twoSided</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is this surface two-sided? </p>

</div>
</div>
<a id="ga65724d286ef5ccb7750731c6661d3ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65724d286ef5ccb7750731c6661d3ed8">&#9670;&nbsp;</a></span>type <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::DiscSpec::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The disc type; this is between 0 and 9 inclusive, as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </p>

</div>
</div>
<a id="ga71893afaab0f7e789f19c4b566e95fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71893afaab0f7e789f19c4b566e95fd2">&#9670;&nbsp;</a></span>type <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::DiscType::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies the disc type within the specified tetrahedron. </p>
<p>The precise meaning of this member is left up to the user, though it must be non-negative for "meaningful" disc types. See the <a class="el" href="structregina_1_1DiscType.html" title="Identifies a single normal or almost normal disc type within a triangulation.">DiscType</a> class notes for details. </p>

</div>
</div>
<a id="ga898d6149eef5330881b0318305a0f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga898d6149eef5330881b0318305a0f910">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::NormalSurface::vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the coordinates of the normal surface in whichever space is appropriate. </p>

</div>
</div>
<a id="ga6ffe4301bf296b37ea8253f242167660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ffe4301bf296b37ea8253f242167660">&#9670;&nbsp;</a></span>which_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> regina::NormalSurfaces::which_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which normal surfaces these represent within the underlying triangulation. </p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="ga7dafddbd2002f15da2be17a09289f05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dafddbd2002f15da2be17a09289f05e">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given disc specifier to the given output stream. </p>
<p>The disc specifier will be written as a triple <code>(tetIndex, type, number)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the disc specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="gaf368816cac7120fc7e63a5601ac98496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf368816cac7120fc7e63a5601ac98496">&#9670;&nbsp;</a></span>operator&lt;&lt; <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given prism specifier to the given output stream. </p>
<p>The prism specifier will be written as a pair <code>(tetIndex, edge)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the prism specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2021, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
