<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: Normal Surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Normal Surfaces</div>  </div>
</div><!--header-->
<div class="contents">

<p>Normal surfaces in 3-manifold triangulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NDiscSpec.html">regina::NDiscSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single normal disc in a normal surface.  <a href="structregina_1_1NDiscSpec.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NDiscSetTet.html">regina::NDiscSetTet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of normal discs inside a single tetrahedron.  <a href="classregina_1_1NDiscSetTet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NDiscSetTetData.html">regina::NDiscSetTetData&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data of type <code>T</code> for every normal disc inside a single tetrahedron.  <a href="classregina_1_1NDiscSetTetData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NDiscSetSurface.html">regina::NDiscSetSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the set of all normal discs forming a normal surface.  <a href="classregina_1_1NDiscSetSurface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NDiscSetSurfaceData.html">regina::NDiscSetSurfaceData&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data of type <code>T</code> for every normal disc within a particular normal surface.  <a href="classregina_1_1NDiscSetSurfaceData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NDiscSpecIterator.html">regina::NDiscSpecIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator used for running through all normal discs in a normal surface.  <a href="classregina_1_1NDiscSpecIterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NDiscType.html">regina::NDiscType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a single normal or almost normal disc type within a triangulation.  <a href="structregina_1_1NDiscType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Triangulation.html">regina::Triangulation&lt; int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>dim</em>-dimensional triangulation, built by gluing together <em>dim</em>-dimensional simplices along their (<em>dim</em>-1)-dimensional facets.  <a href="classregina_1_1Triangulation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face.html">regina::Face&lt; int, int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a <em>subdim</em>-face in the skeleton of a <em>dim</em>-dimensional triangulation.  <a href="classregina_1_1Face.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NormalInfo.html">regina::NormalInfo&lt; coordType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular normal coordinate system.  <a href="structregina_1_1NormalInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html">regina::NNormalSurfaceVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the vector of a single normal surface in a 3-manifold.  <a href="classregina_1_1NNormalSurfaceVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurface.html">regina::NNormalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single normal surface in a 3-manifold.  <a href="classregina_1_1NNormalSurface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceList.html">regina::NNormalSurfaceList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a collection of normal surfaces in a 3-manifold.  <a href="classregina_1_1NNormalSurfaceList.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NPrismSpec.html">regina::NPrismSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single triangular prism in a tetrahedron.  <a href="structregina_1_1NPrismSpec.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPrismSetSurface.html">regina::NPrismSetSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the set of prisms defined by slicing along all the quads in a particular normal surface.  <a href="classregina_1_1NPrismSetSurface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html">regina::NNormalSurfaceVectorANStandard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An almost normal surface vector using standard triangle-quad-oct coordinates.  <a href="classregina_1_1NNormalSurfaceVectorANStandard.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorMirrored.html">regina::NNormalSurfaceVectorMirrored</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calculations.  <a href="classregina_1_1NNormalSurfaceVectorMirrored.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorOriented.html">regina::NNormalSurfaceVectorOriented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using transversely oriented standard (triangle-quad) coordinates.  <a href="classregina_1_1NNormalSurfaceVectorOriented.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorOrientedQuad.html">regina::NNormalSurfaceVectorOrientedQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using transversely oriented quadrilateral coordinates.  <a href="classregina_1_1NNormalSurfaceVectorOrientedQuad.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorQuad.html">regina::NNormalSurfaceVectorQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using quad coordinates.  <a href="classregina_1_1NNormalSurfaceVectorQuad.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorQuadOct.html">regina::NNormalSurfaceVectorQuadOct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An almost normal surface vector using quad-oct coordinates.  <a href="classregina_1_1NNormalSurfaceVectorQuadOct.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorStandard.html">regina::NNormalSurfaceVectorStandard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using standard triangle-quad coordinates.  <a href="classregina_1_1NNormalSurfaceVectorStandard.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SurfaceFilterInfo.html">regina::SurfaceFilterInfo&lt; filterType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular type of normal surface filter.  <a href="structregina_1_1SurfaceFilterInfo.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSurfaceFilter.html">regina::NSurfaceFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that accepts or rejects normal surfaces.  <a href="classregina_1_1NSurfaceFilter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSurfaceSubset.html">regina::NSurfaceSubset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a subset of a normal surface list.  <a href="classregina_1_1NSurfaceSubset.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLFilterReader.html">regina::NXMLFilterReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads the specific details of a normal surface filter.  <a href="classregina_1_1NXMLFilterReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLFilterPacketReader.html">regina::NXMLFilterPacketReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single surface filter.  <a href="classregina_1_1NXMLFilterPacketReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLNormalSurfaceReader.html">regina::NXMLNormalSurfaceReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads a single normal surface.  <a href="classregina_1_1NXMLNormalSurfaceReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NXMLNormalSurfaceListReader.html">regina::NXMLNormalSurfaceListReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single normal surface list.  <a href="classregina_1_1NXMLNormalSurfaceListReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSurfaceFilterCombination.html">regina::NSurfaceFilterCombination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that simply combines other filters.  <a href="classregina_1_1NSurfaceFilterCombination.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSurfaceFilterProperties.html">regina::NSurfaceFilterProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that filters by basic properties of the normal surface.  <a href="classregina_1_1NSurfaceFilterProperties.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga52e13b3da02391f7dedf35e9d63201b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga52e13b3da02391f7dedf35e9d63201b3">REGINA_NORMAL_SURFACE_FLAVOUR</a>(class_, id)</td></tr>
<tr class="memdesc:ga52e13b3da02391f7dedf35e9d63201b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a subclass of NNormalSurfaceVector.  <a href="#ga52e13b3da02391f7dedf35e9d63201b3">More...</a><br/></td></tr>
<tr class="separator:ga52e13b3da02391f7dedf35e9d63201b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga665eac8de6a24d68bddbfa631bcca6c9">REGINA_SURFACE_FILTER</a>(class_, id)</td></tr>
<tr class="memdesc:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a descendant class of NSurfaceFilter.  <a href="#ga665eac8de6a24d68bddbfa631bcca6c9">More...</a><br/></td></tr>
<tr class="separator:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5cde59c8a2b5beab8cb68fb38cb84499"><td class="memItemLeft" align="right" valign="top">typedef Face&lt; 3, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5cde59c8a2b5beab8cb68fb38cb84499">regina::NVertex</a></td></tr>
<tr class="memdesc:ga5cde59c8a2b5beab8cb68fb38cb84499"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef for <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html" title="Represents a vertex in the skeleton of a 3-manifold triangulation.">Face&lt;3, 0&gt;</a>.  <a href="#ga5cde59c8a2b5beab8cb68fb38cb84499">More...</a><br/></td></tr>
<tr class="separator:ga5cde59c8a2b5beab8cb68fb38cb84499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4481302c5412c4d0ec9abfef1943650"><td class="memItemLeft" align="right" valign="top">typedef Face&lt; 3, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf4481302c5412c4d0ec9abfef1943650">regina::NEdge</a></td></tr>
<tr class="memdesc:gaf4481302c5412c4d0ec9abfef1943650"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience typedef for <a class="el" href="classregina_1_1Face_3_013_00_011_01_4.html" title="Represents an edge in the skeleton of a 3-manifold triangulation.">Face&lt;3, 1&gt;</a>.  <a href="#gaf4481302c5412c4d0ec9abfef1943650">More...</a><br/></td></tr>
<tr class="separator:gaf4481302c5412c4d0ec9abfef1943650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a><br class="typebreak"/>
&lt; NormalListFlags &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">regina::NormalList</a></td></tr>
<tr class="memdesc:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal surface lists.  <a href="#ga10adc2dfa823f4b97db64abccdc7f73d">More...</a><br/></td></tr>
<tr class="separator:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239df7c1e704457d116029fc144dc473"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a><br class="typebreak"/>
&lt; NormalAlgFlags &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">regina::NormalAlg</a></td></tr>
<tr class="memdesc:ga239df7c1e704457d116029fc144dc473"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal surface lists.  <a href="#ga239df7c1e704457d116029fc144dc473">More...</a><br/></td></tr>
<tr class="separator:ga239df7c1e704457d116029fc144dc473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae923c7c2fa692192d45bdf563f380918"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">regina::SurfaceExportFields</a> { <br/>
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a81408d5dd0f9deb210bf66ecee761c36">regina::surfaceExportName</a> = 0x0001, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a131a23295ec061f83590561bba365de8">regina::surfaceExportEuler</a> = 0x0002, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a153a815a9b0f7d3b3383f39c2d6f94ca">regina::surfaceExportOrient</a> = 0x0004, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a60a48a7481d07261cf4a4051cffc3bc3">regina::surfaceExportSides</a> = 0x0008, 
<br/>
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918add63709fcbf9038110d4a3b232a466c2">regina::surfaceExportBdry</a> = 0x0010, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a0832d74579319961e0c6f976e28b0356">regina::surfaceExportLink</a> = 0x0020, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918acf49b97bd782901a7f6ee32bf9841b03">regina::surfaceExportType</a> = 0x0040, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a9b7d4c6f39579e1711b203dcf8ed3824">regina::surfaceExportNone</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a90da6f93fd64f642efa8b5862d7b4dac">regina::surfaceExportAllButName</a> = 0x007e, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a> = 0x007f
<br/>
 }</td></tr>
<tr class="memdesc:gae923c7c2fa692192d45bdf563f380918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.  <a href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">More...</a><br/></td></tr>
<tr class="separator:gae923c7c2fa692192d45bdf563f380918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a> { <br/>
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a36273f97819ff462b10db091f8a93f75">regina::NS_STANDARD</a> = 0, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47af3d1b2ccecff610fdaae1e4f3dde0744">regina::NS_QUAD</a> = 1, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47ad2d9d61fc90b31363ec5931b1a300aa8">regina::NS_AN_LEGACY</a> = 100, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a4a7e1fc6780905418e84cadf782dd82f">regina::NS_AN_QUAD_OCT</a> = 101, 
<br/>
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a0de57480ceb39c23829e982e5bef7d84">regina::NS_AN_STANDARD</a> = 102, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae">regina::NS_EDGE_WEIGHT</a> = 200, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47ae8c39b9dd91ad81bf89ca633c8d9598f">regina::NS_TRIANGLE_ARCS</a> = 201, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a426f8d72390eb0220effee259c2dc483">regina::REGINA_DEPRECATED_ENUM</a> = 201, 
<br/>
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a602873a7f7351b3822c37b075ba88c43">regina::NS_ORIENTED</a> = 300, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a205b46c71691c8092a5afa1d99ab556a">regina::NS_ORIENTED_QUAD</a> = 301, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a9f471af2d202b88f06ed65be82e5d7eb">regina::NS_ANGLE</a> = 400
<br/>
 }</td></tr>
<tr class="memdesc:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different coordinate systems that can be used for enumerating and displaying normal surfaces.  <a href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">More...</a><br/></td></tr>
<tr class="separator:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff25e58607c49cca84049a1069c2cce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">regina::NormalListFlags</a> { <br/>
&#160;&#160;<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">regina::NS_LIST_DEFAULT</a> = 0x0000, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea41f7f2158c91f3f64f3354118f6a8761">regina::NS_EMBEDDED_ONLY</a> = 0x0001, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea1e0c5bf3f4138d8ec4a88caeb5f87a61">regina::NS_IMMERSED_SINGULAR</a> = 0x0002, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea38cd0d13c8afd0f688eda457d5ed550d">regina::NS_VERTEX</a> = 0x0004, 
<br/>
&#160;&#160;<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea949286ba72f0deec9b6bbe2b8a23b39c">regina::NS_FUNDAMENTAL</a> = 0x0008, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2cceaab119737dcff1409ff0f2071baee7e40">regina::NS_LEGACY</a> = 0x4000, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea64cbdf1921e4a99c5943b4039dac2709">regina::NS_CUSTOM</a> = 0x8000
<br/>
 }</td></tr>
<tr class="memdesc:gabff25e58607c49cca84049a1069c2cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation.  <a href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">More...</a><br/></td></tr>
<tr class="separator:gabff25e58607c49cca84049a1069c2cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">regina::NormalAlgFlags</a> { <br/>
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">regina::NS_ALG_DEFAULT</a> = 0x0000, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea4c4bfbfefa31e5c048a0d9e25abf9f89">regina::NS_VERTEX_VIA_REDUCED</a> = 0x0001, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea15bc7c42b8b986d93863600852d271c7">regina::NS_VERTEX_STD_DIRECT</a> = 0x0002, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea482b7e69b14c44d02b29055726b04830">regina::NS_VERTEX_TREE</a> = 0x0010, 
<br/>
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeac988e037d6c164c645567750680c6e11">regina::NS_VERTEX_DD</a> = 0x0020, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea33ff9b1fafe5bc6aa4dbf851ec2b9ae6">regina::NS_HILBERT_PRIMAL</a> = 0x0100, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea77887211e55db67ba4ba10247cd159f3">regina::NS_HILBERT_DUAL</a> = 0x0200, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea1da3bc474ed341903ab0f043488e27c3">regina::NS_HILBERT_CD</a> = 0x0400, 
<br/>
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea7d84f194dd4d881f2175acae85fa3742">regina::NS_HILBERT_FULLCONE</a> = 0x0800, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea61e5c6c91ab2a0c4ac8a6fca9cccd430">regina::NS_ALG_LEGACY</a> = 0x4000, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea6d1833185860331a3be3d7f909b1323a">regina::NS_ALG_CUSTOM</a> = 0x8000
<br/>
 }</td></tr>
<tr class="memdesc:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations.  <a href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">More...</a><br/></td></tr>
<tr class="separator:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ab803471723156fb2ecb24b7b1c859"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a> { <a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004">regina::NS_FILTER_DEFAULT</a> = 0, 
<a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859abad02c85eeeda839925c60cd245fb478">regina::NS_FILTER_PROPERTIES</a> = 1, 
<a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a53350ed09529a46c5ed4298a14d9c6a2">regina::NS_FILTER_COMBINATION</a> = 2
 }</td></tr>
<tr class="memdesc:ga38ab803471723156fb2ecb24b7b1c859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations.  <a href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">More...</a><br/></td></tr>
<tr class="separator:ga38ab803471723156fb2ecb24b7b1c859"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa835bb40bfcf36e0541809044f35ea5e"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gaa835bb40bfcf36e0541809044f35ea5e"><td class="memTemplItemLeft" align="right" valign="top">ReturnsTraits&lt; FunctionObject &gt;<br class="typebreak"/>
::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa835bb40bfcf36e0541809044f35ea5e">regina::forCoords</a> (NormalCoords coords, FunctionObject &amp;&amp;func, typename ReturnsTraits&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaa835bb40bfcf36e0541809044f35ea5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime.  <a href="#gaa835bb40bfcf36e0541809044f35ea5e">More...</a><br/></td></tr>
<tr class="separator:gaa835bb40bfcf36e0541809044f35ea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8922018a2db9ec5f9c7b2e09e77216f"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gac8922018a2db9ec5f9c7b2e09e77216f"><td class="memTemplItemLeft" align="right" valign="top">ReturnsTraits&lt; FunctionObject &gt;<br class="typebreak"/>
::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac8922018a2db9ec5f9c7b2e09e77216f">regina::forCoords</a> (NormalCoords coords, FunctionObject &amp;&amp;func, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gac8922018a2db9ec5f9c7b2e09e77216f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime.  <a href="#gac8922018a2db9ec5f9c7b2e09e77216f">More...</a><br/></td></tr>
<tr class="separator:gac8922018a2db9ec5f9c7b2e09e77216f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga683a7a8a9ff4870797ed8d1cbbb15e35"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject &gt; </td></tr>
<tr class="memitem:ga683a7a8a9ff4870797ed8d1cbbb15e35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <br class="typebreak"/>
FunctionObject::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga683a7a8a9ff4870797ed8d1cbbb15e35">regina::forFlavour</a> (NormalCoords coords, FunctionObject func, typename FunctionObject::ReturnType defaultReturn)</td></tr>
<tr class="memdesc:ga683a7a8a9ff4870797ed8d1cbbb15e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for the registry-based template function <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a>.  <a href="#ga683a7a8a9ff4870797ed8d1cbbb15e35">More...</a><br/></td></tr>
<tr class="separator:ga683a7a8a9ff4870797ed8d1cbbb15e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf00631b75df786b87c4e8b755512230c"><td class="memTemplParams" colspan="2">template&lt;typename VoidFunctionObject &gt; </td></tr>
<tr class="memitem:gaf00631b75df786b87c4e8b755512230c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf00631b75df786b87c4e8b755512230c">regina::forFlavour</a> (NormalCoords coords, VoidFunctionObject func)</td></tr>
<tr class="memdesc:gaf00631b75df786b87c4e8b755512230c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for the registry-based template function <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a>.  <a href="#gaf00631b75df786b87c4e8b755512230c">More...</a><br/></td></tr>
<tr class="separator:gaf00631b75df786b87c4e8b755512230c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07288bf625eb5d9b8d0be1fb730f8a01"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga07288bf625eb5d9b8d0be1fb730f8a01"><td class="memTemplItemLeft" align="right" valign="top">ReturnsTraits&lt; FunctionObject &gt;<br class="typebreak"/>
::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga07288bf625eb5d9b8d0be1fb730f8a01">regina::forFilter</a> (SurfaceFilterType filter, FunctionObject &amp;&amp;func, typename ReturnsTraits&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga07288bf625eb5d9b8d0be1fb730f8a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime.  <a href="#ga07288bf625eb5d9b8d0be1fb730f8a01">More...</a><br/></td></tr>
<tr class="separator:ga07288bf625eb5d9b8d0be1fb730f8a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f1771e5f2090d65618c705c6c0f8b4"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gae6f1771e5f2090d65618c705c6c0f8b4"><td class="memTemplItemLeft" align="right" valign="top">ReturnsTraits&lt; FunctionObject &gt;<br class="typebreak"/>
::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae6f1771e5f2090d65618c705c6c0f8b4">regina::forFilter</a> (SurfaceFilterType filter, FunctionObject &amp;&amp;func, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gae6f1771e5f2090d65618c705c6c0f8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime.  <a href="#gae6f1771e5f2090d65618c705c6c0f8b4">More...</a><br/></td></tr>
<tr class="separator:gae6f1771e5f2090d65618c705c6c0f8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga876e554eb4fda7ead0f73db0324841d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga876e554eb4fda7ead0f73db0324841d7">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NDiscSpec &amp;spec)</td></tr>
<tr class="memdesc:ga876e554eb4fda7ead0f73db0324841d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc specifier to the given output stream.  <a href="#ga876e554eb4fda7ead0f73db0324841d7">More...</a><br/></td></tr>
<tr class="separator:ga876e554eb4fda7ead0f73db0324841d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691d08a8f65b1322e0846cf55b319461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga691d08a8f65b1322e0846cf55b319461">regina::numberDiscsAwayFromVertex</a> (int discType, int vertex)</td></tr>
<tr class="memdesc:ga691d08a8f65b1322e0846cf55b319461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not normal discs of the given type are numbered away from the given vertex.  <a href="#ga691d08a8f65b1322e0846cf55b319461">More...</a><br/></td></tr>
<tr class="separator:ga691d08a8f65b1322e0846cf55b319461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0355cb839a1c4401eb06ea08d175047d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga0355cb839a1c4401eb06ea08d175047d">regina::discOrientationFollowsEdge</a> (int discType, int vertex, int edgeStart, int edgeEnd)</td></tr>
<tr class="memdesc:ga0355cb839a1c4401eb06ea08d175047d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc.  <a href="#ga0355cb839a1c4401eb06ea08d175047d">More...</a><br/></td></tr>
<tr class="separator:ga0355cb839a1c4401eb06ea08d175047d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78991ddbd00ab2ed9fd8773ae60e59ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga78991ddbd00ab2ed9fd8773ae60e59ad">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NDiscType &amp;type)</td></tr>
<tr class="memdesc:ga78991ddbd00ab2ed9fd8773ae60e59ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc type to the given output stream.  <a href="#ga78991ddbd00ab2ed9fd8773ae60e59ad">More...</a><br/></td></tr>
<tr class="separator:ga78991ddbd00ab2ed9fd8773ae60e59ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fdd39f2276a1b073e1a30037faca272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NNormalSurfaceVector *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7fdd39f2276a1b073e1a30037faca272">regina::makeZeroVector</a> (const NTriangulation *triangulation, NormalCoords coords)</td></tr>
<tr class="memdesc:ga7fdd39f2276a1b073e1a30037faca272"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and the given coordinate system.  <a href="#ga7fdd39f2276a1b073e1a30037faca272">More...</a><br/></td></tr>
<tr class="separator:ga7fdd39f2276a1b073e1a30037faca272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeea16b80f40ad799901739937d94e86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NMatrixInt *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaeea16b80f40ad799901739937d94e86b">regina::makeMatchingEquations</a> (const NTriangulation *triangulation, NormalCoords coords)</td></tr>
<tr class="memdesc:gaeea16b80f40ad799901739937d94e86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal surface matching equations for the given triangulation using the given coordinate system.  <a href="#gaeea16b80f40ad799901739937d94e86b">More...</a><br/></td></tr>
<tr class="separator:gaeea16b80f40ad799901739937d94e86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac280f5dbf734d58f7c14d7344a991c80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NEnumConstraintList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac280f5dbf734d58f7c14d7344a991c80">regina::makeEmbeddedConstraints</a> (const NTriangulation *triangulation, NormalCoords coords)</td></tr>
<tr class="memdesc:gac280f5dbf734d58f7c14d7344a991c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal surfaces be embedded.  <a href="#gac280f5dbf734d58f7c14d7344a991c80">More...</a><br/></td></tr>
<tr class="separator:gac280f5dbf734d58f7c14d7344a991c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92f3f038eac514d3e599ff3d92d8485"><td class="memItemLeft" align="right" valign="top">NormalList&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae92f3f038eac514d3e599ff3d92d8485">regina::operator|</a> (NormalListFlags lhs, NormalListFlags rhs)</td></tr>
<tr class="memdesc:gae92f3f038eac514d3e599ff3d92d8485"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="#gae92f3f038eac514d3e599ff3d92d8485">More...</a><br/></td></tr>
<tr class="separator:gae92f3f038eac514d3e599ff3d92d8485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="memItemLeft" align="right" valign="top">NormalAlg&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4428e0ba8bfcc8083b37e9e3e2220c96">regina::operator|</a> (NormalAlgFlags lhs, NormalAlgFlags rhs)</td></tr>
<tr class="memdesc:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="#ga4428e0ba8bfcc8083b37e9e3e2220c96">More...</a><br/></td></tr>
<tr class="separator:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938ab6c0418b2eb992b136796af68d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga938ab6c0418b2eb992b136796af68d0c">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const NPrismSpec &amp;spec)</td></tr>
<tr class="memdesc:ga938ab6c0418b2eb992b136796af68d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given prism specifier to the given output stream.  <a href="#ga938ab6c0418b2eb992b136796af68d0c">More...</a><br/></td></tr>
<tr class="separator:ga938ab6c0418b2eb992b136796af68d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaec9d18f213d2d3fab0c4b39506080670"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> typedef <br class="typebreak"/>
NewFunction1<br class="typebreak"/>
&lt; NNormalSurfaceVector, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaec9d18f213d2d3fab0c4b39506080670">regina::NewNormalSurfaceVector</a></td></tr>
<tr class="memdesc:gaec9d18f213d2d3fab0c4b39506080670"><td class="mdescLeft">&#160;</td><td class="mdescRight">A legacy typedef provided for backward compatibility only.  <a href="#gaec9d18f213d2d3fab0c4b39506080670">More...</a><br/></td></tr>
<tr class="separator:gaec9d18f213d2d3fab0c4b39506080670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b578aec3d1a608e11d90c9b33d9113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113">regina::quadSeparating</a> [4][4]</td></tr>
<tr class="memdesc:gad7b578aec3d1a608e11d90c9b33d9113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.  <a href="#gad7b578aec3d1a608e11d90c9b33d9113">More...</a><br/></td></tr>
<tr class="separator:gad7b578aec3d1a608e11d90c9b33d9113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b746a3a6579824b6b5f75701d6bc385"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> <br class="typebreak"/>
const int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9b746a3a6579824b6b5f75701d6bc385">regina::vertexSplit</a> )[4]</td></tr>
<tr class="memdesc:ga9b746a3a6579824b6b5f75701d6bc385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a>.  <a href="#ga9b746a3a6579824b6b5f75701d6bc385">More...</a><br/></td></tr>
<tr class="separator:ga9b746a3a6579824b6b5f75701d6bc385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3079fddda965e048d4a3c033751b8ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gab3079fddda965e048d4a3c033751b8ca">regina::quadMeeting</a> [4][4][2]</td></tr>
<tr class="memdesc:gab3079fddda965e048d4a3c033751b8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types meet which edges in a tetrahedron.  <a href="#gab3079fddda965e048d4a3c033751b8ca">More...</a><br/></td></tr>
<tr class="separator:gab3079fddda965e048d4a3c033751b8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a84af39ca5120e7de5751a1944717c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> <br class="typebreak"/>
const int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga09a84af39ca5120e7de5751a1944717c">regina::vertexSplitMeeting</a> )[4][2]</td></tr>
<tr class="memdesc:ga09a84af39ca5120e7de5751a1944717c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for <a class="el" href="group__surfaces.html#gab3079fddda965e048d4a3c033751b8ca" title="Lists which quadrilateral types meet which edges in a tetrahedron.">regina::quadMeeting</a>.  <a href="#ga09a84af39ca5120e7de5751a1944717c">More...</a><br/></td></tr>
<tr class="separator:ga09a84af39ca5120e7de5751a1944717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ae12937602edaa05b6ba010dd8a18d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> <br class="typebreak"/>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga05ae12937602edaa05b6ba010dd8a18d">regina::vertexSplitDefn</a> [3][4]</td></tr>
<tr class="memdesc:ga05ae12937602edaa05b6ba010dd8a18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated array that lists the vertices which each quadrilateral type separates within a tetrahedron.  <a href="#ga05ae12937602edaa05b6ba010dd8a18d">More...</a><br/></td></tr>
<tr class="separator:ga05ae12937602edaa05b6ba010dd8a18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a16e2bec83bf891238ad350e4630d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7a16e2bec83bf891238ad350e4630d77">regina::quadPartner</a> [3][4]</td></tr>
<tr class="memdesc:ga7a16e2bec83bf891238ad350e4630d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron.  <a href="#ga7a16e2bec83bf891238ad350e4630d77">More...</a><br/></td></tr>
<tr class="separator:ga7a16e2bec83bf891238ad350e4630d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga594f0f7cce4bb4c023ad5129f9266869"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> <br class="typebreak"/>
const int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga594f0f7cce4bb4c023ad5129f9266869">regina::vertexSplitPartner</a> )[4]</td></tr>
<tr class="memdesc:ga594f0f7cce4bb4c023ad5129f9266869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for <a class="el" href="group__surfaces.html#ga7a16e2bec83bf891238ad350e4630d77" title="Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedr...">regina::quadPartner</a>.  <a href="#ga594f0f7cce4bb4c023ad5129f9266869">More...</a><br/></td></tr>
<tr class="separator:ga594f0f7cce4bb4c023ad5129f9266869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e0cdd2884ac43d3e7ddff9e6947b566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1e0cdd2884ac43d3e7ddff9e6947b566">regina::quadString</a> [3][6]</td></tr>
<tr class="memdesc:ga1e0cdd2884ac43d3e7ddff9e6947b566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains strings that can be used to represent each quadrilateral type in a tetrahedron.  <a href="#ga1e0cdd2884ac43d3e7ddff9e6947b566">More...</a><br/></td></tr>
<tr class="separator:ga1e0cdd2884ac43d3e7ddff9e6947b566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e751dda815ce837f3bf21965217538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> <br class="typebreak"/>
const char(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac7e751dda815ce837f3bf21965217538">regina::vertexSplitString</a> )[6]</td></tr>
<tr class="memdesc:gac7e751dda815ce837f3bf21965217538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated alias for <a class="el" href="group__surfaces.html#ga1e0cdd2884ac43d3e7ddff9e6947b566" title="Contains strings that can be used to represent each quadrilateral type in a tetrahedron.">regina::quadString</a>.  <a href="#gac7e751dda815ce837f3bf21965217538">More...</a><br/></td></tr>
<tr class="separator:gac7e751dda815ce837f3bf21965217538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e15cb120c3a2568d49b0381edfa3c8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const NPerm4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3e15cb120c3a2568d49b0381edfa3c8c">regina::triDiscArcs</a> [4][3]</td></tr>
<tr class="memdesc:ga3e15cb120c3a2568d49b0381edfa3c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc.  <a href="#ga3e15cb120c3a2568d49b0381edfa3c8c">More...</a><br/></td></tr>
<tr class="separator:ga3e15cb120c3a2568d49b0381edfa3c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851602918fbf6b5ac09b3aa2e0bc6187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const NPerm4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga851602918fbf6b5ac09b3aa2e0bc6187">regina::quadDiscArcs</a> [3][4]</td></tr>
<tr class="memdesc:ga851602918fbf6b5ac09b3aa2e0bc6187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc.  <a href="#ga851602918fbf6b5ac09b3aa2e0bc6187">More...</a><br/></td></tr>
<tr class="separator:ga851602918fbf6b5ac09b3aa2e0bc6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41fbaaaadbe5bdd44af16faacc5d77a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const NPerm4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga41fbaaaadbe5bdd44af16faacc5d77a6">regina::octDiscArcs</a> [3][8]</td></tr>
<tr class="memdesc:ga41fbaaaadbe5bdd44af16faacc5d77a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc.  <a href="#ga41fbaaaadbe5bdd44af16faacc5d77a6">More...</a><br/></td></tr>
<tr class="separator:ga41fbaaaadbe5bdd44af16faacc5d77a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Normal surfaces in 3-manifold triangulations. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga52e13b3da02391f7dedf35e9d63201b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_NORMAL_SURFACE_FLAVOUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>: \</div>
<div class="line">        typedef NormalInfo&lt;id&gt; Info; \</div>
<div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47" title="Represents different coordinate systems that can be used for enumerating and displaying normal surfac...">NormalCoords</a> coordsID = id; \</div>
<div class="line">        REGINA_DEPRECATED <span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47" title="Represents different coordinate systems that can be used for enumerating and displaying normal surfac...">NormalCoords</a> coordType = id; \</div>
<div class="line">        inline <span class="keyword">virtual</span> NNormalSurfaceVector* clone()<span class="keyword"> const </span>{ \</div>
<div class="line">            return <span class="keyword">new</span> class_(*<span class="keyword">this</span>); \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsAlmostNormal()<span class="keyword"> const </span>{ \</div>
<div class="line">            return Info::almostNormal; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsSpun()<span class="keyword"> const </span>{ \</div>
<div class="line">            return Info::spun; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsOriented()<span class="keyword"> const </span>{ \</div>
<div class="line">            return Info::oriented; \</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a subclass of NNormalSurfaceVector. </p>
<p>Every subclass of NNormalSurfaceVector <em>must</em> include REGINA_NORMAL_SURFACE_FLAVOUR at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>coordsID</em> and a deprecated compile-time constant <em>coordType</em>, both equal to the corresponding NormalCoords constant;</li>
<li>a typedef <em>Info</em>, which refers to the corresponding specialisation of the NormalInfo&lt;&gt; template;</li>
<li>declarations and implementations of the virtual functions NNormalSurfaceVector::clone(), NNormalSurfaceVector::allowsAlmostNormal(), NNormalSurfaceVector::allowsSpun(), and NNormalSurfaceVector::allowsOriented().</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this subclass of NNormalSurfaceVector. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding NNormalCoords constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga665eac8de6a24d68bddbfa631bcca6c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_SURFACE_FILTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>: \</div>
<div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859" title="Represents different types of filter classes that can be used to filter lists of normal surfaces in 3...">SurfaceFilterType</a> filterTypeID = id; \</div>
<div class="line">        inline <span class="keyword">virtual</span> <a class="code" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859" title="Represents different types of filter classes that can be used to filter lists of normal surfaces in 3...">SurfaceFilterType</a> filterType()<span class="keyword"> const </span>{ \</div>
<div class="line">            return id; \</div>
<div class="line">        } \</div>
<div class="line">        inline <span class="keyword">virtual</span> std::string filterTypeName()<span class="keyword"> const </span>{ \</div>
<div class="line">            return SurfaceFilterInfo&lt;id&gt;::name(); \</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a descendant class of NSurfaceFilter. </p>
<p>Every descendant class of NSurfaceFilter <em>must</em> include REGINA_SURFACE_FILTER at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>filterTypeID</em>, which is equal to the corresponding SurfaceFilterType constant;</li>
<li>declarations and implementations of the virtual functions NSurfaceFilter::filterType() and NSurfaceFilter::filterTypeName();</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this descendant class of NSurfaceFilter. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding SurfaceFilterType constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf4481302c5412c4d0ec9abfef1943650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Face&lt; 3, 1 &gt; <a class="el" href="group__surfaces.html#gaf4481302c5412c4d0ec9abfef1943650">regina::NEdge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef for <a class="el" href="classregina_1_1Face_3_013_00_011_01_4.html" title="Represents an edge in the skeleton of a 3-manifold triangulation.">Face&lt;3, 1&gt;</a>. </p>

</div>
</div>
<a class="anchor" id="ga239df7c1e704457d116029fc144dc473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;NormalAlgFlags&gt; <a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">regina::NormalAlg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal surface lists. </p>
<dl class="section user"><dt>Python:</dt><dd>This is present, and all values in the NormalAlgFlags enumeration type are treated as members of this NormalAlg class. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10adc2dfa823f4b97db64abccdc7f73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;NormalListFlags&gt; <a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">regina::NormalList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal surface lists. </p>
<dl class="section user"><dt>Python:</dt><dd>This is present, and all values in the NormalListFlags enumeration type are treated as members of this NormalList class. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5cde59c8a2b5beab8cb68fb38cb84499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Face&lt; 3, 0 &gt; <a class="el" href="group__surfaces.html#ga5cde59c8a2b5beab8cb68fb38cb84499">regina::NVertex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience typedef for <a class="el" href="classregina_1_1Face_3_013_00_010_01_4.html" title="Represents a vertex in the skeleton of a 3-manifold triangulation.">Face&lt;3, 0&gt;</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga3c4cfc5de652a5beaadaaee0cacdeede"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">regina::NormalAlgFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations. </p>
<p>These options are typically combined in a bitwise fashion using the NormalAlg type, and then passed to enumeration routines such as <a class="el" href="classregina_1_1NNormalSurfaceList.html#a00689fa2687df35c35bac735d565e56e" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation...">NNormalSurfaceList::enumerate()</a>.</p>
<dl class="section user"><dt>Python:</dt><dd>The values in this enumeration type are present, but they are treated by Python as NormalList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b"></a>NS_ALG_DEFAULT</em>&nbsp;</td><td class="fielddoc">
<p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea4c4bfbfefa31e5c048a0d9e25abf9f89"></a>NS_VERTEX_VIA_REDUCED</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should first enumerate in quadrilateral or quadrilateral-octagon coordinates, and then expand this "reduced" solution set to the (typically larger) "standard" solution set. </p>
<p>This is typically much faster than a direct enumeration in standard normal or almost normal coordinates, and enumeration routines will use this option where possible unless explicitly requested not to (via the flag NS_VERTEX_STD_DIRECT).</p>
<p>For an explanation of this procedure, see B. A. Burton, "Converting between quadrilateral and standard solution sets in
normal surface theory", Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>This flag is incompatible with NS_VERTEX_STD_DIRECT. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea15bc7c42b8b986d93863600852d271c7"></a>NS_VERTEX_STD_DIRECT</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should work directly in that coordinate system, and should not go via the "reduced" (quadrilateral or quadrilateral-octagon) coordinate system. </p>
<p>This is typically <em>much</em> slower than going via the reduced system, and users should only request this if they have a specialised need. See NS_VERTEX_VIA_REDUCED for further information.</p>
<p>This flag is incompatible with NS_VERTEX_VIA_REDUCED. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea482b7e69b14c44d02b29055726b04830"></a>NS_VERTEX_TREE</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating vertex normal surfaces, this flag indicates that the tree traversal algorithm should be used. </p>
<p>This algorithm is based on linear and integer programming techniques, and has many desirable properties including a relatively low overhead. Enumeration algorithms will use it if possible unless a different method is explicitly requested.</p>
<p>For details on the tree traversal algorithm, see B. A. Burton and M. Ozlen, "A tree traversal algorithm for decision problems in
knot theory and 3-manifold topology", Algorithmica 65 (2013), pp. 772-801.</p>
<p>This flag is incompatible with NS_VERTEX_DD. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedeac988e037d6c164c645567750680c6e11"></a>NS_VERTEX_DD</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating vertex normal surfaces, this flag indicates that a modified double description method should be used. </p>
<p>This algorithm can suffer from a combinatorial explosion with larger problems, leading to extremely large time and memory footprints. Users should only request this if they have some specialised need.</p>
<p>For details on the modified double description method, see B. A. Burton, "Optimizing the double description method for
normal surface enumeration", Mathematics of Computation 79 (2010), pp. 453-484.</p>
<p>This flag is incompatible with NS_VERTEX_TREE. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea33ff9b1fafe5bc6aa4dbf851ec2b9ae6"></a>NS_HILBERT_PRIMAL</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating fundamental normal surfaces, this flag indicates that the primal method should be used for enumerating a Hilbert basis. </p>
<p>The primal method is recommended, and enumeration algorithms will use it if possible unless a different method is explicitly requested. This method uses code from Normaliz for parts of its processing.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_DUAL, NS_HILBERT_CD and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea77887211e55db67ba4ba10247cd159f3"></a>NS_HILBERT_DUAL</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating fundamental normal surfaces, this flag indicates that the dual method should be used for enumerating a Hilbert basis. </p>
<p>The dual method is fast (like the primal method), but its performance is highly variable; for this reason the primal method is recommended instead. This method does not make use of Normaliz, and is the recommended method for situations in which Normaliz is not available for some reason.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_CD and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea1da3bc474ed341903ab0f043488e27c3"></a>NS_HILBERT_CD</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating fundamental normal surfaces, this flag indicates that a modified Contejean-Devie procedure should be used for enumerating a Hilbert basis. </p>
<p>The Contejean-Devie procedure is typically <em>much</em> slower than either the primal or dual method, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_DUAL and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea7d84f194dd4d881f2175acae85fa3742"></a>NS_HILBERT_FULLCONE</em>&nbsp;</td><td class="fielddoc">
<p>When enumerating fundamental normal surfaces, this flag indicates that a Hilbert basis for the full solution cone should be constructed, and additional combinatorial constraints (such as the quadrilateral constraints) should only be enforced as the final step. </p>
<p>If you are only enumerating properly embedded surfaces then this procedure <em>extremely</em> slow, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_DUAL and NS_HILBERT_CD. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea61e5c6c91ab2a0c4ac8a6fca9cccd430"></a>NS_ALG_LEGACY</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that a normal surface list was enumerated using an older version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of the algorithm used to build each list, and so in such cases no further algorithmic information is available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3c4cfc5de652a5beaadaaee0cacdeedea6d1833185860331a3be3d7f909b1323a"></a>NS_ALG_CUSTOM</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that a normal surface list was built using a customised algorithm. </p>
<p>In such cases, no further details on the algorithm are available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9817fc7125c53daea4e3f3cbfe987a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different coordinate systems that can be used for enumerating and displaying normal surfaces. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own coordinate system, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a36273f97819ff462b10db091f8a93f75"></a>NS_STANDARD</em>&nbsp;</td><td class="fielddoc">
<p>Represents standard triangle-quadrilateral coordinates for normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47af3d1b2ccecff610fdaae1e4f3dde0744"></a>NS_QUAD</em>&nbsp;</td><td class="fielddoc">
<p>Represents quadrilateral coordinates for normal surfaces. </p>
<p>For details, see "Normal surface Q-theory", Jeffrey L. Tollefson, Pacific J. Math. 183 (1998), no. 2, 359&ndash;374. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47ad2d9d61fc90b31363ec5931b1a300aa8"></a>NS_AN_LEGACY</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that a list of almost normal surfaces was created using Regina 4.5.1 or earlier, where surfaces with more than one octagon of the same type were stripped out of the final solution set. </p>
<p>As of Regina 4.6 such surfaces are now included in the solution set, since we need them if we wish to enumerate <em>all</em> almost normal surfaces (not just the <em>vertex</em> almost normal surfaces).</p>
<p>This coordinate system is only used with legacy data files; new vectors and lists cannot be created in this coordinate system. The underlying coordinates are identical to those of NS_AN_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a4a7e1fc6780905418e84cadf782dd82f"></a>NS_AN_QUAD_OCT</em>&nbsp;</td><td class="fielddoc">
<p>Represents quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
<p>For details, see "Quadrilateral-octagon coordinates for almost normal surfaces", Benjamin A. Burton, Experiment. Math. 19 (2010), 285-315. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a0de57480ceb39c23829e982e5bef7d84"></a>NS_AN_STANDARD</em>&nbsp;</td><td class="fielddoc">
<p>Represents standard triangle-quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae"></a>NS_EDGE_WEIGHT</em>&nbsp;</td><td class="fielddoc">
<p>Represents edge weight coordinates for normal surfaces. </p>
<p>This coordinate system is for display only; surface vectors and lists cannot be created in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47ae8c39b9dd91ad81bf89ca633c8d9598f"></a>NS_TRIANGLE_ARCS</em>&nbsp;</td><td class="fielddoc">
<p>Represents triangle arc coordinates for normal surfaces. </p>
<p>This coordinate system is for display only; surface vectors and lists cannot be created in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a426f8d72390eb0220effee259c2dc483"></a>REGINA_DEPRECATED_ENUM</em>&nbsp;</td><td class="fielddoc">
<p>A deprecated alias for NS_TRIANGLE_ARCS. </p>
<p>This represents triangle arc coordinates for normal surfaces. See NS_TRIANGLE_ARCS for further details.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000402">Deprecated:</a></b></dt><dd>This constant will be removed in a future version of Regina. Please use NS_TRIANGLE_ARCS instead. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a602873a7f7351b3822c37b075ba88c43"></a>NS_ORIENTED</em>&nbsp;</td><td class="fielddoc">
<p>Represents standard triangle-quadrilateral coordinates for transversely oriented normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a205b46c71691c8092a5afa1d99ab556a"></a>NS_ORIENTED_QUAD</em>&nbsp;</td><td class="fielddoc">
<p>Represents quadrilateral coordinates for transversely oriented normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga9817fc7125c53daea4e3f3cbfe987a47a9f471af2d202b88f06ed65be82e5d7eb"></a>NS_ANGLE</em>&nbsp;</td><td class="fielddoc">
<p>Represents angle structure coordinates. </p>
<p>This coordinate system is <em>not</em> for use with normal surfaces: it cannot be used either to display them or enumerate them. Instead it is for use with angle structures on triangulations. Because the combinatorics and linear algebra of angle strutures are tightly related to those of normal surfaces, we include NS_ANGLE here so that angle structure routines can make use of some of Regina's existing normal surface machinery.</p>
<p>For a triangulation with <em>n</em> tetrahedra, this system has 3<em>n</em>+1 coordinates. The first 3<em>n</em> are analogous to quadrilateral coordinates (specifically, for each quadrilateral type <em>Q</em>, the corresponding angle structure coordinate represents the pair of angles in the same tetrahedron that <em>Q</em> does not meet). The final coordinate is a scaling coordinate, used to projectivise the angle structure polytope so that it becomes a polyhedral cone that is invariant under (positive) scaling. If the final scaling coordinate is <em>s</em>, then a rational value of <em>x</em> in any other coordinate position should be interpreted as the angle <em>x</em>.&pi;/<em>s</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This coordinate system must not be used with any of Regina's routines unless they explicitly declare that NS_ANGLE is allowed. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gabff25e58607c49cca84049a1069c2cce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">regina::NormalListFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation. </p>
<p>The NormalList enumeration refers to the <em>contents</em> of the list, whereas the NormalAlgFlags enumeration refers to the <em>algorithm</em> used to build it.</p>
<dl class="section user"><dt>Python:</dt><dd>The values in this enumeration type are present, but they are treated by Python as NormalList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864"></a>NS_LIST_DEFAULT</em>&nbsp;</td><td class="fielddoc">
<p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabff25e58607c49cca84049a1069c2ccea41f7f2158c91f3f64f3354118f6a8761"></a>NS_EMBEDDED_ONLY</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that this list is restricted to properly embedded surfaces only. </p>
<p>This flag is incompatible with NS_IMMERSED_SINGULAR. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabff25e58607c49cca84049a1069c2ccea1e0c5bf3f4138d8ec4a88caeb5f87a61"></a>NS_IMMERSED_SINGULAR</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that the scope of this list includes not just properly embedded surfaces, but also immersed and/or branched surfaces. </p>
<p>This is no guarantee that the list <em>contains</em> immersed and/or branched surfaces; it merely states that such surfaces have not been explicitly excluded (in particular, the quadrilateral constraints have not been enforced).</p>
<p>This flag is incompatible with NS_EMBEDDED_ONLY. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabff25e58607c49cca84049a1069c2ccea38cd0d13c8afd0f688eda457d5ed550d"></a>NS_VERTEX</em>&nbsp;</td><td class="fielddoc">
<p>Indicates a list of all vertex normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with NS_FUNDAMENTAL. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabff25e58607c49cca84049a1069c2ccea949286ba72f0deec9b6bbe2b8a23b39c"></a>NS_FUNDAMENTAL</em>&nbsp;</td><td class="fielddoc">
<p>Indicates a list of all fundamental normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with NS_VERTEX. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabff25e58607c49cca84049a1069c2cceaab119737dcff1409ff0f2071baee7e40"></a>NS_LEGACY</em>&nbsp;</td><td class="fielddoc">
<p>Indicates a list that was constructed using an old version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of how each list was constructed, beyond whether immersed and/or singular surfaces were included. Therefore no information is available for such lists, other than the presence or absence of the NS_EMBEDDED_ONLY and/or NS_IMMERSED_SINGULAR flags.</p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggabff25e58607c49cca84049a1069c2ccea64cbdf1921e4a99c5943b4039dac2709"></a>NS_CUSTOM</em>&nbsp;</td><td class="fielddoc">
<p>Indicates some other type of list, typically hand-crafted by the user or built by some customised algorithm. </p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae923c7c2fa692192d45bdf563f380918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">regina::SurfaceExportFields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to describe a field, or a set of fields, that can be exported alongside a normal surface list. </p>
<p>This enumeration type is used with export routines such as <a class="el" href="classregina_1_1NNormalSurfaceList.html#ac1eca9cbc4ee850841eaac32ad951655" title="Exports this list of normal surfaces as a plain text CSV (comma-separated value) file, using standard coordinates.">NNormalSurfaceList::saveCSVStandard()</a> or <a class="el" href="classregina_1_1NNormalSurfaceList.html#a2265caf9046cbbb399ed634c6da2e2c7" title="Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file...">NNormalSurfaceList::saveCSVEdgeWeight()</a>.</p>
<p>This type describes fields in addition to normal coordinates, not the normal coordinates themselves (which are always exported). Each field describes some property of a single normal surface, and corresponds to a single column in a table of normal surfaces.</p>
<p>This type should be treated as a bitmask: you can describe a set of fields by combining the values for individual fields using bitwise <em>or</em>.</p>
<p>The list of available fields may grow with future releases of Regina. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918a81408d5dd0f9deb210bf66ecee761c36"></a>surfaceExportName</em>&nbsp;</td><td class="fielddoc">
<p>Represents the user-assigned surface name. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918a131a23295ec061f83590561bba365de8"></a>surfaceExportEuler</em>&nbsp;</td><td class="fielddoc">
<p>Represents the calculated Euler characteristic of a surface. </p>
<p>This will be an integer, and will be left empty if the Euler characteristic cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918a153a815a9b0f7d3b3383f39c2d6f94ca"></a>surfaceExportOrient</em>&nbsp;</td><td class="fielddoc">
<p>Represents the calculated property of whether a surface is orientable. </p>
<p>This will be the string <code>TRUE</code> or <code>FALSE</code>, or will be left empty if the orientability cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918a60a48a7481d07261cf4a4051cffc3bc3"></a>surfaceExportSides</em>&nbsp;</td><td class="fielddoc">
<p>Represents the calculated property of whether a surface is one-sided or two-sided. </p>
<p>This will be the integer 1 or 2, or will be left empty if the "sidedness" cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918add63709fcbf9038110d4a3b232a466c2"></a>surfaceExportBdry</em>&nbsp;</td><td class="fielddoc">
<p>Represents the calculated property of whether a surface is bounded. </p>
<p>In most cases, this will be one of the strings "closed", "real bdry" or "infinite" (where "infinite" indicates a surface with infinitely many discs). For spun-normal surfaces in certain ideal triangulations, this string will be followed by the boundary slopes of the surface at the cusps: these written as a list of pairs (<em>p</em>, <em>q</em>), one for each cusp, indicating that the boundary curves of the surface run <em>p</em> times around the meridian and <em>q</em> times around the longitude. See <a class="el" href="classregina_1_1NNormalSurface.html#a5754658b86d6561768415f82f32f5b45" title="Computes the information about the boundary slopes of this surface at each cusp of the triangulation...">NNormalSurface::boundaryIntersections()</a> for further information on interpreting these values. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918a0832d74579319961e0c6f976e28b0356"></a>surfaceExportLink</em>&nbsp;</td><td class="fielddoc">
<p>Represents whether a surface is a single vertex link or a thin edge link. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#a5e004efb3013600e890355889f76e4c4" title="Determines whether or not a rational multiple of this surface is the link of a single vertex...">NNormalSurface::isVertexLink()</a> and <a class="el" href="classregina_1_1NNormalSurface.html#af26fcd1816990604e6c437bcbb07244d" title="Determines whether or not a rational multiple of this surface is the thin link of a single edge...">NNormalSurface::isThinEdgeLink()</a> for details. This will be written as a human-readable string. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918acf49b97bd782901a7f6ee32bf9841b03"></a>surfaceExportType</em>&nbsp;</td><td class="fielddoc">
<p>Represents any additional high-level properties of a surface, such as whether it is a splitting surface or a central surface. </p>
<p>This will be written as a human-readable string. This field is somewhat arbitrary, and the precise properties it describes are subject to change in future releases of Regina. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918a9b7d4c6f39579e1711b203dcf8ed3824"></a>surfaceExportNone</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that no additional fields should be exported. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918a90da6f93fd64f642efa8b5862d7b4dac"></a>surfaceExportAllButName</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that all available fields should be exported, except for the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64"></a>surfaceExportAll</em>&nbsp;</td><td class="fielddoc">
<p>Indicates that all available fields should be exported, including the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga38ab803471723156fb2ecb24b7b1c859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own filter class, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004"></a>NS_FILTER_DEFAULT</em>&nbsp;</td><td class="fielddoc">
<p>Represents the <a class="el" href="classregina_1_1NSurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">NSurfaceFilter</a> class: a do-nothing filter that accepts any normal surface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga38ab803471723156fb2ecb24b7b1c859abad02c85eeeda839925c60cd245fb478"></a>NS_FILTER_PROPERTIES</em>&nbsp;</td><td class="fielddoc">
<p>Represents the <a class="el" href="classregina_1_1NSurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface.">NSurfaceFilterProperties</a> subclass: a filter that examines simple properties of a normal surface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga38ab803471723156fb2ecb24b7b1c859a53350ed09529a46c5ed4298a14d9c6a2"></a>NS_FILTER_COMBINATION</em>&nbsp;</td><td class="fielddoc">
<p>Represents the <a class="el" href="classregina_1_1NSurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters.">NSurfaceFilterCombination</a> subclass: a filter that combines other filters using boolean AND or OR. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0355cb839a1c4401eb06ea08d175047d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::discOrientationFollowsEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc. </p>
<p>Natural boundary orientation is defined by arrays <a class="el" href="group__surfaces.html#ga3e15cb120c3a2568d49b0381edfa3c8c" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular...">regina::triDiscArcs</a>, <a class="el" href="group__surfaces.html#ga851602918fbf6b5ac09b3aa2e0bc6187" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilate...">regina::quadDiscArcs</a> and <a class="el" href="group__surfaces.html#ga41fbaaaadbe5bdd44af16faacc5d77a6" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal ...">regina::octDiscArcs</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal arc lies on a normal disc of the given type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1NDiscSpec.html" title="Specifies a single normal disc in a normal surface.">NDiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex about which the normal arc runs. </td></tr>
    <tr><td class="paramname">edgeStart</td><td>the start vertex of the edge to which the normal arc is parallel. </td></tr>
    <tr><td class="paramname">edgeEnd</td><td>the end vertex of the edge to which the normal arc is parallel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa835bb40bfcf36e0541809044f35ea5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnsTraits&lt;FunctionObject&gt;::ReturnType regina::forCoords </td>
          <td>(</td>
          <td class="paramtype">NormalCoords&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ReturnsTraits&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal surfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;NormalInfo&lt;c&gt;&gt;(...)</code> is defined for any valid NormalCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;NormalInfo&lt;coords&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from <a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a>&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a NormalInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given coordinate system is invalid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given coordinate system is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="gac8922018a2db9ec5f9c7b2e09e77216f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnsTraits&lt;FunctionObject&gt;::Void regina::forCoords </td>
          <td>(</td>
          <td class="paramtype">NormalCoords&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal surfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;NormalInfo&lt;c&gt;&gt;(...)</code> is defined for any valid NormalCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, ...)</code>, this routine will call <code>func.operator()&lt;NormalInfo&lt;coords&gt;&gt;(...)</code> in turn. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em>. (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a NormalInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07288bf625eb5d9b8d0be1fb730f8a01"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnsTraits&lt;FunctionObject&gt;::ReturnType regina::forFilter </td>
          <td>(</td>
          <td class="paramtype">SurfaceFilterType&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename ReturnsTraits&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible normal surface filter types.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new filter type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;SurfaceFilterInfo&lt;t&gt;&gt;(...)</code> is defined for any valid SurfaceFilterType enum value <em>t</em>. Then, when the user calls <code>forFilter(filter, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;SurfaceFilterInfo&lt;filter&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>filter</em> does not denote a valid filter type, then <a class="el" href="group__surfaces.html#ga07288bf625eb5d9b8d0be1fb730f8a01" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__surfaces.html#ga07288bf625eb5d9b8d0be1fb730f8a01" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from <a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a>&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>the given type of normal surface filter. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a SurfaceFilterInfo&lt;filter&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given filter type is not valid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap then in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given filter type is not valid. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6f1771e5f2090d65618c705c6c0f8b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnsTraits&lt;FunctionObject&gt;::Void regina::forFilter </td>
          <td>(</td>
          <td class="paramtype">SurfaceFilterType&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible normal surface filter types.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new filter type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;SurfaceFilterInfo&lt;t&gt;&gt;(...)</code> is defined for any valid SurfaceFilterType enum value <em>t</em>. Then, when the user calls <code>forFilter(filter, func, ...)</code>, this routine will call <code>func.operator()&lt;SurfaceFilterInfo&lt;filter&gt;&gt;(...)</code> in turn. If <em>filter</em> does not denote a valid filter type, then <a class="el" href="group__surfaces.html#ga07288bf625eb5d9b8d0be1fb730f8a01" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__surfaces.html#ga07288bf625eb5d9b8d0be1fb730f8a01" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em> (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__surfaces.html#ga07288bf625eb5d9b8d0be1fb730f8a01" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>the given type of normal surface filter. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a SurfaceFilterInfo&lt;filter&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap then in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga683a7a8a9ff4870797ed8d1cbbb15e35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> FunctionObject::ReturnType regina::forFlavour </td>
          <td>(</td>
          <td class="paramtype">NormalCoords&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename FunctionObject::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for the registry-based template function <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a>. </p>
<p>See <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="gaf00631b75df786b87c4e8b755512230c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoidFunctionObject &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> void regina::forFlavour </td>
          <td>(</td>
          <td class="paramtype">NormalCoords&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VoidFunctionObject&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for the registry-based template function <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a>. </p>
<p>See <a class="el" href="group__hypersurface.html#ga08190ad0965de193fb37ca4a18d68436" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> for further details. </p>

</div>
</div>
<a class="anchor" id="gac280f5dbf734d58f7c14d7344a991c80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NEnumConstraintList* regina::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const NTriangulation *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormalCoords&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal surfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the given coordinate system.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeea16b80f40ad799901739937d94e86b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NMatrixInt* regina::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const NTriangulation *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormalCoords&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal surface matching equations for the given triangulation using the given coordinate system. </p>
<p>The returned matrix will be newly allocated and its destruction will be the responsibility of the caller of this routine.</p>
<p>Each equation will be represented as a row of the matrix. Each column of the matrix represents a coordinate in the given coordinate system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fdd39f2276a1b073e1a30037faca272"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> NNormalSurfaceVector* regina::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const NTriangulation *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormalCoords&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and the given coordinate system. </p>
<p>All elements of this vector will be initialised to zero.</p>
<p>The new vector will be of the subclass of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> corresponding to the given coordinate system. The caller of this routine is responsible for destroying the new vector.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a class="anchor" id="ga691d08a8f65b1322e0846cf55b319461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> bool regina::numberDiscsAwayFromVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not normal discs of the given type are numbered away from the given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1NDiscSpec.html" title="Specifies a single normal disc in a normal surface.">NDiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex under consideration; this should be between 0 and 3 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if normal discs of the given type are numbered away from the given vertex, or <code>false</code> if they are numbered towards the given vertex. </dd></dl>

</div>
</div>
<a class="anchor" id="ga938ab6c0418b2eb992b136796af68d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NPrismSpec &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given prism specifier to the given output stream. </p>
<p>The prism specifier will be written as a pair <code>(tetIndex, edge)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the prism specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga876e554eb4fda7ead0f73db0324841d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NDiscSpec &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given disc specifier to the given output stream. </p>
<p>The disc specifier will be written as a triple <code>(tetIndex, type, number)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the disc specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78991ddbd00ab2ed9fd8773ae60e59ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NDiscType &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given disc type to the given output stream. </p>
<p>The disc type will be written as a pair <code>(tetIndex, type)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">type</td><td>the disc type to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a class="anchor" id="gae92f3f038eac514d3e599ff3d92d8485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NormalList regina::operator| </td>
          <td>(</td>
          <td class="paramtype">NormalListFlags&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormalListFlags&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4428e0ba8bfcc8083b37e9e3e2220c96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NormalAlg regina::operator| </td>
          <td>(</td>
          <td class="paramtype">NormalAlgFlags&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NormalAlgFlags&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gaec9d18f213d2d3fab0c4b39506080670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> typedef NewFunction1&lt;NNormalSurfaceVector, size_t&gt; regina::NewNormalSurfaceVector</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A legacy typedef provided for backward compatibility only. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000352">Deprecated:</a></b></dt><dd>The old NewNormalSurfaceVector class has been redesigned as the more general template class <a class="el" href="structregina_1_1NewFunction1.html" title="Deprecated function object for creating new objects subclassed from Base.">NewFunction1</a>, and moved into the header <a class="el" href="registryutils_8h.html" title="Miscellaneous utility classes for working with registries of packet types, normal coordinate systems...">registryutils.h</a>. This typedef is provided for backward compatibility, and will be removed in some future version of Regina. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41fbaaaadbe5bdd44af16faacc5d77a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const NPerm4 regina::octDiscArcs[3][8]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>octDiscArcs[i]</code> lists the boundary arcs of the octagonal disc of type <em>i</em>. See <a class="el" href="classregina_1_1NNormalSurface.html#ab6d7f6f5f6cb35f5d060443beac0c755" title="Returns the number of octagonal discs of the given type in this normal surface.">NNormalSurface::octs()</a> for further details.</p>
<p>Note that permutation <code>octDiscArcs[i][j]</code> will be even precisely when <code>j</code> is 0, 1, 4 or 5.</p>
<dl class="section user"><dt>C++:</dt><dd>This array is replaced by a macro <code>octDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a class="anchor" id="ga851602918fbf6b5ac09b3aa2e0bc6187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const NPerm4 regina::quadDiscArcs[3][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>quadDiscArcs[i]</code> lists the boundary arcs of the quadrilateral disc of type <em>i</em>. See <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a> for further details.</p>
<p>Note that permutation <code>quadDiscArcs[i][j]</code> will be even precisely when <code>j</code> is even.</p>
<dl class="section user"><dt>C++:</dt><dd>This array is replaced by a macro <code>quadDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a class="anchor" id="gab3079fddda965e048d4a3c033751b8ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int regina::quadMeeting[4][4][2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists which quadrilateral types meet which edges in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p><code>quadMeeting[i][j][0,1]</code> are the numbers of the two quadrilateral types that meet the edge joining tetrahedron vertices <code>i</code> and <code>j</code>. </p>

</div>
</div>
<a class="anchor" id="ga7a16e2bec83bf891238ad350e4630d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int regina::quadPartner[3][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> pairs vertex <code>v</code> with vertex <code>quadPartner[i][v]</code>. </p>

</div>
</div>
<a class="anchor" id="gad7b578aec3d1a608e11d90c9b33d9113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int regina::quadSeparating[4][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists which quadrilateral types separate which pairs of vertices in a tetrahedron. </p>
<p>As outlined in <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a>, there are three quadrilateral types in a tetrahedron, numbered 0, 1 and 2. Each quadrilateral type separates the four tetrahedron vertices 0,1,2,3 into two pairs. <code>quadSeparating[i][j]</code> is the number of the quadrilateral type that keeps vertices <code>i</code> and <code>j</code> together.</p>
<p>It is guaranteed that quadrilateral type <em>i</em> will keep the vertices of edge <em>i</em> together (and will therefore also keep the vertices of edge <em>5-i</em> together). </p>

</div>
</div>
<a class="anchor" id="ga1e0cdd2884ac43d3e7ddff9e6947b566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const char regina::quadString[3][6]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains strings that can be used to represent each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>The string describing quadrilateral type <code>i</code> is <code>quadString[i]</code> and is of the form <code>02/13</code>, which in this case is the quadrilateral type that splits vertices 0,2 from vertices 1,3. </p>

</div>
</div>
<a class="anchor" id="ga3e15cb120c3a2568d49b0381edfa3c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const NPerm4 regina::triDiscArcs[4][3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>triDiscArcs[i]</code> lists the boundary arcs of the triangular disc of type <em>i</em>. See <a class="el" href="classregina_1_1NNormalSurface.html#aa50bb0db0c6f7664ad26a15b26f213c1" title="Returns the number of triangular discs of the given type in this normal surface.">NNormalSurface::triangles()</a> for further details.</p>
<p>Note that every permutation in this array is even.</p>
<dl class="section user"><dt>C++:</dt><dd>This array is replaced by a macro <code>triDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b746a3a6579824b6b5f75701d6bc385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int(* regina::vertexSplit)[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000353">Deprecated:</a></b></dt><dd>This array has been renamed to <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a>. See the <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga05ae12937602edaa05b6ba010dd8a18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int regina::vertexSplitDefn[3][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated array that lists the vertices which each quadrilateral type separates within a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gad7b578aec3d1a608e11d90c9b33d9113" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> splits the vertex pairs <code>vertexSplitDefn[i][0,1]</code> and <code>vertexSplitDefn[i][2,3]</code>.</p>
<p>It is guaranteed that:</p>
<ul>
<li><code>vertexSplitDefn[i][0] &lt; vertexSplitDefn[i][1]</code>;</li>
</ul>
<ul>
<li><code>vertexSplitDefn[i][2] &lt; vertexSplitDefn[i][3]</code>;</li>
</ul>
<ul>
<li><code>vertexSplitDefn[i][0] &lt; vertexSplitDefn[i][2]</code>.</li>
</ul>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000355">Deprecated:</a></b></dt><dd>This array is redundant, and will be removed in a future release of Regina. Instead of vertexSplitDefn[<em>i</em>][<em>j</em>], you can call <a class="el" href="group__detail.html#ga5eea7a2ffbccd1271f4fdfa80fa02556" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">NEdge::ordering</a>(<em>i</em>)[<em>j</em>] which carries the same information. Be aware however that <a class="el" href="group__detail.html#ga5eea7a2ffbccd1271f4fdfa80fa02556" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">NEdge::ordering()</a> might reorder the images <a class="el" href="group__detail.html#ga5eea7a2ffbccd1271f4fdfa80fa02556" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">NEdge::ordering</a>(<em>i</em>)[2] and <a class="el" href="group__detail.html#ga5eea7a2ffbccd1271f4fdfa80fa02556" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">NEdge::ordering</a>(<em>i</em>)[3]. </dd></dl>

</div>
</div>
<a class="anchor" id="ga09a84af39ca5120e7de5751a1944717c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int(* regina::vertexSplitMeeting)[4][2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for <a class="el" href="group__surfaces.html#gab3079fddda965e048d4a3c033751b8ca" title="Lists which quadrilateral types meet which edges in a tetrahedron.">regina::quadMeeting</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000354">Deprecated:</a></b></dt><dd>This array has been renamed to <a class="el" href="group__surfaces.html#gab3079fddda965e048d4a3c033751b8ca" title="Lists which quadrilateral types meet which edges in a tetrahedron.">regina::quadMeeting</a>. See the <a class="el" href="group__surfaces.html#gab3079fddda965e048d4a3c033751b8ca" title="Lists which quadrilateral types meet which edges in a tetrahedron.">regina::quadMeeting</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ga594f0f7cce4bb4c023ad5129f9266869"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const int(* regina::vertexSplitPartner)[4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for <a class="el" href="group__surfaces.html#ga7a16e2bec83bf891238ad350e4630d77" title="Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedr...">regina::quadPartner</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000356">Deprecated:</a></b></dt><dd>This array has been renamed to <a class="el" href="group__surfaces.html#ga7a16e2bec83bf891238ad350e4630d77" title="Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedr...">regina::quadPartner</a>. See the <a class="el" href="group__surfaces.html#ga7a16e2bec83bf891238ad350e4630d77" title="Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedr...">regina::quadPartner</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="gac7e751dda815ce837f3bf21965217538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__engine.html#ga40f523e616a7b654de9ee1d254b1f614">REGINA_DEPRECATED</a> <a class="el" href="group__engine.html#ga74a5f137da12842a64dce0a7c78fb3f9">REGINA_API</a> const char(* regina::vertexSplitString)[6]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated alias for <a class="el" href="group__surfaces.html#ga1e0cdd2884ac43d3e7ddff9e6947b566" title="Contains strings that can be used to represent each quadrilateral type in a tetrahedron.">regina::quadString</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000357">Deprecated:</a></b></dt><dd>This array has been renamed to <a class="el" href="group__surfaces.html#ga1e0cdd2884ac43d3e7ddff9e6947b566" title="Contains strings that can be used to represent each quadrilateral type in a tetrahedron.">regina::quadString</a>. See the <a class="el" href="group__surfaces.html#ga1e0cdd2884ac43d3e7ddff9e6947b566" title="Contains strings that can be used to represent each quadrilateral type in a tetrahedron.">regina::quadString</a> documentation for further details. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
