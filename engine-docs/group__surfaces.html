<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: Normal Surfaces</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Normal Surfaces</div>  </div>
</div><!--header-->
<div class="contents">

<p>Normal surfaces in 3-manifold triangulations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single normal disc in a normal surface.  <a href="structregina_1_1DiscSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetTet.html">regina::DiscSetTet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of normal discs inside a single tetrahedron.  <a href="classregina_1_1DiscSetTet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data of type <code>T</code> for every normal disc inside a single tetrahedron.  <a href="classregina_1_1DiscSetTetData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetSurface.html">regina::DiscSetSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the set of all normal discs forming a normal surface.  <a href="classregina_1_1DiscSetSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores data of type <code>T</code> for every normal disc within a particular normal surface.  <a href="classregina_1_1DiscSetSurfaceData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1DiscSpecIterator.html">regina::DiscSpecIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator used for running through all normal discs in a normal surface.  <a href="classregina_1_1DiscSpecIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_01regina_1_1DiscSpecIterator_01_4.html">std::iterator_traits&lt; regina::DiscSpecIterator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1DiscType.html">regina::DiscType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a single normal or almost normal disc type within a triangulation.  <a href="structregina_1_1DiscType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Matrix.html">regina::Matrix&lt; T, ring &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of elements of the given type <em>T</em>.  <a href="classregina_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NormalInfo.html">regina::NormalInfo&lt; coordType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular normal coordinate system.  <a href="structregina_1_1NormalInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaceVector.html">regina::NormalSurfaceVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the vector of a single normal surface in a 3-manifold.  <a href="classregina_1_1NormalSurfaceVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurface.html">regina::NormalSurface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single normal surface in a 3-manifold.  <a href="classregina_1_1NormalSurface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html">regina::NormalSurfaces</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet representing a collection of normal surfaces in a 3-manifold.  <a href="classregina_1_1NormalSurfaces.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorANStandard.html">regina::NSVectorANStandard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An almost normal surface vector using standard triangle-quad-oct coordinates.  <a href="classregina_1_1NSVectorANStandard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorMirrored.html">regina::NSVectorMirrored</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calculations.  <a href="classregina_1_1NSVectorMirrored.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOriented.html">regina::NSVectorOriented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using transversely oriented standard (triangle-quad) coordinates.  <a href="classregina_1_1NSVectorOriented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorOrientedQuad.html">regina::NSVectorOrientedQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using transversely oriented quadrilateral coordinates.  <a href="classregina_1_1NSVectorOrientedQuad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuad.html">regina::NSVectorQuad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using quad coordinates.  <a href="classregina_1_1NSVectorQuad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuadClosed.html">regina::NSVectorQuadClosed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector for a normal surface in an ideal triangulation, expressed using quad coordinates and enumerated to include closed surfaces only.  <a href="classregina_1_1NSVectorQuadClosed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuadOct.html">regina::NSVectorQuadOct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An almost normal surface vector using quad-oct coordinates.  <a href="classregina_1_1NSVectorQuadOct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorQuadOctClosed.html">regina::NSVectorQuadOctClosed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector for an almost normal surface in an ideal triangulation, expressed using quad-oct coordinates and enumerated to include closed surfaces only.  <a href="classregina_1_1NSVectorQuadOctClosed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NSVectorStandard.html">regina::NSVectorStandard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface vector using standard triangle-quad coordinates.  <a href="classregina_1_1NSVectorStandard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1PrismSpec.html">regina::PrismSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a single triangular prism in a tetrahedron.  <a href="structregina_1_1PrismSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1SurfaceFilterInfo.html">regina::SurfaceFilterInfo&lt; filterType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template that stores information about a particular type of normal surface filter.  <a href="structregina_1_1SurfaceFilterInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilter.html">regina::SurfaceFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A packet that accepts or rejects normal surfaces.  <a href="classregina_1_1SurfaceFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilterCombination.html">regina::SurfaceFilterCombination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that simply combines other filters.  <a href="classregina_1_1SurfaceFilterCombination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SurfaceFilterProperties.html">regina::SurfaceFilterProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A normal surface filter that filters by basic properties of the normal surface.  <a href="classregina_1_1SurfaceFilterProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLFilterReader.html">regina::XMLFilterReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads the specific details of a normal surface filter.  <a href="classregina_1_1XMLFilterReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLFilterPacketReader.html">regina::XMLFilterPacketReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single surface filter.  <a href="classregina_1_1XMLFilterPacketReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLNormalSurfaceReader.html">regina::XMLNormalSurfaceReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML element reader that reads a single normal surface.  <a href="classregina_1_1XMLNormalSurfaceReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1XMLNormalSurfacesReader.html">regina::XMLNormalSurfacesReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An XML packet reader that reads a single normal surface list.  <a href="classregina_1_1XMLNormalSurfacesReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga28d182dc4885f0c9045d90e6e7c259ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga28d182dc4885f0c9045d90e6e7c259ad">REGINA_NORMAL_SURFACE_FLAVOUR</a>(class_,  id,  superclass)</td></tr>
<tr class="memdesc:ga28d182dc4885f0c9045d90e6e7c259ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a subclass of NormalSurfaceVector.  <a href="#ga28d182dc4885f0c9045d90e6e7c259ad">More...</a><br /></td></tr>
<tr class="separator:ga28d182dc4885f0c9045d90e6e7c259ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga665eac8de6a24d68bddbfa631bcca6c9">REGINA_SURFACE_FILTER</a>(class_,  id)</td></tr>
<tr class="memdesc:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines various constants, types and virtual functions for a descendant class of SurfaceFilter.  <a href="#ga665eac8de6a24d68bddbfa631bcca6c9">More...</a><br /></td></tr>
<tr class="separator:ga665eac8de6a24d68bddbfa631bcca6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacc58cdaf40c4b2c896cbaf2900a3d048"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">regina::DiscSetTetData&lt; T &gt;::DataPtr</a></td></tr>
<tr class="memdesc:gacc58cdaf40c4b2c896cbaf2900a3d048"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that is a pointer to the data stored with each disc.  <a href="#gacc58cdaf40c4b2c896cbaf2900a3d048">More...</a><br /></td></tr>
<tr class="separator:gacc58cdaf40c4b2c896cbaf2900a3d048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea7f09ab89f375885be57b35504903f9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaea7f09ab89f375885be57b35504903f9">regina::NDiscSpec</a></td></tr>
<tr class="memdesc:gaea7f09ab89f375885be57b35504903f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gaea7f09ab89f375885be57b35504903f9">More...</a><br /></td></tr>
<tr class="separator:gaea7f09ab89f375885be57b35504903f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga318507a759439c77b9434bb6850bdc7c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga318507a759439c77b9434bb6850bdc7c">regina::NDiscSetTet</a></td></tr>
<tr class="memdesc:ga318507a759439c77b9434bb6850bdc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga318507a759439c77b9434bb6850bdc7c">More...</a><br /></td></tr>
<tr class="separator:ga318507a759439c77b9434bb6850bdc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga36ba5f508fd4dc4737a800ec796cf8e6">regina::NDiscSetTetData</a> = <a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga36ba5f508fd4dc4737a800ec796cf8e6">More...</a><br /></td></tr>
<tr class="separator:ga36ba5f508fd4dc4737a800ec796cf8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014be930b28c03042f107405114409d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga014be930b28c03042f107405114409d4">regina::NDiscSetSurface</a></td></tr>
<tr class="memdesc:ga014be930b28c03042f107405114409d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga014be930b28c03042f107405114409d4">More...</a><br /></td></tr>
<tr class="separator:ga014be930b28c03042f107405114409d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3d65b1cb926fb791d18597bfac6ce3b7">regina::NDiscSetSurfaceData</a> = <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga3d65b1cb926fb791d18597bfac6ce3b7">More...</a><br /></td></tr>
<tr class="separator:ga3d65b1cb926fb791d18597bfac6ce3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2176828f10a7955938e520514257106a"><td class="memItemLeft" align="right" valign="top"><a id="ga2176828f10a7955938e520514257106a"></a>
typedef long&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::difference_type</b></td></tr>
<tr class="separator:ga2176828f10a7955938e520514257106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae4b71e322d2f5e21ad31b1a7ef299b"><td class="memItemLeft" align="right" valign="top"><a id="ga7ae4b71e322d2f5e21ad31b1a7ef299b"></a>
typedef const <a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::value_type</b></td></tr>
<tr class="separator:ga7ae4b71e322d2f5e21ad31b1a7ef299b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13975adf31a154fb608ecf939cb7f8f7"><td class="memItemLeft" align="right" valign="top"><a id="ga13975adf31a154fb608ecf939cb7f8f7"></a>
typedef const <a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::pointer</b></td></tr>
<tr class="separator:ga13975adf31a154fb608ecf939cb7f8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d140fcc5cf9997c9dc650bb6b4cc8a9"><td class="memItemLeft" align="right" valign="top"><a id="ga0d140fcc5cf9997c9dc650bb6b4cc8a9"></a>
typedef const <a class="el" href="structregina_1_1DiscSpec.html">regina::DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::reference</b></td></tr>
<tr class="separator:ga0d140fcc5cf9997c9dc650bb6b4cc8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d3e968559a5f3b076013effa9bbded"><td class="memItemLeft" align="right" valign="top"><a id="ga89d3e968559a5f3b076013effa9bbded"></a>
typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><b>std::iterator_traits&lt; regina::DiscSpecIterator &gt;::iterator_category</b></td></tr>
<tr class="separator:ga89d3e968559a5f3b076013effa9bbded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ef87df7daabeda40a127d961caedfc0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1DiscType.html">DiscType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1ef87df7daabeda40a127d961caedfc0">regina::NDiscType</a></td></tr>
<tr class="memdesc:ga1ef87df7daabeda40a127d961caedfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga1ef87df7daabeda40a127d961caedfc0">More...</a><br /></td></tr>
<tr class="separator:ga1ef87df7daabeda40a127d961caedfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; <a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">regina::NormalList</a></td></tr>
<tr class="memdesc:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal surface lists.  <a href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">More...</a><br /></td></tr>
<tr class="separator:ga10adc2dfa823f4b97db64abccdc7f73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga239df7c1e704457d116029fc144dc473"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt; <a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">regina::NormalAlg</a></td></tr>
<tr class="memdesc:ga239df7c1e704457d116029fc144dc473"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combination of flags for types of normal surface lists.  <a href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">More...</a><br /></td></tr>
<tr class="separator:ga239df7c1e704457d116029fc144dc473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e1de8b765f5bcd733cb5fe28063326"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga76e1de8b765f5bcd733cb5fe28063326">regina::NNormalSurfaceVector</a></td></tr>
<tr class="memdesc:ga76e1de8b765f5bcd733cb5fe28063326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga76e1de8b765f5bcd733cb5fe28063326">More...</a><br /></td></tr>
<tr class="separator:ga76e1de8b765f5bcd733cb5fe28063326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b1bb46b52686165041bff4d0936eda"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae6b1bb46b52686165041bff4d0936eda">regina::NNormalSurface</a></td></tr>
<tr class="memdesc:gae6b1bb46b52686165041bff4d0936eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gae6b1bb46b52686165041bff4d0936eda">More...</a><br /></td></tr>
<tr class="separator:gae6b1bb46b52686165041bff4d0936eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1651d8ca85f9e04cd7c4345e7660be7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac1651d8ca85f9e04cd7c4345e7660be7">regina::NNormalSurfaceList</a></td></tr>
<tr class="memdesc:gac1651d8ca85f9e04cd7c4345e7660be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gac1651d8ca85f9e04cd7c4345e7660be7">More...</a><br /></td></tr>
<tr class="separator:gac1651d8ca85f9e04cd7c4345e7660be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8962f2fc5b8ed3347b8157097de22f0f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorANStandard.html">NSVectorANStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8962f2fc5b8ed3347b8157097de22f0f">regina::NNormalSurfaceVectorANStandard</a></td></tr>
<tr class="memdesc:ga8962f2fc5b8ed3347b8157097de22f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga8962f2fc5b8ed3347b8157097de22f0f">More...</a><br /></td></tr>
<tr class="separator:ga8962f2fc5b8ed3347b8157097de22f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a007103e8da63d8e29f79a642df29c5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorMirrored.html">NSVectorMirrored</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3a007103e8da63d8e29f79a642df29c5">regina::NNormalSurfaceVectorMirrored</a></td></tr>
<tr class="memdesc:ga3a007103e8da63d8e29f79a642df29c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga3a007103e8da63d8e29f79a642df29c5">More...</a><br /></td></tr>
<tr class="separator:ga3a007103e8da63d8e29f79a642df29c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3d48602a97ee3e83d4407f341e6455"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorOriented.html">NSVectorOriented</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5b3d48602a97ee3e83d4407f341e6455">regina::NNormalSurfaceVectorOriented</a></td></tr>
<tr class="memdesc:ga5b3d48602a97ee3e83d4407f341e6455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga5b3d48602a97ee3e83d4407f341e6455">More...</a><br /></td></tr>
<tr class="separator:ga5b3d48602a97ee3e83d4407f341e6455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde6a7ffe1f773fa073d0bc33e4744f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorOrientedQuad.html">NSVectorOrientedQuad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaffde6a7ffe1f773fa073d0bc33e4744f">regina::NNormalSurfaceVectorOrientedQuad</a></td></tr>
<tr class="memdesc:gaffde6a7ffe1f773fa073d0bc33e4744f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gaffde6a7ffe1f773fa073d0bc33e4744f">More...</a><br /></td></tr>
<tr class="separator:gaffde6a7ffe1f773fa073d0bc33e4744f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc7349b11544a8b8d78c61e19daedc4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorQuad.html">NSVectorQuad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6dc7349b11544a8b8d78c61e19daedc4">regina::NNormalSurfaceVectorQuad</a></td></tr>
<tr class="memdesc:ga6dc7349b11544a8b8d78c61e19daedc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga6dc7349b11544a8b8d78c61e19daedc4">More...</a><br /></td></tr>
<tr class="separator:ga6dc7349b11544a8b8d78c61e19daedc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aa7bc30d85d431385818f616ebc5004"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorQuadOct.html">NSVectorQuadOct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6aa7bc30d85d431385818f616ebc5004">regina::NNormalSurfaceVectorQuadOct</a></td></tr>
<tr class="memdesc:ga6aa7bc30d85d431385818f616ebc5004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga6aa7bc30d85d431385818f616ebc5004">More...</a><br /></td></tr>
<tr class="separator:ga6aa7bc30d85d431385818f616ebc5004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7bc8620edc82bec1339e1460e7b1e75"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NSVectorStandard.html">NSVectorStandard</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad7bc8620edc82bec1339e1460e7b1e75">regina::NNormalSurfaceVectorStandard</a></td></tr>
<tr class="memdesc:gad7bc8620edc82bec1339e1460e7b1e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#gad7bc8620edc82bec1339e1460e7b1e75">More...</a><br /></td></tr>
<tr class="separator:gad7bc8620edc82bec1339e1460e7b1e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc97e79a145070e73896ab2b7730415"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga0dc97e79a145070e73896ab2b7730415">regina::NPrismSpec</a></td></tr>
<tr class="memdesc:ga0dc97e79a145070e73896ab2b7730415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga0dc97e79a145070e73896ab2b7730415">More...</a><br /></td></tr>
<tr class="separator:ga0dc97e79a145070e73896ab2b7730415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de04b41af82d94b20738074da3f97a3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6de04b41af82d94b20738074da3f97a3">regina::NSurfaceFilter</a></td></tr>
<tr class="memdesc:ga6de04b41af82d94b20738074da3f97a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga6de04b41af82d94b20738074da3f97a3">More...</a><br /></td></tr>
<tr class="separator:ga6de04b41af82d94b20738074da3f97a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cdc257da3694fba7fb12daf605240ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3cdc257da3694fba7fb12daf605240ba">regina::NSurfaceFilterCombination</a></td></tr>
<tr class="memdesc:ga3cdc257da3694fba7fb12daf605240ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga3cdc257da3694fba7fb12daf605240ba">More...</a><br /></td></tr>
<tr class="separator:ga3cdc257da3694fba7fb12daf605240ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51eaf1ba4c64a4761d40dffc506a2344"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga51eaf1ba4c64a4761d40dffc506a2344">regina::NSurfaceFilterProperties</a></td></tr>
<tr class="memdesc:ga51eaf1ba4c64a4761d40dffc506a2344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated typedef for backward compatibility.  <a href="group__surfaces.html#ga51eaf1ba4c64a4761d40dffc506a2344">More...</a><br /></td></tr>
<tr class="separator:ga51eaf1ba4c64a4761d40dffc506a2344"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a36273f97819ff462b10db091f8a93f75">regina::NS_STANDARD</a> = 0, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47af3d1b2ccecff610fdaae1e4f3dde0744">regina::NS_QUAD</a> = 1, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a676715b936f4d82fbf2cd2b66be3b5cf">regina::NS_QUAD_CLOSED</a> = 10, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47ad2d9d61fc90b31363ec5931b1a300aa8">regina::NS_AN_LEGACY</a> = 100, 
<br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a4a7e1fc6780905418e84cadf782dd82f">regina::NS_AN_QUAD_OCT</a> = 101, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a0de57480ceb39c23829e982e5bef7d84">regina::NS_AN_STANDARD</a> = 102, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a8ad2e142ae1dda418034657e42365d90">regina::NS_AN_QUAD_OCT_CLOSED</a> = 110, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae">regina::NS_EDGE_WEIGHT</a> = 200, 
<br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47ae8c39b9dd91ad81bf89ca633c8d9598f">regina::NS_TRIANGLE_ARCS</a> = 201, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a602873a7f7351b3822c37b075ba88c43">regina::NS_ORIENTED</a> = 300, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a205b46c71691c8092a5afa1d99ab556a">regina::NS_ORIENTED_QUAD</a> = 301, 
<a class="el" href="group__surfaces.html#gga9817fc7125c53daea4e3f3cbfe987a47a9f471af2d202b88f06ed65be82e5d7eb">regina::NS_ANGLE</a> = 400
<br />
 }</td></tr>
<tr class="memdesc:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different coordinate systems that can be used for enumerating and displaying normal surfaces.  <a href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">More...</a><br /></td></tr>
<tr class="separator:ga9817fc7125c53daea4e3f3cbfe987a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff25e58607c49cca84049a1069c2cce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">regina::NormalListFlags</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">regina::NS_LIST_DEFAULT</a> = 0x0000, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea41f7f2158c91f3f64f3354118f6a8761">regina::NS_EMBEDDED_ONLY</a> = 0x0001, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea1e0c5bf3f4138d8ec4a88caeb5f87a61">regina::NS_IMMERSED_SINGULAR</a> = 0x0002, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea38cd0d13c8afd0f688eda457d5ed550d">regina::NS_VERTEX</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea949286ba72f0deec9b6bbe2b8a23b39c">regina::NS_FUNDAMENTAL</a> = 0x0008, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2cceaab119737dcff1409ff0f2071baee7e40">regina::NS_LEGACY</a> = 0x4000, 
<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccea64cbdf1921e4a99c5943b4039dac2709">regina::NS_CUSTOM</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:gabff25e58607c49cca84049a1069c2cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation.  <a href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">More...</a><br /></td></tr>
<tr class="separator:gabff25e58607c49cca84049a1069c2cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">regina::NormalAlgFlags</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">regina::NS_ALG_DEFAULT</a> = 0x0000, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea4c4bfbfefa31e5c048a0d9e25abf9f89">regina::NS_VERTEX_VIA_REDUCED</a> = 0x0001, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea15bc7c42b8b986d93863600852d271c7">regina::NS_VERTEX_STD_DIRECT</a> = 0x0002, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea482b7e69b14c44d02b29055726b04830">regina::NS_VERTEX_TREE</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeac988e037d6c164c645567750680c6e11">regina::NS_VERTEX_DD</a> = 0x0020, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea33ff9b1fafe5bc6aa4dbf851ec2b9ae6">regina::NS_HILBERT_PRIMAL</a> = 0x0100, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea77887211e55db67ba4ba10247cd159f3">regina::NS_HILBERT_DUAL</a> = 0x0200, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea1da3bc474ed341903ab0f043488e27c3">regina::NS_HILBERT_CD</a> = 0x0400, 
<br />
&#160;&#160;<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea7d84f194dd4d881f2175acae85fa3742">regina::NS_HILBERT_FULLCONE</a> = 0x0800, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea61e5c6c91ab2a0c4ac8a6fca9cccd430">regina::NS_ALG_LEGACY</a> = 0x4000, 
<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedea6d1833185860331a3be3d7f909b1323a">regina::NS_ALG_CUSTOM</a> = 0x8000
<br />
 }</td></tr>
<tr class="memdesc:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations.  <a href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">More...</a><br /></td></tr>
<tr class="separator:ga3c4cfc5de652a5beaadaaee0cacdeede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae923c7c2fa692192d45bdf563f380918"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">regina::SurfaceExportFields</a> { <br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a81408d5dd0f9deb210bf66ecee761c36">regina::surfaceExportName</a> = 0x0001, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a131a23295ec061f83590561bba365de8">regina::surfaceExportEuler</a> = 0x0002, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a153a815a9b0f7d3b3383f39c2d6f94ca">regina::surfaceExportOrient</a> = 0x0004, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a60a48a7481d07261cf4a4051cffc3bc3">regina::surfaceExportSides</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918add63709fcbf9038110d4a3b232a466c2">regina::surfaceExportBdry</a> = 0x0010, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a0832d74579319961e0c6f976e28b0356">regina::surfaceExportLink</a> = 0x0020, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918acf49b97bd782901a7f6ee32bf9841b03">regina::surfaceExportType</a> = 0x0040, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a9b7d4c6f39579e1711b203dcf8ed3824">regina::surfaceExportNone</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918a90da6f93fd64f642efa8b5862d7b4dac">regina::surfaceExportAllButName</a> = 0x007e, 
<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a> = 0x007f
<br />
 }</td></tr>
<tr class="memdesc:gae923c7c2fa692192d45bdf563f380918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.  <a href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">More...</a><br /></td></tr>
<tr class="separator:gae923c7c2fa692192d45bdf563f380918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ab803471723156fb2ecb24b7b1c859"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a> { <a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004">regina::NS_FILTER_DEFAULT</a> = 0, 
<a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859abad02c85eeeda839925c60cd245fb478">regina::NS_FILTER_PROPERTIES</a> = 1, 
<a class="el" href="group__surfaces.html#gga38ab803471723156fb2ecb24b7b1c859a53350ed09529a46c5ed4298a14d9c6a2">regina::NS_FILTER_COMBINATION</a> = 2
 }</td></tr>
<tr class="memdesc:ga38ab803471723156fb2ecb24b7b1c859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations.  <a href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">More...</a><br /></td></tr>
<tr class="separator:ga38ab803471723156fb2ecb24b7b1c859"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadd13f0c33b3131122ddb15804973fd56"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gadd13f0c33b3131122ddb15804973fd56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadd13f0c33b3131122ddb15804973fd56">regina::forCoords</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, FunctionObject &amp;&amp;func, typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gadd13f0c33b3131122ddb15804973fd56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime.  <a href="group__surfaces.html#gadd13f0c33b3131122ddb15804973fd56">More...</a><br /></td></tr>
<tr class="separator:gadd13f0c33b3131122ddb15804973fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6bec1eb2ca5e5a7fd11bedfb1dee56f7">regina::forCoords</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords, FunctionObject &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime.  <a href="group__surfaces.html#ga6bec1eb2ca5e5a7fd11bedfb1dee56f7">More...</a><br /></td></tr>
<tr class="separator:ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d41a228f90e254a5707f175f55dfb39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9d41a228f90e254a5707f175f55dfb39">regina::DiscSpec::DiscSpec</a> ()</td></tr>
<tr class="memdesc:ga9d41a228f90e254a5707f175f55dfb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised disc specifier.  <a href="#ga9d41a228f90e254a5707f175f55dfb39">More...</a><br /></td></tr>
<tr class="separator:ga9d41a228f90e254a5707f175f55dfb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga185aaf4b2430cf3089dba1a4ddb83930"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga185aaf4b2430cf3089dba1a4ddb83930">regina::DiscSpec::DiscSpec</a> (size_t newTetIndex, int newType, unsigned long newNumber)</td></tr>
<tr class="memdesc:ga185aaf4b2430cf3089dba1a4ddb83930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc specifier containing the given values.  <a href="#ga185aaf4b2430cf3089dba1a4ddb83930">More...</a><br /></td></tr>
<tr class="separator:ga185aaf4b2430cf3089dba1a4ddb83930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga660af5ac1a6ab75d34c6671f2cebfa3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga660af5ac1a6ab75d34c6671f2cebfa3b">regina::DiscSpec::DiscSpec</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga660af5ac1a6ab75d34c6671f2cebfa3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc specifier that is a clone of the given specifier.  <a href="#ga660af5ac1a6ab75d34c6671f2cebfa3b">More...</a><br /></td></tr>
<tr class="separator:ga660af5ac1a6ab75d34c6671f2cebfa3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d24cc1a1425473f871d57828db512df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3d24cc1a1425473f871d57828db512df">regina::DiscSpec::operator=</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;cloneMe)=default</td></tr>
<tr class="memdesc:ga3d24cc1a1425473f871d57828db512df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the values from the given disc specifier into this specifier.  <a href="#ga3d24cc1a1425473f871d57828db512df">More...</a><br /></td></tr>
<tr class="separator:ga3d24cc1a1425473f871d57828db512df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b7d3518b9329fe520e02ecfb37ac19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae9b7d3518b9329fe520e02ecfb37ac19">regina::DiscSpec::operator==</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:gae9b7d3518b9329fe520e02ecfb37ac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given disc specifier contain identical information.  <a href="#gae9b7d3518b9329fe520e02ecfb37ac19">More...</a><br /></td></tr>
<tr class="separator:gae9b7d3518b9329fe520e02ecfb37ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga429fbf9409a23f162b99f1e3e7ecc39e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga429fbf9409a23f162b99f1e3e7ecc39e">regina::DiscSpec::operator !=</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;other) const</td></tr>
<tr class="memdesc:ga429fbf9409a23f162b99f1e3e7ecc39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given disc specifier contain different information.  <a href="#ga429fbf9409a23f162b99f1e3e7ecc39e">More...</a><br /></td></tr>
<tr class="separator:ga429fbf9409a23f162b99f1e3e7ecc39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdd4772a47d25242a4afeaaef48aca4f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabdd4772a47d25242a4afeaaef48aca4f">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:gabdd4772a47d25242a4afeaaef48aca4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc specifier to the given output stream.  <a href="group__surfaces.html#gabdd4772a47d25242a4afeaaef48aca4f">More...</a><br /></td></tr>
<tr class="separator:gabdd4772a47d25242a4afeaaef48aca4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga17dfc1f57595cbc9ec5662a76d25c161">regina::numberDiscsAwayFromVertex</a> (int discType, int vertex)</td></tr>
<tr class="memdesc:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not normal discs of the given type are numbered away from the given vertex.  <a href="group__surfaces.html#ga17dfc1f57595cbc9ec5662a76d25c161">More...</a><br /></td></tr>
<tr class="separator:ga17dfc1f57595cbc9ec5662a76d25c161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc8d5800d8613931ff0483a8388308c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaacc8d5800d8613931ff0483a8388308c">regina::discOrientationFollowsEdge</a> (int discType, int vertex, int edgeStart, int edgeEnd)</td></tr>
<tr class="memdesc:gaacc8d5800d8613931ff0483a8388308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc.  <a href="group__surfaces.html#gaacc8d5800d8613931ff0483a8388308c">More...</a><br /></td></tr>
<tr class="separator:gaacc8d5800d8613931ff0483a8388308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe441060b0e0bf2334000a5a3deb33a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gabe441060b0e0bf2334000a5a3deb33a2">regina::DiscSetTet::DiscSetTet</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, size_t tetIndex)</td></tr>
<tr class="memdesc:gabe441060b0e0bf2334000a5a3deb33a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal discs corresponding to the discs of the given normal surface that lie within the given tetrahedron.  <a href="#gabe441060b0e0bf2334000a5a3deb33a2">More...</a><br /></td></tr>
<tr class="separator:gabe441060b0e0bf2334000a5a3deb33a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7f0f6d8f893f8f8e7f971c6eff4b7c1b">regina::DiscSetTet::DiscSetTet</a> (unsigned long tri0, unsigned long tri1, unsigned long tri2, unsigned long tri3, unsigned long quad0, unsigned long quad1, unsigned long quad2, unsigned long oct0=0, unsigned long oct1=0, unsigned long oct2=0)</td></tr>
<tr class="memdesc:ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal discs where the number of discs of each type is explicitly given.  <a href="#ga7f0f6d8f893f8f8e7f971c6eff4b7c1b">More...</a><br /></td></tr>
<tr class="separator:ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70df6a9c427d5d3647407cfbb46052c7"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga70df6a9c427d5d3647407cfbb46052c7">regina::DiscSetTet::~DiscSetTet</a> ()</td></tr>
<tr class="memdesc:ga70df6a9c427d5d3647407cfbb46052c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this disc set.  <a href="#ga70df6a9c427d5d3647407cfbb46052c7">More...</a><br /></td></tr>
<tr class="separator:ga70df6a9c427d5d3647407cfbb46052c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cc0ec5a7a3f45404ca2933f153a108"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga10cc0ec5a7a3f45404ca2933f153a108">regina::DiscSetTet::nDiscs</a> (int type) const</td></tr>
<tr class="memdesc:ga10cc0ec5a7a3f45404ca2933f153a108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of discs of the given type inside this tetrahedron.  <a href="#ga10cc0ec5a7a3f45404ca2933f153a108">More...</a><br /></td></tr>
<tr class="separator:ga10cc0ec5a7a3f45404ca2933f153a108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccafa8884a778da2a68041bbc3c0f0f9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaccafa8884a778da2a68041bbc3c0f0f9">regina::DiscSetTet::arcFromDisc</a> (int arcFace, int arcVertex, int discType, unsigned long discNumber) const</td></tr>
<tr class="memdesc:gaccafa8884a778da2a68041bbc3c0f0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which normal arc of a given type on a given face of this tetrahedron corresponds to the given normal disc.  <a href="#gaccafa8884a778da2a68041bbc3c0f0f9">More...</a><br /></td></tr>
<tr class="separator:gaccafa8884a778da2a68041bbc3c0f0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga00a3f5bdb957c5b10c0b5ec9ebfbe94a">regina::DiscSetTet::discFromArc</a> (int arcFace, int arcVertex, unsigned long arcNumber, int &amp;discType, unsigned long &amp;discNumber) const</td></tr>
<tr class="memdesc:ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which normal disc in this tetrahedron meets the given normal arc on the given face.  <a href="#ga00a3f5bdb957c5b10c0b5ec9ebfbe94a">More...</a><br /></td></tr>
<tr class="separator:ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97b82d38101ec729082b2a2e54180c27"><td class="memItemLeft" align="right" valign="top"><a id="ga97b82d38101ec729082b2a2e54180c27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTet::DiscSetTet</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga97b82d38101ec729082b2a2e54180c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga940c62e36c1949d49df9e0e445d5eeaa"><td class="memItemLeft" align="right" valign="top"><a id="ga940c62e36c1949d49df9e0e445d5eeaa"></a>
<a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTet::operator=</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga940c62e36c1949d49df9e0e445d5eeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4526a51c67f6cc9b10a4dad45a1f1686"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4526a51c67f6cc9b10a4dad45a1f1686">regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, size_t tetIndex)</td></tr>
<tr class="memdesc:ga4526a51c67f6cc9b10a4dad45a1f1686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron.  <a href="#ga4526a51c67f6cc9b10a4dad45a1f1686">More...</a><br /></td></tr>
<tr class="separator:ga4526a51c67f6cc9b10a4dad45a1f1686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe87cf10ed4fd6e10266bd92cabda4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8fe87cf10ed4fd6e10266bd92cabda4e">regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, size_t tetIndex, const T &amp;initValue)</td></tr>
<tr class="memdesc:ga8fe87cf10ed4fd6e10266bd92cabda4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron.  <a href="#ga8fe87cf10ed4fd6e10266bd92cabda4e">More...</a><br /></td></tr>
<tr class="separator:ga8fe87cf10ed4fd6e10266bd92cabda4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c5875e05c90ed38f5384735bcac92d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6c5875e05c90ed38f5384735bcac92d8">regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</a> (unsigned long tri0, unsigned long tri1, unsigned long tri2, unsigned long tri3, unsigned long quad0, unsigned long quad1, unsigned long quad2, unsigned long oct0=0, unsigned long oct1=0, unsigned long oct2=0)</td></tr>
<tr class="memdesc:ga6c5875e05c90ed38f5384735bcac92d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set where the number of discs of each type is explicitly given.  <a href="#ga6c5875e05c90ed38f5384735bcac92d8">More...</a><br /></td></tr>
<tr class="separator:ga6c5875e05c90ed38f5384735bcac92d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce3172b88a1b68738f19ea48c734932"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadce3172b88a1b68738f19ea48c734932">regina::DiscSetTetData&lt; T &gt;::~DiscSetTetData</a> ()</td></tr>
<tr class="memdesc:gadce3172b88a1b68738f19ea48c734932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this disc set and deallocates all data arrays.  <a href="#gadce3172b88a1b68738f19ea48c734932">More...</a><br /></td></tr>
<tr class="separator:gadce3172b88a1b68738f19ea48c734932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b40482617d929f84c1f8eeb7e00ff92"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga3b40482617d929f84c1f8eeb7e00ff92">regina::DiscSetTetData&lt; T &gt;::data</a> (int discType, unsigned long discNumber)</td></tr>
<tr class="memdesc:ga3b40482617d929f84c1f8eeb7e00ff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the data corresponding to the given normal disc.  <a href="#ga3b40482617d929f84c1f8eeb7e00ff92">More...</a><br /></td></tr>
<tr class="separator:ga3b40482617d929f84c1f8eeb7e00ff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga275bdf9d54ac076e911bbc409cfa89ee"><td class="memItemLeft" align="right" valign="top"><a id="ga275bdf9d54ac076e911bbc409cfa89ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTetData&lt; T &gt;::DiscSetTetData</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga275bdf9d54ac076e911bbc409cfa89ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3af2b04943dce588782cadc7441dfd"><td class="memItemLeft" align="right" valign="top"><a id="ga7b3af2b04943dce588782cadc7441dfd"></a>
<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetTetData&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;)=delete</td></tr>
<tr class="separator:ga7b3af2b04943dce588782cadc7441dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc5a059c5627c16967d7438dc742fca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9bc5a059c5627c16967d7438dc742fca">regina::DiscSetSurface::DiscSetSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, bool b)</td></tr>
<tr class="memdesc:ga9bc5a059c5627c16967d7438dc742fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="#ga9bc5a059c5627c16967d7438dc742fca">More...</a><br /></td></tr>
<tr class="separator:ga9bc5a059c5627c16967d7438dc742fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7d4e0bcd28a1aba2869b9db72e6c48f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad7d4e0bcd28a1aba2869b9db72e6c48f">regina::DiscSetSurface::DiscSetSurface</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface)</td></tr>
<tr class="memdesc:gad7d4e0bcd28a1aba2869b9db72e6c48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="#gad7d4e0bcd28a1aba2869b9db72e6c48f">More...</a><br /></td></tr>
<tr class="separator:gad7d4e0bcd28a1aba2869b9db72e6c48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga124a63e9a57ffc4fff0fef553fa2862c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga124a63e9a57ffc4fff0fef553fa2862c">regina::DiscSetSurface::~DiscSetSurface</a> ()</td></tr>
<tr class="memdesc:ga124a63e9a57ffc4fff0fef553fa2862c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this set of discs and deallocates all associated memory.  <a href="#ga124a63e9a57ffc4fff0fef553fa2862c">More...</a><br /></td></tr>
<tr class="separator:ga124a63e9a57ffc4fff0fef553fa2862c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4244895ae54265d8c0544ee65370483"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac4244895ae54265d8c0544ee65370483">regina::DiscSetSurface::nTets</a> () const</td></tr>
<tr class="memdesc:gac4244895ae54265d8c0544ee65370483"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in the underlying triangulation.  <a href="#gac4244895ae54265d8c0544ee65370483">More...</a><br /></td></tr>
<tr class="separator:gac4244895ae54265d8c0544ee65370483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf48dd20fe6cfdd7e9f41e919b577b8b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacf48dd20fe6cfdd7e9f41e919b577b8b">regina::DiscSetSurface::nDiscs</a> (size_t tetIndex, int type) const</td></tr>
<tr class="memdesc:gacf48dd20fe6cfdd7e9f41e919b577b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of discs of the given type inside the given tetrahedron.  <a href="#gacf48dd20fe6cfdd7e9f41e919b577b8b">More...</a><br /></td></tr>
<tr class="separator:gacf48dd20fe6cfdd7e9f41e919b577b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6318837e6c80c4648a7971e038db9d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga6318837e6c80c4648a7971e038db9d6f">regina::DiscSetSurface::tetDiscs</a> (size_t tetIndex) const</td></tr>
<tr class="memdesc:ga6318837e6c80c4648a7971e038db9d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific set of discs living inside the given tetrahedron.  <a href="#ga6318837e6c80c4648a7971e038db9d6f">More...</a><br /></td></tr>
<tr class="separator:ga6318837e6c80c4648a7971e038db9d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14859baec94b6d792d0234fa2c4def8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga14859baec94b6d792d0234fa2c4def8e">regina::DiscSetSurface::adjacentDisc</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;disc, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; arc, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; &amp;adjArc) const</td></tr>
<tr class="memdesc:ga14859baec94b6d792d0234fa2c4def8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which normal disc is adjacent to the given normal disc along the given directed normal arc in the surface described by this disc set.  <a href="#ga14859baec94b6d792d0234fa2c4def8e">More...</a><br /></td></tr>
<tr class="separator:ga14859baec94b6d792d0234fa2c4def8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bcb320960af2e96d587cc40549a48c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c">regina::DiscSetSurface::begin</a> () const</td></tr>
<tr class="memdesc:gaf1bcb320960af2e96d587cc40549a48c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of all normal discs in the underlying normal surface.  <a href="#gaf1bcb320960af2e96d587cc40549a48c">More...</a><br /></td></tr>
<tr class="separator:gaf1bcb320960af2e96d587cc40549a48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26003982483e680a1c073ab250702d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae26003982483e680a1c073ab250702d2">regina::DiscSetSurface::end</a> () const</td></tr>
<tr class="memdesc:gae26003982483e680a1c073ab250702d2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of all normal discs in the underlying normal surface.  <a href="#gae26003982483e680a1c073ab250702d2">More...</a><br /></td></tr>
<tr class="separator:gae26003982483e680a1c073ab250702d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa98fc1d32bd109ee9a706f82647f98c2"><td class="memItemLeft" align="right" valign="top"><a id="gaa98fc1d32bd109ee9a706f82647f98c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurface::DiscSetSurface</b> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;)=delete</td></tr>
<tr class="separator:gaa98fc1d32bd109ee9a706f82647f98c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb651be00fdccfe7832199490356c459"><td class="memItemLeft" align="right" valign="top"><a id="gafb651be00fdccfe7832199490356c459"></a>
<a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurface::operator=</b> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;)=delete</td></tr>
<tr class="separator:gafb651be00fdccfe7832199490356c459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351ff55619cc35b42f37ddb369e0fcc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga351ff55619cc35b42f37ddb369e0fcc9">regina::DiscSetSurfaceData&lt; T &gt;::DiscSetSurfaceData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface)</td></tr>
<tr class="memdesc:ga351ff55619cc35b42f37ddb369e0fcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="#ga351ff55619cc35b42f37ddb369e0fcc9">More...</a><br /></td></tr>
<tr class="separator:ga351ff55619cc35b42f37ddb369e0fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c7e00d669bca83a672de12e45f627c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga97c7e00d669bca83a672de12e45f627c">regina::DiscSetSurfaceData&lt; T &gt;::DiscSetSurfaceData</a> (const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;surface, const T &amp;initValue)</td></tr>
<tr class="memdesc:ga97c7e00d669bca83a672de12e45f627c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new disc set corresponding to the discs of the given normal surface.  <a href="#ga97c7e00d669bca83a672de12e45f627c">More...</a><br /></td></tr>
<tr class="separator:ga97c7e00d669bca83a672de12e45f627c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab688229f8a6ef82f631b8e77e82def0"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaab688229f8a6ef82f631b8e77e82def0">regina::DiscSetSurfaceData&lt; T &gt;::data</a> (const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;disc)</td></tr>
<tr class="memdesc:gaab688229f8a6ef82f631b8e77e82def0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a reference to the data corresponding to the given normal disc.  <a href="#gaab688229f8a6ef82f631b8e77e82def0">More...</a><br /></td></tr>
<tr class="separator:gaab688229f8a6ef82f631b8e77e82def0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccbb0096eb72d35f6db6481943b7eefe"><td class="memItemLeft" align="right" valign="top"><a id="gaccbb0096eb72d35f6db6481943b7eefe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurfaceData&lt; T &gt;::DiscSetSurfaceData</b> (const <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> &amp;)=delete</td></tr>
<tr class="separator:gaccbb0096eb72d35f6db6481943b7eefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e02b86250fd6eb7a88a1acc6c16293"><td class="memItemLeft" align="right" valign="top"><a id="gac4e02b86250fd6eb7a88a1acc6c16293"></a>
<a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSetSurfaceData&lt; T &gt;::operator=</b> (const <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> &amp;)=delete</td></tr>
<tr class="separator:gac4e02b86250fd6eb7a88a1acc6c16293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e169fff6424f1acf397c42bca638b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa9e169fff6424f1acf397c42bca638b7">regina::DiscSpecIterator::DiscSpecIterator</a> ()</td></tr>
<tr class="memdesc:gaa9e169fff6424f1acf397c42bca638b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new uninitialised iterator.  <a href="#gaa9e169fff6424f1acf397c42bca638b7">More...</a><br /></td></tr>
<tr class="separator:gaa9e169fff6424f1acf397c42bca638b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a16a72e475679372711d2a9c8ce32c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac2a16a72e475679372711d2a9c8ce32c">regina::DiscSpecIterator::DiscSpecIterator</a> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;discSet)</td></tr>
<tr class="memdesc:gac2a16a72e475679372711d2a9c8ce32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new iterator pointing to the first disc in the given disc set.  <a href="#gac2a16a72e475679372711d2a9c8ce32c">More...</a><br /></td></tr>
<tr class="separator:gac2a16a72e475679372711d2a9c8ce32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21a02ea41beef23675e3133af8eea0bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga21a02ea41beef23675e3133af8eea0bc">regina::DiscSpecIterator::DiscSpecIterator</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:ga21a02ea41beef23675e3133af8eea0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="#ga21a02ea41beef23675e3133af8eea0bc">More...</a><br /></td></tr>
<tr class="separator:ga21a02ea41beef23675e3133af8eea0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2f9987a917198b7fbe777fdb37c3511"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad2f9987a917198b7fbe777fdb37c3511">regina::DiscSpecIterator::init</a> (const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;discSet)</td></tr>
<tr class="memdesc:gad2f9987a917198b7fbe777fdb37c3511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points this iterator to the first disc in the given disc set.  <a href="#gad2f9987a917198b7fbe777fdb37c3511">More...</a><br /></td></tr>
<tr class="separator:gad2f9987a917198b7fbe777fdb37c3511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6e86b724a23f0be60c43ffdae7c037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaeb6e86b724a23f0be60c43ffdae7c037">regina::DiscSpecIterator::operator=</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;)=default</td></tr>
<tr class="memdesc:gaeb6e86b724a23f0be60c43ffdae7c037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment operator.  <a href="#gaeb6e86b724a23f0be60c43ffdae7c037">More...</a><br /></td></tr>
<tr class="separator:gaeb6e86b724a23f0be60c43ffdae7c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47ea429f2da590de2bb9552562a1fa22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga47ea429f2da590de2bb9552562a1fa22">regina::DiscSpecIterator::operator++</a> ()</td></tr>
<tr class="memdesc:ga47ea429f2da590de2bb9552562a1fa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preincrement operator.  <a href="#ga47ea429f2da590de2bb9552562a1fa22">More...</a><br /></td></tr>
<tr class="separator:ga47ea429f2da590de2bb9552562a1fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f06d8171f9e775f0a80889c0501ba65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9f06d8171f9e775f0a80889c0501ba65">regina::DiscSpecIterator::operator++</a> (int)</td></tr>
<tr class="memdesc:ga9f06d8171f9e775f0a80889c0501ba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postincrement operator.  <a href="#ga9f06d8171f9e775f0a80889c0501ba65">More...</a><br /></td></tr>
<tr class="separator:ga9f06d8171f9e775f0a80889c0501ba65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacadbbafff2133bc6f5de417feeb01a4a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gacadbbafff2133bc6f5de417feeb01a4a">regina::DiscSpecIterator::operator *</a> () const</td></tr>
<tr class="memdesc:gacadbbafff2133bc6f5de417feeb01a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the disc pointed to by this iterator.  <a href="#gacadbbafff2133bc6f5de417feeb01a4a">More...</a><br /></td></tr>
<tr class="separator:gacadbbafff2133bc6f5de417feeb01a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2e60e17d1ef726a70b9393638f09fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1d2e60e17d1ef726a70b9393638f09fa">regina::DiscSpecIterator::done</a> () const</td></tr>
<tr class="memdesc:ga1d2e60e17d1ef726a70b9393638f09fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this iterator is past-the-end.  <a href="#ga1d2e60e17d1ef726a70b9393638f09fa">More...</a><br /></td></tr>
<tr class="separator:ga1d2e60e17d1ef726a70b9393638f09fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad214e90993b4a051e3029c7e75c7d83a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad214e90993b4a051e3029c7e75c7d83a">regina::DiscSpecIterator::operator==</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:gad214e90993b4a051e3029c7e75c7d83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given iterator are equal.  <a href="#gad214e90993b4a051e3029c7e75c7d83a">More...</a><br /></td></tr>
<tr class="separator:gad214e90993b4a051e3029c7e75c7d83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9851f970d780a428a60e0f7dbae2021f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga9851f970d780a428a60e0f7dbae2021f">regina::DiscSpecIterator::operator !=</a> (const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;other) const</td></tr>
<tr class="memdesc:ga9851f970d780a428a60e0f7dbae2021f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this and the given iterator are different.  <a href="#ga9851f970d780a428a60e0f7dbae2021f">More...</a><br /></td></tr>
<tr class="separator:ga9851f970d780a428a60e0f7dbae2021f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4d42ed9b68e522ff445b5d3e777176f4">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;type)</td></tr>
<tr class="memdesc:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc type to the given output stream.  <a href="group__surfaces.html#ga4d42ed9b68e522ff445b5d3e777176f4">More...</a><br /></td></tr>
<tr class="separator:ga4d42ed9b68e522ff445b5d3e777176f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfcdfb4006b01269d80720b647e1dc37"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:gadfcdfb4006b01269d80720b647e1dc37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37">regina::forFilter</a> (<a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filter, FunctionObject &amp;&amp;func, typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType defaultReturn, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gadfcdfb4006b01269d80720b647e1dc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime.  <a href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37">More...</a><br /></td></tr>
<tr class="separator:gadfcdfb4006b01269d80720b647e1dc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="memTemplParams" colspan="2">template&lt;typename FunctionObject , typename... Args&gt; </td></tr>
<tr class="memitem:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::Void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga5af9e496cbc7b631780b88a04e7e04b0">regina::forFilter</a> (<a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filter, FunctionObject &amp;&amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime.  <a href="group__surfaces.html#ga5af9e496cbc7b631780b88a04e7e04b0">More...</a><br /></td></tr>
<tr class="separator:ga5af9e496cbc7b631780b88a04e7e04b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae92f3f038eac514d3e599ff3d92d8485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae92f3f038eac514d3e599ff3d92d8485">regina::operator|</a> (<a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a> lhs, <a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a> rhs)</td></tr>
<tr class="memdesc:gae92f3f038eac514d3e599ff3d92d8485"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="group__surfaces.html#gae92f3f038eac514d3e599ff3d92d8485">More...</a><br /></td></tr>
<tr class="separator:gae92f3f038eac514d3e599ff3d92d8485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4428e0ba8bfcc8083b37e9e3e2220c96">regina::operator|</a> (<a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a> lhs, <a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a> rhs)</td></tr>
<tr class="memdesc:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags.  <a href="group__surfaces.html#ga4428e0ba8bfcc8083b37e9e3e2220c96">More...</a><br /></td></tr>
<tr class="separator:ga4428e0ba8bfcc8083b37e9e3e2220c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eda282781417dd21160e899db7d8bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2eda282781417dd21160e899db7d8bfb">regina::makeZeroVector</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga2eda282781417dd21160e899db7d8bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and the given coordinate system.  <a href="group__surfaces.html#ga2eda282781417dd21160e899db7d8bfb">More...</a><br /></td></tr>
<tr class="separator:ga2eda282781417dd21160e899db7d8bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a886092529bcf35c5e6def77e18c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga15a886092529bcf35c5e6def77e18c64">regina::makeMatchingEquations</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:ga15a886092529bcf35c5e6def77e18c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of normal surface matching equations for the given triangulation using the given coordinate system.  <a href="group__surfaces.html#ga15a886092529bcf35c5e6def77e18c64">More...</a><br /></td></tr>
<tr class="separator:ga15a886092529bcf35c5e6def77e18c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeffc85eaf2fc2c37cf1e6fb87f951b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaeeffc85eaf2fc2c37cf1e6fb87f951b9">regina::makeEmbeddedConstraints</a> (const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *triangulation, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coords)</td></tr>
<tr class="memdesc:gaeeffc85eaf2fc2c37cf1e6fb87f951b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new set of validity constraints representing the condition that normal surfaces be embedded.  <a href="group__surfaces.html#gaeeffc85eaf2fc2c37cf1e6fb87f951b9">More...</a><br /></td></tr>
<tr class="separator:gaeeffc85eaf2fc2c37cf1e6fb87f951b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73fa623e9df3fbdffe981d730ced7f2"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf73fa623e9df3fbdffe981d730ced7f2">regina::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:gaf73fa623e9df3fbdffe981d730ced7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given prism specifier to the given output stream.  <a href="group__surfaces.html#gaf73fa623e9df3fbdffe981d730ced7f2">More...</a><br /></td></tr>
<tr class="separator:gaf73fa623e9df3fbdffe981d730ced7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gac5261f157c24a778410b72973a29d8f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac5261f157c24a778410b72973a29d8f4">regina::DiscSpec::tetIndex</a></td></tr>
<tr class="memdesc:gac5261f157c24a778410b72973a29d8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index in the triangulation of the tetrahedron containing the disc.  <a href="#gac5261f157c24a778410b72973a29d8f4">More...</a><br /></td></tr>
<tr class="separator:gac5261f157c24a778410b72973a29d8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65724d286ef5ccb7750731c6661d3ed8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga65724d286ef5ccb7750731c6661d3ed8">regina::DiscSpec::type</a></td></tr>
<tr class="memdesc:ga65724d286ef5ccb7750731c6661d3ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc type; this is between 0 and 9 inclusive, as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes.  <a href="#ga65724d286ef5ccb7750731c6661d3ed8">More...</a><br /></td></tr>
<tr class="separator:ga65724d286ef5ccb7750731c6661d3ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a135b6871de3392dd31f8da6eda4fb"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaa6a135b6871de3392dd31f8da6eda4fb">regina::DiscSpec::number</a></td></tr>
<tr class="memdesc:gaa6a135b6871de3392dd31f8da6eda4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies which disc of the particular type in the particular tetrahedron is being referred to; discs are numbered as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes.  <a href="#gaa6a135b6871de3392dd31f8da6eda4fb">More...</a><br /></td></tr>
<tr class="separator:gaa6a135b6871de3392dd31f8da6eda4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbb5afac6d75ceab81eaaea50673d44a"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gafbb5afac6d75ceab81eaaea50673d44a">regina::DiscSetTet::internalNDiscs</a> [10]</td></tr>
<tr class="memdesc:gafbb5afac6d75ceab81eaaea50673d44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of discs of each type.  <a href="#gafbb5afac6d75ceab81eaaea50673d44a">More...</a><br /></td></tr>
<tr class="separator:gafbb5afac6d75ceab81eaaea50673d44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca315fbe07e6aee27bf13647db6aa6b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">DataPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaca315fbe07e6aee27bf13647db6aa6b6">regina::DiscSetTetData&lt; T &gt;::internalData</a> [10]</td></tr>
<tr class="memdesc:gaca315fbe07e6aee27bf13647db6aa6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the data corresponding to each normal disc.  <a href="#gaca315fbe07e6aee27bf13647db6aa6b6">More...</a><br /></td></tr>
<tr class="separator:gaca315fbe07e6aee27bf13647db6aa6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0f57cc02ce279ec26f660c6afe1748a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gad0f57cc02ce279ec26f660c6afe1748a">regina::DiscSetSurface::discSets</a></td></tr>
<tr class="memdesc:gad0f57cc02ce279ec26f660c6afe1748a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc sets corresponding to each tetrahedron.  <a href="#gad0f57cc02ce279ec26f660c6afe1748a">More...</a><br /></td></tr>
<tr class="separator:gad0f57cc02ce279ec26f660c6afe1748a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a22ab75ad4c87286476a25ca1c8e5a7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga2a22ab75ad4c87286476a25ca1c8e5a7">regina::DiscSetSurface::triangulation</a></td></tr>
<tr class="memdesc:ga2a22ab75ad4c87286476a25ca1c8e5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The triangulation in which the normal surface lives.  <a href="#ga2a22ab75ad4c87286476a25ca1c8e5a7">More...</a><br /></td></tr>
<tr class="separator:ga2a22ab75ad4c87286476a25ca1c8e5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343e081f5dee36db898b93f087de6b2e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga343e081f5dee36db898b93f087de6b2e">regina::DiscSpecIterator::internalDiscSet</a></td></tr>
<tr class="memdesc:ga343e081f5dee36db898b93f087de6b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc set through which we are iterating.  <a href="#ga343e081f5dee36db898b93f087de6b2e">More...</a><br /></td></tr>
<tr class="separator:ga343e081f5dee36db898b93f087de6b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07af029fdcbe831f24700d44be47231"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gaf07af029fdcbe831f24700d44be47231">regina::DiscSpecIterator::current</a></td></tr>
<tr class="memdesc:gaf07af029fdcbe831f24700d44be47231"><td class="mdescLeft">&#160;</td><td class="mdescRight">The disc currently pointed to.  <a href="#gaf07af029fdcbe831f24700d44be47231">More...</a><br /></td></tr>
<tr class="separator:gaf07af029fdcbe831f24700d44be47231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac514ed78842ca859a43dcd7a973db246"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246">regina::quadSeparating</a> [4][4]</td></tr>
<tr class="memdesc:gac514ed78842ca859a43dcd7a973db246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.  <a href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246">More...</a><br /></td></tr>
<tr class="separator:gac514ed78842ca859a43dcd7a973db246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dd2a65f964363e8b619487011a4805"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga07dd2a65f964363e8b619487011a4805">regina::quadMeeting</a> [4][4][2]</td></tr>
<tr class="memdesc:ga07dd2a65f964363e8b619487011a4805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which quadrilateral types meet which edges in a tetrahedron.  <a href="group__surfaces.html#ga07dd2a65f964363e8b619487011a4805">More...</a><br /></td></tr>
<tr class="separator:ga07dd2a65f964363e8b619487011a4805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8920a1e646a768ea0eb9c40f904813fd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga8920a1e646a768ea0eb9c40f904813fd">regina::quadDefn</a> [3][4]</td></tr>
<tr class="memdesc:ga8920a1e646a768ea0eb9c40f904813fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists which vertices each quadrilateral type separates in a tetrahedron.  <a href="group__surfaces.html#ga8920a1e646a768ea0eb9c40f904813fd">More...</a><br /></td></tr>
<tr class="separator:ga8920a1e646a768ea0eb9c40f904813fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac06d9e3981cbce33198558cb05246502"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gac06d9e3981cbce33198558cb05246502">regina::quadPartner</a> [3][4]</td></tr>
<tr class="memdesc:gac06d9e3981cbce33198558cb05246502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron.  <a href="group__surfaces.html#gac06d9e3981cbce33198558cb05246502">More...</a><br /></td></tr>
<tr class="separator:gac06d9e3981cbce33198558cb05246502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4061f33eff68ee48a6acc372a53676b1"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga4061f33eff68ee48a6acc372a53676b1">regina::quadString</a> [3][6]</td></tr>
<tr class="memdesc:ga4061f33eff68ee48a6acc372a53676b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains strings that can be used to represent each quadrilateral type in a tetrahedron.  <a href="group__surfaces.html#ga4061f33eff68ee48a6acc372a53676b1">More...</a><br /></td></tr>
<tr class="separator:ga4061f33eff68ee48a6acc372a53676b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed7e2568c2e6085550dec8b1ff5eeb1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga1ed7e2568c2e6085550dec8b1ff5eeb1">regina::triDiscArcs</a> [4][3]</td></tr>
<tr class="memdesc:ga1ed7e2568c2e6085550dec8b1ff5eeb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc.  <a href="group__surfaces.html#ga1ed7e2568c2e6085550dec8b1ff5eeb1">More...</a><br /></td></tr>
<tr class="separator:ga1ed7e2568c2e6085550dec8b1ff5eeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga315832a821efcad8d12ee4d0158a0bbd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga315832a821efcad8d12ee4d0158a0bbd">regina::quadDiscArcs</a> [3][4]</td></tr>
<tr class="memdesc:ga315832a821efcad8d12ee4d0158a0bbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc.  <a href="group__surfaces.html#ga315832a821efcad8d12ee4d0158a0bbd">More...</a><br /></td></tr>
<tr class="separator:ga315832a821efcad8d12ee4d0158a0bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d5fc76b76881cf4851d177f1adb912"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#gae3d5fc76b76881cf4851d177f1adb912">regina::octDiscArcs</a> [3][8]</td></tr>
<tr class="memdesc:gae3d5fc76b76881cf4851d177f1adb912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc.  <a href="group__surfaces.html#gae3d5fc76b76881cf4851d177f1adb912">More...</a><br /></td></tr>
<tr class="separator:gae3d5fc76b76881cf4851d177f1adb912"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friend-members"></a>
Friends</h2></td></tr>
<tr class="memitem:ga4e45dad662fb0b7b4a52ae8711c11801"><td class="memItemLeft" align="right" valign="top"><a id="ga4e45dad662fb0b7b4a52ae8711c11801"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>regina::DiscSpecIterator::DiscSetSurface</b></td></tr>
<tr class="separator:ga4e45dad662fb0b7b4a52ae8711c11801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dafddbd2002f15da2be17a09289f05e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__surfaces.html#ga7dafddbd2002f15da2be17a09289f05e">regina::DiscSpec::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;spec)</td></tr>
<tr class="memdesc:ga7dafddbd2002f15da2be17a09289f05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the given disc specifier to the given output stream.  <a href="#ga7dafddbd2002f15da2be17a09289f05e">More...</a><br /></td></tr>
<tr class="separator:ga7dafddbd2002f15da2be17a09289f05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Normal surfaces in 3-manifold triangulations. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga28d182dc4885f0c9045d90e6e7c259ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d182dc4885f0c9045d90e6e7c259ad">&#9670;&nbsp;</a></span>REGINA_NORMAL_SURFACE_FLAVOUR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_NORMAL_SURFACE_FLAVOUR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">superclass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>: \</div><div class="line">        typedef NormalInfo&lt;id&gt; Info; \</div><div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> coordsID = id; \</div><div class="line">        inline class_(<span class="keyword">const</span> class_&amp; cloneMe) : \</div><div class="line">                superclass(cloneMe.coords()) {} \</div><div class="line">        inline <span class="keyword">virtual</span> NormalSurfaceVector* clone()<span class="keyword"> const override </span>{ \</div><div class="line">            return <span class="keyword">new</span> class_(*<span class="keyword">this</span>); \</div><div class="line">        } \</div><div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsAlmostNormal()<span class="keyword"> const override </span>{ \</div><div class="line">            return Info::almostNormal; \</div><div class="line">        } \</div><div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsSpun()<span class="keyword"> const override </span>{ \</div><div class="line">            return Info::spun; \</div><div class="line">        } \</div><div class="line">        inline <span class="keyword">virtual</span> <span class="keywordtype">bool</span> allowsOriented()<span class="keyword"> const override </span>{ \</div><div class="line">            return Info::oriented; \</div><div class="line">        }</div><div class="ttc" id="group__surfaces_html_ga9817fc7125c53daea4e3f3cbfe987a47"><div class="ttname"><a href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a></div><div class="ttdeci">NormalCoords</div><div class="ttdoc">Represents different coordinate systems that can be used for enumerating and displaying normal surfac...</div><div class="ttdef"><b>Definition:</b> normalcoords.h:59</div></div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a subclass of NormalSurfaceVector. </p>
<p>Every subclass of NormalSurfaceVector <em>must</em> include REGINA_NORMAL_SURFACE_FLAVOUR at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>coordsID</em> that is equal to the corresponding NormalCoords constant;</li>
<li>a typedef <em>Info</em>, which refers to the corresponding specialisation of the NormalInfo&lt;&gt; template;</li>
<li>a copy constructor that takes a vector of the same subclass;</li>
<li>declarations and implementations of the virtual functions NormalSurfaceVector::clone(), NormalSurfaceVector::allowsAlmostNormal(), NormalSurfaceVector::allowsSpun(), and NormalSurfaceVector::allowsOriented().</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this subclass of NormalSurfaceVector. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding NNormalCoords constant. </td></tr>
    <tr><td class="paramname">superclass</td><td>the vector class from which <em>class_</em> is derived. This is typically NormalSurfaceVector, though in some cases it may be different (e.g., NSVectorMirrored). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga665eac8de6a24d68bddbfa631bcca6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga665eac8de6a24d68bddbfa631bcca6c9">&#9670;&nbsp;</a></span>REGINA_SURFACE_FILTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REGINA_SURFACE_FILTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">class_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">public</span>: \</div><div class="line">        static constexpr <span class="keyword">const</span> <a class="code" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filterTypeID = id; \</div><div class="line">        inline <span class="keyword">virtual</span> <a class="code" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a> filterType()<span class="keyword"> const override </span>{ \</div><div class="line">            return id; \</div><div class="line">        } \</div><div class="line">        inline <span class="keyword">virtual</span> std::string filterTypeName()<span class="keyword"> const override </span>{ \</div><div class="line">            return SurfaceFilterInfo&lt;id&gt;::name(); \</div><div class="line">        }</div><div class="ttc" id="group__surfaces_html_ga38ab803471723156fb2ecb24b7b1c859"><div class="ttname"><a href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a></div><div class="ttdeci">SurfaceFilterType</div><div class="ttdoc">Represents different types of filter classes that can be used to filter lists of normal surfaces in 3...</div><div class="ttdef"><b>Definition:</b> surfacefiltertype.h:58</div></div>
</div><!-- fragment -->
<p>Defines various constants, types and virtual functions for a descendant class of SurfaceFilter. </p>
<p>Every descendant class of SurfaceFilter <em>must</em> include REGINA_SURFACE_FILTER at the beginning of the class definition.</p>
<p>This macro provides the class with:</p>
<ul>
<li>a compile-time constant <em>filterTypeID</em>, which is equal to the corresponding SurfaceFilterType constant;</li>
<li>declarations and implementations of the virtual functions SurfaceFilter::filterType() and SurfaceFilter::filterTypeName();</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">class_</td><td>the name of this descendant class of SurfaceFilter. </td></tr>
    <tr><td class="paramname">id</td><td>the corresponding SurfaceFilterType constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gacc58cdaf40c4b2c896cbaf2900a3d048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc58cdaf40c4b2c896cbaf2900a3d048">&#9670;&nbsp;</a></span>DataPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">DataPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type that is a pointer to the data stored with each disc. </p>

</div>
</div>
<a id="ga014be930b28c03042f107405114409d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga014be930b28c03042f107405114409d4">&#9670;&nbsp;</a></span>NDiscSetSurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> <a class="el" href="group__surfaces.html#ga014be930b28c03042f107405114409d4">regina::NDiscSetSurface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000155">Deprecated:</a></b></dt><dd>The class NDiscSetSurface has now been renamed to <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a>. </dd></dl>

</div>
</div>
<a id="ga3d65b1cb926fb791d18597bfac6ce3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d65b1cb926fb791d18597bfac6ce3b7">&#9670;&nbsp;</a></span>NDiscSetSurfaceData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__surfaces.html#ga3d65b1cb926fb791d18597bfac6ce3b7">regina::NDiscSetSurfaceData</a> = typedef <a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000156">Deprecated:</a></b></dt><dd>The class NDiscSetSurfaceData has now been renamed to <a class="el" href="classregina_1_1DiscSetSurfaceData.html" title="Stores data of type T for every normal disc within a particular normal surface.">DiscSetSurfaceData</a>. </dd></dl>

</div>
</div>
<a id="ga318507a759439c77b9434bb6850bdc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga318507a759439c77b9434bb6850bdc7c">&#9670;&nbsp;</a></span>NDiscSetTet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> <a class="el" href="group__surfaces.html#ga318507a759439c77b9434bb6850bdc7c">regina::NDiscSetTet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000153">Deprecated:</a></b></dt><dd>The class NDiscSetTet has now been renamed to <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a>. </dd></dl>

</div>
</div>
<a id="ga36ba5f508fd4dc4737a800ec796cf8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36ba5f508fd4dc4737a800ec796cf8e6">&#9670;&nbsp;</a></span>NDiscSetTetData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__surfaces.html#ga36ba5f508fd4dc4737a800ec796cf8e6">regina::NDiscSetTetData</a> = typedef <a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000154">Deprecated:</a></b></dt><dd>The class NDiscSetTetData has now been renamed to <a class="el" href="classregina_1_1DiscSetTetData.html" title="Stores data of type T for every normal disc inside a single tetrahedron.">DiscSetTetData</a>. </dd></dl>

</div>
</div>
<a id="gaea7f09ab89f375885be57b35504903f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea7f09ab89f375885be57b35504903f9">&#9670;&nbsp;</a></span>NDiscSpec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> <a class="el" href="group__surfaces.html#gaea7f09ab89f375885be57b35504903f9">regina::NDiscSpec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000152">Deprecated:</a></b></dt><dd>The class NDiscSpec has now been renamed to <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a>. </dd></dl>

</div>
</div>
<a id="ga1ef87df7daabeda40a127d961caedfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ef87df7daabeda40a127d961caedfc0">&#9670;&nbsp;</a></span>NDiscType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1DiscType.html">DiscType</a> <a class="el" href="group__surfaces.html#ga1ef87df7daabeda40a127d961caedfc0">regina::NDiscType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000157">Deprecated:</a></b></dt><dd>The class NDiscType has now been renamed to <a class="el" href="structregina_1_1DiscType.html" title="Identifies a single normal or almost normal disc type within a triangulation.">DiscType</a>. </dd></dl>

</div>
</div>
<a id="gae6b1bb46b52686165041bff4d0936eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6b1bb46b52686165041bff4d0936eda">&#9670;&nbsp;</a></span>NNormalSurface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> <a class="el" href="group__surfaces.html#gae6b1bb46b52686165041bff4d0936eda">regina::NNormalSurface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000159">Deprecated:</a></b></dt><dd>The class NNormalSurface has now been renamed to <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold.">NormalSurface</a>. </dd></dl>

</div>
</div>
<a id="gac1651d8ca85f9e04cd7c4345e7660be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1651d8ca85f9e04cd7c4345e7660be7">&#9670;&nbsp;</a></span>NNormalSurfaceList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> <a class="el" href="group__surfaces.html#gac1651d8ca85f9e04cd7c4345e7660be7">regina::NNormalSurfaceList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000160">Deprecated:</a></b></dt><dd>The class NNormalSurfaceList has now been renamed to <a class="el" href="classregina_1_1NormalSurfaces.html" title="A packet representing a collection of normal surfaces in a 3-manifold.">NormalSurfaces</a>. </dd></dl>

</div>
</div>
<a id="ga76e1de8b765f5bcd733cb5fe28063326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e1de8b765f5bcd733cb5fe28063326">&#9670;&nbsp;</a></span>NNormalSurfaceVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a> <a class="el" href="group__surfaces.html#ga76e1de8b765f5bcd733cb5fe28063326">regina::NNormalSurfaceVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000158">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVector has now been renamed to <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>. </dd></dl>

</div>
</div>
<a id="ga8962f2fc5b8ed3347b8157097de22f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8962f2fc5b8ed3347b8157097de22f0f">&#9670;&nbsp;</a></span>NNormalSurfaceVectorANStandard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorANStandard.html">NSVectorANStandard</a> <a class="el" href="group__surfaces.html#ga8962f2fc5b8ed3347b8157097de22f0f">regina::NNormalSurfaceVectorANStandard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000161">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorANStandard has now been renamed to <a class="el" href="classregina_1_1NSVectorANStandard.html" title="An almost normal surface vector using standard triangle-quad-oct coordinates.">NSVectorANStandard</a>. </dd></dl>

</div>
</div>
<a id="ga3a007103e8da63d8e29f79a642df29c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a007103e8da63d8e29f79a642df29c5">&#9670;&nbsp;</a></span>NNormalSurfaceVectorMirrored</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorMirrored.html">NSVectorMirrored</a> <a class="el" href="group__surfaces.html#ga3a007103e8da63d8e29f79a642df29c5">regina::NNormalSurfaceVectorMirrored</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000162">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorMirrored has now been renamed to <a class="el" href="classregina_1_1NSVectorMirrored.html" title="A normal surface vector that is mirrored in another coordinate system to avoid frequent lengthy calcu...">NSVectorMirrored</a>. </dd></dl>

</div>
</div>
<a id="ga5b3d48602a97ee3e83d4407f341e6455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b3d48602a97ee3e83d4407f341e6455">&#9670;&nbsp;</a></span>NNormalSurfaceVectorOriented</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorOriented.html">NSVectorOriented</a> <a class="el" href="group__surfaces.html#ga5b3d48602a97ee3e83d4407f341e6455">regina::NNormalSurfaceVectorOriented</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000163">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorOriented has now been renamed to <a class="el" href="classregina_1_1NSVectorOriented.html" title="A normal surface vector using transversely oriented standard (triangle-quad) coordinates.">NSVectorOriented</a>. </dd></dl>

</div>
</div>
<a id="gaffde6a7ffe1f773fa073d0bc33e4744f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde6a7ffe1f773fa073d0bc33e4744f">&#9670;&nbsp;</a></span>NNormalSurfaceVectorOrientedQuad</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorOrientedQuad.html">NSVectorOrientedQuad</a> <a class="el" href="group__surfaces.html#gaffde6a7ffe1f773fa073d0bc33e4744f">regina::NNormalSurfaceVectorOrientedQuad</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000164">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorOrientedQuad has now been renamed to <a class="el" href="classregina_1_1NSVectorOrientedQuad.html" title="A normal surface vector using transversely oriented quadrilateral coordinates.">NSVectorOrientedQuad</a>. </dd></dl>

</div>
</div>
<a id="ga6dc7349b11544a8b8d78c61e19daedc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dc7349b11544a8b8d78c61e19daedc4">&#9670;&nbsp;</a></span>NNormalSurfaceVectorQuad</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorQuad.html">NSVectorQuad</a> <a class="el" href="group__surfaces.html#ga6dc7349b11544a8b8d78c61e19daedc4">regina::NNormalSurfaceVectorQuad</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000165">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorQuad has now been renamed to <a class="el" href="classregina_1_1NSVectorQuad.html" title="A normal surface vector using quad coordinates.">NSVectorQuad</a>. </dd></dl>

</div>
</div>
<a id="ga6aa7bc30d85d431385818f616ebc5004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aa7bc30d85d431385818f616ebc5004">&#9670;&nbsp;</a></span>NNormalSurfaceVectorQuadOct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorQuadOct.html">NSVectorQuadOct</a> <a class="el" href="group__surfaces.html#ga6aa7bc30d85d431385818f616ebc5004">regina::NNormalSurfaceVectorQuadOct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000166">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorQuadOct has now been renamed to <a class="el" href="classregina_1_1NSVectorQuadOct.html" title="An almost normal surface vector using quad-oct coordinates.">NSVectorQuadOct</a>. </dd></dl>

</div>
</div>
<a id="gad7bc8620edc82bec1339e1460e7b1e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7bc8620edc82bec1339e1460e7b1e75">&#9670;&nbsp;</a></span>NNormalSurfaceVectorStandard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NSVectorStandard.html">NSVectorStandard</a> <a class="el" href="group__surfaces.html#gad7bc8620edc82bec1339e1460e7b1e75">regina::NNormalSurfaceVectorStandard</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000167">Deprecated:</a></b></dt><dd>The class NNormalSurfaceVectorStandard has now been renamed to <a class="el" href="classregina_1_1NSVectorStandard.html" title="A normal surface vector using standard triangle-quad coordinates.">NSVectorStandard</a>. </dd></dl>

</div>
</div>
<a id="ga239df7c1e704457d116029fc144dc473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga239df7c1e704457d116029fc144dc473">&#9670;&nbsp;</a></span>NormalAlg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;<a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a>&gt; <a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">regina::NormalAlg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal surface lists. </p>
<dl class="section user"><dt>Python:\n This is present, and all values in the NormalAlgFlags</dt><dd>enumeration type are treated as members of this NormalAlg class. </dd></dl>

</div>
</div>
<a id="ga10adc2dfa823f4b97db64abccdc7f73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10adc2dfa823f4b97db64abccdc7f73d">&#9670;&nbsp;</a></span>NormalList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Flags.html">regina::Flags</a>&lt;<a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a>&gt; <a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">regina::NormalList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A combination of flags for types of normal surface lists. </p>
<dl class="section user"><dt>Python:\n This is present, and all values in the NormalListFlags</dt><dd>enumeration type are treated as members of this NormalList class. </dd></dl>

</div>
</div>
<a id="ga0dc97e79a145070e73896ab2b7730415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dc97e79a145070e73896ab2b7730415">&#9670;&nbsp;</a></span>NPrismSpec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> <a class="el" href="group__surfaces.html#ga0dc97e79a145070e73896ab2b7730415">regina::NPrismSpec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000168">Deprecated:</a></b></dt><dd>The class NPrismSpec has now been renamed to <a class="el" href="structregina_1_1PrismSpec.html" title="Specifies a single triangular prism in a tetrahedron.">PrismSpec</a>. </dd></dl>

</div>
</div>
<a id="ga6de04b41af82d94b20738074da3f97a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6de04b41af82d94b20738074da3f97a3">&#9670;&nbsp;</a></span>NSurfaceFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SurfaceFilter.html">SurfaceFilter</a> <a class="el" href="group__surfaces.html#ga6de04b41af82d94b20738074da3f97a3">regina::NSurfaceFilter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000169">Deprecated:</a></b></dt><dd>The class NSurfaceFilter has now been renamed to <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a>. </dd></dl>

</div>
</div>
<a id="ga3cdc257da3694fba7fb12daf605240ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cdc257da3694fba7fb12daf605240ba">&#9670;&nbsp;</a></span>NSurfaceFilterCombination</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SurfaceFilterCombination.html">SurfaceFilterCombination</a> <a class="el" href="group__surfaces.html#ga3cdc257da3694fba7fb12daf605240ba">regina::NSurfaceFilterCombination</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000170">Deprecated:</a></b></dt><dd>The class NSurfaceFilterCombination has now been renamed to <a class="el" href="classregina_1_1SurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters.">SurfaceFilterCombination</a>. </dd></dl>

</div>
</div>
<a id="ga51eaf1ba4c64a4761d40dffc506a2344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51eaf1ba4c64a4761d40dffc506a2344">&#9670;&nbsp;</a></span>NSurfaceFilterProperties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1SurfaceFilterProperties.html">SurfaceFilterProperties</a> <a class="el" href="group__surfaces.html#ga51eaf1ba4c64a4761d40dffc506a2344">regina::NSurfaceFilterProperties</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated typedef for backward compatibility. </p>
<p>This typedef will be removed in a future release of Regina.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000171">Deprecated:</a></b></dt><dd>The class NSurfaceFilterProperties has now been renamed to <a class="el" href="classregina_1_1SurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface.">SurfaceFilterProperties</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3c4cfc5de652a5beaadaaee0cacdeede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4cfc5de652a5beaadaaee0cacdeede">&#9670;&nbsp;</a></span>NormalAlgFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">regina::NormalAlgFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents options and variants of algorithms for enumerating various types of normal surfaces in 3-manifold triangulations. </p>
<p>These options are typically combined in a bitwise fashion using the NormalAlg type, and then passed to enumeration routines such as <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">NormalSurfaces::enumerate()</a>.</p>
<dl class="section user"><dt>Python:\n The values in this enumeration type are present, but</dt><dd>they are treated by Python as NormalList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b"></a>NS_ALG_DEFAULT&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea4c4bfbfefa31e5c048a0d9e25abf9f89"></a>NS_VERTEX_VIA_REDUCED&#160;</td><td class="fielddoc"><p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should first enumerate in quadrilateral or quadrilateral-octagon coordinates, and then expand this "reduced" solution set to the (typically larger) "standard" solution set. </p>
<p>This is typically much faster than a direct enumeration in standard normal or almost normal coordinates, and enumeration routines will use this option where possible unless explicitly requested not to (via the flag NS_VERTEX_STD_DIRECT).</p>
<p>For an explanation of this procedure, see B. A. Burton, "Converting between quadrilateral and standard solution sets in
normal surface theory", Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>This flag is incompatible with NS_VERTEX_STD_DIRECT. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea15bc7c42b8b986d93863600852d271c7"></a>NS_VERTEX_STD_DIRECT&#160;</td><td class="fielddoc"><p>When enumerating in standard normal or almost normal coordinates, this flag indicates that the algorithm should work directly in that coordinate system, and should not go via the "reduced" (quadrilateral or quadrilateral-octagon) coordinate system. </p>
<p>This is typically <em>much</em> slower than going via the reduced system, and users should only request this if they have a specialised need. See NS_VERTEX_VIA_REDUCED for further information.</p>
<p>This flag is incompatible with NS_VERTEX_VIA_REDUCED. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea482b7e69b14c44d02b29055726b04830"></a>NS_VERTEX_TREE&#160;</td><td class="fielddoc"><p>When enumerating vertex normal surfaces, this flag indicates that the tree traversal algorithm should be used. </p>
<p>This algorithm is based on linear and integer programming techniques, and has many desirable properties including a relatively low overhead. Enumeration algorithms will use it if possible unless a different method is explicitly requested.</p>
<p>For details on the tree traversal algorithm, see B. A. Burton and M. Ozlen, "A tree traversal algorithm for decision problems in
knot theory and 3-manifold topology", Algorithmica 65 (2013), pp. 772-801.</p>
<p>This flag is incompatible with NS_VERTEX_DD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedeac988e037d6c164c645567750680c6e11"></a>NS_VERTEX_DD&#160;</td><td class="fielddoc"><p>When enumerating vertex normal surfaces, this flag indicates that a modified double description method should be used. </p>
<p>This algorithm can suffer from a combinatorial explosion with larger problems, leading to extremely large time and memory footprints. Users should only request this if they have some specialised need.</p>
<p>For details on the modified double description method, see B. A. Burton, "Optimizing the double description method for
normal surface enumeration", Mathematics of Computation 79 (2010), pp. 453-484.</p>
<p>This flag is incompatible with NS_VERTEX_TREE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea33ff9b1fafe5bc6aa4dbf851ec2b9ae6"></a>NS_HILBERT_PRIMAL&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that the primal method should be used for enumerating a Hilbert basis. </p>
<p>The primal method is recommended, and enumeration algorithms will use it if possible unless a different method is explicitly requested. This method uses code from Normaliz for parts of its processing.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_DUAL, NS_HILBERT_CD and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea77887211e55db67ba4ba10247cd159f3"></a>NS_HILBERT_DUAL&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that the dual method should be used for enumerating a Hilbert basis. </p>
<p>The dual method is fast (like the primal method), but its performance is highly variable; for this reason the primal method is recommended instead. This method does not make use of Normaliz, and is the recommended method for situations in which Normaliz is not available for some reason.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_CD and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea1da3bc474ed341903ab0f043488e27c3"></a>NS_HILBERT_CD&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that a modified Contejean-Devie procedure should be used for enumerating a Hilbert basis. </p>
<p>The Contejean-Devie procedure is typically <em>much</em> slower than either the primal or dual method, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_DUAL and NS_HILBERT_FULLCONE. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea7d84f194dd4d881f2175acae85fa3742"></a>NS_HILBERT_FULLCONE&#160;</td><td class="fielddoc"><p>When enumerating fundamental normal surfaces, this flag indicates that a Hilbert basis for the full solution cone should be constructed, and additional combinatorial constraints (such as the quadrilateral constraints) should only be enforced as the final step. </p>
<p>If you are only enumerating properly embedded surfaces then this procedure <em>extremely</em> slow, and users should only request it if they have some specialised need.</p>
<p>For details and comparisons of the various options for enumerating fundamental normal surfaces, see B. A. Burton, "Enumerating
fundamental normal surfaces: Algorithms, experiments and invariants", ALENEX 2014: Proceedings of the Meeting on Algorithm Engineering &amp; Experiments, SIAM, 2014, pp. 112-124.</p>
<p>This flag is incompatible with NS_HILBERT_PRIMAL, NS_HILBERT_DUAL and NS_HILBERT_CD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea61e5c6c91ab2a0c4ac8a6fca9cccd430"></a>NS_ALG_LEGACY&#160;</td><td class="fielddoc"><p>Indicates that a normal surface list was enumerated using an older version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of the algorithm used to build each list, and so in such cases no further algorithmic information is available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c4cfc5de652a5beaadaaee0cacdeedea6d1833185860331a3be3d7f909b1323a"></a>NS_ALG_CUSTOM&#160;</td><td class="fielddoc"><p>Indicates that a normal surface list was built using a customised algorithm. </p>
<p>In such cases, no further details on the algorithm are available.</p>
<p>If this flag is passed to an enumeration algorithm, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9817fc7125c53daea4e3f3cbfe987a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9817fc7125c53daea4e3f3cbfe987a47">&#9670;&nbsp;</a></span>NormalCoords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">regina::NormalCoords</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different coordinate systems that can be used for enumerating and displaying normal surfaces. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own coordinate system, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a36273f97819ff462b10db091f8a93f75"></a>NS_STANDARD&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral coordinates for normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47af3d1b2ccecff610fdaae1e4f3dde0744"></a>NS_QUAD&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates for normal surfaces. </p>
<p>For details, see "Normal surface Q-theory", Jeffrey L. Tollefson, Pacific J. Math. 183 (1998), no. 2, 359&ndash;374. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a676715b936f4d82fbf2cd2b66be3b5cf"></a>NS_QUAD_CLOSED&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates in ideal triangulations for enumerating closed surfaces only (thus excluding spun-normal surfaces). </p>
<p>The coordinates themselves are identical to quadrilateral coordinates, as described by NS_QUAD; however, the enumeration procedure introduces additional constraints. The resulting solution space is the space Q_0 as described in "Computing closed
essential surfaces in knot complements", by Burton, Coward and Tillmann, in SCG ’13: Proceedings of the 29th Annual Symposium on Computational Geometry, ACM, 2013, pp. 405–414.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Regina can only create matching equations in this coordinate system for a limited class of triangulations. Currently, such triangulations <em>must</em> be oriented and ideal, with precisely one torus cusp and no other boundary components or internal vertices. Moreover, SnapPea must be able to work with them without retriangulating (though this should follow from the other constraints). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ad2d9d61fc90b31363ec5931b1a300aa8"></a>NS_AN_LEGACY&#160;</td><td class="fielddoc"><p>Indicates that a list of almost normal surfaces was created using Regina 4.5.1 or earlier, where surfaces with more than one octagon of the same type were stripped out of the final solution set. </p>
<p>As of Regina 4.6 such surfaces are now included in the solution set, since we need them if we wish to enumerate <em>all</em> almost normal surfaces (not just the <em>vertex</em> almost normal surfaces).</p>
<p>This coordinate system is only used with legacy data files; new vectors and lists cannot be created in this coordinate system. The underlying coordinates are identical to those of NS_AN_STANDARD. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a4a7e1fc6780905418e84cadf782dd82f"></a>NS_AN_QUAD_OCT&#160;</td><td class="fielddoc"><p>Represents quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
<p>For details, see "Quadrilateral-octagon coordinates for almost normal surfaces", Benjamin A. Burton, Experiment. Math. 19 (2010), 285-315. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a0de57480ceb39c23829e982e5bef7d84"></a>NS_AN_STANDARD&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral-octagon coordinates for octagonal almost normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a8ad2e142ae1dda418034657e42365d90"></a>NS_AN_QUAD_OCT_CLOSED&#160;</td><td class="fielddoc"><p>Represents quadrilateral-octagon coordinates in ideal triangulations for enumerating closed surfaces only (thus excluding spun-almost normal surfaces). </p>
<p>The coordinates themselves are identical to quadrilateral-octagon coordinates, as described by NS_AN_QUAD_OCT; however, the enumeration procedure introduces additional constraints.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Regina can only create matching equations in this coordinate system for a limited class of triangulations. Currently, such triangulations <em>must</em> be oriented and ideal, with precisely one torus cusp and no other boundary components or internal vertices. Moreover, SnapPea must be able to work with them without retriangulating (though this should follow from the other constraints). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a6d6dd8fc113db7aff565c1f6c33e39ae"></a>NS_EDGE_WEIGHT&#160;</td><td class="fielddoc"><p>Represents edge weight coordinates for normal surfaces. </p>
<p>This coordinate system is for display only; surface vectors and lists cannot be created in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47ae8c39b9dd91ad81bf89ca633c8d9598f"></a>NS_TRIANGLE_ARCS&#160;</td><td class="fielddoc"><p>Represents triangle arc coordinates for normal surfaces. </p>
<p>This coordinate system is for display only; surface vectors and lists cannot be created in this coordinate system. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a602873a7f7351b3822c37b075ba88c43"></a>NS_ORIENTED&#160;</td><td class="fielddoc"><p>Represents standard triangle-quadrilateral coordinates for transversely oriented normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a205b46c71691c8092a5afa1d99ab556a"></a>NS_ORIENTED_QUAD&#160;</td><td class="fielddoc"><p>Represents quadrilateral coordinates for transversely oriented normal surfaces. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9817fc7125c53daea4e3f3cbfe987a47a9f471af2d202b88f06ed65be82e5d7eb"></a>NS_ANGLE&#160;</td><td class="fielddoc"><p>Represents angle structure coordinates. </p>
<p>This coordinate system is <em>not</em> for use with normal surfaces: it cannot be used either to display them or enumerate them. Instead it is for use with angle structures on triangulations. Because the combinatorics and linear algebra of angle strutures are tightly related to those of normal surfaces, we include NS_ANGLE here so that angle structure routines can make use of some of Regina's existing normal surface machinery.</p>
<p>For a triangulation with <em>n</em> tetrahedra, this system has 3<em>n</em>+1 coordinates. The first 3<em>n</em> are analogous to quadrilateral coordinates (specifically, for each quadrilateral type <em>Q</em>, the corresponding angle structure coordinate represents the pair of angles in the same tetrahedron that <em>Q</em> does not meet). The final coordinate is a scaling coordinate, used to projectivise the angle structure polytope so that it becomes a polyhedral cone that is invariant under (positive) scaling. If the final scaling coordinate is <em>s</em>, then a rational value of <em>x</em> in any other coordinate position should be interpreted as the angle <em>x</em>.&pi;/<em>s</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This coordinate system must not be used with any of Regina's routines unless they explicitly declare that NS_ANGLE is allowed. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a id="gabff25e58607c49cca84049a1069c2cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff25e58607c49cca84049a1069c2cce">&#9670;&nbsp;</a></span>NormalListFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">regina::NormalListFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different lists of normal surfaces that might be constructed for a given 3-manifold triangulation. </p>
<p>The NormalList enumeration refers to the <em>contents</em> of the list, whereas the NormalAlgFlags enumeration refers to the <em>algorithm</em> used to build it.</p>
<dl class="section user"><dt>Python:\n The values in this enumeration type are present, but</dt><dd>they are treated by Python as NormalList objects (and they can be combined and/or queried as such). The underlying enumeration type is not exposed to Python. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864"></a>NS_LIST_DEFAULT&#160;</td><td class="fielddoc"><p>An empty flag, indicating to an enumeration routine that it should use its default behaviour. </p>
<p>The numeric value of this flag is zero (i.e., it has no effect when combined with other flags using bitwise OR). </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea41f7f2158c91f3f64f3354118f6a8761"></a>NS_EMBEDDED_ONLY&#160;</td><td class="fielddoc"><p>Indicates that this list is restricted to properly embedded surfaces only. </p>
<p>This flag is incompatible with NS_IMMERSED_SINGULAR. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea1e0c5bf3f4138d8ec4a88caeb5f87a61"></a>NS_IMMERSED_SINGULAR&#160;</td><td class="fielddoc"><p>Indicates that the scope of this list includes not just properly embedded surfaces, but also immersed and/or branched surfaces. </p>
<p>This is no guarantee that the list <em>contains</em> immersed and/or branched surfaces; it merely states that such surfaces have not been explicitly excluded (in particular, the quadrilateral constraints have not been enforced).</p>
<p>This flag is incompatible with NS_EMBEDDED_ONLY. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea38cd0d13c8afd0f688eda457d5ed550d"></a>NS_VERTEX&#160;</td><td class="fielddoc"><p>Indicates a list of all vertex normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with NS_FUNDAMENTAL. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea949286ba72f0deec9b6bbe2b8a23b39c"></a>NS_FUNDAMENTAL&#160;</td><td class="fielddoc"><p>Indicates a list of all fundamental normal surfaces, with respect to the particular normal coordinate system used by the list. </p>
<p>This flag is incompatible with NS_VERTEX. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2cceaab119737dcff1409ff0f2071baee7e40"></a>NS_LEGACY&#160;</td><td class="fielddoc"><p>Indicates a list that was constructed using an old version of Regina (4.93 or earlier). </p>
<p>These older versions did not retain details of how each list was constructed, beyond whether immersed and/or singular surfaces were included. Therefore no information is available for such lists, other than the presence or absence of the NS_EMBEDDED_ONLY and/or NS_IMMERSED_SINGULAR flags.</p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabff25e58607c49cca84049a1069c2ccea64cbdf1921e4a99c5943b4039dac2709"></a>NS_CUSTOM&#160;</td><td class="fielddoc"><p>Indicates some other type of list, typically hand-crafted by the user or built by some customised algorithm. </p>
<p>If this flag is passed to an enumeration routine, it will be ignored. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae923c7c2fa692192d45bdf563f380918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae923c7c2fa692192d45bdf563f380918">&#9670;&nbsp;</a></span>SurfaceExportFields</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918">regina::SurfaceExportFields</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to describe a field, or a set of fields, that can be exported alongside a normal surface list. </p>
<p>This enumeration type is used with export routines such as <a class="el" href="classregina_1_1NormalSurfaces.html#a2b308eb9fd7a131b2c370a589b7e43c6" title="Exports this list of normal surfaces as a plain text CSV (comma-separated value) file,...">NormalSurfaces::saveCSVStandard()</a> or <a class="el" href="classregina_1_1NormalSurfaces.html#ae2559f5cea6339eb69cdcc532f970409" title="Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file,...">NormalSurfaces::saveCSVEdgeWeight()</a>.</p>
<p>This type describes fields in addition to normal coordinates, not the normal coordinates themselves (which are always exported). Each field describes some property of a single normal surface, and corresponds to a single column in a table of normal surfaces.</p>
<p>This type should be treated as a bitmask: you can describe a set of fields by combining the values for individual fields using bitwise <em>or</em>.</p>
<p>The list of available fields may grow with future releases of Regina. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a81408d5dd0f9deb210bf66ecee761c36"></a>surfaceExportName&#160;</td><td class="fielddoc"><p>Represents the user-assigned surface name. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a131a23295ec061f83590561bba365de8"></a>surfaceExportEuler&#160;</td><td class="fielddoc"><p>Represents the calculated Euler characteristic of a surface. </p>
<p>This will be an integer, and will be left empty if the Euler characteristic cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a153a815a9b0f7d3b3383f39c2d6f94ca"></a>surfaceExportOrient&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is orientable. </p>
<p>This will be the string <code>TRUE</code> or <code>FALSE</code>, or will be left empty if the orientability cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a60a48a7481d07261cf4a4051cffc3bc3"></a>surfaceExportSides&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is one-sided or two-sided. </p>
<p>This will be the integer 1 or 2, or will be left empty if the "sidedness" cannot be computed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918add63709fcbf9038110d4a3b232a466c2"></a>surfaceExportBdry&#160;</td><td class="fielddoc"><p>Represents the calculated property of whether a surface is bounded. </p>
<p>In most cases, this will be one of the strings "closed", "real bdry" or "infinite" (where "infinite" indicates a surface with infinitely many discs). For spun-normal surfaces in certain ideal triangulations, this string will be followed by the boundary slopes of the surface at the cusps: these written as a list of pairs (<em>p</em>, <em>q</em>), one for each cusp, indicating that the boundary curves of the surface run <em>p</em> times around the meridian and <em>q</em> times around the longitude. See <a class="el" href="classregina_1_1NormalSurface.html#a0b6b0e73ae35e166dc07e3ac1cd54cae" title="Computes the information about the boundary slopes of this surface at each cusp of the triangulation.">NormalSurface::boundaryIntersections()</a> for further information on interpreting these values. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a0832d74579319961e0c6f976e28b0356"></a>surfaceExportLink&#160;</td><td class="fielddoc"><p>Represents whether a surface is a single vertex link or a thin edge link. </p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#af98616d2b0b270a6a427133d3cd88cae" title="Determines whether or not a rational multiple of this surface is the link of a single vertex.">NormalSurface::isVertexLink()</a> and <a class="el" href="classregina_1_1NormalSurface.html#ab82721dfe41b187548593091b7274e6e" title="Determines whether or not a rational multiple of this surface is the thin link of a single edge.">NormalSurface::isThinEdgeLink()</a> for details. This will be written as a human-readable string. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918acf49b97bd782901a7f6ee32bf9841b03"></a>surfaceExportType&#160;</td><td class="fielddoc"><p>Represents any additional high-level properties of a surface, such as whether it is a splitting surface or a central surface. </p>
<p>This will be written as a human-readable string. This field is somewhat arbitrary, and the precise properties it describes are subject to change in future releases of Regina. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a9b7d4c6f39579e1711b203dcf8ed3824"></a>surfaceExportNone&#160;</td><td class="fielddoc"><p>Indicates that no additional fields should be exported. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918a90da6f93fd64f642efa8b5862d7b4dac"></a>surfaceExportAllButName&#160;</td><td class="fielddoc"><p>Indicates that all available fields should be exported, except for the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64"></a>surfaceExportAll&#160;</td><td class="fielddoc"><p>Indicates that all available fields should be exported, including the user-assigned surface name. </p>
<p>Since the list of available fields may grow with future releases, the numerical value of this constant may change as a result. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga38ab803471723156fb2ecb24b7b1c859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38ab803471723156fb2ecb24b7b1c859">&#9670;&nbsp;</a></span>SurfaceFilterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">regina::SurfaceFilterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents different types of filter classes that can be used to filter lists of normal surfaces in 3-manifold triangulations. </p>
<p>IDs 0-9999 are reserved for future use by Regina. If you are extending Regina to include your own filter class, you should choose an ID &gt;= 10000. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859a3fdd8d34f303e31f88989e95836b4004"></a>NS_FILTER_DEFAULT&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilter.html" title="A packet that accepts or rejects normal surfaces.">SurfaceFilter</a> class: a do-nothing filter that accepts any normal surface. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859abad02c85eeeda839925c60cd245fb478"></a>NS_FILTER_PROPERTIES&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilterProperties.html" title="A normal surface filter that filters by basic properties of the normal surface.">SurfaceFilterProperties</a> subclass: a filter that examines simple properties of a normal surface. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga38ab803471723156fb2ecb24b7b1c859a53350ed09529a46c5ed4298a14d9c6a2"></a>NS_FILTER_COMBINATION&#160;</td><td class="fielddoc"><p>Represents the <a class="el" href="classregina_1_1SurfaceFilterCombination.html" title="A normal surface filter that simply combines other filters.">SurfaceFilterCombination</a> subclass: a filter that combines other filters using boolean AND or OR. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga14859baec94b6d792d0234fa2c4def8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14859baec94b6d792d0234fa2c4def8e">&#9670;&nbsp;</a></span>adjacentDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>* regina::DiscSetSurface::adjacentDisc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>disc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt;&#160;</td>
          <td class="paramname"><em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjArc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which normal disc is adjacent to the given normal disc along the given directed normal arc in the surface described by this disc set. </p>
<p>A directed normal arc will be specified by a permutation <em>p</em>, where the arc runs around vertex <code>p[0]</code> parallel to the directed edge from vertex <code>p[1]</code> to <code>p[2]</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disc</td><td>the given normal disc; this must be a disc in this disc set. </td></tr>
    <tr><td class="paramname">arc</td><td>the given normal arc; this must actually be an arc on the boundary of the given normal disc (although it may run in either direction). </td></tr>
    <tr><td class="paramname">adjArc</td><td>returns the same directed normal arc that was passed, but expressed in terms of the vertices of the adjacent tetrahedron. Any value may be initially passed. If there is no adjacent disc/tetrahedron, this permutation will remain unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal disc adjacent to the given disc along the given arc, or 0 if there is no adjacent disc. This disc specifier will be newly created, and it is up to the caller of this routine to dispose of it. </dd></dl>

</div>
</div>
<a id="gaccafa8884a778da2a68041bbc3c0f0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccafa8884a778da2a68041bbc3c0f0f9">&#9670;&nbsp;</a></span>arcFromDisc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetTet::arcFromDisc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>discNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which normal arc of a given type on a given face of this tetrahedron corresponds to the given normal disc. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal disc actually meets a normal arc of the given type on the given face.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arcFace</td><td>the face of this tetrahedron containing the normal arc (between 0 and 3 inclusive). </td></tr>
    <tr><td class="paramname">arcVertex</td><td>the vertex of this tetrahedron about which the normal arc runs (between 0 and 3 inclusive); <em>arcFace</em> and <em>arcVertex</em> should not be the same. </td></tr>
    <tr><td class="paramname">discType</td><td>the disc type of the given normal disc; this should be between 0 and 9 inclusive, as described in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">discNumber</td><td>indicates which normal disc of the given disc type is referred to (between 0 and <code>nDiscs(discType)-1</code> inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of the normal arc of the given type that belongs to the given normal disc. Arcs of a given type (where <em>arcFace</em> and <em>arcVertex</em> together define the arc type) are numbered starting at 0 from the tetrahedron vertex outwards. </dd></dl>

</div>
</div>
<a id="gaf1bcb320960af2e96d587cc40549a48c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1bcb320960af2e96d587cc40549a48c">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> regina::DiscSetSurface::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of all normal discs in the underlying normal surface. </p>
<p>These <a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c" title="Returns an iterator at the beginning of the range of all normal discs in the underlying normal surfac...">begin()</a> and <a class="el" href="group__surfaces.html#gae26003982483e680a1c073ab250702d2" title="Returns an iterator at the end of the range of all normal discs in the underlying normal surface.">end()</a> routines allow you to iterate through all normal discs using C++11 range-based <code>for</code> loops:</p>
<div class="fragment"><div class="line"><a class="code" href="group__surfaces.html#ga9bc5a059c5627c16967d7438dc742fca">DiscSetSurface</a>* discs = ...;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> DiscSpec&amp; s : *discs) { ... }</div></div><!-- fragment --><p>In Python, a <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> can be treated as an iterable object, again iterating through all normal discs:</p>
<div class="fragment"><div class="line">discs = ...</div><div class="line"><span class="keywordflow">for</span> s <span class="keywordflow">in</span> discs:</div><div class="line">    ...</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of the range of all normal discs. </dd></dl>

</div>
</div>
<a id="ga3b40482617d929f84c1f8eeb7e00ff92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b40482617d929f84c1f8eeb7e00ff92">&#9670;&nbsp;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>discNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the data corresponding to the given normal disc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the disc type of the given normal disc; this should be between 0 and 9 inclusive, as described in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">discNumber</td><td>indicates which normal disc of the given disc type is referred to; this should be between 0 and <code>nDiscs(discType)-1</code> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the data corresponding to the given normal disc. </dd></dl>

</div>
</div>
<a id="gaab688229f8a6ef82f631b8e77e82def0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab688229f8a6ef82f631b8e77e82def0">&#9670;&nbsp;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>disc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves a reference to the data corresponding to the given normal disc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">disc</td><td>the disc whose data we require; this must refer to a disc within this disc set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the data corresponding to the given normal disc. </dd></dl>

</div>
</div>
<a id="ga00a3f5bdb957c5b10c0b5ec9ebfbe94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00a3f5bdb957c5b10c0b5ec9ebfbe94a">&#9670;&nbsp;</a></span>discFromArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::DiscSetTet::discFromArc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcFace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>arcNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>discNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which normal disc in this tetrahedron meets the given normal arc on the given face. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal arc actually exists in the normal surface with which this <em><a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a></em> object was created.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arcFace</td><td>the face of this tetrahedron containing the normal arc (between 0 and 3 inclusive). </td></tr>
    <tr><td class="paramname">arcVertex</td><td>the vertex of this tetrahedron about which the normal arc runs (between 0 and 3 inclusive); <em>arcFace</em> and <em>arcVertex</em> should not be the same. </td></tr>
    <tr><td class="paramname">arcNumber</td><td>indicates which normal arc of the given type is referred to. Arcs of a given type (where <em>arcFace</em> and <em>arcVertex</em> together define the arc type) are numbered starting at 0 from the tetrahedron vertex outwards. </td></tr>
    <tr><td class="paramname">discType</td><td>returns the disc type of the normal disc that meets the given normal arc; this will be between 0 and 9 inclusive, as described in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. Any value may be initially passed. </td></tr>
    <tr><td class="paramname">discNumber</td><td>returns a number that indicates which normal disc of the returned disc type (<code>discType</code>) meets the given normal arc; this will be between 0 and <code>nDiscs(discType)-1</code> inclusive. Any value may be initially passed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacc8d5800d8613931ff0483a8388308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc8d5800d8613931ff0483a8388308c">&#9670;&nbsp;</a></span>discOrientationFollowsEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::discOrientationFollowsEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edgeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not the natural boundary orientation of a normal disc of the given type follows the given directed normal arc. </p>
<p>Natural boundary orientation is defined by arrays <a class="el" href="group__surfaces.html#ga1ed7e2568c2e6085550dec8b1ff5eeb1" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular...">regina::triDiscArcs</a>, <a class="el" href="group__surfaces.html#ga315832a821efcad8d12ee4d0158a0bbd" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilate...">regina::quadDiscArcs</a> and <a class="el" href="group__surfaces.html#gae3d5fc76b76881cf4851d177f1adb912" title="Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal ...">regina::octDiscArcs</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given normal arc lies on a normal disc of the given type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex about which the normal arc runs. </td></tr>
    <tr><td class="paramname">edgeStart</td><td>the start vertex of the edge to which the normal arc is parallel. </td></tr>
    <tr><td class="paramname">edgeEnd</td><td>the end vertex of the edge to which the normal arc is parallel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9bc5a059c5627c16967d7438dc742fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bc5a059c5627c16967d7438dc742fca">&#9670;&nbsp;</a></span>DiscSetSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetSurface::DiscSetSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<p>The array of tetrahedron disc set pointers will be created but the <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a> objects themselves will <b>not</b> be created.</p>
<p>This constructor should be called from constructors of subclasses who wish to use objects of a subclass of <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a>, which this constructor allows them to create for themselves.</p>
<dl class="section warning"><dt>Warning</dt><dd>After calling this constructor, each <a class="el" href="classregina_1_1DiscSetTet.html" title="Represents a set of normal discs inside a single tetrahedron.">DiscSetTet</a> object in the <em>discSets</em> array <b>must</b> be created, since the <em><a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a></em> destructor will attempt to destroy them! The <em>discSets</em> array will have size <code>surface.triangulation()-&gt;size()</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">b</td><td>this parameter is ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7d4e0bcd28a1aba2869b9db72e6c48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7d4e0bcd28a1aba2869b9db72e6c48f">&#9670;&nbsp;</a></span>DiscSetSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetSurface::DiscSetSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga351ff55619cc35b42f37ddb369e0fcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga351ff55619cc35b42f37ddb369e0fcc9">&#9670;&nbsp;</a></span>DiscSetSurfaceData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<p>The data for each disc will remain uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97c7e00d669bca83a672de12e45f627c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97c7e00d669bca83a672de12e45f627c">&#9670;&nbsp;</a></span>DiscSetSurfaceData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetSurfaceData.html">regina::DiscSetSurfaceData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetSurfaceData.html">DiscSetSurfaceData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface. </p>
<p>The data for each disc will be initialised to the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">initValue</td><td>the value with which to initialise the data corresponding to each disc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe441060b0e0bf2334000a5a3deb33a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe441060b0e0bf2334000a5a3deb33a2">&#9670;&nbsp;</a></span>DiscSetTet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetTet::DiscSetTet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal discs corresponding to the discs of the given normal surface that lie within the given tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron that our discs must lie in; this must be between 0 and <code>tri.size()-1</code> inclusive, where <code>tri</code> is the triangulation containing the given normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f0f6d8f893f8f8e7f971c6eff4b7c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f0f6d8f893f8f8e7f971c6eff4b7c1b">&#9670;&nbsp;</a></span>DiscSetTet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetTet::DiscSetTet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal discs where the number of discs of each type is explicitly given. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri0</td><td>the number of triangular discs surrounding vertex 0. </td></tr>
    <tr><td class="paramname">tri1</td><td>the number of triangular discs surrounding vertex 1. </td></tr>
    <tr><td class="paramname">tri2</td><td>the number of triangular discs surrounding vertex 2. </td></tr>
    <tr><td class="paramname">tri3</td><td>the number of triangular discs surrounding vertex 3. </td></tr>
    <tr><td class="paramname">quad0</td><td>the number of quadrilateral discs of type 0. </td></tr>
    <tr><td class="paramname">quad1</td><td>the number of quadrilateral discs of type 1. </td></tr>
    <tr><td class="paramname">quad2</td><td>the number of quadrilateral discs of type 2. </td></tr>
    <tr><td class="paramname">oct0</td><td>the number of octahedral discs of type 0. </td></tr>
    <tr><td class="paramname">oct1</td><td>the number of octahedral discs of type 1. </td></tr>
    <tr><td class="paramname">oct2</td><td>the number of octahedral discs of type 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4526a51c67f6cc9b10a4dad45a1f1686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4526a51c67f6cc9b10a4dad45a1f1686">&#9670;&nbsp;</a></span>DiscSetTetData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron. </p>
<p>The data for each disc will remain uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron that our discs must lie in; this must be between 0 and <code>tri.size()-1</code> inclusive, where <code>tri</code> is the triangulation containing the given normal surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8fe87cf10ed4fd6e10266bd92cabda4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fe87cf10ed4fd6e10266bd92cabda4e">&#9670;&nbsp;</a></span>DiscSetTetData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>initValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set corresponding to the discs of the given normal surface that lie within the given tetrahedron. </p>
<p>The data for each disc will be initialised to the given value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surface</td><td>the normal surface whose discs we shall use. </td></tr>
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron that our discs must lie in; this must be between 0 and <code>tri.size()-1</code> inclusive, where <code>tri</code> is the triangulation containing the given normal surface. </td></tr>
    <tr><td class="paramname">initValue</td><td>the value with which to initialise the data corresponding to each disc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c5875e05c90ed38f5384735bcac92d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c5875e05c90ed38f5384735bcac92d8">&#9670;&nbsp;</a></span>DiscSetTetData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>tri3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>quad2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct1</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>oct2</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc set where the number of discs of each type is explicitly given. </p>
<p>The data for each disc will remain uninitialised.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tri0</td><td>the number of triangular discs surrounding vertex 0. </td></tr>
    <tr><td class="paramname">tri1</td><td>the number of triangular discs surrounding vertex 1. </td></tr>
    <tr><td class="paramname">tri2</td><td>the number of triangular discs surrounding vertex 2. </td></tr>
    <tr><td class="paramname">tri3</td><td>the number of triangular discs surrounding vertex 3. </td></tr>
    <tr><td class="paramname">quad0</td><td>the number of quadrilateral discs of type 0. </td></tr>
    <tr><td class="paramname">quad1</td><td>the number of quadrilateral discs of type 1. </td></tr>
    <tr><td class="paramname">quad2</td><td>the number of quadrilateral discs of type 2. </td></tr>
    <tr><td class="paramname">oct0</td><td>the number of octahedral discs of type 0. </td></tr>
    <tr><td class="paramname">oct1</td><td>the number of octahedral discs of type 1. </td></tr>
    <tr><td class="paramname">oct2</td><td>the number of octahedral discs of type 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9d41a228f90e254a5707f175f55dfb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d41a228f90e254a5707f175f55dfb39">&#9670;&nbsp;</a></span>DiscSpec() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpec::DiscSpec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised disc specifier. </p>

</div>
</div>
<a id="ga185aaf4b2430cf3089dba1a4ddb83930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga185aaf4b2430cf3089dba1a4ddb83930">&#9670;&nbsp;</a></span>DiscSpec() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpec::DiscSpec </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newTetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>newNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc specifier containing the given values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newTetIndex</td><td>the index in the triangulation of the tetrahedron containing the disc. </td></tr>
    <tr><td class="paramname">newType</td><td>the disc type; this is between 0 and 9 inclusive, as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </td></tr>
    <tr><td class="paramname">newNumber</td><td>specifies which disc of the particular type in the particular tetrahedron is being referred to; discs are numbered as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga660af5ac1a6ab75d34c6671f2cebfa3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga660af5ac1a6ab75d34c6671f2cebfa3b">&#9670;&nbsp;</a></span>DiscSpec() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpec::DiscSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new disc specifier that is a clone of the given specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the disc specifier to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9e169fff6424f1acf397c42bca638b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e169fff6424f1acf397c42bca638b7">&#9670;&nbsp;</a></span>DiscSpecIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpecIterator::DiscSpecIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new uninitialised iterator. </p>
<p>This iterator cannot be used or queried until either <a class="el" href="group__surfaces.html#gad2f9987a917198b7fbe777fdb37c3511" title="Points this iterator to the first disc in the given disc set.">init()</a> or the assignmemnt operator is called. </p>

</div>
</div>
<a id="gac2a16a72e475679372711d2a9c8ce32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a16a72e475679372711d2a9c8ce32c">&#9670;&nbsp;</a></span>DiscSpecIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpecIterator::DiscSpecIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>discSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new iterator pointing to the first disc in the given disc set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discSet</td><td>the disc set used to initialise this iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21a02ea41beef23675e3133af8eea0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a02ea41beef23675e3133af8eea0bc">&#9670;&nbsp;</a></span>DiscSpecIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSpecIterator::DiscSpecIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>

</div>
</div>
<a id="ga1d2e60e17d1ef726a70b9393638f09fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d2e60e17d1ef726a70b9393638f09fa">&#9670;&nbsp;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpecIterator::done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this iterator is past-the-end. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this iterator is past-the-end. </dd></dl>

</div>
</div>
<a id="gae26003982483e680a1c073ab250702d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26003982483e680a1c073ab250702d2">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> regina::DiscSetSurface::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the end of the range of all normal discs in the underlying normal surface. </p>
<p>In C++, the <a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c" title="Returns an iterator at the beginning of the range of all normal discs in the underlying normal surfac...">begin()</a> and <a class="el" href="group__surfaces.html#gae26003982483e680a1c073ab250702d2" title="Returns an iterator at the end of the range of all normal discs in the underlying normal surface.">end()</a> routines allow you to iterate through all normal discs using C++11 range-based <code>for</code> loops. In Python, a <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> can be treated as an iterable object.</p>
<p>See the <a class="el" href="group__surfaces.html#gaf1bcb320960af2e96d587cc40549a48c" title="Returns an iterator at the beginning of the range of all normal discs in the underlying normal surfac...">begin()</a> documentation for further details.</p>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the end of the range of all normal discs. </dd></dl>

</div>
</div>
<a id="gadd13f0c33b3131122ddb15804973fd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd13f0c33b3131122ddb15804973fd56">&#9670;&nbsp;</a></span>forCoords() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::ReturnType regina::forCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal surfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;NormalInfo&lt;c&gt;&gt;(...)</code> is defined for any valid NormalCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;NormalInfo&lt;coords&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from Returns&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a NormalInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given coordinate system is invalid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given coordinate system is invalid. </dd></dl>

</div>
</div>
<a id="ga6bec1eb2ca5e5a7fd11bedfb1dee56f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bec1eb2ca5e5a7fd11bedfb1dee56f7">&#9670;&nbsp;</a></span>forCoords() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::Void regina::forCoords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of NormalCoords, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible coordinate sytems.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new coordinate system is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>This function can only work with coordinate systems in which you can create and store normal surfaces. All other coordinate systems are considered invalid for our purposes here.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;NormalInfo&lt;c&gt;&gt;(...)</code> is defined for any valid NormalCoords enum value <em>c</em>. Then, when the user calls <code>forCoords(coords, func, ...)</code>, this routine will call <code>func.operator()&lt;NormalInfo&lt;coords&gt;&gt;(...)</code> in turn. If <em>coords</em> does not denote a valid coordinate system as described above, then <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em>. (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__hypersurface.html#ga36de7c6e11fe8b3cf37d0ea7f6f90645" title="Allows the user to call a template function whose template parameter matches a given value of HyperCo...">forCoords()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the given normal coordinate system. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a NormalInfo&lt;coords&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap them in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a id="gadfcdfb4006b01269d80720b647e1dc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfcdfb4006b01269d80720b647e1dc37">&#9670;&nbsp;</a></span>forFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::ReturnType regina::forFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt; FunctionObject &gt;::ReturnType&#160;</td>
          <td class="paramname"><em>defaultReturn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible normal surface filter types.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new filter type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;SurfaceFilterInfo&lt;t&gt;&gt;(...)</code> is defined for any valid SurfaceFilterType enum value <em>t</em>. Then, when the user calls <code>forFilter(filter, func, defaultReturn, ...)</code>, this routine will call <code>func.operator()&lt;SurfaceFilterInfo&lt;filter&gt;&gt;(...)</code> and pass back the corresponding return value. If <em>filter</em> does not denote a valid filter type, then <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> will pass back <em>defaultReturn</em> instead.</p>
<p>There is also a variant of <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> that works with void functions, and so does not take the extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The function object must have a typedef <em>ReturnType</em> indicating the return type of the corresponding templated bracket operator. Inheriting from Returns&lt;...&gt; is a convenient way to ensure this.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>the given type of normal surface filter. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a SurfaceFilterInfo&lt;filter&gt; object. </td></tr>
    <tr><td class="paramname">defaultReturn</td><td>the value to return if the given filter type is not valid. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap then in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the return value from the corresponding bracket operator of <em>func</em>, or <em>defaultReturn</em> if the given filter type is not valid. </dd></dl>

</div>
</div>
<a id="ga5af9e496cbc7b631780b88a04e7e04b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5af9e496cbc7b631780b88a04e7e04b0">&#9670;&nbsp;</a></span>forFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionObject , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1ReturnsTraits.html">ReturnsTraits</a>&lt;FunctionObject&gt;::Void regina::forFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga38ab803471723156fb2ecb24b7b1c859">SurfaceFilterType</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionObject &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to call a template function whose template parameter matches a given value of SurfaceFilterType, which is not known until runtime. </p>
<p>In essence, this routine contains a switch/case statement that runs through all possible normal surface filter types.</p>
<p>The advantages of this routine are that (i) the user does not need to repeatedly type such switch/case statements themselves; and (ii) if a new filter type is added then only a small amount of code needs to be extended to incorporate it.</p>
<p>In detail: the function object <em>func</em> must define a templated bracket operator, so that <code>func.operator()&lt;SurfaceFilterInfo&lt;t&gt;&gt;(...)</code> is defined for any valid SurfaceFilterType enum value <em>t</em>. Then, when the user calls <code>forFilter(filter, func, ...)</code>, this routine will call <code>func.operator()&lt;SurfaceFilterInfo&lt;filter&gt;&gt;(...)</code> in turn. If <em>filter</em> does not denote a valid filter type, then <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> will do nothing.</p>
<p>There is also a variant of <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> that works with functions with return values, and which takes an extra <em>defaultReturn</em> argument.</p>
<dl class="section pre"><dt>Precondition</dt><dd>There must not exist a type <em>FunctionObject::ReturnType</em> (or, if <em>FunctionObject</em> is a reference to a class/struct <em>F</em>, there must likewise not exist a type <em>F::ReturnType</em>). The existence of a type <em>FunctionObject::ReturnType</em> will cause the non-void variant of <a class="el" href="group__surfaces.html#gadfcdfb4006b01269d80720b647e1dc37" title="Allows the user to call a template function whose template parameter matches a given value of Surface...">forFilter()</a> to be used instead.</dd></dl>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>the given type of normal surface filter. </td></tr>
    <tr><td class="paramname">func</td><td>the function object whose bracket operator we will call with a SurfaceFilterInfo&lt;filter&gt; object. </td></tr>
    <tr><td class="paramname">args</td><td>any additional arguments to pass to the bracket operator for <em>func</em>. These will be copied/moved, so if you wish to pass references then you may need to wrap then in std::ref or std::cref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing; the return type <code>ReturnsTraits&lt;FunctionObject&gt;::Void</code> simply evaluates to <code>void</code>. </dd></dl>

</div>
</div>
<a id="gad2f9987a917198b7fbe777fdb37c3511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2f9987a917198b7fbe777fdb37c3511">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::DiscSpecIterator::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a> &amp;&#160;</td>
          <td class="paramname"><em>discSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Points this iterator to the first disc in the given disc set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discSet</td><td>the disc set used to reinitialise this iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeeffc85eaf2fc2c37cf1e6fb87f951b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeeffc85eaf2fc2c37cf1e6fb87f951b9">&#9670;&nbsp;</a></span>makeEmbeddedConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enumerate.html#ga1c6a2d141f3bd1255506c8d87bc17c64">EnumConstraints</a>* regina::makeEmbeddedConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of validity constraints representing the condition that normal surfaces be embedded. </p>
<p>The validity constraints will be expressed relative to the given coordinate system.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these validity constraints will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of constraints. </dd></dl>

</div>
</div>
<a id="ga15a886092529bcf35c5e6def77e18c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15a886092529bcf35c5e6def77e18c64">&#9670;&nbsp;</a></span>makeMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::makeMatchingEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new set of normal surface matching equations for the given triangulation using the given coordinate system. </p>
<p>The returned matrix will be newly allocated and its destruction will be the responsibility of the caller of this routine.</p>
<p>Each equation will be represented as a row of the matrix. Each column of the matrix represents a coordinate in the given coordinate system.</p>
<p>For some coordinate systems, Regina may not be able to create matching equations for all triangulations (these coordinate systems are explicitly mentioned as such in the NormalCoords enum documentation). If Regina cannot create the matching equations as requested, this routine will return <code>null</code> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which these matching equations will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated set of matching equations, or <code>null</code> if Regina is not able to construct them for the given combination of triangulation and coordinate system. </dd></dl>

</div>
</div>
<a id="ga2eda282781417dd21160e899db7d8bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eda282781417dd21160e899db7d8bfb">&#9670;&nbsp;</a></span>makeZeroVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaceVector.html">NormalSurfaceVector</a>* regina::makeZeroVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new normal surface vector of the appropriate length for the given triangulation and the given coordinate system. </p>
<p>All elements of this vector will be initialised to zero.</p>
<p>The new vector will be of the subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> corresponding to the given coordinate system. The caller of this routine is responsible for destroying the new vector.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triangulation</td><td>the triangulation upon which the underlying coordinate system is based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new zero vector of the correct class and length. </dd></dl>

</div>
</div>
<a id="ga10cc0ec5a7a3f45404ca2933f153a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10cc0ec5a7a3f45404ca2933f153a108">&#9670;&nbsp;</a></span>nDiscs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetTet::nDiscs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of discs of the given type inside this tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the disc type to examine; this should be between 0 and 9 inclusive. Disc types are outlined in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of discs of the given type inside this tetrahedron. </dd></dl>

</div>
</div>
<a id="gacf48dd20fe6cfdd7e9f41e919b577b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf48dd20fe6cfdd7e9f41e919b577b8b">&#9670;&nbsp;</a></span>nDiscs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetSurface::nDiscs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of discs of the given type inside the given tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron to examine. </td></tr>
    <tr><td class="paramname">type</td><td>the disc type to examine; this should be between 0 and 9 inclusive. Disc types are outlined in the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of discs of the given type inside the given tetrahedron. </dd></dl>

</div>
</div>
<a id="gac4244895ae54265d8c0544ee65370483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4244895ae54265d8c0544ee65370483">&#9670;&nbsp;</a></span>nTets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::DiscSetSurface::nTets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of tetrahedra in the underlying triangulation. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra. </dd></dl>

</div>
</div>
<a id="ga17dfc1f57595cbc9ec5662a76d25c161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17dfc1f57595cbc9ec5662a76d25c161">&#9670;&nbsp;</a></span>numberDiscsAwayFromVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::numberDiscsAwayFromVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>discType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether or not normal discs of the given type are numbered away from the given vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">discType</td><td>the normal disc type under consideration; this should be between 0 and 9 inclusive, as described by the <a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a> class notes. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex under consideration; this should be between 0 and 3 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if normal discs of the given type are numbered away from the given vertex, or <code>false</code> if they are numbered towards the given vertex. </dd></dl>

</div>
</div>
<a id="ga429fbf9409a23f162b99f1e3e7ecc39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga429fbf9409a23f162b99f1e3e7ecc39e">&#9670;&nbsp;</a></span>operator !=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpec::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given disc specifier contain different information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the disc specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given disc specifier contain different information. </dd></dl>

</div>
</div>
<a id="ga9851f970d780a428a60e0f7dbae2021f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9851f970d780a428a60e0f7dbae2021f">&#9670;&nbsp;</a></span>operator !=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpecIterator::operator != </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given iterator are different. </p>
<p>Two iterators are considered equal if (i) they were constructed from the same <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> object (not two different <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> objects with identical contents), and (ii) they point to the same disc of the same tetrahedron.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given iterator are equal. </dd></dl>

</div>
</div>
<a id="gacadbbafff2133bc6f5de417feeb01a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacadbbafff2133bc6f5de417feeb01a4a">&#9670;&nbsp;</a></span>operator *()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp; regina::DiscSpecIterator::operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a reference to the disc pointed to by this iterator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python:\n This routine is called deref(), since Python does</dt><dd>not support the dereference operator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the disc pointed to by this iterator. </dd></dl>

</div>
</div>
<a id="ga47ea429f2da590de2bb9552562a1fa22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47ea429f2da590de2bb9552562a1fa22">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp; regina::DiscSpecIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Preincrement operator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python:\n Not present; instead this class implements</dt><dd><code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this iterator. </dd></dl>

</div>
</div>
<a id="ga9f06d8171f9e775f0a80889c0501ba65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f06d8171f9e775f0a80889c0501ba65">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> regina::DiscSpecIterator::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Postincrement operator. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This iterator is not past-the-end.</dd></dl>
<dl class="section user"><dt>Python:\n Not present; instead this class implements</dt><dd><code>next()</code>, which either returns the current packet in the subtree and increments the iterator, or else throws a <code>StopIteration</code> exception if the iterator is past-the-end.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this iterator before it was incremented. </dd></dl>

</div>
</div>
<a id="gaf73fa623e9df3fbdffe981d730ced7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf73fa623e9df3fbdffe981d730ced7f2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1PrismSpec.html">PrismSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given prism specifier to the given output stream. </p>
<p>The prism specifier will be written as a pair <code>(tetIndex, edge)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the prism specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga4d42ed9b68e522ff445b5d3e777176f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d42ed9b68e522ff445b5d3e777176f4">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscType.html">DiscType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given disc type to the given output stream. </p>
<p>The disc type will be written as a pair <code>(tetIndex, type)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">type</td><td>the disc type to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the given output stream. </dd></dl>

</div>
</div>
<a id="gabdd4772a47d25242a4afeaaef48aca4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdd4772a47d25242a4afeaaef48aca4f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; regina::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the given disc specifier to the given output stream. </p>
<p>The disc specifier will be written as a triple <code>(tetIndex, type, number)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the disc specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
<a id="ga3d24cc1a1425473f871d57828db512df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d24cc1a1425473f871d57828db512df">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a>&amp; regina::DiscSpec::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the values from the given disc specifier into this specifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the disc specifier whose values should be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this disc specifier. </dd></dl>

</div>
</div>
<a id="gaeb6e86b724a23f0be60c43ffdae7c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb6e86b724a23f0be60c43ffdae7c037">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a>&amp; regina::DiscSpecIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment operator. </p>

</div>
</div>
<a id="gae9b7d3518b9329fe520e02ecfb37ac19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9b7d3518b9329fe520e02ecfb37ac19">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpec::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given disc specifier contain identical information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the disc specifier to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given disc specifier contain identical information. </dd></dl>

</div>
</div>
<a id="gad214e90993b4a051e3029c7e75c7d83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad214e90993b4a051e3029c7e75c7d83a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::DiscSpecIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1DiscSpecIterator.html">DiscSpecIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this and the given iterator are equal. </p>
<p>Two iterators are considered equal if (i) they were constructed from the same <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> object (not two different <a class="el" href="classregina_1_1DiscSetSurface.html" title="Represents the set of all normal discs forming a normal surface.">DiscSetSurface</a> objects with identical contents), and (ii) they point to the same disc of the same tetrahedron.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the iterator to compare with this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this and the given iterator are equal. </dd></dl>

</div>
</div>
<a id="gae92f3f038eac514d3e599ff3d92d8485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae92f3f038eac514d3e599ff3d92d8485">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#gabff25e58607c49cca84049a1069c2cce">NormalListFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="ga4428e0ba8bfcc8083b37e9e3e2220c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4428e0ba8bfcc8083b37e9e3e2220c96">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> regina::operator| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga3c4cfc5de652a5beaadaaee0cacdeede">NormalAlgFlags</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the bitwise OR of the two given flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the first flag to combine. </td></tr>
    <tr><td class="paramname">rhs</td><td>the second flag to combine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the combination of both flags. </dd></dl>

</div>
</div>
<a id="ga6318837e6c80c4648a7971e038db9d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6318837e6c80c4648a7971e038db9d6f">&#9670;&nbsp;</a></span>tetDiscs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a> &amp; regina::DiscSetSurface::tetDiscs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the specific set of discs living inside the given tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the given tetrahedron. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of discs inside the given tetrahedron. </dd></dl>

</div>
</div>
<a id="ga124a63e9a57ffc4fff0fef553fa2862c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga124a63e9a57ffc4fff0fef553fa2862c">&#9670;&nbsp;</a></span>~DiscSetSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual regina::DiscSetSurface::~DiscSetSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this set of discs and deallocates all associated memory. </p>

</div>
</div>
<a id="ga70df6a9c427d5d3647407cfbb46052c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70df6a9c427d5d3647407cfbb46052c7">&#9670;&nbsp;</a></span>~DiscSetTet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::DiscSetTet::~DiscSetTet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this disc set. </p>

</div>
</div>
<a id="gadce3172b88a1b68738f19ea48c734932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadce3172b88a1b68738f19ea48c734932">&#9670;&nbsp;</a></span>~DiscSetTetData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::~<a class="el" href="classregina_1_1DiscSetTetData.html">DiscSetTetData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this disc set and deallocates all data arrays. </p>
<p>Note that no assumption is made about type <code>T</code>, so if data elements are pointers to dynamically allocated objects, these will not be destroyed. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gaf07af029fdcbe831f24700d44be47231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf07af029fdcbe831f24700d44be47231">&#9670;&nbsp;</a></span>current</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> regina::DiscSpecIterator::current</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The disc currently pointed to. </p>

</div>
</div>
<a id="gad0f57cc02ce279ec26f660c6afe1748a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0f57cc02ce279ec26f660c6afe1748a">&#9670;&nbsp;</a></span>discSets</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1DiscSetTet.html">DiscSetTet</a>** regina::DiscSetSurface::discSets</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The disc sets corresponding to each tetrahedron. </p>

</div>
</div>
<a id="gaca315fbe07e6aee27bf13647db6aa6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca315fbe07e6aee27bf13647db6aa6b6">&#9670;&nbsp;</a></span>internalData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#gacc58cdaf40c4b2c896cbaf2900a3d048">DataPtr</a> <a class="el" href="classregina_1_1DiscSetTetData.html">regina::DiscSetTetData</a>&lt; T &gt;::internalData[10]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the data corresponding to each normal disc. </p>

</div>
</div>
<a id="ga343e081f5dee36db898b93f087de6b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343e081f5dee36db898b93f087de6b2e">&#9670;&nbsp;</a></span>internalDiscSet</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1DiscSetSurface.html">DiscSetSurface</a>* regina::DiscSpecIterator::internalDiscSet</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The disc set through which we are iterating. </p>

</div>
</div>
<a id="gafbb5afac6d75ceab81eaaea50673d44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbb5afac6d75ceab81eaaea50673d44a">&#9670;&nbsp;</a></span>internalNDiscs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSetTet::internalNDiscs[10]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of discs of each type. </p>

</div>
</div>
<a id="gaa6a135b6871de3392dd31f8da6eda4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6a135b6871de3392dd31f8da6eda4fb">&#9670;&nbsp;</a></span>number</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long regina::DiscSpec::number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies which disc of the particular type in the particular tetrahedron is being referred to; discs are numbered as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </p>

</div>
</div>
<a id="gae3d5fc76b76881cf4851d177f1adb912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3d5fc76b76881cf4851d177f1adb912">&#9670;&nbsp;</a></span>octDiscArcs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::octDiscArcs[3][8]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of octagonal normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>octDiscArcs[i]</code> lists the boundary arcs of the octagonal disc of type <em>i</em>. See <a class="el" href="classregina_1_1NormalSurface.html#abae51e35ce30784d586dfca6576243ee" title="Returns the number of octagonal discs of the given type in this normal surface.">NormalSurface::octs()</a> for further details.</p>
<p>Note that permutation <code>octDiscArcs[i][j]</code> will be even precisely when <code>j</code> is 0, 1, 4 or 5.</p>
<dl class="section user"><dt>C++:\n This array is replaced by a macro</dt><dd><code>octDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a id="ga8920a1e646a768ea0eb9c40f904813fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8920a1e646a768ea0eb9c40f904813fd">&#9670;&nbsp;</a></span>quadDefn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadDefn[3][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists which vertices each quadrilateral type separates in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> splits the vertex pairs <code>quadDefn[i][0,1]</code> and <code>quadDefn[i][2,3]</code>.</p>
<p>It is guaranteed that:</p>
<ul>
<li><code>quadDefn[i][0] &lt; quadDefn[i][1]</code>;</li>
<li><code>quadDefn[i][2] &lt; quadDefn[i][3]</code>;</li>
<li><code>quadDefn[i][0] &lt; quadDefn[i][2]</code>.</li>
</ul>
<p>This array contains similar information to the function <a class="el" href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">Edge&lt;3&gt;::ordering()</a>. Instead of quadDefn[<em>i</em>][<em>j</em>], you can call <a class="el" href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">Edge&lt;3&gt;::ordering</a>(<em>i</em>)[<em>j</em>]; this will give the same results for <em>j</em> = 0 and 1, but it might switch the results for <em>j</em> = 2 and 3. </p>

</div>
</div>
<a id="ga315832a821efcad8d12ee4d0158a0bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga315832a821efcad8d12ee4d0158a0bbd">&#9670;&nbsp;</a></span>quadDiscArcs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::quadDiscArcs[3][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of quadrilateral normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>quadDiscArcs[i]</code> lists the boundary arcs of the quadrilateral disc of type <em>i</em>. See <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for further details.</p>
<p>Note that permutation <code>quadDiscArcs[i][j]</code> will be even precisely when <code>j</code> is even.</p>
<dl class="section user"><dt>C++:\n This array is replaced by a macro</dt><dd><code>quadDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a id="ga07dd2a65f964363e8b619487011a4805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07dd2a65f964363e8b619487011a4805">&#9670;&nbsp;</a></span>quadMeeting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadMeeting[4][4][2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists which quadrilateral types meet which edges in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p><code>quadMeeting[i][j][0,1]</code> are the numbers of the two quadrilateral types that meet the edge joining tetrahedron vertices <code>i</code> and <code>j</code>. </p>

</div>
</div>
<a id="gac06d9e3981cbce33198558cb05246502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac06d9e3981cbce33198558cb05246502">&#9670;&nbsp;</a></span>quadPartner</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadPartner[3][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists the second vertex with which each vertex is paired under each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>Quadrilateral type <code>i</code> pairs vertex <code>v</code> with vertex <code>quadPartner[i][v]</code>. </p>

</div>
</div>
<a id="gac514ed78842ca859a43dcd7a973db246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac514ed78842ca859a43dcd7a973db246">&#9670;&nbsp;</a></span>quadSeparating</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int regina::quadSeparating[4][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists which quadrilateral types separate which pairs of vertices in a tetrahedron. </p>
<p>As outlined in <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a>, there are three quadrilateral types in a tetrahedron, numbered 0, 1 and 2. Each quadrilateral type separates the four tetrahedron vertices 0,1,2,3 into two pairs. <code>quadSeparating[i][j]</code> is the number of the quadrilateral type that keeps vertices <code>i</code> and <code>j</code> together.</p>
<p>It is guaranteed that quadrilateral type <em>i</em> will keep the vertices of edge <em>i</em> together (and will therefore also keep the vertices of edge <em>5-i</em> together). </p>

</div>
</div>
<a id="ga4061f33eff68ee48a6acc372a53676b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4061f33eff68ee48a6acc372a53676b1">&#9670;&nbsp;</a></span>quadString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char regina::quadString[3][6]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains strings that can be used to represent each quadrilateral type in a tetrahedron. </p>
<p>See <a class="el" href="group__surfaces.html#gac514ed78842ca859a43dcd7a973db246" title="Lists which quadrilateral types separate which pairs of vertices in a tetrahedron.">regina::quadSeparating</a> and <a class="el" href="classregina_1_1NormalSurface.html#ac8380567805860ecdbde4bde09a5fc9c" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NormalSurface::quads()</a> for more information on quadrilateral types.</p>
<p>The string describing quadrilateral type <code>i</code> is <code>quadString[i]</code> and is of the form <code>02/13</code>, which in this case is the quadrilateral type that splits vertices 0,2 from vertices 1,3. </p>

</div>
</div>
<a id="gac5261f157c24a778410b72973a29d8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5261f157c24a778410b72973a29d8f4">&#9670;&nbsp;</a></span>tetIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::DiscSpec::tetIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The index in the triangulation of the tetrahedron containing the disc. </p>

</div>
</div>
<a id="ga2a22ab75ad4c87286476a25ca1c8e5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a22ab75ad4c87286476a25ca1c8e5a7">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::DiscSetSurface::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The triangulation in which the normal surface lives. </p>

</div>
</div>
<a id="ga1ed7e2568c2e6085550dec8b1ff5eeb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed7e2568c2e6085550dec8b1ff5eeb1">&#9670;&nbsp;</a></span>triDiscArcs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;4&gt; regina::triDiscArcs[4][3]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lists in consecutive order the directed normal arcs that form the boundary of each type of triangular normal disc. </p>
<p>Each permutation <em>p</em> represents an arc about vertex <code>p[0]</code> parallel to the directed edge from <code>p[1]</code> to <code>p[2]</code>.</p>
<p>Array <code>triDiscArcs[i]</code> lists the boundary arcs of the triangular disc of type <em>i</em>. See <a class="el" href="classregina_1_1NormalSurface.html#aa25f8c4dad5d3efcfe3f01aeca20c8a8" title="Returns the number of triangular discs of the given type in this normal surface.">NormalSurface::triangles()</a> for further details.</p>
<p>Note that every permutation in this array is even.</p>
<dl class="section user"><dt>C++:\n This array is replaced by a macro</dt><dd><code>triDiscArcs(discType, arcIndex)</code> that essentially looks up the corresponding array. This is necessary because of a bug in gcc 2.95. </dd></dl>

</div>
</div>
<a id="ga65724d286ef5ccb7750731c6661d3ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65724d286ef5ccb7750731c6661d3ed8">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int regina::DiscSpec::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The disc type; this is between 0 and 9 inclusive, as described in the <em><a class="el" href="structregina_1_1DiscSpec.html" title="Specifies a single normal disc in a normal surface.">DiscSpec</a></em> class notes. </p>

</div>
</div>
<h2 class="groupheader">Friends</h2>
<a id="ga7dafddbd2002f15da2be17a09289f05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dafddbd2002f15da2be17a09289f05e">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structregina_1_1DiscSpec.html">DiscSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the given disc specifier to the given output stream. </p>
<p>The disc specifier will be written as a triple <code>(tetIndex, type, number)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">spec</td><td>the disc specifier to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to <em>out</em>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
