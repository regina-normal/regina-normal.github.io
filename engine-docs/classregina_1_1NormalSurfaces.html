<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::NormalSurfaces Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1NormalSurfaces-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NormalSurfaces Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A packet representing a collection of normal surfaces in a 3-manifold.  
 <a href="classregina_1_1NormalSurfaces.html#details">More...</a></p>

<p><code>#include &lt;surfaces/normalsurfaces.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NormalSurfaces:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NormalSurfaces.png" usemap="#regina::NormalSurfaces_map" alt=""/>
  <map id="regina::NormalSurfaces_map" name="regina::NormalSurfaces_map">
<area href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon." alt="regina::Packet" shape="rect" coords="111,56,323,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; Packet &gt;" shape="rect" coords="0,0,212,24"/>
<area href="classregina_1_1SafePointeeBase.html" alt="regina::SafePointeeBase&lt; Packet &gt;" shape="rect" coords="222,0,434,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html">SurfaceInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output iterator used to insert surfaces into an <a class="el" href="classregina_1_1NormalSurfaces.html" title="A packet representing a collection of normal surfaces in a 3-manifold.">NormalSurfaces</a>.  <a href="structregina_1_1NormalSurfaces_1_1SurfaceInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bidirectional iterator that runs through the raw vectors for surfaces in this list.  <a href="classregina_1_1NormalSurfaces_1_1VectorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td></tr>
<tr class="memdesc:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object being pointed to.  <a href="#a2e4bacf91fc79a12ae3a02f4339ed034">More...</a><br /></td></tr>
<tr class="separator:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a275289f18f2ae608d8f2d573967f63bb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a275289f18f2ae608d8f2d573967f63bb">~NormalSurfaces</a> ()</td></tr>
<tr class="memdesc:a275289f18f2ae608d8f2d573967f63bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys this list and all the surfaces within.  <a href="#a275289f18f2ae608d8f2d573967f63bb">More...</a><br /></td></tr>
<tr class="separator:a275289f18f2ae608d8f2d573967f63bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada70246d67b766fd35a224bd561ee071"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">coords</a> () const</td></tr>
<tr class="memdesc:ada70246d67b766fd35a224bd561ee071"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system being used by the surfaces stored in this set.  <a href="#ada70246d67b766fd35a224bd561ee071">More...</a><br /></td></tr>
<tr class="separator:ada70246d67b766fd35a224bd561ee071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a12326b8c6dfebfefe97b34b15920c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">which</a> () const</td></tr>
<tr class="memdesc:a2a12326b8c6dfebfefe97b34b15920c7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of which normal surfaces this list represents within the underlying triangulation.  <a href="#a2a12326b8c6dfebfefe97b34b15920c7">More...</a><br /></td></tr>
<tr class="separator:a2a12326b8c6dfebfefe97b34b15920c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb828ac80eb4538f156dfd63b4c30f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a9fb828ac80eb4538f156dfd63b4c30f9">algorithm</a> () const</td></tr>
<tr class="memdesc:a9fb828ac80eb4538f156dfd63b4c30f9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the algorithm that was used to enumerate this list.  <a href="#a9fb828ac80eb4538f156dfd63b4c30f9">More...</a><br /></td></tr>
<tr class="separator:a9fb828ac80eb4538f156dfd63b4c30f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286441732edb4692736f33e769489dde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a286441732edb4692736f33e769489dde">allowsAlmostNormal</a> () const</td></tr>
<tr class="memdesc:a286441732edb4692736f33e769489dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="#a286441732edb4692736f33e769489dde">More...</a><br /></td></tr>
<tr class="separator:a286441732edb4692736f33e769489dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3529c33550ecf08dcd6d7a33409a8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a0f3529c33550ecf08dcd6d7a33409a8b">allowsSpun</a> () const</td></tr>
<tr class="memdesc:a0f3529c33550ecf08dcd6d7a33409a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system being used allows for spun normal surfaces.  <a href="#a0f3529c33550ecf08dcd6d7a33409a8b">More...</a><br /></td></tr>
<tr class="separator:a0f3529c33550ecf08dcd6d7a33409a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbcbedabcb93d26a3cd50eee857f27f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a4bbcbedabcb93d26a3cd50eee857f27f">allowsOriented</a> () const</td></tr>
<tr class="memdesc:a4bbcbedabcb93d26a3cd50eee857f27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the coordinate system being used allows for transversely oriented normal surfaces.  <a href="#a4bbcbedabcb93d26a3cd50eee857f27f">More...</a><br /></td></tr>
<tr class="separator:a4bbcbedabcb93d26a3cd50eee857f27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4235db32ccba3f9f49e8b668afb8ad85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a4235db32ccba3f9f49e8b668afb8ad85">isEmbeddedOnly</a> () const</td></tr>
<tr class="memdesc:a4235db32ccba3f9f49e8b668afb8ad85"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was constructed to contain only properly embedded surfaces.  <a href="#a4235db32ccba3f9f49e8b668afb8ad85">More...</a><br /></td></tr>
<tr class="separator:a4235db32ccba3f9f49e8b668afb8ad85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa808164e874f88896ac40703b6409c36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#aa808164e874f88896ac40703b6409c36">triangulation</a> () const</td></tr>
<tr class="memdesc:aa808164e874f88896ac40703b6409c36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which these normal surfaces live.  <a href="#aa808164e874f88896ac40703b6409c36">More...</a><br /></td></tr>
<tr class="separator:aa808164e874f88896ac40703b6409c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aae88a4f82d88e1ed542f17d26904d7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a0aae88a4f82d88e1ed542f17d26904d7">size</a> () const</td></tr>
<tr class="memdesc:a0aae88a4f82d88e1ed542f17d26904d7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of surfaces stored in this list.  <a href="#a0aae88a4f82d88e1ed542f17d26904d7">More...</a><br /></td></tr>
<tr class="separator:a0aae88a4f82d88e1ed542f17d26904d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75527d87d83254739c7e52175546acf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#aa75527d87d83254739c7e52175546acf">surface</a> (size_t index) const</td></tr>
<tr class="memdesc:aa75527d87d83254739c7e52175546acf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the surface at the requested index in this set.  <a href="#aa75527d87d83254739c7e52175546acf">More...</a><br /></td></tr>
<tr class="separator:aa75527d87d83254739c7e52175546acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564d43bd562cadba9bddbcd960d77596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a564d43bd562cadba9bddbcd960d77596">writeAllSurfaces</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:a564d43bd562cadba9bddbcd960d77596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the number of surfaces in this set followed by the details of each surface to the given output stream.  <a href="#a564d43bd562cadba9bddbcd960d77596">More...</a><br /></td></tr>
<tr class="separator:a564d43bd562cadba9bddbcd960d77596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6801fb032b55c800bb82e89fce2bbe71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a6801fb032b55c800bb82e89fce2bbe71">writeTextShort</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:a6801fb032b55c800bb82e89fce2bbe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a6801fb032b55c800bb82e89fce2bbe71">More...</a><br /></td></tr>
<tr class="separator:a6801fb032b55c800bb82e89fce2bbe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07dcdec28b20348705f8cec15838957"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ad07dcdec28b20348705f8cec15838957">writeTextLong</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:ad07dcdec28b20348705f8cec15838957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#ad07dcdec28b20348705f8cec15838957">More...</a><br /></td></tr>
<tr class="separator:ad07dcdec28b20348705f8cec15838957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33634993b549ee12249b97a019fe002"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ad33634993b549ee12249b97a019fe002">dependsOnParent</a> () const override</td></tr>
<tr class="memdesc:ad33634993b549ee12249b97a019fe002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="#ad33634993b549ee12249b97a019fe002">More...</a><br /></td></tr>
<tr class="separator:ad33634993b549ee12249b97a019fe002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d837b8eb709fd079d4ec8e5f30889"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a923d837b8eb709fd079d4ec8e5f30889">quadToStandard</a> () const</td></tr>
<tr class="memdesc:a923d837b8eb709fd079d4ec8e5f30889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embedded vertex normal surfaces in standard (tri-quad) space.  <a href="#a923d837b8eb709fd079d4ec8e5f30889">More...</a><br /></td></tr>
<tr class="separator:a923d837b8eb709fd079d4ec8e5f30889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e160a2b7934ad098ab2252adfd128db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a8e160a2b7934ad098ab2252adfd128db">quadOctToStandardAN</a> () const</td></tr>
<tr class="memdesc:a8e160a2b7934ad098ab2252adfd128db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space to the set of all embedded vertex almost normal surfaces in the standard tri-quad-oct space.  <a href="#a8e160a2b7934ad098ab2252adfd128db">More...</a><br /></td></tr>
<tr class="separator:a8e160a2b7934ad098ab2252adfd128db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ffe41e50f214351ee2086ef600661a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a92ffe41e50f214351ee2086ef600661a">standardToQuad</a> () const</td></tr>
<tr class="memdesc:a92ffe41e50f214351ee2086ef600661a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of all embedded vertex normal surfaces in quadrilateral space.  <a href="#a92ffe41e50f214351ee2086ef600661a">More...</a><br /></td></tr>
<tr class="separator:a92ffe41e50f214351ee2086ef600661a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3212b3ec1451db0bcc98871c65d78937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a3212b3ec1451db0bcc98871c65d78937">standardANToQuadOct</a> () const</td></tr>
<tr class="memdesc:a3212b3ec1451db0bcc98871c65d78937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space to the set of all embedded vertex almost normal surfaces in the smaller quadrilateral-octagon space.  <a href="#a3212b3ec1451db0bcc98871c65d78937">More...</a><br /></td></tr>
<tr class="separator:a3212b3ec1451db0bcc98871c65d78937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2995d136dc8e575605230cec31dd8c9"><td class="memTemplParams" colspan="2">template&lt;typename Comparison &gt; </td></tr>
<tr class="memitem:ae2995d136dc8e575605230cec31dd8c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ae2995d136dc8e575605230cec31dd8c9">sort</a> (Comparison &amp;&amp;comp)</td></tr>
<tr class="memdesc:ae2995d136dc8e575605230cec31dd8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the surfaces in this list according to the given criterion.  <a href="#ae2995d136dc8e575605230cec31dd8c9">More...</a><br /></td></tr>
<tr class="separator:ae2995d136dc8e575605230cec31dd8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c9723cc44bf8da34f136eb7c27a835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ae8c9723cc44bf8da34f136eb7c27a835">filterForLocallyCompatiblePairs</a> () const</td></tr>
<tr class="memdesc:ae8c9723cc44bf8da34f136eb7c27a835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list filled with the surfaces from this list that have at least one locally compatible partner.  <a href="#ae8c9723cc44bf8da34f136eb7c27a835">More...</a><br /></td></tr>
<tr class="separator:ae8c9723cc44bf8da34f136eb7c27a835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9324d55752c936e253e9c36cce704908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a9324d55752c936e253e9c36cce704908">filterForDisjointPairs</a> () const</td></tr>
<tr class="memdesc:a9324d55752c936e253e9c36cce704908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list filled with the surfaces from this list that have at least one disjoint partner.  <a href="#a9324d55752c936e253e9c36cce704908">More...</a><br /></td></tr>
<tr class="separator:a9324d55752c936e253e9c36cce704908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed23bbdd0688519b1eb4a3077cec118"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a7ed23bbdd0688519b1eb4a3077cec118">filterForPotentiallyIncompressible</a> () const</td></tr>
<tr class="memdesc:a7ed23bbdd0688519b1eb4a3077cec118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new list filled with only the surfaces from this list that "might" represent two-sided incompressible surfaces.  <a href="#a7ed23bbdd0688519b1eb4a3077cec118">More...</a><br /></td></tr>
<tr class="separator:a7ed23bbdd0688519b1eb4a3077cec118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1959b9dcedd0e35e00320f0490eaf75c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a1959b9dcedd0e35e00320f0490eaf75c">recreateMatchingEquations</a> () const</td></tr>
<tr class="memdesc:a1959b9dcedd0e35e00320f0490eaf75c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created matrix containing the matching equations that were used to create this normal surface list.  <a href="#a1959b9dcedd0e35e00320f0490eaf75c">More...</a><br /></td></tr>
<tr class="separator:a1959b9dcedd0e35e00320f0490eaf75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b308eb9fd7a131b2c370a589b7e43c6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a2b308eb9fd7a131b2c370a589b7e43c6">saveCSVStandard</a> (const char *filename, int additionalFields=<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a>)</td></tr>
<tr class="memdesc:a2b308eb9fd7a131b2c370a589b7e43c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports this list of normal surfaces as a plain text CSV (comma-separated value) file, using standard coordinates.  <a href="#a2b308eb9fd7a131b2c370a589b7e43c6">More...</a><br /></td></tr>
<tr class="separator:a2b308eb9fd7a131b2c370a589b7e43c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2559f5cea6339eb69cdcc532f970409"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#ae2559f5cea6339eb69cdcc532f970409">saveCSVEdgeWeight</a> (const char *filename, int additionalFields=<a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a>)</td></tr>
<tr class="memdesc:ae2559f5cea6339eb69cdcc532f970409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file, using edge weight coordinates.  <a href="#ae2559f5cea6339eb69cdcc532f970409">More...</a><br /></td></tr>
<tr class="separator:ae2559f5cea6339eb69cdcc532f970409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8da79103f921bee2f52e6fdb39eb2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#adb8da79103f921bee2f52e6fdb39eb2e">beginVectors</a> () const</td></tr>
<tr class="memdesc:adb8da79103f921bee2f52e6fdb39eb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that gives access to the raw vectors for surfaces in this list, pointing to the beginning of this surface list.  <a href="#adb8da79103f921bee2f52e6fdb39eb2e">More...</a><br /></td></tr>
<tr class="separator:adb8da79103f921bee2f52e6fdb39eb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268c1848908924fc19644b83309beeba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">VectorIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a268c1848908924fc19644b83309beeba">endVectors</a> () const</td></tr>
<tr class="memdesc:a268c1848908924fc19644b83309beeba"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that gives access to the raw vectors for surfaces in this list, pointing past the end of this surface list.  <a href="#a268c1848908924fc19644b83309beeba">More...</a><br /></td></tr>
<tr class="separator:a268c1848908924fc19644b83309beeba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">hasOwner</a> () const</td></tr>
<tr class="memdesc:gac85ba39c124eda4ce631b653d6bb0a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object.  <a href="group__packet.html#gac85ba39c124eda4ce631b653d6bb0a29">More...</a><br /></td></tr>
<tr class="separator:gac85ba39c124eda4ce631b653d6bb0a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa724448326c5e5b0ba727fe6ce6d1233"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#aa724448326c5e5b0ba727fe6ce6d1233">hasSafePtr</a> () const</td></tr>
<tr class="memdesc:aa724448326c5e5b0ba727fe6ce6d1233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is there one or more SafePtr currently pointing to this object?  <a href="#aa724448326c5e5b0ba727fe6ce6d1233">More...</a><br /></td></tr>
<tr class="separator:aa724448326c5e5b0ba727fe6ce6d1233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Identification</div></td></tr>
<tr class="memitem:ga11e183185ea0a33e67e2574fc93c7469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a> () const =0</td></tr>
<tr class="memdesc:ga11e183185ea0a33e67e2574fc93c7469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet.  <a href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">More...</a><br /></td></tr>
<tr class="separator:ga11e183185ea0a33e67e2574fc93c7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787a09ec531988778fcfb0bc87effdd4"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">typeName</a> () const =0</td></tr>
<tr class="memdesc:ga787a09ec531988778fcfb0bc87effdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet.  <a href="group__packet.html#ga787a09ec531988778fcfb0bc87effdd4">More...</a><br /></td></tr>
<tr class="separator:ga787a09ec531988778fcfb0bc87effdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a> () const</td></tr>
<tr class="memdesc:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">More...</a><br /></td></tr>
<tr class="separator:gafd05b16f0990a54ac7f95bc32cf1483e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfaee615502b79cbeef31628a1186dc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">humanLabel</a> () const</td></tr>
<tr class="memdesc:gadfaee615502b79cbeef31628a1186dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="group__packet.html#gadfaee615502b79cbeef31628a1186dc4">More...</a><br /></td></tr>
<tr class="separator:gadfaee615502b79cbeef31628a1186dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">adornedLabel</a> (const std::string &amp;adornment) const</td></tr>
<tr class="memdesc:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string.  <a href="group__packet.html#gae1cd6eea63e8cd41d7517f86b8c7776d">More...</a><br /></td></tr>
<tr class="separator:gae1cd6eea63e8cd41d7517f86b8c7776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd869991cbf664891629f21a5432b02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gadfd869991cbf664891629f21a5432b02">setLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:gadfd869991cbf664891629f21a5432b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="group__packet.html#gadfd869991cbf664891629f21a5432b02">More...</a><br /></td></tr>
<tr class="separator:gadfd869991cbf664891629f21a5432b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29f5775c175a56d06da14444b391ed3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">fullName</a> () const</td></tr>
<tr class="memdesc:ga29f5775c175a56d06da14444b391ed3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet.  <a href="group__packet.html#ga29f5775c175a56d06da14444b391ed3a">More...</a><br /></td></tr>
<tr class="separator:ga29f5775c175a56d06da14444b391ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tags</div></td></tr>
<tr class="memitem:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">hasTag</a> (const std::string &amp;tag) const</td></tr>
<tr class="memdesc:gaf4315a8b8ebcf47e781c204927f8845f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="group__packet.html#gaf4315a8b8ebcf47e781c204927f8845f">More...</a><br /></td></tr>
<tr class="separator:gaf4315a8b8ebcf47e781c204927f8845f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4404beade84983a4f1c051cd64035ddf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">hasTags</a> () const</td></tr>
<tr class="memdesc:ga4404beade84983a4f1c051cd64035ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="group__packet.html#ga4404beade84983a4f1c051cd64035ddf">More...</a><br /></td></tr>
<tr class="separator:ga4404beade84983a4f1c051cd64035ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="group__packet.html#ga982b9936f9e9dc11ce932d4e8c7402de">More...</a><br /></td></tr>
<tr class="separator:ga982b9936f9e9dc11ce932d4e8c7402de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="group__packet.html#gacb9880c0189b8f60827cd0ce9a2bb32c">More...</a><br /></td></tr>
<tr class="separator:gacb9880c0189b8f60827cd0ce9a2bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">removeAllTags</a> ()</td></tr>
<tr class="memdesc:gaee2405989e058dbfddf7ae445d47ddcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="group__packet.html#gaee2405989e058dbfddf7ae445d47ddcf">More...</a><br /></td></tr>
<tr class="separator:gaee2405989e058dbfddf7ae445d47ddcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06d41356ff086d078b04f34919aac26d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">tags</a> () const</td></tr>
<tr class="memdesc:ga06d41356ff086d078b04f34919aac26d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="group__packet.html#ga06d41356ff086d078b04f34919aac26d">More...</a><br /></td></tr>
<tr class="separator:ga06d41356ff086d078b04f34919aac26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event Handling</div></td></tr>
<tr class="memitem:gaa504cfa813a3190c00337743915ffef5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">listen</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gaa504cfa813a3190c00337743915ffef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="group__packet.html#gaa504cfa813a3190c00337743915ffef5">More...</a><br /></td></tr>
<tr class="separator:gaa504cfa813a3190c00337743915ffef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">isListening</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="group__packet.html#gacd2dc2dee3396afb9dbf07c38fe10d63">More...</a><br /></td></tr>
<tr class="separator:gacd2dc2dee3396afb9dbf07c38fe10d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae71b40cd2416de174bba61db2ec92f1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">unlisten</a> (<a class="el" href="classregina_1_1PacketListener.html">PacketListener</a> *listener)</td></tr>
<tr class="memdesc:gae71b40cd2416de174bba61db2ec92f1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="group__packet.html#gae71b40cd2416de174bba61db2ec92f1d">More...</a><br /></td></tr>
<tr class="separator:gae71b40cd2416de174bba61db2ec92f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Queries</div></td></tr>
<tr class="memitem:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a> () const</td></tr>
<tr class="memdesc:gab80d6d7bc86d4600980f0c9555bb6237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">More...</a><br /></td></tr>
<tr class="separator:gab80d6d7bc86d4600980f0c9555bb6237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">firstChild</a> () const</td></tr>
<tr class="memdesc:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="group__packet.html#ga6eec5fa6ced4aa15edcef36d9d299a5d">More...</a><br /></td></tr>
<tr class="separator:ga6eec5fa6ced4aa15edcef36d9d299a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">lastChild</a> () const</td></tr>
<tr class="memdesc:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="group__packet.html#ga0a6c8037ec9109e8bf422b3cade7676e">More...</a><br /></td></tr>
<tr class="separator:ga0a6c8037ec9109e8bf422b3cade7676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">nextSibling</a> () const</td></tr>
<tr class="memdesc:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="group__packet.html#ga7afd16bf0e5cf7a3efe8f5d0944fe165">More...</a><br /></td></tr>
<tr class="separator:ga7afd16bf0e5cf7a3efe8f5d0944fe165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84decda10642eccee55a109e70e10076"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga84decda10642eccee55a109e70e10076">prevSibling</a> () const</td></tr>
<tr class="memdesc:ga84decda10642eccee55a109e70e10076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="group__packet.html#ga84decda10642eccee55a109e70e10076">More...</a><br /></td></tr>
<tr class="separator:ga84decda10642eccee55a109e70e10076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">root</a> () const</td></tr>
<tr class="memdesc:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="group__packet.html#ga49a21b8f9147249e97d68ac6cdce0c20">More...</a><br /></td></tr>
<tr class="separator:ga49a21b8f9147249e97d68ac6cdce0c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">levelsDownTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="group__packet.html#ga8d80a76204afdb9ea31bfef77b137bf3">More...</a><br /></td></tr>
<tr class="separator:ga8d80a76204afdb9ea31bfef77b137bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">levelsUpTo</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *ancestor) const</td></tr>
<tr class="memdesc:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="group__packet.html#gaf4ed7022c81276beb3ef81ca8db024fa">More...</a><br /></td></tr>
<tr class="separator:gaf4ed7022c81276beb3ef81ca8db024fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">isGrandparentOf</a> (const <a class="el" href="classregina_1_1Packet.html">Packet</a> *descendant) const</td></tr>
<tr class="memdesc:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="group__packet.html#ga8848bba753ebfb2ea9940391da9c2eb9">More...</a><br /></td></tr>
<tr class="separator:ga8848bba753ebfb2ea9940391da9c2eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">countChildren</a> () const</td></tr>
<tr class="memdesc:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet.  <a href="group__packet.html#gae2df11b3b1cecdfbce1a4c53bd1a0395">More...</a><br /></td></tr>
<tr class="separator:gae2df11b3b1cecdfbce1a4c53bd1a0395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">countDescendants</a> () const</td></tr>
<tr class="memdesc:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of strict descendants of this packet.  <a href="group__packet.html#ga33da88ebed1a4ceccdf70172eff4e3f1">More...</a><br /></td></tr>
<tr class="separator:ga33da88ebed1a4ceccdf70172eff4e3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2519c2dac8e039b7acd5df8373c608d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">totalTreeSize</a> () const</td></tr>
<tr class="memdesc:gae2519c2dac8e039b7acd5df8373c608d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gae2519c2dac8e039b7acd5df8373c608d">More...</a><br /></td></tr>
<tr class="separator:gae2519c2dac8e039b7acd5df8373c608d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Manipulation</div></td></tr>
<tr class="memitem:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">insertChildFirst</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gac389781f5c53a7d3aac3206d51ecfd91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="group__packet.html#gac389781f5c53a7d3aac3206d51ecfd91">More...</a><br /></td></tr>
<tr class="separator:gac389781f5c53a7d3aac3206d51ecfd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">insertChildLast</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *child)</td></tr>
<tr class="memdesc:gad3d02be74192f03b372a4195c9e5bc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="group__packet.html#gad3d02be74192f03b372a4195c9e5bc1f">More...</a><br /></td></tr>
<tr class="separator:gad3d02be74192f03b372a4195c9e5bc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9556e8405ca88517ccd5549471fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">insertChildAfter</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newChild, <a class="el" href="classregina_1_1Packet.html">Packet</a> *prevChild)</td></tr>
<tr class="memdesc:gad7f9556e8405ca88517ccd5549471fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="group__packet.html#gad7f9556e8405ca88517ccd5549471fea">More...</a><br /></td></tr>
<tr class="separator:gad7f9556e8405ca88517ccd5549471fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">makeOrphan</a> ()</td></tr>
<tr class="memdesc:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree.  <a href="group__packet.html#gad9aa0488b40a1f3ec702838b2a2ceecc">More...</a><br /></td></tr>
<tr class="separator:gad9aa0488b40a1f3ec702838b2a2ceecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">reparent</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent, bool first=false)</td></tr>
<tr class="memdesc:ga219920e1523d3edf2982da0a3ba1a33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="group__packet.html#ga219920e1523d3edf2982da0a3ba1a33d">More...</a><br /></td></tr>
<tr class="separator:ga219920e1523d3edf2982da0a3ba1a33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">transferChildren</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *newParent)</td></tr>
<tr class="memdesc:ga27ce736503ede9e8c57fb5d169e6414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="group__packet.html#ga27ce736503ede9e8c57fb5d169e6414f">More...</a><br /></td></tr>
<tr class="separator:ga27ce736503ede9e8c57fb5d169e6414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765186c1742fe402922433b77e5f439a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga765186c1742fe402922433b77e5f439a">swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:ga765186c1742fe402922433b77e5f439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="group__packet.html#ga765186c1742fe402922433b77e5f439a">More...</a><br /></td></tr>
<tr class="separator:ga765186c1742fe402922433b77e5f439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="group__packet.html#gae02f6b3ad3a7816cde5d7df456763aaf">More...</a><br /></td></tr>
<tr class="separator:gae02f6b3ad3a7816cde5d7df456763aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adc13b6143cf994779796077aed731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga59adc13b6143cf994779796077aed731">moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:ga59adc13b6143cf994779796077aed731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="group__packet.html#ga59adc13b6143cf994779796077aed731">More...</a><br /></td></tr>
<tr class="separator:ga59adc13b6143cf994779796077aed731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4d7730c57940444bf7d3085459449e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">moveToFirst</a> ()</td></tr>
<tr class="memdesc:gab4d7730c57940444bf7d3085459449e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="group__packet.html#gab4d7730c57940444bf7d3085459449e8">More...</a><br /></td></tr>
<tr class="separator:gab4d7730c57940444bf7d3085459449e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">moveToLast</a> ()</td></tr>
<tr class="memdesc:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="group__packet.html#ga7fcff38ccb62b62d28bed83d2a3a28d5">More...</a><br /></td></tr>
<tr class="separator:ga7fcff38ccb62b62d28bed83d2a3a28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf91bc951714dc60db12810affb266b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">sortChildren</a> ()</td></tr>
<tr class="memdesc:gaf91bc951714dc60db12810affb266b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="group__packet.html#gaf91bc951714dc60db12810affb266b8a">More...</a><br /></td></tr>
<tr class="separator:gaf91bc951714dc60db12810affb266b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Searching and Iterating</div></td></tr>
<tr class="memitem:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">begin</a> ()</td></tr>
<tr class="memdesc:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator at the beginning of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#gab7ab56cf7ba6ebdc6176b1b4bc2cb287">More...</a><br /></td></tr>
<tr class="separator:gab7ab56cf7ba6ebdc6176b1b4bc2cb287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941baf3f572331538ec82154fd3dc997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1SubtreeIterator.html">SubtreeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a> ()</td></tr>
<tr class="memdesc:ga941baf3f572331538ec82154fd3dc997"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an iterator beyond the end of the range of packets in the subtree rooted at this packet.  <a href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">More...</a><br /></td></tr>
<tr class="separator:ga941baf3f572331538ec82154fd3dc997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketDescendants.html">PacketDescendants</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">descendants</a> () const</td></tr>
<tr class="memdesc:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through all strict descendants of this packet in the packet tree.  <a href="group__packet.html#ga4cf495d57c19d371358ba5e9955a6dc5">More...</a><br /></td></tr>
<tr class="separator:ga4cf495d57c19d371358ba5e9955a6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf17dd27f603463f226e64ccb65211060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1PacketChildren.html">PacketChildren</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">children</a> () const</td></tr>
<tr class="memdesc:gaf17dd27f603463f226e64ccb65211060"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a lightweight object for iterating through the immediate children of this packet.  <a href="group__packet.html#gaf17dd27f603463f226e64ccb65211060">More...</a><br /></td></tr>
<tr class="separator:gaf17dd27f603463f226e64ccb65211060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">nextTreePacket</a> ()</td></tr>
<tr class="memdesc:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#ga7bd2bc8fc84f44023a0a4b26ad839621">More...</a><br /></td></tr>
<tr class="separator:ga7bd2bc8fc84f44023a0a4b26ad839621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">nextTreePacket</a> () const</td></tr>
<tr class="memdesc:gaeaff341860febcb3daadd1b9b4216c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="group__packet.html#gaeaff341860febcb3daadd1b9b4216c3d">More...</a><br /></td></tr>
<tr class="separator:gaeaff341860febcb3daadd1b9b4216c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga6b3f24565a5053de126c8169d1a3ccdb">More...</a><br /></td></tr>
<tr class="separator:ga6b3f24565a5053de126c8169d1a3ccdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74345507fd3326dc1b22a284b90da5d1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">nextTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga74345507fd3326dc1b22a284b90da5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="group__packet.html#ga74345507fd3326dc1b22a284b90da5d1">More...</a><br /></td></tr>
<tr class="separator:ga74345507fd3326dc1b22a284b90da5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e196f0f1c415b457df17f96d5b6518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>)</td></tr>
<tr class="memdesc:ga12e196f0f1c415b457df17f96d5b6518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga12e196f0f1c415b457df17f96d5b6518">More...</a><br /></td></tr>
<tr class="separator:ga12e196f0f1c415b457df17f96d5b6518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">firstTreePacket</a> (const std::string &amp;<a class="el" href="group__packet.html#ga11e183185ea0a33e67e2574fc93c7469">type</a>) const</td></tr>
<tr class="memdesc:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="group__packet.html#ga9a8ec6e940be4cf49c3f19a563b9cb16">More...</a><br /></td></tr>
<tr class="separator:ga9a8ec6e940be4cf49c3f19a563b9cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>)</td></tr>
<tr class="memdesc:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#ga6f7c7be06c9ed6d15f99787ea5d883b2">More...</a><br /></td></tr>
<tr class="separator:ga6f7c7be06c9ed6d15f99787ea5d883b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7855ea352221d498d1ca38a34d85af5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">findPacketLabel</a> (const std::string &amp;<a class="el" href="group__packet.html#gafd05b16f0990a54ac7f95bc32cf1483e">label</a>) const</td></tr>
<tr class="memdesc:gac7855ea352221d498d1ca38a34d85af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="group__packet.html#gac7855ea352221d498d1ca38a34d85af5">More...</a><br /></td></tr>
<tr class="separator:gac7855ea352221d498d1ca38a34d85af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Dependencies</div></td></tr>
<tr class="memitem:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">isPacketEditable</a> () const</td></tr>
<tr class="memdesc:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children.  <a href="group__packet.html#gaa03a6c9fb8c55dbed8a86f32b5975437">More...</a><br /></td></tr>
<tr class="separator:gaa03a6c9fb8c55dbed8a86f32b5975437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloning</div></td></tr>
<tr class="memitem:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">clone</a> (bool cloneDescendants=false, bool <a class="el" href="group__packet.html#ga941baf3f572331538ec82154fd3dc997">end</a>=true) const</td></tr>
<tr class="memdesc:ga73c411ef1237a06ad6b634d3db67f17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="group__packet.html#ga73c411ef1237a06ad6b634d3db67f17d">More...</a><br /></td></tr>
<tr class="separator:ga73c411ef1237a06ad6b634d3db67f17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File I/O</div></td></tr>
<tr class="memitem:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">save</a> (const char *filename, bool compressed=true) const</td></tr>
<tr class="memdesc:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="group__packet.html#ga9e2f7f2c116c52b44aa9dcf092a87892">More...</a><br /></td></tr>
<tr class="separator:ga9e2f7f2c116c52b44aa9dcf092a87892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">save</a> (std::ostream &amp;s, bool compressed=true) const</td></tr>
<tr class="memdesc:ga898ec49e8d39c46cd965ad506493f2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="group__packet.html#ga898ec49e8d39c46cd965ad506493f2cc">More...</a><br /></td></tr>
<tr class="separator:ga898ec49e8d39c46cd965ad506493f2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">writeXMLFile</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga0bf681a968d890cd848f1277ea22ea0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="group__packet.html#ga0bf681a968d890cd848f1277ea22ea0f">More...</a><br /></td></tr>
<tr class="separator:ga0bf681a968d890cd848f1277ea22ea0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">internalID</a> () const</td></tr>
<tr class="memdesc:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="group__packet.html#ga0b6130ab1dda164f6c6a6158a854f79f">More...</a><br /></td></tr>
<tr class="separator:ga0b6130ab1dda164f6c6a6158a854f79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a64309eac6ce681355dfc352c53299535"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535">enumerate</a> (<a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *owner, <a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">coords</a>, <a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">which</a>=<a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">NS_LIST_DEFAULT</a>, <a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> algHints=<a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">NS_ALG_DEFAULT</a>, <a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *tracker=nullptr)</td></tr>
<tr class="memdesc:a64309eac6ce681355dfc352c53299535"><td class="mdescLeft">&#160;</td><td class="mdescRight">A unified routine for enumerating various classes of normal surfaces within a given triangulation.  <a href="#a64309eac6ce681355dfc352c53299535">More...</a><br /></td></tr>
<tr class="separator:a64309eac6ce681355dfc352c53299535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e8ee06f16ca9ceacc610b0e58c0d08"><td class="memItemLeft" align="right" valign="top"><a id="a32e8ee06f16ca9ceacc610b0e58c0d08"></a>
static <a class="el" href="classregina_1_1XMLPacketReader.html">XMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>xmlReader</b> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>, <a class="el" href="classregina_1_1XMLTreeResolver.html">XMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:a32e8ee06f16ca9ceacc610b0e58c0d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructors</div></td></tr>
<tr class="memitem:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">safeDelete</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either destroys or orphans the given packet, according to whether it has safe pointers that currently reference it.  <a href="group__packet.html#ga2fe7098f6a0b61e94e9e301e4c93a89e">More...</a><br /></td></tr>
<tr class="separator:ga2fe7098f6a0b61e94e9e301e4c93a89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a58f3147bd0d010d26972dc3230334ca7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a58f3147bd0d010d26972dc3230334ca7">NormalSurfaces</a> (<a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> <a class="el" href="classregina_1_1NormalSurfaces.html#ada70246d67b766fd35a224bd561ee071">coords</a>, <a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a2a12326b8c6dfebfefe97b34b15920c7">which</a>, <a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> <a class="el" href="classregina_1_1NormalSurfaces.html#a9fb828ac80eb4538f156dfd63b4c30f9">algorithm</a>)</td></tr>
<tr class="memdesc:a58f3147bd0d010d26972dc3230334ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty list of normal surfaces with the given parameters.  <a href="#a58f3147bd0d010d26972dc3230334ca7">More...</a><br /></td></tr>
<tr class="separator:a58f3147bd0d010d26972dc3230334ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0ab53ae8085a452393a764bd8d5b27"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#adc0ab53ae8085a452393a764bd8d5b27">internalClonePacket</a> (<a class="el" href="classregina_1_1Packet.html">Packet</a> *<a class="el" href="group__packet.html#gab80d6d7bc86d4600980f0c9555bb6237">parent</a>) const override</td></tr>
<tr class="memdesc:adc0ab53ae8085a452393a764bd8d5b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="#adc0ab53ae8085a452393a764bd8d5b27">More...</a><br /></td></tr>
<tr class="separator:adc0ab53ae8085a452393a764bd8d5b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5539ec7f016ba2e9fca94f00971f4c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#aa5539ec7f016ba2e9fca94f00971f4c3">writeXMLPacketData</a> (std::ostream &amp;out) const override</td></tr>
<tr class="memdesc:aa5539ec7f016ba2e9fca94f00971f4c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="#aa5539ec7f016ba2e9fca94f00971f4c3">More...</a><br /></td></tr>
<tr class="separator:aa5539ec7f016ba2e9fca94f00971f4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">writeXMLPacketTree</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the subtree with this packet as matriarch.  <a href="group__packet.html#ga690d1f04ae42ab3778726d37fbd0fe54">More...</a><br /></td></tr>
<tr class="separator:ga690d1f04ae42ab3778726d37fbd0fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a30f9f73eb24a005ad31dc5d07e7f4c93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a30f9f73eb24a005ad31dc5d07e7f4c93">surfaces</a></td></tr>
<tr class="memdesc:a30f9f73eb24a005ad31dc5d07e7f4c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the normal surfaces stored in this packet.  <a href="#a30f9f73eb24a005ad31dc5d07e7f4c93">More...</a><br /></td></tr>
<tr class="separator:a30f9f73eb24a005ad31dc5d07e7f4c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317370303ab0e90b1367b33d57a92e83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a317370303ab0e90b1367b33d57a92e83">coords_</a></td></tr>
<tr class="memdesc:a317370303ab0e90b1367b33d57a92e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores which coordinate system is being used by the normal surfaces in this packet.  <a href="#a317370303ab0e90b1367b33d57a92e83">More...</a><br /></td></tr>
<tr class="separator:a317370303ab0e90b1367b33d57a92e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffe4301bf296b37ea8253f242167660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#a6ffe4301bf296b37ea8253f242167660">which_</a></td></tr>
<tr class="memdesc:a6ffe4301bf296b37ea8253f242167660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which normal surfaces these represent within the underlying triangulation.  <a href="#a6ffe4301bf296b37ea8253f242167660">More...</a><br /></td></tr>
<tr class="separator:a6ffe4301bf296b37ea8253f242167660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e72355f8511a648f728fc452ba850a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NormalSurfaces.html#aa0e72355f8511a648f728fc452ba850a">algorithm_</a></td></tr>
<tr class="memdesc:aa0e72355f8511a648f728fc452ba850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the details of the enumeration algorithm that was used to generate this list.  <a href="#aa0e72355f8511a648f728fc452ba850a">More...</a><br /></td></tr>
<tr class="separator:aa0e72355f8511a648f728fc452ba850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab9b961cf5afa19151031bc345822f39e"><td class="memItemLeft" align="right" valign="top"><a id="ab9b961cf5afa19151031bc345822f39e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>XMLNormalSurfacesReader</b></td></tr>
<tr class="separator:ab9b961cf5afa19151031bc345822f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A packet representing a collection of normal surfaces in a 3-manifold. </p>
<p>Such a packet must always be a child packet of the triangulation from which the surfaces were obtained. If this triangulation changes, the information contained in this packet will become invalid.</p>
<p>See the <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a> class notes for details of what to do when introducing a new coordinate system.</p>
<p>Normal surface lists should be created using the routine <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd><p class="startdd"><em>Feature:</em> Allow custom matching equations. </p>
<p class="interdd"><em>Feature:</em> Allow enumeration with some coordinates explicitly set to zero. </p>
<p class="interdd"><em>Feature:</em> Allow generating only closed surfaces. </p>
<p class="enddd"><em>Feature:</em> Generate facets of the solution space representing embedded surfaces. </p>
</dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2e4bacf91fc79a12ae3a02f4339ed034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4bacf91fc79a12ae3a02f4339ed034">&#9670;&nbsp;</a></span>SafePointeeType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1Packet.html">Packet</a>  <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a>  &gt;::<a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of object being pointed to. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a275289f18f2ae608d8f2d573967f63bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275289f18f2ae608d8f2d573967f63bb">&#9670;&nbsp;</a></span>~NormalSurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::~NormalSurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys this list and all the surfaces within. </p>

</div>
</div>
<a id="a58f3147bd0d010d26972dc3230334ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f3147bd0d010d26972dc3230334ca7">&#9670;&nbsp;</a></span>NormalSurfaces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NormalSurfaces::NormalSurfaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td>
          <td class="paramname"><em>algorithm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty list of normal surfaces with the given parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>the coordinate system to be used for filling this list. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal surfaces these will represent within the underlying triangulation. </td></tr>
    <tr><td class="paramname">algorithm</td><td>details of the enumeration algorithm that will be used to fill this list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9fb828ac80eb4538f156dfd63b4c30f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb828ac80eb4538f156dfd63b4c30f9">&#9670;&nbsp;</a></span>algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> regina::NormalSurfaces::algorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of the algorithm that was used to enumerate this list. </p>
<p>These may not be the same NormalAlg flags that were passed to <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>. In particular, default values will have been explicitly filled in, invalid and/or redundant values will have been removed, and unavailable and/or unsupported combinations of algorithm flags will be replaced with whatever algorithm was actually used.</p>
<dl class="section return"><dt>Returns</dt><dd>details of the algorithm used to enumerate this list. </dd></dl>

</div>
</div>
<a id="a286441732edb4692736f33e769489dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286441732edb4692736f33e769489dde">&#9670;&nbsp;</a></span>allowsAlmostNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the coordinate system being used allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed. </dd></dl>

</div>
</div>
<a id="a4bbcbedabcb93d26a3cd50eee857f27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbcbedabcb93d26a3cd50eee857f27f">&#9670;&nbsp;</a></span>allowsOriented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the coordinate system being used allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported. </dd></dl>

</div>
</div>
<a id="a0f3529c33550ecf08dcd6d7a33409a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3529c33550ecf08dcd6d7a33409a8b">&#9670;&nbsp;</a></span>allowsSpun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::allowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the coordinate system being used allows for spun normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun normal surface are supported. </dd></dl>

</div>
</div>
<a id="adb8da79103f921bee2f52e6fdb39eb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8da79103f921bee2f52e6fdb39eb2e">&#9670;&nbsp;</a></span>beginVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::beginVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator that gives access to the raw vectors for surfaces in this list, pointing to the beginning of this surface list. </p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator at the beginning of this surface list. </dd></dl>

</div>
</div>
<a id="ada70246d67b766fd35a224bd561ee071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada70246d67b766fd35a224bd561ee071">&#9670;&nbsp;</a></span>coords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> regina::NormalSurfaces::coords </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the coordinate system being used by the surfaces stored in this set. </p>
<dl class="section return"><dt>Returns</dt><dd>the coordinate system used. </dd></dl>

</div>
</div>
<a id="ad33634993b549ee12249b97a019fe002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33634993b549ee12249b97a019fe002">&#9670;&nbsp;</a></span>dependsOnParent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#ga36260b904a2bf98d9484869267ddf7b5">regina::Packet</a>.</p>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a268c1848908924fc19644b83309beeba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268c1848908924fc19644b83309beeba">&#9670;&nbsp;</a></span>endVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces_1_1VectorIterator.html">NormalSurfaces::VectorIterator</a> regina::NormalSurfaces::endVectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator that gives access to the raw vectors for surfaces in this list, pointing past the end of this surface list. </p>
<p>This iterator is not dereferenceable.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator past the end of this surface list. </dd></dl>

</div>
</div>
<a id="a64309eac6ce681355dfc352c53299535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64309eac6ce681355dfc352c53299535">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::enumerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; 3 &gt; *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a>&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a>&#160;</td>
          <td class="paramname"><em>which</em> = <code><a class="el" href="group__surfaces.html#ggabff25e58607c49cca84049a1069c2ccead3eeb14f2572d18cd230d6dab84e1864">NS_LIST_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a>&#160;</td>
          <td class="paramname"><em>algHints</em> = <code><a class="el" href="group__surfaces.html#gga3c4cfc5de652a5beaadaaee0cacdeedeadae5f2eb4210841d3473b97e2ccb7c6b">NS_ALG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1ProgressTracker.html">ProgressTracker</a> *&#160;</td>
          <td class="paramname"><em>tracker</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A unified routine for enumerating various classes of normal surfaces within a given triangulation. </p>
<p>The NormalCoords argument allows you to specify an underlying coordinate system (e.g., standard coordinates, quadrilateral coordinates or almost normal coordinates).</p>
<p>The NormalList argument is a combination of flags that allows you to specify exactly which normal surfaces you require. This includes (i) whether you want all vertex surfaces or all fundamental surfaces, which defaults to NS_VERTEX if you specify neither or both; and (ii) whether you want only properly embedded surfaces or you also wish to include immersed and/or singular surfaces, which defaults to NS_EMBEDDED_ONLY if you specify neither or both.</p>
<p>The NormalAlg argument is a combination of flags that allows you to control the underlying enumeration algorithm. These flags are treated as hints only: if your selection of algorithm is invalid, unavailable or unsupported then Regina will choose something more appropriate. Unless you have some specialised need, the default NS_ALG_DEFAULT (which makes no hints at all) will allow Regina to choose what it thinks will be the most efficient method.</p>
<p>The enumerated surfaces will be stored in a new normal surface list, and their representations will be scaled down to use the smallest possible integer coordinates. This normal surface list will be inserted into the packet tree as the last child of the given triangulation. This triangulation <b>must</b> remain the parent of this normal surface list, and must not change while this normal surface list remains in existence.</p>
<p>If a progress tracker is passed, the normal surface enumeration will take place in a new thread and this routine will return immediately. If the user cancels the operation from another thread, then the normal surface list will <em>not</em> be inserted into the packet tree (but the caller of this routine will still need to delete it). Regarding progress tracking, this routine will declare and work through a series of stages whose combined weights sum to 1; typically this means that the given tracker must not have been used before.</p>
<p>If no progress tracker is passed, the enumeration will run in the current thread and this routine will return only when the enumeration is complete. Note that this enumeration can be extremely slow for larger triangulations.</p>
<p>If an error occurs, then this routine will return <code>null</code>, no normal surface list will be created, and the progress tracker (if passed) will be marked as finished. Errors can occur in the following scenarios:</p>
<ul>
<li>Regina could not create the matching equations for the given triangulation in the given coordinate system. This is only possible in certain coordinate systems, and all such coordinate systems are marked as such in the NormalCoords enum documentation.</li>
<li>A progress tracker is passed but a new thread could not be started.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>the triangulation upon which this list of normal surfaces will be based. </td></tr>
    <tr><td class="paramname">coords</td><td>the coordinate system to be used. </td></tr>
    <tr><td class="paramname">which</td><td>indicates which normal surfaces should be enumerated. </td></tr>
    <tr><td class="paramname">algHints</td><td>passes requests to Regina for which specific enumeration algorithm should be used. </td></tr>
    <tr><td class="paramname">tracker</td><td>a progress tracker through which progress will be reported, or <code>null</code> if no progress reporting is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created normal surface list. Note that if a progress tracker is passed then this list may not be completely filled when this routine returns. If an error occurs (as described above) then this routine will return <code>null</code> instead. </dd></dl>

</div>
</div>
<a id="a9324d55752c936e253e9c36cce704908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9324d55752c936e253e9c36cce704908">&#9670;&nbsp;</a></span>filterForDisjointPairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::filterForDisjointPairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new list filled with the surfaces from this list that have at least one disjoint partner. </p>
<p>In other words, a surface <em>S</em> from this list will be placed in the new list if and only if there is some other surface <em>T</em> in this list for which <em>S</em> and <em>T</em> can be made to intersect nowhere at all, without changing either normal isotopy class. See <a class="el" href="classregina_1_1NormalSurface.html#a7bda2f060aca3d7228ce8758f67eefeb" title="Determines whether this and the given surface can be placed within the surrounding triangulation so t...">NormalSurface::disjoint()</a> for further details on disjointness testing.</p>
<p>This routine cannot deal with empty, disconnected or non-compact surfaces. Such surfaces will be silently ignored, and will not be used in any disjointness tests (in particular, they will never be considered as a "disjoint partner" for any other surface).</p>
<p>The new list will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the new list will also be returned from this routine.</p>
<p>This original list is not altered in any way. Likewise, the surfaces in the new list are deep copies of the originals (so they can be altered without affecting the original surfaces).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This list contains only embedded normal surfaces. More precisely, <a class="el" href="classregina_1_1NormalSurfaces.html#a4235db32ccba3f9f49e8b668afb8ad85" title="Returns whether this list was constructed to contain only properly embedded surfaces.">isEmbeddedOnly()</a> must return <code>true</code>. </dd>
<dd>
All surfaces within this list are stored using the same coordinate system (i.e., the same subclass of <a class="el" href="classregina_1_1NormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NormalSurfaceVector</a>).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this list contains a vertex link (plus at least one other surface), then the new list will be identical to the old (i.e., every surface will be copied across).</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000042">Todo:</a></b></dt><dd>Deal properly with surfaces that are too large to handle.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new list, which will also have been inserted as a new child packet of the underlying triangulation. </dd></dl>

</div>
</div>
<a id="ae8c9723cc44bf8da34f136eb7c27a835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c9723cc44bf8da34f136eb7c27a835">&#9670;&nbsp;</a></span>filterForLocallyCompatiblePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::filterForLocallyCompatiblePairs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new list filled with the surfaces from this list that have at least one locally compatible partner. </p>
<p>In other words, a surface <em>S</em> from this list will be placed in the new list if and only if there is some other surface <em>T</em> in this list for which <em>S</em> and <em>T</em> are locally compatible. See <a class="el" href="classregina_1_1NormalSurface.html#aa1aa3f944bc8cd084d2a00aadc0f0eb2" title="Determines whether this and the given surface are locally compatible.">NormalSurface::locallyCompatible()</a> for further details on compatibility testing.</p>
<p>The new list will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the new list will also be returned from this routine.</p>
<p>This original list is not altered in any way. Likewise, the surfaces in the new list are deep copies of the originals (so they can be altered without affecting the original surfaces).</p>
<dl class="section pre"><dt>Precondition</dt><dd>This list contains only embedded normal surfaces. More precisely, <a class="el" href="classregina_1_1NormalSurfaces.html#a4235db32ccba3f9f49e8b668afb8ad85" title="Returns whether this list was constructed to contain only properly embedded surfaces.">isEmbeddedOnly()</a> must return <code>true</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If this list contains a vertex link (plus at least one other surface), then the new list will be identical to the old (i.e., every surface will be copied across).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new list, which will also have been inserted as a new child packet of the underlying triangulation. </dd></dl>

</div>
</div>
<a id="a7ed23bbdd0688519b1eb4a3077cec118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed23bbdd0688519b1eb4a3077cec118">&#9670;&nbsp;</a></span>filterForPotentiallyIncompressible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::filterForPotentiallyIncompressible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new list filled with only the surfaces from this list that "might" represent two-sided incompressible surfaces. </p>
<p>More precisely, we consider all two-sided surfaces in this list, as well as the two-sided double covers of all one-sided surfaces in this list (see below for details on how one-sided surfaces are handled). Each of these surfaces is examined using relatively fast heuristic tests for incompressibility. Any surface that is definitely <em>not</em> incompressible is thrown away, and all other surfaces are placed in the new list.</p>
<p>Therefore, it is guaranteed that every incompressible surface from the old list will be placed in the new list. However, it is not known whether any given surface in the new list is indeed incompressible.</p>
<p>See <a class="el" href="classregina_1_1NormalSurface.html#a40448875fc5e68801492acfd10dc680b" title="Determines whether this is an incompressible surface within the surrounding 3-manifold.">NormalSurface::isIncompressible()</a> for the definition of incompressibility that is used here. Note in particular that spheres are <em>never</em> considered incompressible.</p>
<p>As indicated above, this filter works exclusively with two-sided surfaces. If a surface in this list is one-sided, the heuristic incompressibility tests will be run on its two-sided double cover. Nevertheless, if the tests pass, the original one-sided surface (not the double cover) will be added to the new list.</p>
<p>The new list will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the new list will also be returned from this routine.</p>
<p>This original list is not altered in any way. Likewise, the surfaces in the new list are deep copies of the originals (so they can be altered without affecting the original surfaces).</p>
<p>Currently the heuristic tests include (i) throwing away all vertex links and thin edge links, and then (ii) cutting along the remaining surfaces and running <a class="el" href="classregina_1_1Triangulation_3_013_01_4.html#a31d8cba1fae2b39de379ff6c8df4d61c" title="Searches for a &quot;simple&quot; compressing disc inside this triangulation.">Triangulation&lt;3&gt;::hasSimpleCompressingDisc()</a> on the resulting bounded triangulations. For more details on these tests see "The Weber-Seifert dodecahedral space is non-Haken", Benjamin A. Burton, J. Hyam Rubinstein and Stephan Tillmann, Trans. Amer. Math. Soc. 364:2 (2012), pp. 911-932.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying 3-manifold triangulation is valid and closed. In particular, it has no ideal vertices. </dd>
<dd>
This list contains only embedded normal surfaces. More precisely, <a class="el" href="classregina_1_1NormalSurfaces.html#a4235db32ccba3f9f49e8b668afb8ad85" title="Returns whether this list was constructed to contain only properly embedded surfaces.">isEmbeddedOnly()</a> must return <code>true</code>. </dd>
<dd>
This list contains only compact, connected normal surfaces. </dd>
<dd>
No surfaces in this list contain any octagonal discs.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The behaviour of this routine is subject to change in future versions of Regina, since additional tests may be added to improve the power of this filtering.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000043">Todo:</a></b></dt><dd>Add progress tracking.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the new list, which will also have been inserted as a new child packet of the underlying triangulation. </dd></dl>

</div>
</div>
<a id="aa724448326c5e5b0ba727fe6ce6d1233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa724448326c5e5b0ba727fe6ce6d1233">&#9670;&nbsp;</a></span>hasSafePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a>  &gt;::hasSafePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is there one or more <a class="el" href="classregina_1_1SafePtr.html" title="A reference counted smart pointer that supports alternate models of ownership.">SafePtr</a> currently pointing to this object? </p>

</div>
</div>
<a id="adc0ab53ae8085a452393a764bd8d5b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0ab53ae8085a452393a764bd8d5b27">&#9670;&nbsp;</a></span>internalClonePacket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1Packet.html">Packet</a>* regina::NormalSurfaces::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1Packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="group__packet.html#gacd4d2e82e583276a70128d952b46bd53">regina::Packet</a>.</p>

</div>
</div>
<a id="a4235db32ccba3f9f49e8b668afb8ad85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4235db32ccba3f9f49e8b668afb8ad85">&#9670;&nbsp;</a></span>isEmbeddedOnly()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::isEmbeddedOnly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> whether this list was constructed to contain only properly embedded surfaces. </p>
<p>If this returns <code>false</code>, it does not guarantee that immersed and/or singular surfaces are present; it merely indicates that they were not deliberately excluded (for instance, the quadrilateral constraints were not enforced).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this list was constructed to contain only properly embedded surfaces, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a8e160a2b7934ad098ab2252adfd128db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e160a2b7934ad098ab2252adfd128db">&#9670;&nbsp;</a></span>quadOctToStandardAN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::quadOctToStandardAN </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space to the set of all embedded vertex almost normal surfaces in the standard tri-quad-oct space. </p>
<p>This routine is the almost normal analogue to the <a class="el" href="classregina_1_1NormalSurfaces.html#a923d837b8eb709fd079d4ec8e5f30889" title="Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embe...">quadToStandard()</a> conversion routine; see the <a class="el" href="classregina_1_1NormalSurfaces.html#a923d837b8eb709fd079d4ec8e5f30889" title="Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embe...">quadToStandard()</a> documentation for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This surface list is precisely the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space; no more, no less. Moreover, these vectors are stored using quadrilateral-octagon coordinates. Typically this means that it was obtained through <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_AN_QUAD_OCT and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex almost normal surfaces in standard tri-quad-oct coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="a923d837b8eb709fd079d4ec8e5f30889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923d837b8eb709fd079d4ec8e5f30889">&#9670;&nbsp;</a></span>quadToStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::quadToStandard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex normal surfaces in quadrilateral space to the set of all embedded vertex normal surfaces in standard (tri-quad) space. </p>
<p>The initial list in quadrilateral space is taken to be this normal surface list; the final list in standard space will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the final list will also be returned from this routine.</p>
<p>This routine can only be used with normal surfaces, not almost normal surfaces. For almost normal surfaces, see the similar routine <a class="el" href="classregina_1_1NormalSurfaces.html#a8e160a2b7934ad098ab2252adfd128db" title="Converts the set of all embedded vertex almost normal surfaces in quadrilateral-octagon space to the ...">quadOctToStandardAN()</a>.</p>
<p>This procedure is available for any triangulation whose vertex links are all spheres and/or discs, and is <em>much</em> faster than enumerating surfaces directly in standard tri-quad coordinates. The underlying algorithm is described in detail in "Converting between quadrilateral and standard solution sets in normal surface theory", Benjamin A. Burton, Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>Typically users do not need to call this routine directly, since the standard <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a> routine will use it implicitly where possible. That is, when asked for standard vertex surfaces, <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a> will first find all <em>quadrilateral</em> vertex surfaces and then use this procedure to convert them to standard vertex surfaces; this is generally orders of magnitude faster than enumerating surfaces directly in standard coordinates.</p>
<p>Nevertheless, this standalone routine is provided as a convenience for users who already have a set of quadrilateral vertex surfaces, and who simply wish to convert them to a set of standard vertex surfaces without the cost of implicitly enumerating the quadrilateral vertex surfaces again.</p>
<p>It should be noted that this routine does <em>not</em> simply convert vectors from one form to another; instead it converts a full solution set of vertex surfaces in quadrilateral coordinates to a full solution set of vertex surfaces in standard coordinates. Typically there are many more vertex surfaces in standard coordinates (all of which this routine will find).</p>
<p>This routine will run some very basic sanity checks before starting. Specifically, it will check the validity and vertex links of the underlying triangulation, and will verify that the coordinate system and embedded-only flag are set to NS_QUAD and <code>true</code> respectively. If any of these checks fails, this routine will do nothing and return <code>null</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This normal surface list is precisely the set of all embedded vertex normal surfaces in quadrilateral space; no more, no less. Moreover, these vectors are stored using quadrilateral coordinates. Typically this means that it was obtained through <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_QUAD and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex normal surfaces in standard (tri-quad) coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="a1959b9dcedd0e35e00320f0490eaf75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1959b9dcedd0e35e00320f0490eaf75c">&#9670;&nbsp;</a></span>recreateMatchingEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__hypersurface.html#gaf20e731915f0691913bc317c0b73eab8">MatrixInt</a>* regina::NormalSurfaces::recreateMatchingEquations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a newly created matrix containing the matching equations that were used to create this normal surface list. </p>
<p>The destruction of this matrix is the responsibility of the caller of this routine. Multiple calls to this routine will result in the construction of multiple matrices. This routine in fact merely calls <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> with the appropriate parameters.</p>
<p>The format of the matrix is identical to that returned by <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a>.</p>
<p>Note that there are situations in which <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> returns <code>null</code> (because the triangulation is not supported by the chosen coordinate system). However, this routine should never return <code>null</code>, because if <a class="el" href="group__hypersurface.html#ga26e06572d451bb5cb70b1fa4c165c2f9" title="Creates a new set of normal hypersurface matching equations for the given triangulation using the giv...">makeMatchingEquations()</a> had returned <code>null</code> then this normal surface list would not have been created in the first place.</p>
<dl class="section return"><dt>Returns</dt><dd>the matching equations used to create this normal surface list. </dd></dl>

</div>
</div>
<a id="ae2559f5cea6339eb69cdcc532f970409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2559f5cea6339eb69cdcc532f970409">&#9670;&nbsp;</a></span>saveCSVEdgeWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::saveCSVEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>additionalFields</em> = <code><a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports the given list of normal surfaces as a plain text CSV (comma-separated value) file, using edge weight coordinates. </p>
<p>CSV files are human-readable and human-editable, and are suitable for importing into spreadsheets and databases.</p>
<p>The surfaces will be exported in edge weight coordinates. Thus there will be one coordinate for each edge of the underlying triangulation; each such coordinate will become a separate field in the CSV file.</p>
<p>As well as the normal surface coordinates, additional properties of the normal surfaces (such as Euler characteristic, orientability, and so on) can be included as extra fields in the export. Users can select precisely which properties to include by passing a bitmask, formed as a bitwise <em>or</em> combination of constants from the <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> enumeration type.</p>
<p>The CSV format used here begins with a header row, and uses commas as field separators. <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a> fields with arbitrary contents are placed inside double quotes, and the double quote character itself is represented by a pair of double quotes. Thus the string <code>my "normal" surface's name</code> would be stored as <code>"my ""normal"" surface's name"</code>.</p>
<dl class="section user"><dt>Internationalisation:\n This routine makes no assumptions about the</dt><dd><a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. Any user strings such as surface names will be written in UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the CSV file to export to. </td></tr>
    <tr><td class="paramname">additionalFields</td><td>a bitwise combination of constants from <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> indicating which additional properties of surfaces should be included in the export. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the export was successful, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2b308eb9fd7a131b2c370a589b7e43c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b308eb9fd7a131b2c370a589b7e43c6">&#9670;&nbsp;</a></span>saveCSVStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NormalSurfaces::saveCSVStandard </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>additionalFields</em> = <code><a class="el" href="group__surfaces.html#ggae923c7c2fa692192d45bdf563f380918abfd3be05c29ca1ebd429d2fa4588ef64">regina::surfaceExportAll</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports this list of normal surfaces as a plain text CSV (comma-separated value) file, using standard coordinates. </p>
<p>CSV files are human-readable and human-editable, and are suitable for importing into spreadsheets and databases.</p>
<p>The surfaces will be exported in standard coordinates (tri-quad coordinates for normal surfaces, or tri-quad-oct coordinates for almost normal surfaces). Each coordinate will become a separate field in the CSV file.</p>
<p>As well as the normal surface coordinates, additional properties of the normal surfaces (such as Euler characteristic, orientability, and so on) can be included as extra fields in the export. Users can select precisely which properties to include by passing a bitmask, formed as a bitwise <em>or</em> combination of constants from the <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> enumeration type.</p>
<p>The CSV format used here begins with a header row, and uses commas as field separators. <a class="el" href="classregina_1_1Text.html" title="A packet representing a text string.">Text</a> fields with arbitrary contents are placed inside double quotes, and the double quote character itself is represented by a pair of double quotes. Thus the string <code>my "normal" surface's name</code> would be stored as <code>"my ""normal"" surface's name"</code>.</p>
<dl class="section user"><dt>Internationalisation:\n This routine makes no assumptions about the</dt><dd><a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. Any user strings such as surface names will be written in UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the CSV file to export to. </td></tr>
    <tr><td class="paramname">additionalFields</td><td>a bitwise combination of constants from <a class="el" href="group__surfaces.html#gae923c7c2fa692192d45bdf563f380918" title="Used to describe a field, or a set of fields, that can be exported alongside a normal surface list.">regina::SurfaceExportFields</a> indicating which additional properties of surfaces should be included in the export. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the export was successful, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a0aae88a4f82d88e1ed542f17d26904d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aae88a4f82d88e1ed542f17d26904d7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NormalSurfaces::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of surfaces stored in this list. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of surfaces. </dd></dl>

</div>
</div>
<a id="ae2995d136dc8e575605230cec31dd8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2995d136dc8e575605230cec31dd8c9">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Comparison &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::sort </td>
          <td>(</td>
          <td class="paramtype">Comparison &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the surfaces in this list according to the given criterion. </p>
<p>This sort is stable, i.e., surfaces that are equivalent under the given criterion will remain in the same relative order.</p>
<p>The implementation of this routine uses std::stable_sort.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>a binary function (or function object) that accepts two const <a class="el" href="classregina_1_1NormalSurface.html" title="Represents a single normal surface in a 3-manifold.">NormalSurface</a> pointers, and returns <code>true</code> if and only if the first surface should appear before the second in the sorted list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3212b3ec1451db0bcc98871c65d78937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3212b3ec1451db0bcc98871c65d78937">&#9670;&nbsp;</a></span>standardANToQuadOct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::standardANToQuadOct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space to the set of all embedded vertex almost normal surfaces in the smaller quadrilateral-octagon space. </p>
<p>This routine is the almost normal analogue to the <a class="el" href="classregina_1_1NormalSurfaces.html#a92ffe41e50f214351ee2086ef600661a" title="Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of al...">standardToQuad()</a> conversion routine; see the <a class="el" href="classregina_1_1NormalSurfaces.html#a92ffe41e50f214351ee2086ef600661a" title="Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of al...">standardToQuad()</a> documentation for further information.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This normal surface list is precisely the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space; no more, no less. Typically this means that it was obtained through <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_AN_STANDARD and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex almost normal surfaces in quadrilateral-octagon coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="a92ffe41e50f214351ee2086ef600661a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ffe41e50f214351ee2086ef600661a">&#9670;&nbsp;</a></span>standardToQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NormalSurfaces.html">NormalSurfaces</a>* regina::NormalSurfaces::standardToQuad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the set of all embedded vertex normal surfaces in standard (tri-quad) space to the set of all embedded vertex normal surfaces in quadrilateral space. </p>
<p>The initial list in standard space is taken to be this normal surface list; the final list in quadrilateral space will be inserted as a new child packet of the underlying triangulation (specifically, as the final child). As a convenience, the final list will also be returned from this routine.</p>
<p>This routine can only be used with normal surfaces, not almost normal surfaces. For almost normal surfaces, see the similar routine <a class="el" href="classregina_1_1NormalSurfaces.html#a3212b3ec1451db0bcc98871c65d78937" title="Converts the set of all embedded vertex almost normal surfaces in standard tri-quad-oct space to the ...">standardANToQuadOct()</a>.</p>
<p>This procedure is available for any triangulation whose vertex links are all spheres and/or discs. The underlying algorithm is described in detail in "Converting between quadrilateral and
standard solution sets in normal surface theory", Benjamin A. Burton, Algebr. Geom. Topol. 9 (2009), 2121-2174.</p>
<p>It should be noted that this routine does <em>not</em> simply convert vectors from one form to another; instead it converts a full solution set of vertex surfaces in standard coordinates to a full solution set of vertex surfaces in quadrilateral coordinates. Typically there are far fewer vertex surfaces in quadrilateral coordinates (all of which this routine will find).</p>
<p>This routine will run some very basic sanity checks before starting. Specifically, it will check the validity and vertex links of the underlying triangulation, and will verify that the coordinate system and embedded-only flag are set to NS_STANDARD and <code>true</code> respectively. If any of these checks fails, this routine will do nothing and return <code>null</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The underlying triangulation (the parent packet of this normal surface list) is valid, and the link of every vertex is either a sphere or a disc. </dd>
<dd>
This normal surface list is precisely the set of all embedded vertex normal surfaces in standard (tri-quad) space; no more, no less. Moreover, these vectors are stored using standard coordinates. Typically this means that this list was obtained through <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>, with the coordinate system set to NS_STANDARD and with <em>embeddedOnly</em> set to <code>true</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a full list of vertex normal surfaces in quadrilateral coordinates, or <code>null</code> if any of the basic sanity checks failed. </dd></dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:\n In addition to str(), this is also used as the</dt><dd>Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="aa75527d87d83254739c7e52175546acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75527d87d83254739c7e52175546acf">&#9670;&nbsp;</a></span>surface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a> * regina::NormalSurfaces::surface </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the surface at the requested index in this set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested surface in this set; this must be between 0 and <a class="el" href="classregina_1_1NormalSurfaces.html#a0aae88a4f82d88e1ed542f17d26904d7" title="Returns the number of surfaces stored in this list.">size()</a>-1 inclusive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normal surface at the requested index in this set. </dd></dl>

</div>
</div>
<a id="aa808164e874f88896ac40703b6409c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa808164e874f88896ac40703b6409c36">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt;3&gt;* regina::NormalSurfaces::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation in which these normal surfaces live. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation in which these surfaces live. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1Packet.html">Packet</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a2a12326b8c6dfebfefe97b34b15920c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a12326b8c6dfebfefe97b34b15920c7">&#9670;&nbsp;</a></span>which()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> regina::NormalSurfaces::which </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> details of which normal surfaces this list represents within the underlying triangulation. </p>
<p>This may not be the same NormalList that was passed to <a class="el" href="classregina_1_1NormalSurfaces.html#a64309eac6ce681355dfc352c53299535" title="A unified routine for enumerating various classes of normal surfaces within a given triangulation.">enumerate()</a>. In particular, default values will have been explicitly filled in (such as NS_VERTEX and/or NS_EMBEDDED_ONLY), and invalid and/or redundant values will have been removed.</p>
<dl class="section return"><dt>Returns</dt><dd>details of what this list represents. </dd></dl>

</div>
</div>
<a id="a564d43bd562cadba9bddbcd960d77596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564d43bd562cadba9bddbcd960d77596">&#9670;&nbsp;</a></span>writeAllSurfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NormalSurfaces::writeAllSurfaces </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the number of surfaces in this set followed by the details of each surface to the given output stream. </p>
<p><a class="el" href="structregina_1_1Output.html" title="A common base class for objects that write human-readable text output.">Output</a> will be over many lines.</p>
<dl class="section user"><dt>Python:\n Parameter <em>out</em> is not present and is assumed</dt><dd>to be standard output.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad07dcdec28b20348705f8cec15838957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07dcdec28b20348705f8cec15838957">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalSurfaces::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1Packet.html" title="Represents a packet of information that may be individually edited or operated upon.">Packet</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="group__packet.html#ga044a5c8d80d5aeb0e13a335bfc9b4ed3">regina::Packet</a>.</p>

</div>
</div>
<a id="a6801fb032b55c800bb82e89fce2bbe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6801fb032b55c800bb82e89fce2bbe71">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalSurfaces::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga54930e66829e2b832b2b8d5b6813e55d">regina::Packet</a>.</p>

</div>
</div>
<a id="aa5539ec7f016ba2e9fca94f00971f4c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5539ec7f016ba2e9fca94f00971f4c3">&#9670;&nbsp;</a></span>writeXMLPacketData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NormalSurfaces::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="group__packet.html#ga7efec42b4c85d5590a07a0184bb3b0ec">regina::Packet</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa0e72355f8511a648f728fc452ba850a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e72355f8511a648f728fc452ba850a">&#9670;&nbsp;</a></span>algorithm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga239df7c1e704457d116029fc144dc473">NormalAlg</a> regina::NormalSurfaces::algorithm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the details of the enumeration algorithm that was used to generate this list. </p>
<p>This might not be the same as the <em>algorithmHints</em> flag passed to the corresponding enumeration routine (e.g., if invalid or inappropriate flags were passed). </p>

</div>
</div>
<a id="a317370303ab0e90b1367b33d57a92e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317370303ab0e90b1367b33d57a92e83">&#9670;&nbsp;</a></span>coords_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga9817fc7125c53daea4e3f3cbfe987a47">NormalCoords</a> regina::NormalSurfaces::coords_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores which coordinate system is being used by the normal surfaces in this packet. </p>

</div>
</div>
<a id="a30f9f73eb24a005ad31dc5d07e7f4c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f9f73eb24a005ad31dc5d07e7f4c93">&#9670;&nbsp;</a></span>surfaces</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classregina_1_1NormalSurface.html">NormalSurface</a>*&gt; regina::NormalSurfaces::surfaces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the normal surfaces stored in this packet. </p>

</div>
</div>
<a id="a6ffe4301bf296b37ea8253f242167660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffe4301bf296b37ea8253f242167660">&#9670;&nbsp;</a></span>which_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__surfaces.html#ga10adc2dfa823f4b97db64abccdc7f73d">NormalList</a> regina::NormalSurfaces::which_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which normal surfaces these represent within the underlying triangulation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surfaces/<a class="el" href="normalsurfaces_8h.html">normalsurfaces.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
