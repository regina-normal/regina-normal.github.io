<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NNormalSurfaceVectorANStandard Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html">NNormalSurfaceVectorANStandard</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classregina_1_1NNormalSurfaceVectorANStandard-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NNormalSurfaceVectorANStandard Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__surfaces.html">Normal Surfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>An almost normal surface vector using standard triangle-quad-oct coordinates.  
 <a href="classregina_1_1NNormalSurfaceVectorANStandard.html#details">More...</a></p>

<p><code>#include &lt;surfaces/nsanstandard.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NNormalSurfaceVectorANStandard:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NNormalSurfaceVectorANStandard.png" usemap="#regina::NNormalSurfaceVectorANStandard_map" alt=""/>
  <map id="regina::NNormalSurfaceVectorANStandard_map" name="regina::NNormalSurfaceVectorANStandard_map">
<area href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold." alt="regina::NNormalSurfaceVector" shape="rect" coords="0,112,255,136"/>
<area href="classregina_1_1NRay.html" title="A fast class for storing a ray rooted at the origin whose coordinates are rational." alt="regina::NRay" shape="rect" coords="0,56,255,80"/>
<area href="classregina_1_1NVector.html" alt="regina::NVector&lt; NLargeInteger &gt;" shape="rect" coords="0,0,255,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a356396d6d75645c49a7f9d47de0e3c0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html#a356396d6d75645c49a7f9d47de0e3c0f">NNormalSurfaceVectorANStandard</a> (size_t length)</td></tr>
<tr class="memdesc:a356396d6d75645c49a7f9d47de0e3c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector all of whose entries are initialised to zero.  <a href="#a356396d6d75645c49a7f9d47de0e3c0f">More...</a><br/></td></tr>
<tr class="separator:a356396d6d75645c49a7f9d47de0e3c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675f98156507df4d7dd340514d943ac0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html#a675f98156507df4d7dd340514d943ac0">NNormalSurfaceVectorANStandard</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;cloneMe)</td></tr>
<tr class="memdesc:a675f98156507df4d7dd340514d943ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vector that is a clone of the given vector.  <a href="#a675f98156507df4d7dd340514d943ac0">More...</a><br/></td></tr>
<tr class="separator:a675f98156507df4d7dd340514d943ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a7f5947af838b146276b7228b4a027"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html#ad0a7f5947af838b146276b7228b4a027">triangles</a> (size_t tetIndex, int vertex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:ad0a7f5947af838b146276b7228b4a027"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface.  <a href="#ad0a7f5947af838b146276b7228b4a027">More...</a><br/></td></tr>
<tr class="separator:ad0a7f5947af838b146276b7228b4a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea136ebd286b033ee953f69fc2d81f3a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html#aea136ebd286b033ee953f69fc2d81f3a">quads</a> (size_t tetIndex, int quadType, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:aea136ebd286b033ee953f69fc2d81f3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface.  <a href="#aea136ebd286b033ee953f69fc2d81f3a">More...</a><br/></td></tr>
<tr class="separator:aea136ebd286b033ee953f69fc2d81f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa04d5c450dc606da4e8eae69fca6877"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html#aaa04d5c450dc606da4e8eae69fca6877">octs</a> (size_t tetIndex, int octType, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:aaa04d5c450dc606da4e8eae69fca6877"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface.  <a href="#aaa04d5c450dc606da4e8eae69fca6877">More...</a><br/></td></tr>
<tr class="separator:aaa04d5c450dc606da4e8eae69fca6877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0ad8f47a2de6ea5dbcd0c0558f5cb1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html#a7e0ad8f47a2de6ea5dbcd0c0558f5cb1">edgeWeight</a> (size_t edgeIndex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a7e0ad8f47a2de6ea5dbcd0c0558f5cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge.  <a href="#a7e0ad8f47a2de6ea5dbcd0c0558f5cb1">More...</a><br/></td></tr>
<tr class="separator:a7e0ad8f47a2de6ea5dbcd0c0558f5cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b5c7161dff8fe2377f806bfc06668f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVectorANStandard.html#aa4b5c7161dff8fe2377f806bfc06668f">arcs</a> (size_t triIndex, int triVertex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:aa4b5c7161dff8fe2377f806bfc06668f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="#aa4b5c7161dff8fe2377f806bfc06668f">More...</a><br/></td></tr>
<tr class="separator:aa4b5c7161dff8fe2377f806bfc06668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb4a19c75da0c668e36161778688667"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NNormalSurfaceVector.html">NNormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#aefb4a19c75da0c668e36161778688667">clone</a> () const =0</td></tr>
<tr class="memdesc:aefb4a19c75da0c668e36161778688667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a newly allocated clone of this vector.  <a href="#aefb4a19c75da0c668e36161778688667">More...</a><br/></td></tr>
<tr class="separator:aefb4a19c75da0c668e36161778688667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa409ccb9682c0f3fc4b69c6b2ef00b3b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#aa409ccb9682c0f3fc4b69c6b2ef00b3b">allowsAlmostNormal</a> () const =0</td></tr>
<tr class="memdesc:aa409ccb9682c0f3fc4b69c6b2ef00b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs.  <a href="#aa409ccb9682c0f3fc4b69c6b2ef00b3b">More...</a><br/></td></tr>
<tr class="separator:aa409ccb9682c0f3fc4b69c6b2ef00b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec05341f270a4655bca8fba0b5169d99"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#aec05341f270a4655bca8fba0b5169d99">allowsSpun</a> () const =0</td></tr>
<tr class="memdesc:aec05341f270a4655bca8fba0b5169d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles.  <a href="#aec05341f270a4655bca8fba0b5169d99">More...</a><br/></td></tr>
<tr class="separator:aec05341f270a4655bca8fba0b5169d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d37c0449840f62c18149f2d537e13"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a4d0d37c0449840f62c18149f2d537e13">allowsOriented</a> () const =0</td></tr>
<tr class="memdesc:a4d0d37c0449840f62c18149f2d537e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces.  <a href="#a4d0d37c0449840f62c18149f2d537e13">More...</a><br/></td></tr>
<tr class="separator:a4d0d37c0449840f62c18149f2d537e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44631a5e232b62cb304ef2541288b9ed"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a44631a5e232b62cb304ef2541288b9ed">hasMultipleOctDiscs</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a44631a5e232b62cb304ef2541288b9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this normal surface has more than one octagonal disc.  <a href="#a44631a5e232b62cb304ef2541288b9ed">More...</a><br/></td></tr>
<tr class="separator:a44631a5e232b62cb304ef2541288b9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216044fb5329f993584d206b94544ac3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a216044fb5329f993584d206b94544ac3">isCompact</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a216044fb5329f993584d206b94544ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is compact (has finitely many discs).  <a href="#a216044fb5329f993584d206b94544ac3">More...</a><br/></td></tr>
<tr class="separator:a216044fb5329f993584d206b94544ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dbcbc8981bbb69857ab5d093de0eb5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#af8dbcbc8981bbb69857ab5d093de0eb5">isVertexLinking</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:af8dbcbc8981bbb69857ab5d093de0eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is vertex linking.  <a href="#af8dbcbc8981bbb69857ab5d093de0eb5">More...</a><br/></td></tr>
<tr class="separator:af8dbcbc8981bbb69857ab5d093de0eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457078b284462b5819fc43baef2d4653"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="group__surfaces.html#ga5cde59c8a2b5beab8cb68fb38cb84499">NVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a457078b284462b5819fc43baef2d4653">isVertexLink</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a457078b284462b5819fc43baef2d4653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the link of a single vertex.  <a href="#a457078b284462b5819fc43baef2d4653">More...</a><br/></td></tr>
<tr class="separator:a457078b284462b5819fc43baef2d4653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b27a21fc2e495433ec859660c5702f9"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; const <a class="el" href="group__surfaces.html#gaf4481302c5412c4d0ec9abfef1943650">NEdge</a> <br class="typebreak"/>
*, const <a class="el" href="group__surfaces.html#gaf4481302c5412c4d0ec9abfef1943650">NEdge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a6b27a21fc2e495433ec859660c5702f9">isThinEdgeLink</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a6b27a21fc2e495433ec859660c5702f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a rational multiple of the normal surface represented is the thin link of a single edge.  <a href="#a6b27a21fc2e495433ec859660c5702f9">More...</a><br/></td></tr>
<tr class="separator:a6b27a21fc2e495433ec859660c5702f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dc3967fd4e1e16ebb6130de411823c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a40dc3967fd4e1e16ebb6130de411823c">isSplitting</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a40dc3967fd4e1e16ebb6130de411823c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a splitting surface in the given triangulation.  <a href="#a40dc3967fd4e1e16ebb6130de411823c">More...</a><br/></td></tr>
<tr class="separator:a40dc3967fd4e1e16ebb6130de411823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b113139723b86fbbb701822a6091071"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a4b113139723b86fbbb701822a6091071">isCentral</a> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a4b113139723b86fbbb701822a6091071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the normal surface represented is a central surface in the given triangulation.  <a href="#a4b113139723b86fbbb701822a6091071">More...</a><br/></td></tr>
<tr class="separator:a4b113139723b86fbbb701822a6091071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dd12ba1cbc2f5ad0020660e4306648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac1dd12ba1cbc2f5ad0020660e4306648">getTriangleCoord</a> (size_t tetIndex, int vertex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:ac1dd12ba1cbc2f5ad0020660e4306648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of triangular discs of the given type in this normal surface.  <a href="#ac1dd12ba1cbc2f5ad0020660e4306648">More...</a><br/></td></tr>
<tr class="separator:ac1dd12ba1cbc2f5ad0020660e4306648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c9fa88088479b28057545ae55d69cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a02c9fa88088479b28057545ae55d69cc">orientedTriangles</a> (size_t tetIndex, int vertex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang, bool orientation) const </td></tr>
<tr class="memdesc:a02c9fa88088479b28057545ae55d69cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface.  <a href="#a02c9fa88088479b28057545ae55d69cc">More...</a><br/></td></tr>
<tr class="separator:a02c9fa88088479b28057545ae55d69cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d4931f6eef9a3508b83976aec90e59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a23d4931f6eef9a3508b83976aec90e59">getOrientedTriangleCoord</a> (size_t tetIndex, int vertex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang, bool orientation) const </td></tr>
<tr class="memdesc:a23d4931f6eef9a3508b83976aec90e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of oriented triangular discs of the given type in this normal surface.  <a href="#a23d4931f6eef9a3508b83976aec90e59">More...</a><br/></td></tr>
<tr class="separator:a23d4931f6eef9a3508b83976aec90e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac552a452db1476f07f9a693fa2e1a6db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac552a452db1476f07f9a693fa2e1a6db">getQuadCoord</a> (size_t tetIndex, int quadType, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:ac552a452db1476f07f9a693fa2e1a6db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of quadrilateral discs of the given type in this normal surface.  <a href="#ac552a452db1476f07f9a693fa2e1a6db">More...</a><br/></td></tr>
<tr class="separator:ac552a452db1476f07f9a693fa2e1a6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26994181f19a3f9e7d5b9f0fdfd2686f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a26994181f19a3f9e7d5b9f0fdfd2686f">orientedQuads</a> (size_t tetIndex, int quadType, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang, bool orientation) const </td></tr>
<tr class="memdesc:a26994181f19a3f9e7d5b9f0fdfd2686f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="#a26994181f19a3f9e7d5b9f0fdfd2686f">More...</a><br/></td></tr>
<tr class="separator:a26994181f19a3f9e7d5b9f0fdfd2686f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ab518099435cf6e80a1b2f285e0e94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#af1ab518099435cf6e80a1b2f285e0e94">getOrientedQuadCoord</a> (size_t tetIndex, int quadType, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang, bool orientation) const </td></tr>
<tr class="memdesc:af1ab518099435cf6e80a1b2f285e0e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of oriented quadrilateral discs of the given type in this normal surface.  <a href="#af1ab518099435cf6e80a1b2f285e0e94">More...</a><br/></td></tr>
<tr class="separator:af1ab518099435cf6e80a1b2f285e0e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134c383a875860979ef028bff810fef4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a134c383a875860979ef028bff810fef4">getOctCoord</a> (size_t tetIndex, int octType, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a134c383a875860979ef028bff810fef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of octagonal discs of the given type in this normal surface.  <a href="#a134c383a875860979ef028bff810fef4">More...</a><br/></td></tr>
<tr class="separator:a134c383a875860979ef028bff810fef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e1ffca3e86657a333f59870389e5903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a6e1ffca3e86657a333f59870389e5903">getEdgeWeight</a> (size_t edgeIndex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a6e1ffca3e86657a333f59870389e5903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of times this normal surfaces crosses the given edge.  <a href="#a6e1ffca3e86657a333f59870389e5903">More...</a><br/></td></tr>
<tr class="separator:a6e1ffca3e86657a333f59870389e5903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa863fb3a73955f8601611dfbc191e947"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#aa863fb3a73955f8601611dfbc191e947">getTriangleArcs</a> (size_t triIndex, int triVertex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:aa863fb3a73955f8601611dfbc191e947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of arcs in which this normal surface intersects the given triangle in the given direction.  <a href="#aa863fb3a73955f8601611dfbc191e947">More...</a><br/></td></tr>
<tr class="separator:aa863fb3a73955f8601611dfbc191e947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc4c57783851f5780850719c77d2d70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NNormalSurfaceVector.html#a7dc4c57783851f5780850719c77d2d70">getFaceArcs</a> (size_t triIndex, int triVertex, const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triang) const </td></tr>
<tr class="memdesc:a7dc4c57783851f5780850719c77d2d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">arcs()</a>.  <a href="#a7dc4c57783851f5780850719c77d2d70">More...</a><br/></td></tr>
<tr class="separator:a7dc4c57783851f5780850719c77d2d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e1a1f744eba1ee66dfc0721ce41f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NRay.html#a17e1a1f744eba1ee66dfc0721ce41f74">scaleDown</a> ()</td></tr>
<tr class="memdesc:a17e1a1f744eba1ee66dfc0721ce41f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales this vector down by the greatest common divisor of all its elements.  <a href="#a17e1a1f744eba1ee66dfc0721ce41f74">More...</a><br/></td></tr>
<tr class="separator:a17e1a1f744eba1ee66dfc0721ce41f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88b4783f5822c9304eeae53dfb34ec0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NRay.html#ab88b4783f5822c9304eeae53dfb34ec0">negate</a> ()</td></tr>
<tr class="memdesc:ab88b4783f5822c9304eeae53dfb34ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates every element of this vector.  <a href="#ab88b4783f5822c9304eeae53dfb34ec0">More...</a><br/></td></tr>
<tr class="separator:ab88b4783f5822c9304eeae53dfb34ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232f9c52eb61d3cbd6caea2b399e0529"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a232f9c52eb61d3cbd6caea2b399e0529">size</a> () const</td></tr>
<tr class="memdesc:a232f9c52eb61d3cbd6caea2b399e0529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the vector.  <a href="#a232f9c52eb61d3cbd6caea2b399e0529">More...</a><br/></td></tr>
<tr class="separator:a232f9c52eb61d3cbd6caea2b399e0529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09822e1b73fbef9edef6ab556c012b3a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a09822e1b73fbef9edef6ab556c012b3a">operator[]</a> (size_t index) const</td></tr>
<tr class="memdesc:a09822e1b73fbef9edef6ab556c012b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the given index in the vector.  <a href="#a09822e1b73fbef9edef6ab556c012b3a">More...</a><br/></td></tr>
<tr class="separator:a09822e1b73fbef9edef6ab556c012b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8b2ea6c296c895d5278ed0baa9421a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a6a8b2ea6c296c895d5278ed0baa9421a">setElement</a> (size_t index, const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;value)</td></tr>
<tr class="memdesc:a6a8b2ea6c296c895d5278ed0baa9421a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the element at the given index in the vector to the given value.  <a href="#a6a8b2ea6c296c895d5278ed0baa9421a">More...</a><br/></td></tr>
<tr class="separator:a6a8b2ea6c296c895d5278ed0baa9421a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0101ec07a40d2e8d812b6c99c043a98b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a0101ec07a40d2e8d812b6c99c043a98b">operator==</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;compare) const</td></tr>
<tr class="memdesc:a0101ec07a40d2e8d812b6c99c043a98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this vector is equal to the given vector.  <a href="#a0101ec07a40d2e8d812b6c99c043a98b">More...</a><br/></td></tr>
<tr class="separator:a0101ec07a40d2e8d812b6c99c043a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5df88b37f8de039ed2016f90a1c28f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#af5df88b37f8de039ed2016f90a1c28f4">operator+=</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:af5df88b37f8de039ed2016f90a1c28f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given vector to this vector.  <a href="#af5df88b37f8de039ed2016f90a1c28f4">More...</a><br/></td></tr>
<tr class="separator:af5df88b37f8de039ed2016f90a1c28f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15683c49d99a2e4a583621d587f0a0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#ad15683c49d99a2e4a583621d587f0a0a">operator-=</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other)</td></tr>
<tr class="memdesc:ad15683c49d99a2e4a583621d587f0a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given vector from this vector.  <a href="#ad15683c49d99a2e4a583621d587f0a0a">More...</a><br/></td></tr>
<tr class="separator:ad15683c49d99a2e4a583621d587f0a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb6fbe77e79f00a0136c2a204a0559a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a4fb6fbe77e79f00a0136c2a204a0559a">operator*=</a> (const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;factor)</td></tr>
<tr class="memdesc:a4fb6fbe77e79f00a0136c2a204a0559a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this vector by the given scalar.  <a href="#a4fb6fbe77e79f00a0136c2a204a0559a">More...</a><br/></td></tr>
<tr class="separator:a4fb6fbe77e79f00a0136c2a204a0559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f2558cf3f297122a667ab5a2e81b61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a83f2558cf3f297122a667ab5a2e81b61">operator*</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other) const</td></tr>
<tr class="memdesc:a83f2558cf3f297122a667ab5a2e81b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of this vector and the given vector.  <a href="#a83f2558cf3f297122a667ab5a2e81b61">More...</a><br/></td></tr>
<tr class="separator:a83f2558cf3f297122a667ab5a2e81b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d67741f77990e3141973436ef1d34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a49d67741f77990e3141973436ef1d34f">norm</a> () const</td></tr>
<tr class="memdesc:a49d67741f77990e3141973436ef1d34f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the norm of this vector.  <a href="#a49d67741f77990e3141973436ef1d34f">More...</a><br/></td></tr>
<tr class="separator:a49d67741f77990e3141973436ef1d34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047575b4e446c804f5397c65f046e073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a047575b4e446c804f5397c65f046e073">elementSum</a> () const</td></tr>
<tr class="memdesc:a047575b4e446c804f5397c65f046e073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of all elements of this vector.  <a href="#a047575b4e446c804f5397c65f046e073">More...</a><br/></td></tr>
<tr class="separator:a047575b4e446c804f5397c65f046e073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67084429d7dc2f74ef4cf8ced9c0b22b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a67084429d7dc2f74ef4cf8ced9c0b22b">addCopies</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other, const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;multiple)</td></tr>
<tr class="memdesc:a67084429d7dc2f74ef4cf8ced9c0b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given multiple of the given vector to this vector.  <a href="#a67084429d7dc2f74ef4cf8ced9c0b22b">More...</a><br/></td></tr>
<tr class="separator:a67084429d7dc2f74ef4cf8ced9c0b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815a3224a9f83ddcd8b9856b3db50409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a815a3224a9f83ddcd8b9856b3db50409">subtractCopies</a> (const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;other, const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp;multiple)</td></tr>
<tr class="memdesc:a815a3224a9f83ddcd8b9856b3db50409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the given multiple of the given vector to this vector.  <a href="#a815a3224a9f83ddcd8b9856b3db50409">More...</a><br/></td></tr>
<tr class="separator:a815a3224a9f83ddcd8b9856b3db50409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aba3749024701da50a2e72bbad22cfc7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba3749024701da50a2e72bbad22cfc7b"></a>
static <a class="el" href="classregina_1_1NNormalSurfaceVector.html">NNormalSurfaceVector</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeZeroVector</b> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triangulation)</td></tr>
<tr class="separator:aba3749024701da50a2e72bbad22cfc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b45038fa6afa859e352231098f0b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55b45038fa6afa859e352231098f0b71"></a>
static <a class="el" href="classregina_1_1NMatrixInt.html">NMatrixInt</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeMatchingEquations</b> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triangulation)</td></tr>
<tr class="separator:a55b45038fa6afa859e352231098f0b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4e8d76c9e55441e2d37ce68afd0e63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a4e8d76c9e55441e2d37ce68afd0e63"></a>
static <a class="el" href="classregina_1_1NEnumConstraintList.html">NEnumConstraintList</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>makeEmbeddedConstraints</b> (const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *triangulation)</td></tr>
<tr class="separator:a0a4e8d76c9e55441e2d37ce68afd0e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#ga7bf8d50ab891667c80d04d5f50774ce5">zero</a></td></tr>
<tr class="memdesc:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero in the underlying number system.  <a href="#ga7bf8d50ab891667c80d04d5f50774ce5">More...</a><br/></td></tr>
<tr class="separator:ga7bf8d50ab891667c80d04d5f50774ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfc1c84a78adf6df36ed538f45740bf9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gabfc1c84a78adf6df36ed538f45740bf9">one</a></td></tr>
<tr class="memdesc:gabfc1c84a78adf6df36ed538f45740bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">One in the underlying number system.  <a href="#gabfc1c84a78adf6df36ed538f45740bf9">More...</a><br/></td></tr>
<tr class="separator:gabfc1c84a78adf6df36ed538f45740bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__maths.html#gafc8368c6a98e3b332af41d21dd7ac9a6">minusOne</a></td></tr>
<tr class="memdesc:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative one in the underlying number system.  <a href="#gafc8368c6a98e3b332af41d21dd7ac9a6">More...</a><br/></td></tr>
<tr class="separator:gafc8368c6a98e3b332af41d21dd7ac9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abb95dfe16aba3835409b6fb0a33f3142"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#abb95dfe16aba3835409b6fb0a33f3142">elements</a></td></tr>
<tr class="memdesc:abb95dfe16aba3835409b6fb0a33f3142"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal array containing all vector elements.  <a href="#abb95dfe16aba3835409b6fb0a33f3142">More...</a><br/></td></tr>
<tr class="separator:abb95dfe16aba3835409b6fb0a33f3142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ead92e64702378a2bb61e9a823248f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NVector.html#a13ead92e64702378a2bb61e9a823248f">end</a></td></tr>
<tr class="memdesc:a13ead92e64702378a2bb61e9a823248f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer just beyond the end of the internal array.  <a href="#a13ead92e64702378a2bb61e9a823248f">More...</a><br/></td></tr>
<tr class="separator:a13ead92e64702378a2bb61e9a823248f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An almost normal surface vector using standard triangle-quad-oct coordinates. </p>
<p>If there are <em>t</em> tetrahedra in the underlying triangulation, there must be precisely 10<em>t</em> coordinates. The first ten coordinates will be for the first tetrahedron, the next ten for the second tetrahedron and so on. For each tetrahedron, the first four represent the number of triangular discs about vertex 0, 1, 2 and 3, the next three represent the number of quadrilateral discs of type 0, 1 and 2 (see <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a>) and the final three represent the number of octagonal discs of type 0, 1 and 2 (see <a class="el" href="classregina_1_1NNormalSurface.html#ab6d7f6f5f6cb35f5d060443beac0c755" title="Returns the number of octagonal discs of the given type in this normal surface.">NNormalSurface::octs()</a>).</p>
<dl class="section user"><dt>Python:</dt><dd>Not present. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a356396d6d75645c49a7f9d47de0e3c0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NNormalSurfaceVectorANStandard::NNormalSurfaceVectorANStandard </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector all of whose entries are initialised to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>the number of elements in the new vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a675f98156507df4d7dd340514d943ac0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NNormalSurfaceVectorANStandard::NNormalSurfaceVectorANStandard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cloneMe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new vector that is a clone of the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneMe</td><td>the vector to clone. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67084429d7dc2f74ef4cf8ced9c0b22b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::addCopies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>multiple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given multiple of the given vector to this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector a multiple of which will be added to this vector. </td></tr>
    <tr><td class="paramname">multiple</td><td>the multiple of <em>other</em> to be added to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa409ccb9682c0f3fc4b69c6b2ef00b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalSurfaceVector::allowsAlmostNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for almost normal surfaces, that is, allows for octagonal discs. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> octagonal discs.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if almost normal surfaces are allowed. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d0d37c0449840f62c18149f2d537e13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalSurfaceVector::allowsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for transversely oriented normal surfaces. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if transverse orientations are supported. </dd></dl>

</div>
</div>
<a class="anchor" id="aec05341f270a4655bca8fba0b5169d99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalSurfaceVector::allowsSpun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specific underlying coordinate system allows for spun-normal surfaces; that is, surfaces with infinitely many triangles. </p>
<p>Note that this has nothing to do with whether or not this specific surface <em>contains</em> infinitely many triangles.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if spun-normal surfaces are allowed. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4b5c7161dff8fe2377f806bfc06668f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVectorANStandard::arcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#aa6aebaa1dc87a9719b201b3bb17fe9c9" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">NNormalSurface::arcs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and NTriangulation::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944">regina::NNormalSurfaceVector</a>.</p>

</div>
</div>
<a class="anchor" id="aefb4a19c75da0c668e36161778688667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NNormalSurfaceVector.html">NNormalSurfaceVector</a>* regina::NNormalSurfaceVector::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a newly allocated clone of this vector. </p>
<p>The clone will be of the same subclass of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> as this vector. </p>

</div>
</div>
<a class="anchor" id="a7e0ad8f47a2de6ea5dbcd0c0558f5cb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVectorANStandard::edgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of times this normal surface crosses the given edge. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#a9b27c70b81fe1921c4b2d0e05d386311" title="Returns the number of times this normal surface crosses the given edge.">NNormalSurface::edgeWeight()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edgeIndex</td><td>the index in the triangulation of the edge in which we are interested; this should be between 0 and NTriangulation::countEdges()-1 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface crosses the given edge. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a559e62db31ba101ce2813965b9ff275b">regina::NNormalSurfaceVector</a>.</p>

</div>
</div>
<a class="anchor" id="a047575b4e446c804f5397c65f046e073"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::elementSum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of all elements of this vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the sum of the elements of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e1ffca3e86657a333f59870389e5903"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getEdgeWeight </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edgeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of times this normal surfaces crosses the given edge. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000363">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a559e62db31ba101ce2813965b9ff275b" title="Returns the number of times this normal surface crosses the given edge.">edgeWeight()</a>. See the <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a559e62db31ba101ce2813965b9ff275b" title="Returns the number of times this normal surface crosses the given edge.">edgeWeight()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dc4c57783851f5780850719c77d2d70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getFaceArcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">arcs()</a>. </p>
<p>This routine returns the number of arcs in which this normal surface intersects the given triangle in the given direction. See <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">arcs()</a> for further details.</p>
<p>Since this is an alias only, it is non-virtual and cannot be overridden. Its implementation simply calls <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">arcs()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000365">Deprecated:</a></b></dt><dd>This routine will be removed in a future version of Regina. Please use <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">arcs()</a> instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triIndex</td><td>the index in the triangulation of the triangle in which we are interested; this should be between 0 and NTriangulation::countTriangles()-1 inclusive. </td></tr>
    <tr><td class="paramname">triVertex</td><td>the vertex of the triangle (0, 1 or 2) around which the arcs of intersection that we are interested in lie; only these arcs will be counted. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of times this normal surface intersect the given triangle with the given arc type. </dd></dl>

</div>
</div>
<a class="anchor" id="a134c383a875860979ef028bff810fef4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getOctCoord </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of octagonal discs of the given type in this normal surface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000362">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a7355933fceaf96cede86a24cf28240d7" title="Returns the number of octagonal discs of the given type in this normal surface.">octs()</a>. See the <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a7355933fceaf96cede86a24cf28240d7" title="Returns the number of octagonal discs of the given type in this normal surface.">octs()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="af1ab518099435cf6e80a1b2f285e0e94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getOrientedQuadCoord </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000361">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a26994181f19a3f9e7d5b9f0fdfd2686f" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface...">orientedQuads()</a>. See the <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a26994181f19a3f9e7d5b9f0fdfd2686f" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface...">orientedQuads()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a23d4931f6eef9a3508b83976aec90e59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getOrientedTriangleCoord </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of oriented triangular discs of the given type in this normal surface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000359">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a02c9fa88088479b28057545ae55d69cc" title="Returns the number of oriented triangular discs of the given type in this normal surface.">orientedTriangles()</a>. See the <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a02c9fa88088479b28057545ae55d69cc" title="Returns the number of oriented triangular discs of the given type in this normal surface.">orientedTriangles()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ac552a452db1476f07f9a693fa2e1a6db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getQuadCoord </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of quadrilateral discs of the given type in this normal surface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000360">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a24d1def27b6f7aa5e8bf4fbe01f16acb" title="Returns the number of quadrilateral discs of the given type in this normal surface.">quads()</a>. See the <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a24d1def27b6f7aa5e8bf4fbe01f16acb" title="Returns the number of quadrilateral discs of the given type in this normal surface.">quads()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="aa863fb3a73955f8601611dfbc191e947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getTriangleArcs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>triIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>triVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of arcs in which this normal surface intersects the given triangle in the given direction. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000364">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">arcs()</a>. See the <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac417f3bfc48d4099790806698af0c944" title="Returns the number of arcs in which this normal surface intersects the given triangle in the given di...">arcs()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1dd12ba1cbc2f5ad0020660e4306648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::getTriangleCoord </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of triangular discs of the given type in this normal surface. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000358">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac6bc4d3961be11cfdcf49d51bf1c6290" title="Returns the number of triangular discs of the given type in this normal surface.">triangles()</a>. See the <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac6bc4d3961be11cfdcf49d51bf1c6290" title="Returns the number of triangular discs of the given type in this normal surface.">triangles()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a44631a5e232b62cb304ef2541288b9ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalSurfaceVector::hasMultipleOctDiscs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this normal surface has more than one octagonal disc. </p>
<p>It may be assumed that at most one octagonal disc <em>type</em> exists in this surface. This routine will return <code>true</code> if an octagonal type does exist and its coordinate is greater than one.</p>
<p>The default implementation for this routine simply calculates all the octagonal coordinates and returns as soon as a positive or negative result can be established. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<p>If a subclass does not allow for almost normal surfaces, this routine will never be called and thus does not need to be overwritten.</p>
<dl class="section pre"><dt>Precondition</dt><dd>At most one octagonal disc <em>type</em> exists in this surface. </dd>
<dd>
This normal surface vector is using a coordinate system that allows for almost normal surfaces.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if there is an octagonal disc type present and its coordinate is greater than one. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b113139723b86fbbb701822a6091071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::isCentral </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a central surface in the given triangulation. </p>
<p>A <em>central</em> surface is a compact surface containing at most one normal or almost normal disc per tetrahedron. If the surface is central, the number of tetrahedra it meets (i.e., the number of discs in the surface) will be returned.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of tetrahedra that the surface meets if it is a central surface, or 0 if it is not a central surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a216044fb5329f993584d206b94544ac3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalSurfaceVector::isCompact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is compact (has finitely many discs). </p>
<p>The default implementation for this routine simply runs through every disc type until a disc type with infinite disc count is found or all disc types have been examined. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is compact. </dd></dl>

</div>
</div>
<a class="anchor" id="a40dc3967fd4e1e16ebb6130de411823c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalSurfaceVector::isSplitting </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is a splitting surface in the given triangulation. </p>
<p>A <em>splitting</em> surface is a compact surface containing precisely one quad per tetrahedron and no other normal (or almost normal) discs.</p>
<p>The default implementation for this routine simply runs through and checks the count for each disc type. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is a splitting surface. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b27a21fc2e495433ec859660c5702f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::pair&lt;const <a class="el" href="group__surfaces.html#gaf4481302c5412c4d0ec9abfef1943650">NEdge</a>*, const <a class="el" href="group__surfaces.html#gaf4481302c5412c4d0ec9abfef1943650">NEdge</a>*&gt; regina::NNormalSurfaceVector::isThinEdgeLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the thin link of a single edge. </p>
<p>If there are two different edges <em>e1</em> and <em>e2</em> for which the surface could be expressed as the thin link of either <em>e1</em> or <em>e2</em>, the pair (<em>e1</em>,<em>e2</em>) will be returned. If the surface is the thin link of only one edge <em>e</em>, the pair (<em>e</em>,0) will be returned. If the surface is not the thin link of any edges, the pair (0,0) will be returned.</p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair containing the edge(s) linked by this surface, as described above. </dd></dl>

</div>
</div>
<a class="anchor" id="a457078b284462b5819fc43baef2d4653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="group__surfaces.html#ga5cde59c8a2b5beab8cb68fb38cb84499">NVertex</a>* regina::NNormalSurfaceVector::isVertexLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a rational multiple of the normal surface represented is the link of a single vertex. </p>
<p>The default implementation for this routine involves counting the number of discs of every type. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vertex linked by this surface, or 0 if this surface is not the link of a single vertex. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NNormalSurfaceVectorOrientedQuad.html#a88e9fcb0376c3dc47ebefe4a086cca64">regina::NNormalSurfaceVectorOrientedQuad</a>, <a class="el" href="classregina_1_1NNormalSurfaceVectorQuadOct.html#aa4df83ebcfda6d42563f495be18652bd">regina::NNormalSurfaceVectorQuadOct</a>, and <a class="el" href="classregina_1_1NNormalSurfaceVectorQuad.html#aa61df5eb0b6a4aace98a7472b9008ab6">regina::NNormalSurfaceVectorQuad</a>.</p>

</div>
</div>
<a class="anchor" id="af8dbcbc8981bbb69857ab5d093de0eb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool regina::NNormalSurfaceVector::isVertexLinking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the normal surface represented is vertex linking. </p>
<p>A <em>vertex linking</em> surface contains only triangles.</p>
<p>The default implementation for this routine simply runs through every non-triangular disc type ensuring that each has no corresponding discs. Subclasses of <a class="el" href="classregina_1_1NNormalSurfaceVector.html" title="Stores the vector of a single normal surface in a 3-manifold.">NNormalSurfaceVector</a> should override this if they can provide a faster implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the normal surface represented is vertex linking. </dd></dl>

</div>
</div>
<a class="anchor" id="ab88b4783f5822c9304eeae53dfb34ec0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NRay::negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates every element of this vector. </p>
<p>This is an optimised implementation that overrides <a class="el" href="classregina_1_1NVector.html#af5da9fd836844c94e6aa6cea855ee174" title="Negates every element of this vector.">NVector&lt;NLargeInteger&gt;::negate()</a>. </p>

</div>
</div>
<a class="anchor" id="a49d67741f77990e3141973436ef1d34f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the norm of this vector. </p>
<p>This is the dot product of the vector with itself.</p>
<dl class="section return"><dt>Returns</dt><dd>the norm of this vector. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa04d5c450dc606da4e8eae69fca6877"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVectorANStandard::octs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>octType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of octagonal discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#ab6d7f6f5f6cb35f5d060443beac0c755" title="Returns the number of octagonal discs of the given type in this normal surface.">NNormalSurface::octs()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested octagons reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">NTriangulation::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">octType</td><td>the type of this octagon in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of octagonal discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a7355933fceaf96cede86a24cf28240d7">regina::NNormalSurfaceVector</a>.</p>

</div>
</div>
<a class="anchor" id="a83f2558cf3f297122a667ab5a2e81b61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product of this vector and the given vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector with which this will be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dot product of this and the given vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb6fbe77e79f00a0136c2a204a0559a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this vector by the given scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>the scalar with which this will be multiplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5df88b37f8de039ed2016f90a1c28f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given vector to this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to add to this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad15683c49d99a2e4a583621d587f0a0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given vector from this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector to subtract from this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0101ec07a40d2e8d812b6c99c043a98b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this vector is equal to the given vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td>the vector with which this will be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the this and the given vector are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a09822e1b73fbef9edef6ab556c012b3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> &amp; <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element at the given index in the vector. </p>
<p>A constant reference to the element is returned; the element may not be altered.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> is between 0 and size()-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the vector index to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector element at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a26994181f19a3f9e7d5b9f0fdfd2686f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::orientedQuads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#accb17a7ff053eb3da3ebe65a39a3854e" title="Returns the number of oriented quadrilateral discs of the given type in this normal surface...">NNormalSurface::orientedQuads()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">NTriangulation::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NNormalSurfaceVectorMirrored.html#aa00997ff545abf307c0b38880088fe3e">regina::NNormalSurfaceVectorMirrored</a>, <a class="el" href="classregina_1_1NNormalSurfaceVectorOrientedQuad.html#af4ba620db5cc16d3e1a8859d9a7fd8b9">regina::NNormalSurfaceVectorOrientedQuad</a>, and <a class="el" href="classregina_1_1NNormalSurfaceVectorOriented.html#a32b29539a758d85e85cc01d99e51df71">regina::NNormalSurfaceVectorOriented</a>.</p>

</div>
</div>
<a class="anchor" id="a02c9fa88088479b28057545ae55d69cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVector::orientedTriangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of oriented triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#a12658d411d05c95b87b2a23e3d3702b7" title="Returns the number of oriented triangular discs of the given type in this normal surface.">NNormalSurface::orientedTriangles()</a> for further details.</p>
<p>The default implementation of this routine returns zero, which is suitable for coordinate systems that do not support transverse orientation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">NTriangulation::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
    <tr><td class="paramname">orientation</td><td>the orientation of the normal discs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NNormalSurfaceVectorMirrored.html#a676dd34777f8836a0672b478cea5d790">regina::NNormalSurfaceVectorMirrored</a>, and <a class="el" href="classregina_1_1NNormalSurfaceVectorOriented.html#ad737e335f76782e7fb2cb5ab14d8cee0">regina::NNormalSurfaceVectorOriented</a>.</p>

</div>
</div>
<a class="anchor" id="aea136ebd286b033ee953f69fc2d81f3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVectorANStandard::quads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>quadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of quadrilateral discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#a56e08464b960ab64c7df67b4d6732a26" title="Returns the number of quadrilateral discs of the given type in this normal surface.">NNormalSurface::quads()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested quadrilaterals reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">NTriangulation::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">quadType</td><td>the type of this quadrilateral in the given tetrahedron; this should be 0, 1 or 2. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of quadrilateral discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NNormalSurfaceVector.html#a24d1def27b6f7aa5e8bf4fbe01f16acb">regina::NNormalSurfaceVector</a>.</p>

</div>
</div>
<a class="anchor" id="a17e1a1f744eba1ee66dfc0721ce41f74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NRay::scaleDown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales this vector down by the greatest common divisor of all its elements. </p>
<p>The resulting vector will be the smallest multiple of the original that maintains integral entries, and these entries will have the same signs as the originals.</p>
<p>This routine thus reduces a ray to its smallest possible representation.</p>
<p>This routine poses no problem for vectors containing infinite elements; such elements are simply ignored and left at infinity. </p>

</div>
</div>
<a class="anchor" id="a6a8b2ea6c296c895d5278ed0baa9421a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::setElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the element at the given index in the vector to the given value. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>index</code> is between 0 and size()-1 inclusive.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the vector index to examine. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the vector element at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a232f9c52eb61d3cbd6caea2b399e0529"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>the vector size. </dd></dl>

</div>
</div>
<a class="anchor" id="a815a3224a9f83ddcd8b9856b3db50409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::subtractCopies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NVector.html">NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &amp;&#160;</td>
          <td class="paramname"><em>multiple</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the given multiple of the given vector to this vector. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given vector have the same size.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the vector a multiple of which will be subtracted from this vector. </td></tr>
    <tr><td class="paramname">multiple</td><td>the multiple of <em>other</em> to be subtracted from this vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0a7f5947af838b146276b7228b4a027"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> regina::NNormalSurfaceVectorANStandard::triangles </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__hypersurface.html#gaa504c0ed97bb88a50712083a7af647ab">NTriangulation</a> *&#160;</td>
          <td class="paramname"><em>triang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of triangular discs of the given type in this normal surface. </p>
<p>See <a class="el" href="classregina_1_1NNormalSurface.html#aa50bb0db0c6f7664ad26a15b26f213c1" title="Returns the number of triangular discs of the given type in this normal surface.">NNormalSurface::triangles()</a> for further details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tetIndex</td><td>the index in the triangulation of the tetrahedron in which the requested triangles reside; this should be between 0 and <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html#a6ca55a972a8c21f7e87960431d9ef64c" title="Returns the number of top-dimensional simplices in the triangulation.">NTriangulation::size()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">vertex</td><td>the vertex of the given tetrahedron around which the requested triangles lie; this should be between 0 and 3 inclusive. </td></tr>
    <tr><td class="paramname">triang</td><td>the triangulation in which this normal surface lives. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of triangular discs of the given type. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NNormalSurfaceVector.html#ac6bc4d3961be11cfdcf49d51bf1c6290">regina::NNormalSurfaceVector</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abb95dfe16aba3835409b6fb0a33f3142"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> * <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The internal array containing all vector elements. </p>

</div>
</div>
<a class="anchor" id="a13ead92e64702378a2bb61e9a823248f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a> * <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer just beyond the end of the internal array. </p>
<p>The size of the vector can be computed as (end - elements). </p>

</div>
</div>
<a class="anchor" id="gafc8368c6a98e3b332af41d21dd7ac9a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::minusOne</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negative one in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="gabfc1c84a78adf6df36ed538f45740bf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::one</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<a class="anchor" id="ga7bf8d50ab891667c80d04d5f50774ce5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  <a class="el" href="classregina_1_1NVector.html">regina::NVector</a>&lt; <a class="el" href="group__maths.html#gaa6d69c58fa05d5cee189921c16d3f7ad">NLargeInteger</a>  &gt;::zero</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero in the underlying number system. </p>
<p>This would be <code>const</code> if it weren't for the fact that some compilers don't like this. It should never be modified! </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>surfaces/<a class="el" href="nsanstandard_8h.html">nsanstandard.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
