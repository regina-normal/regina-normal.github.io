<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Regina Calculation Engine: regina::Face&lt; 3, 3 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1Face_3_013_00_013_01_4.html">Face&lt; 3, 3 &gt;</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classregina_1_1Face_3_013_00_013_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::Face&lt; 3, 3 &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__dim3.html">3-Manifold Triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a tetrahedron within a 3-manifold triangulation.  
 <a href="classregina_1_1Face_3_013_00_013_01_4.html#details">More...</a></p>

<p><code>#include &lt;triangulation/dim3.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::Face&lt; 3, 3 &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1Face_3_013_00_013_01_4.png" usemap="#regina::Face_3C_203_2C_203_20_3E_map" alt=""/>
  <map id="regina::Face_3C_203_2C_203_20_3E_map" name="regina::Face_3C_203_2C_203_20_3E_map">
<area href="classregina_1_1detail_1_1SimplexBase.html" alt="regina::detail::SimplexBase&lt; 3 &gt;" shape="rect" coords="522,112,860,136"/>
<area href="classregina_1_1MarkedElement.html" title="A base class for elements of MarkedVector." alt="regina::MarkedElement" shape="rect" coords="0,56,338,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; SimplexBase&lt; dim &gt; &gt;" shape="rect" coords="348,56,686,80"/>
<area href="classregina_1_1detail_1_1SimplexFacesSuite.html" alt="regina::detail::SimplexFacesSuite&lt; dim, dim-1 &gt;" shape="rect" coords="696,56,1034,80"/>
<area href="classregina_1_1alias_1_1FaceOfSimplex.html" alt="regina::alias::FaceOfSimplex&lt; SimplexBase&lt; dim &gt;, dim &gt;" shape="rect" coords="1044,56,1382,80"/>
<area href="classregina_1_1detail_1_1SimplexFaces.html" title="Helper class for storing which subdim-faces of a dim-dimensional triangulation appear within each top..." alt="regina::detail::SimplexFaces&lt; dim, subdim &gt;" shape="rect" coords="696,0,1034,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0b7e6840cf1d720009ce05f57e837b8c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structregina_1_1IntOfMinSize.html">IntOfMinSize</a>&lt;(dim/8)+1 &gt;::utype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a0b7e6840cf1d720009ce05f57e837b8c">FacetMask</a></td></tr>
<tr class="memdesc:a0b7e6840cf1d720009ce05f57e837b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type with at least <em>dim</em>+1 bits.  <a href="#a0b7e6840cf1d720009ce05f57e837b8c">More...</a><br /></td></tr>
<tr class="separator:a0b7e6840cf1d720009ce05f57e837b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a674b8434d6c9baf99d39748d5b76cd2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_013_01_4.html#a674b8434d6c9baf99d39748d5b76cd2a">adjacentTetrahedron</a> (int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:a674b8434d6c9baf99d39748d5b76cd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad0c12cf55a47ae78e9b4e91ce46c838d" title="Returns the adjacent simplex that is glued to the given facet of this simplex.">adjacentSimplex()</a>.  <a href="#a674b8434d6c9baf99d39748d5b76cd2a">More...</a><br /></td></tr>
<tr class="separator:a674b8434d6c9baf99d39748d5b76cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccf140ce8a41c983d22111160ec2d8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_013_01_4.html#a0ccf140ce8a41c983d22111160ec2d8b">adjacentFace</a> (int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:a0ccf140ce8a41c983d22111160ec2d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a09416bf06b05b67bad21b9e5184e3584" title="If the given facet of this simplex is glued to facet f of some adjacent simplex, then this routine re...">adjacentFacet()</a>.  <a href="#a0ccf140ce8a41c983d22111160ec2d8b">More...</a><br /></td></tr>
<tr class="separator:a0ccf140ce8a41c983d22111160ec2d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00178392c44456529f5250de6bc448ef"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a00178392c44456529f5250de6bc448ef">description</a> () const</td></tr>
<tr class="memdesc:a00178392c44456529f5250de6bc448ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description associated with this simplex.  <a href="#a00178392c44456529f5250de6bc448ef">More...</a><br /></td></tr>
<tr class="separator:a00178392c44456529f5250de6bc448ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a6d949a6ec9b90b7c9fce5c9da6dc52d6">setDescription</a> (const std::string &amp;desc)</td></tr>
<tr class="memdesc:a6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the description associated with this simplex.  <a href="#a6d949a6ec9b90b7c9fce5c9da6dc52d6">More...</a><br /></td></tr>
<tr class="separator:a6d949a6ec9b90b7c9fce5c9da6dc52d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf51cda05f67725962436cae590a0ff"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#abbf51cda05f67725962436cae590a0ff">index</a> () const</td></tr>
<tr class="memdesc:abbf51cda05f67725962436cae590a0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of this simplex in the underlying triangulation.  <a href="#abbf51cda05f67725962436cae590a0ff">More...</a><br /></td></tr>
<tr class="separator:abbf51cda05f67725962436cae590a0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c12cf55a47ae78e9b4e91ce46c838d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad0c12cf55a47ae78e9b4e91ce46c838d">adjacentSimplex</a> (int facet) const</td></tr>
<tr class="memdesc:ad0c12cf55a47ae78e9b4e91ce46c838d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the adjacent simplex that is glued to the given facet of this simplex.  <a href="#ad0c12cf55a47ae78e9b4e91ce46c838d">More...</a><br /></td></tr>
<tr class="separator:ad0c12cf55a47ae78e9b4e91ce46c838d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ac592b6db07dba1487e054be273799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a39ac592b6db07dba1487e054be273799">adjacentGluing</a> (int facet) const</td></tr>
<tr class="memdesc:a39ac592b6db07dba1487e054be273799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a permutation that indicates precisely how this simplex is glued to the adjacent simplex across the given facet.  <a href="#a39ac592b6db07dba1487e054be273799">More...</a><br /></td></tr>
<tr class="separator:a39ac592b6db07dba1487e054be273799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09416bf06b05b67bad21b9e5184e3584"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a09416bf06b05b67bad21b9e5184e3584">adjacentFacet</a> (int facet) const</td></tr>
<tr class="memdesc:a09416bf06b05b67bad21b9e5184e3584"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the given facet of this simplex is glued to facet <em>f</em> of some adjacent simplex, then this routine returns the adjacent facet number <em>f</em>.  <a href="#a09416bf06b05b67bad21b9e5184e3584">More...</a><br /></td></tr>
<tr class="separator:a09416bf06b05b67bad21b9e5184e3584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb23e0e94cf30e7fe953691c926af6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a9cdb23e0e94cf30e7fe953691c926af6">hasBoundary</a> () const</td></tr>
<tr class="memdesc:a9cdb23e0e94cf30e7fe953691c926af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this simplex has any facets that lie on the triangulation boundary.  <a href="#a9cdb23e0e94cf30e7fe953691c926af6">More...</a><br /></td></tr>
<tr class="separator:a9cdb23e0e94cf30e7fe953691c926af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f0a3046ec46f13f270bbc82193c5cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad1f0a3046ec46f13f270bbc82193c5cc">join</a> (int myFacet, <a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *you, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; gluing)</td></tr>
<tr class="memdesc:ad1f0a3046ec46f13f270bbc82193c5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins the given facet of this simplex to some facet of another simplex.  <a href="#ad1f0a3046ec46f13f270bbc82193c5cc">More...</a><br /></td></tr>
<tr class="separator:ad1f0a3046ec46f13f270bbc82193c5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d139902e93c8ddd7c17cd6f67729b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a4d139902e93c8ddd7c17cd6f67729b22">unjoin</a> (int myFacet)</td></tr>
<tr class="memdesc:a4d139902e93c8ddd7c17cd6f67729b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unglues the given facet of this simplex from whatever it is joined to.  <a href="#a4d139902e93c8ddd7c17cd6f67729b22">More...</a><br /></td></tr>
<tr class="separator:a4d139902e93c8ddd7c17cd6f67729b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df524a7bf262cb0c43ec9d7c39b7687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a0df524a7bf262cb0c43ec9d7c39b7687">isolate</a> ()</td></tr>
<tr class="memdesc:a0df524a7bf262cb0c43ec9d7c39b7687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unglues this simplex from any adjacent simplices.  <a href="#a0df524a7bf262cb0c43ec9d7c39b7687">More...</a><br /></td></tr>
<tr class="separator:a0df524a7bf262cb0c43ec9d7c39b7687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f84802bd71d9affff8a90a6e8ea9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a36f84802bd71d9affff8a90a6e8ea9f0">triangulation</a> () const</td></tr>
<tr class="memdesc:a36f84802bd71d9affff8a90a6e8ea9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the triangulation to which this simplex belongs.  <a href="#a36f84802bd71d9affff8a90a6e8ea9f0">More...</a><br /></td></tr>
<tr class="separator:a36f84802bd71d9affff8a90a6e8ea9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae91a7cee2cdc36220b08d9fe96985f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#aae91a7cee2cdc36220b08d9fe96985f7">component</a> () const</td></tr>
<tr class="memdesc:aae91a7cee2cdc36220b08d9fe96985f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the connected component of the triangulation to which this simplex belongs.  <a href="#aae91a7cee2cdc36220b08d9fe96985f7">More...</a><br /></td></tr>
<tr class="separator:aae91a7cee2cdc36220b08d9fe96985f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727ea46d74705043806e29b1fe32c460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a727ea46d74705043806e29b1fe32c460">face</a> (int face) const</td></tr>
<tr class="memdesc:a727ea46d74705043806e29b1fe32c460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <em>subdim</em>-face of the underlying triangulation that appears as the given <em>subdim</em>-face of this simplex.  <a href="#a727ea46d74705043806e29b1fe32c460">More...</a><br /></td></tr>
<tr class="separator:a727ea46d74705043806e29b1fe32c460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea2c2312ed1484b55eb1db2f25d041e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, 1 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a2ea2c2312ed1484b55eb1db2f25d041e">edge</a> (int i, int j) const</td></tr>
<tr class="memdesc:a2ea2c2312ed1484b55eb1db2f25d041e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the edge of this simplex that connects the two given vertices of this simplex.  <a href="#a2ea2c2312ed1484b55eb1db2f25d041e">More...</a><br /></td></tr>
<tr class="separator:a2ea2c2312ed1484b55eb1db2f25d041e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6192c11252072d2cb57e33aec16e05"><td class="memItemLeft" align="right" valign="top"><a id="afb6192c11252072d2cb57e33aec16e05"></a>
<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 2 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (int i, int j) const</td></tr>
<tr class="separator:afb6192c11252072d2cb57e33aec16e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcca8f1c408b10c155e034fed26aca45"><td class="memItemLeft" align="right" valign="top"><a id="abcca8f1c408b10c155e034fed26aca45"></a>
<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 3 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (int i, int j) const</td></tr>
<tr class="separator:abcca8f1c408b10c155e034fed26aca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e142bf598e8b58da1d8b4260f66274"><td class="memItemLeft" align="right" valign="top"><a id="a07e142bf598e8b58da1d8b4260f66274"></a>
<a class="el" href="group__generic.html#ga0d2ea089ad3d2a6b9141f6d0f2f48861">Edge</a>&lt; 4 &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (int i, int j) const</td></tr>
<tr class="separator:a07e142bf598e8b58da1d8b4260f66274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ab5f66b0a702a6b374af4f0830d9b2fe0">faceMapping</a> (int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a727ea46d74705043806e29b1fe32c460">face</a>) const</td></tr>
<tr class="memdesc:ab5f66b0a702a6b374af4f0830d9b2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Examines the given <em>subdim</em>-face of this simplex, and returns the mapping between the underlying <em>subdim</em>-face of the triangulation and the individual vertices of this simplex.  <a href="#ab5f66b0a702a6b374af4f0830d9b2fe0">More...</a><br /></td></tr>
<tr class="separator:ab5f66b0a702a6b374af4f0830d9b2fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d5105d19509368d155e9f8c497f5e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#aa0d5105d19509368d155e9f8c497f5e4">orientation</a> () const</td></tr>
<tr class="memdesc:aa0d5105d19509368d155e9f8c497f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orientation of this simplex in the <em>dim</em>-dimensional triangulation.  <a href="#aa0d5105d19509368d155e9f8c497f5e4">More...</a><br /></td></tr>
<tr class="separator:aa0d5105d19509368d155e9f8c497f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da19b23a42f47afe636a2cff5f0eee7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a9da19b23a42f47afe636a2cff5f0eee7">facetInMaximalForest</a> (int facet) const</td></tr>
<tr class="memdesc:a9da19b23a42f47afe636a2cff5f0eee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given facet of this simplex belongs to the maximal forest that has been chosen for the dual 1-skeleton of the underlying triangulation.  <a href="#a9da19b23a42f47afe636a2cff5f0eee7">More...</a><br /></td></tr>
<tr class="separator:a9da19b23a42f47afe636a2cff5f0eee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb07d86f5e49e7cf9effbcfa7645b7ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#adb07d86f5e49e7cf9effbcfa7645b7ce">writeTextShort</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:adb07d86f5e49e7cf9effbcfa7645b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#adb07d86f5e49e7cf9effbcfa7645b7ce">More...</a><br /></td></tr>
<tr class="separator:adb07d86f5e49e7cf9effbcfa7645b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf98d5138a8528b99a8a77b4533784a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#abf98d5138a8528b99a8a77b4533784a4">writeTextLong</a> (std::ostream &amp;out) const</td></tr>
<tr class="memdesc:abf98d5138a8528b99a8a77b4533784a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#abf98d5138a8528b99a8a77b4533784a4">More...</a><br /></td></tr>
<tr class="separator:abf98d5138a8528b99a8a77b4533784a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5035a670e370a16699d1cf1c3649da8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1MarkedElement.html#af5035a670e370a16699d1cf1c3649da8">markedIndex</a> () const</td></tr>
<tr class="memdesc:af5035a670e370a16699d1cf1c3649da8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>.  <a href="#af5035a670e370a16699d1cf1c3649da8">More...</a><br /></td></tr>
<tr class="separator:af5035a670e370a16699d1cf1c3649da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2212a7a96adf2538ea875d49a98d99ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad">str</a> () const</td></tr>
<tr class="memdesc:a2212a7a96adf2538ea875d49a98d99ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a2212a7a96adf2538ea875d49a98d99ad">More...</a><br /></td></tr>
<tr class="separator:a2212a7a96adf2538ea875d49a98d99ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae34f42ab7aca350cf7b1dd6f2240a7f2">utf8</a> () const</td></tr>
<tr class="memdesc:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">More...</a><br /></td></tr>
<tr class="separator:ae34f42ab7aca350cf7b1dd6f2240a7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ac2e81e576b58c7d8f52c252c4eb19cda">detail</a> () const</td></tr>
<tr class="memdesc:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#ac2e81e576b58c7d8f52c252c4eb19cda">More...</a><br /></td></tr>
<tr class="separator:ac2e81e576b58c7d8f52c252c4eb19cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:adc4c39e0a3b8437d2c3540b183de7b97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexFacesSuite.html#adc4c39e0a3b8437d2c3540b183de7b97">sameDegrees</a> (const SimplexFacesSuite&lt; dim, subdim &gt; &amp;other, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; p) const</td></tr>
<tr class="memdesc:adc4c39e0a3b8437d2c3540b183de7b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the <em>k</em>-face degrees of this and the given simplex are identical, under the given relabelling, for all faces of all dimensions <em>k</em> &le; <em>subdim</em>.  <a href="#adc4c39e0a3b8437d2c3540b183de7b97">More...</a><br /></td></tr>
<tr class="separator:adc4c39e0a3b8437d2c3540b183de7b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314fb6c464b9d2b0f1169233a75f5a68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexFaces.html#a314fb6c464b9d2b0f1169233a75f5a68">sameDegrees</a> (const SimplexFaces&lt; dim, subdim &gt; &amp;other, <a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; p) const</td></tr>
<tr class="memdesc:a314fb6c464b9d2b0f1169233a75f5a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether the <em>subdim</em>-face degrees of this and the given simplex are identical, under the given relabelling.  <a href="#a314fb6c464b9d2b0f1169233a75f5a68">More...</a><br /></td></tr>
<tr class="separator:a314fb6c464b9d2b0f1169233a75f5a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedf21e482ff437b437980568da0b852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexFaces.html#adedf21e482ff437b437980568da0b852">clear</a> ()</td></tr>
<tr class="memdesc:adedf21e482ff437b437980568da0b852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all face pointers to null.  <a href="#adedf21e482ff437b437980568da0b852">More...</a><br /></td></tr>
<tr class="separator:adedf21e482ff437b437980568da0b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab1f62c40c2775c7d2d03412925c5a2bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexFaces.html#ab1f62c40c2775c7d2d03412925c5a2bf">face_</a> [<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td></tr>
<tr class="memdesc:ab1f62c40c2775c7d2d03412925c5a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The faces of the underlying triangulation that form the individual <em>subdim</em>-faces of this simplex.  <a href="#ab1f62c40c2775c7d2d03412925c5a2bf">More...</a><br /></td></tr>
<tr class="separator:ab1f62c40c2775c7d2d03412925c5a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b08af7c20829b137cd1840cc4f2022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1detail_1_1SimplexFaces.html#ad0b08af7c20829b137cd1840cc4f2022">mapping_</a> [<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td></tr>
<tr class="memdesc:ad0b08af7c20829b137cd1840cc4f2022"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each <em>subdim</em>-face of this simplex, maps vertices (0,1,...,<em>subdim</em>) of the underlying <em>subdim</em>-face of the triangulation to the corresponding vertices of this simplex, as described by faceMapping().  <a href="#ad0b08af7c20829b137cd1840cc4f2022">More...</a><br /></td></tr>
<tr class="separator:ad0b08af7c20829b137cd1840cc4f2022"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1d0602a6c116c8988a3ad360752661e9"><td class="memItemLeft" align="right" valign="top"><a id="a1d0602a6c116c8988a3ad360752661e9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Triangulation&lt; 3 &gt;</b></td></tr>
<tr class="separator:a1d0602a6c116c8988a3ad360752661e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830f8fd15be1fd552a1b44d4801d89e8"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1Face_3_013_00_013_01_4.html#a830f8fd15be1fd552a1b44d4801d89e8">detail::TriangulationBase&lt; 3 &gt;</a></td></tr>
<tr class="memdesc:a830f8fd15be1fd552a1b44d4801d89e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow access to private members.  <a href="#a830f8fd15be1fd552a1b44d4801d89e8">More...</a><br /></td></tr>
<tr class="separator:a830f8fd15be1fd552a1b44d4801d89e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;&gt;<br />
class regina::Face&lt; 3, 3 &gt;</h3>

<p>Represents a tetrahedron within a 3-manifold triangulation. </p>
<p>This class is typically referred to by the aliases Simplex&lt;3&gt; or Tetrahedron&lt;3&gt; (or, for Python users, <code>Simplex3</code> and <code>Tetrahedron3</code>).</p>
<p>The class template <a class="el" href="classregina_1_1Face_3_01dim_00_01dim_01_4.html" title="Represents a top-dimensional simplex in a dim-manifold triangulation.">Face&lt;dim, dim&gt;</a> specialises the generic <a class="el" href="classregina_1_1Face.html" title="Represents a subdim-face in the skeleton of a dim-dimensional triangulation.">Face</a> class template in order to work with top-dimensional simplices in a triangulation. This class <a class="el" href="classregina_1_1Face_3_013_00_013_01_4.html" title="Represents a tetrahedron within a 3-manifold triangulation.">Face&lt;3, 3&gt;</a> specialises it further to add dimension-specific aliases for dimension 3.</p>
<p>See the documentation for the partial specialisation <a class="el" href="classregina_1_1Face_3_01dim_00_01dim_01_4.html" title="Represents a top-dimensional simplex in a dim-manifold triangulation.">Face&lt;dim, dim&gt;</a> for an overview of how a top-dimensional simplex class works. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0b7e6840cf1d720009ce05f57e837b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7e6840cf1d720009ce05f57e837b8c">&#9670;&nbsp;</a></span>FacetMask</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structregina_1_1IntOfMinSize.html">IntOfMinSize</a>&lt;(dim / 8) + 1&gt;::utype <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::<a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a0b7e6840cf1d720009ce05f57e837b8c">FacetMask</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An unsigned integer type with at least <em>dim</em>+1 bits. </p>
<p>This can be used as a bitmask for the <em>dim</em>+1 facets (or vertices) of a <em>dim</em>-simplex. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ccf140ce8a41c983d22111160ec2d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccf140ce8a41c983d22111160ec2d8b">&#9670;&nbsp;</a></span>adjacentFace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 3 &gt;::adjacentFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a09416bf06b05b67bad21b9e5184e3584" title="If the given facet of this simplex is glued to facet f of some adjacent simplex, then this routine re...">adjacentFacet()</a>. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a09416bf06b05b67bad21b9e5184e3584" title="If the given facet of this simplex is glued to facet f of some adjacent simplex, then this routine re...">adjacentFacet()</a> for further information. </p>

</div>
</div>
<a id="a09416bf06b05b67bad21b9e5184e3584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09416bf06b05b67bad21b9e5184e3584">&#9670;&nbsp;</a></span>adjacentFacet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentFacet </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the given facet of this simplex is glued to facet <em>f</em> of some adjacent simplex, then this routine returns the adjacent facet number <em>f</em>. </p>
<p>The return value from this routine is identical to adjacentGluing(<em>facet</em>)[<em>facet</em>].</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet of this simplex has some adjacent simplex (possibly this one) glued to it. In other words, adjacentSimplex(<em>facet</em>) is not <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding facet number of the adjacent simplex that is glued to the given facet of this simplex. </dd></dl>

</div>
</div>
<a id="a39ac592b6db07dba1487e054be273799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ac592b6db07dba1487e054be273799">&#9670;&nbsp;</a></span>adjacentGluing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentGluing </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a permutation that indicates precisely how this simplex is glued to the adjacent simplex across the given facet. </p>
<p>In detail: suppose that the given facet of this simplex is glued to an adjacent simplex <em>A</em>. Then this gluing induces a mapping from the vertices of this simplex to the vertices of <em>A</em>. We can express this mapping in the form of a permutation <em>p</em>, where:</p>
<ul>
<li>for any <em>v</em> &ne; <em>facet</em>, the gluing identifies vertex <em>v</em> of this simplex with vertex <em>p</em>[<em>v</em>] of simplex <em>A</em>;</li>
<li><em>p</em>[<em>facet</em>] indicates the facet of <em>A</em> that is on the other side of the gluing (i.e., the facet of <em>A</em> that is glued to the given facet of this simplex).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The given facet of this simplex has some adjacent simplex (possibly this one) glued to it. In other words, adjacentSimplex(<em>facet</em>) is not <code>null</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a permutation that maps the vertices of this simplex to the vertices of the adjacent simplex, as described above. </dd></dl>

</div>
</div>
<a id="ad0c12cf55a47ae78e9b4e91ce46c838d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c12cf55a47ae78e9b4e91ce46c838d">&#9670;&nbsp;</a></span>adjacentSimplex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::adjacentSimplex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the adjacent simplex that is glued to the given facet of this simplex. </p>
<p>If there is no adjacent simplex (i.e., the given facet lies on the triangulation boundary), then this routine will return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex to examine; this must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the adjacent simplex glued to the given facet, or 0 if the given facet lies on the boundary. </dd></dl>

</div>
</div>
<a id="a674b8434d6c9baf99d39748d5b76cd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674b8434d6c9baf99d39748d5b76cd2a">&#9670;&nbsp;</a></span>adjacentTetrahedron()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; 3 &gt; * <a class="el" href="classregina_1_1Face.html">regina::Face</a>&lt; 3, 3 &gt;::adjacentTetrahedron </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dimension-specific alias for <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad0c12cf55a47ae78e9b4e91ce46c838d" title="Returns the adjacent simplex that is glued to the given facet of this simplex.">adjacentSimplex()</a>. </p>
<p>See <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad0c12cf55a47ae78e9b4e91ce46c838d" title="Returns the adjacent simplex that is glued to the given facet of this simplex.">adjacentSimplex()</a> for further information. </p>

</div>
</div>
<a id="adedf21e482ff437b437980568da0b852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedf21e482ff437b437980568da0b852">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets all face pointers to null. </p>
<p>The faces themselves are not destroyed, and the mapping permutations are not touched. </p>

</div>
</div>
<a id="aae91a7cee2cdc36220b08d9fe96985f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae91a7cee2cdc36220b08d9fe96985f7">&#9670;&nbsp;</a></span>component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Component.html">Component</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::component </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the connected component of the triangulation to which this simplex belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the component containing this simplex. </dd></dl>

</div>
</div>
<a id="a00178392c44456529f5250de6bc448ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00178392c44456529f5250de6bc448ef">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the description associated with this simplex. </p>
<dl class="section return"><dt>Returns</dt><dd>the description of this simplex, or the empty string if no description is stored. </dd></dl>

</div>
</div>
<a id="ac2e81e576b58c7d8f52c252c4eb19cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e81e576b58c7d8f52c252c4eb19cda">&#9670;&nbsp;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; SimplexBase&lt; dim &gt; , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a id="a2ea2c2312ed1484b55eb1db2f25d041e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea2c2312ed1484b55eb1db2f25d041e">&#9670;&nbsp;</a></span>edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, 1&gt;* <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the edge of this simplex that connects the two given vertices of this simplex. </p>
<p>This is a convenience routine to avoid more cumbersome calls to <a class="el" href="group__detail.html#ga7466eaf4d128e641797687eb31f13e7e" title="Identifies which subdim-face in a dim-dimensional simplex is represented by the first (subdim + 1) el...">Edge&lt;dim&gt;::faceNumber()</a>. In dimensions 3 and 4 (where the array Edge&lt;dim&gt;::edgeNumber is defined), this routine is identical to calling <code>edge(Edge&lt;dim&gt;::edgeNumber[i][j])</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the vertex of this simplex that forms one endpoint of the edge; this must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">j</td><td>the vertex of this simplex that forms the other endpoint of the edge; this must be between 0 and <em>dim</em> inclusive, and must also be different from <em>i</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the edge of this simplex that connects vertices <em>i</em> and <em>j</em> of this simplex. </dd></dl>

</div>
</div>
<a id="a727ea46d74705043806e29b1fe32c460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727ea46d74705043806e29b1fe32c460">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt; dim, subdim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the <em>subdim</em>-face of the underlying triangulation that appears as the given <em>subdim</em>-face of this simplex. </p>
<p>See FaceNumbering&lt;dim, subdim&gt; for the conventions of how <em>subdim</em>-faces are numbered within a <em>dim</em>-simplex.</p>
<dl class="section user"><dt>Python:\n Python does not support templates. Instead,</dt><dd>Python users should call this function in the form <code>face(subdim, face)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>subdim</em>-face of this simplex to examine. This should be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding <em>subdim</em>-face of the triangulation. </dd></dl>

</div>
</div>
<a id="ab5f66b0a702a6b374af4f0830d9b2fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f66b0a702a6b374af4f0830d9b2fe0">&#9670;&nbsp;</a></span>faceMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt; <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::faceMapping </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Examines the given <em>subdim</em>-face of this simplex, and returns the mapping between the underlying <em>subdim</em>-face of the triangulation and the individual vertices of this simplex. </p>
<p>Specifically:</p>
<ul>
<li>Suppose several <em>subdim</em>-faces of several top-dimensional simplices are identified within the overall triangulation. Then we call this a single "&lt;i&gt;subdim&lt;/i&gt;-face of the triangulation", and arbitrarily label its vertices (0, ..., <em>subdim</em>).</li>
<li>Now let <em>F</em> denote the <em>subdim</em>-face of the triangulation that corresponds to <em>subdim</em>-face number <em>face</em> of this simplex. Then this routine returns a map from vertices (0, ..., <em>subdim</em>) of <em>F</em> to the corresponding vertex numbers of this simplex.</li>
<li>In particular, if this routine returns the permutation <em>p</em>, then the images <em>p</em>[0,...,<em>subdim</em>] will be some permutation of the vertices <a class="el" href="group__detail.html#ga317bc3a01d0543daddb4c00ab4d27d5b" title="Given a subdim-face number within a dim-dimensional simplex, returns the corresponding canonical orde...">Face&lt;dim, subdim&gt;::ordering</a>[0,...,<em>subdim</em>].</li>
<li>If <em>F</em> also appears as face number <em>k</em> in some other simplex <em>s</em>, then for each <em>i</em> in the range 0 &le; <em>i</em> &le; <em>subdim</em>, vertex <code>p[i]</code> of this simplex will be identified with vertex <em>s</em>.faceMapping(<em>k</em>)[<em>i</em>] of simplex <em>s</em>.</li>
</ul>
<p>If the link of the underlying <em>subdim</em>-face is orientable, then this permutation maps the remaining numbers (<em>subdim</em>+1, ..., <em>dim</em>) to the remaining vertex numbers of this simplex in a manner that preserves orientation as you walk through the many different simplices that contain the same underlying <em>subdim</em>-face. Specifically:</p>
<ul>
<li>The images of (<em>subdim</em>+1, ..., <em>dim</em>) under this permutation imply an orientation for the (<em>dim</em> - <em>subdim</em> - 1)-face opposite <em>F</em> in this simplex. These orientations will be consistent for all simplices containing <em>F</em>.</li>
<li>For faces of codimension two (e.g., edges in a 3-manifold triangulation), this orientation condition is even stronger. Here the link of the face <em>F</em> must be a path (for a boundary face) or a cycle (for an internal face). In each simplex we can form a directed edge from the image of <em>dim</em>-1 to the image of <em>dim</em> under this permutation, and together these directed edges form a directed path or cycle that follows the link of the face <em>F</em>. Moreover, an iteration through the corresponding FaceEmbedding&lt;dim, subdim&gt; objects in order from <code>F.begin()</code> to <code>F.end()</code>, will follow this directed path in order from start to end. (In the case where the link of <em>F</em> is a cycle, the start point in the list of <a class="el" href="classregina_1_1FaceEmbedding.html" title="Details how a subdim-face of a dim-dimensional triangulation appears within each top-dimensional simp...">FaceEmbedding</a> objects will be arbitrary.)</li>
</ul>
<p>Note that, even if the link is orientable, there are still arbitrary decisions to be made for the images of (<em>subdim</em>+1, ..., <em>dim</em>), since there will always be (<em>dim</em>-<em>subdim</em>)!/2 possible mappings that yield the correct orientation.</p>
<dl class="section note"><dt>Note</dt><dd>This routine returns the same permutation as <a class="el" href="classregina_1_1detail_1_1FaceEmbeddingBase.html#a8a8c5079eec12de43bd3fb8d0d7e3fdd" title="Maps vertices (0,...,subdim) of the underlying subdim-face of the triangulation to the corresponding ...">FaceEmbedding&lt;dim, subdim&gt;::vertices()</a>, in the context of the FaceEmbedding&lt;dim, subdim&gt; object that refers to <em>subdim</em>-face number <em>face</em> of this simplex.</dd></dl>
<dl class="section user"><dt>Python:\n Python does not support templates. Instead,</dt><dd>Python users should call this function in the form <code>faceMapping(subdim, face)</code>; that is, the template parameter <em>subdim</em> becomes the first argument of the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>the <em>subdim</em>-face of this simplex to examine. This should be between 0 and (<em>dim</em>+1 choose <em>subdim</em>+1)-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a mapping from the vertices of the underlying <em>subdim</em>-face of the triangulation to the vertices of this simplex. </dd></dl>

</div>
</div>
<a id="a9da19b23a42f47afe636a2cff5f0eee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da19b23a42f47afe636a2cff5f0eee7">&#9670;&nbsp;</a></span>facetInMaximalForest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::facetInMaximalForest </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>facet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given facet of this simplex belongs to the maximal forest that has been chosen for the dual 1-skeleton of the underlying triangulation. </p>
<p>When the skeletal structure of a triangulation is first computed, a maximal forest in the dual 1-skeleton of the triangulation is also constructed. Each dual edge in this maximal forest represents a (<em>dim</em>-1)-face of the (primal) triangulation.</p>
<p>This maximal forest will remain fixed until the triangulation changes, at which point it will be recomputed (as will all other skeletal objects, such as connected components and so on). There is no guarantee that, when it is recomputed, the maximal forest will use the same dual edges as before.</p>
<p>This routine identifies which (<em>dim</em>-1)-faces of the triangulation belong to the dual forest. Because it lives in the Simplex class, this routine can even be used for those dimensions that do not have explicit classes for (<em>dim</em>-1)-faces of the triangulation.</p>
<p>If the skeleton has already been computed, then this routine is very fast (since it just returns a precomputed answer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">facet</td><td>the facet of this simplex that we are examining. This must be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the given facet of this simplex corresponds to a dual edge in the maximal forest chosen for the dual 1-skeleton. </dd></dl>

</div>
</div>
<a id="a9cdb23e0e94cf30e7fe953691c926af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdb23e0e94cf30e7fe953691c926af6">&#9670;&nbsp;</a></span>hasBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::hasBoundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this simplex has any facets that lie on the triangulation boundary. </p>
<p>In other words, this routine determines whether any facet of this simplex is not currently glued to an adjacent simplex.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this simplex has any boundary facets. </dd></dl>

</div>
</div>
<a id="abbf51cda05f67725962436cae590a0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf51cda05f67725962436cae590a0ff">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of this simplex in the underlying triangulation. </p>
<p>The index will be an integer between 0 and <code><a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a36f84802bd71d9affff8a90a6e8ea9f0" title="Returns the triangulation to which this simplex belongs.">triangulation()</a>-&gt;size()-1</code> inclusive.</p>
<p>Note that indexing may change when a simplex is added to or removed from the underlying triangulation.</p>
<dl class="section return"><dt>Returns</dt><dd>the index of this simplex. </dd></dl>

</div>
</div>
<a id="a0df524a7bf262cb0c43ec9d7c39b7687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df524a7bf262cb0c43ec9d7c39b7687">&#9670;&nbsp;</a></span>isolate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::isolate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unglues this simplex from any adjacent simplices. </p>
<p>As a result, every facet of this simplex will become a boundary facet, and this simplex will form its own separate component of the underlying triangulation.</p>
<p>If there were any adjacent simplices to begin with, these will be updated automatically.</p>
<p>This routine is safe to call even if there are no adjacent simplices (in which case it will do nothing). </p>

</div>
</div>
<a id="ad1f0a3046ec46f13f270bbc82193c5cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f0a3046ec46f13f270bbc82193c5cc">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::join </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myFacet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; *&#160;</td>
          <td class="paramname"><em>you</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td>
          <td class="paramname"><em>gluing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Joins the given facet of this simplex to some facet of another simplex. </p>
<p>The other simplex will be updated automatically (i.e., you only need to call <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ad1f0a3046ec46f13f270bbc82193c5cc" title="Joins the given facet of this simplex to some facet of another simplex.">join()</a> from one side of the gluing).</p>
<p>You may join a facet of this simplex to some different facet of the same simplex (i.e., you may pass <em>you</em> == <code>this</code>), though you cannot join a facet to itself.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given simplex belong to the same triangulation. </dd>
<dd>
The given facet of this simplex is not currently glued to anything. </dd>
<dd>
The corresponding facet of the other simplex (i.e., facet <em>gluing</em>[<em>myFacet</em>] of <em>you</em>) is likewise not currently glued to anything. </dd>
<dd>
We are not attempting to glue a facet to itself (i.e., we do not have both <em>you</em> == <code>this</code> and <em>gluing</em>[<em>myFacet</em>] == <em>myFacet</em>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myFacet</td><td>the facet of this simplex that will be glued to the given simplex <em>you</em>. This facet number must be between 0 and <em>dim</em> inclusive. </td></tr>
    <tr><td class="paramname">you</td><td>the other simplex that will be glued to the given facet of this simplex. </td></tr>
    <tr><td class="paramname">gluing</td><td>a permutation that describes how the vertices of this simplex will map to the vertices of <em>you</em> across the new gluing. This permutation should be in the form described by <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a39ac592b6db07dba1487e054be273799" title="Returns a permutation that indicates precisely how this simplex is glued to the adjacent simplex acro...">adjacentGluing()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5035a670e370a16699d1cf1c3649da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5035a670e370a16699d1cf1c3649da8">&#9670;&nbsp;</a></span>markedIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::MarkedElement::markedIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index at which this object is stored in an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>. </p>
<p>If this object does not belong to an <a class="el" href="classregina_1_1MarkedVector.html" title="A vector of objects with fast, space-efficient reverse lookup of array indices.">MarkedVector</a>, the return value is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>the index at which this object is stored. </dd></dl>

</div>
</div>
<a id="aa0d5105d19509368d155e9f8c497f5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d5105d19509368d155e9f8c497f5e4">&#9670;&nbsp;</a></span>orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::orientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the orientation of this simplex in the <em>dim</em>-dimensional triangulation. </p>
<p>The orientation of each top-dimensional simplex is always +1 or -1. In an orientable component of a triangulation, adjacent simplices have the same orientations if one could be transposed onto the other without reflection, and they have opposite orientations if a reflection would be required. In a non-orientable component, orientations are arbitrary (but they will still all be +1 or -1).</p>
<dl class="section return"><dt>Returns</dt><dd>+1 or -1 according to the orientation of this triangle. </dd></dl>

</div>
</div>
<a id="a314fb6c464b9d2b0f1169233a75f5a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314fb6c464b9d2b0f1169233a75f5a68">&#9670;&nbsp;</a></span>sameDegrees() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::sameDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">SimplexFaces</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the <em>subdim</em>-face degrees of this and the given simplex are identical, under the given relabelling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the simplex to compare against this. </td></tr>
    <tr><td class="paramname">p</td><td>a mapping from the vertices of this simplex to the vertices of <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if, for every <em>i</em>, <em>subdim</em>-face number <em>i</em> of this simplex has the same degree as its image in <em>other</em> under the relabelling <em>p</em>. </dd></dl>

</div>
</div>
<a id="adc4c39e0a3b8437d2c3540b183de7b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4c39e0a3b8437d2c3540b183de7b97">&#9670;&nbsp;</a></span>sameDegrees() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classregina_1_1detail_1_1SimplexFacesSuite.html">regina::detail::SimplexFacesSuite</a>&lt; dim &gt;::sameDegrees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1detail_1_1SimplexFacesSuite.html">SimplexFacesSuite</a>&lt; dim, subdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt; dim+1 &gt;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether the <em>k</em>-face degrees of this and the given simplex are identical, under the given relabelling, for all faces of all dimensions <em>k</em> &le; <em>subdim</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the simplex to compare against this. </td></tr>
    <tr><td class="paramname">p</td><td>a mapping from the vertices of this simplex to the vertices of <em>other</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if, for every <em>i</em> and every facial dimension <em>k</em> &le; <em>subdim</em>, <em>k</em>-face number <em>i</em> of this simplex has the same degree as its image in <em>other</em> under the relabelling <em>p</em>. </dd></dl>

</div>
</div>
<a id="a6d949a6ec9b90b7c9fce5c9da6dc52d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d949a6ec9b90b7c9fce5c9da6dc52d6">&#9670;&nbsp;</a></span>setDescription()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::setDescription </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the description associated with this simplex. </p>
<p>This may be any text whatsoever; typically it is intended to be human-readable. Descriptions do not need to be unique.</p>
<p>To remove an existing description, you can simply set the description to the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc</td><td>the new description to assign to this simplex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2212a7a96adf2538ea875d49a98d99ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2212a7a96adf2538ea875d49a98d99ad">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; SimplexBase&lt; dim &gt; , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:\n In addition to str(), this is also used as the</dt><dd>Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="a36f84802bd71d9affff8a90a6e8ea9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f84802bd71d9affff8a90a6e8ea9f0">&#9670;&nbsp;</a></span>triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Triangulation.html">Triangulation</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the triangulation to which this simplex belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the triangulation containing this simplex. </dd></dl>

</div>
</div>
<a id="a4d139902e93c8ddd7c17cd6f67729b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d139902e93c8ddd7c17cd6f67729b22">&#9670;&nbsp;</a></span>unjoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__generic.html#gad4bfc8e4b6a2b1452937e33f56ab9eb3">Simplex</a>&lt; dim &gt; * <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::unjoin </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myFacet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unglues the given facet of this simplex from whatever it is joined to. </p>
<p>As a result, the given facet of this simplex will become a boundary facet.</p>
<p>If there was an adjacent simplex to begin with, then this other simplex will be updated automatically (i.e., you only need to call <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#a4d139902e93c8ddd7c17cd6f67729b22" title="Unglues the given facet of this simplex from whatever it is joined to.">unjoin()</a> from one side of the gluing).</p>
<p>This routine is safe to call even if the given facet is already a boundary facet (in which case it will do nothing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myFacet</td><td>the facet of this simplex whose gluing we will undo. This should be between 0 and <em>dim</em> inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the simplex that was originally glued to the given facet of this simplex, or 0 if this was already a boundary facet. </dd></dl>

</div>
</div>
<a id="ae34f42ab7aca350cf7b1dd6f2240a7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34f42ab7aca350cf7b1dd6f2240a7f2">&#9670;&nbsp;</a></span>utf8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; SimplexBase&lt; dim &gt; , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a short text representation of this object using unicode characters. </p>
<p>Like <a class="el" href="structregina_1_1Output.html#a2212a7a96adf2538ea875d49a98d99ad" title="Returns a short text representation of this object.">str()</a>, this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a id="abf98d5138a8528b99a8a77b4533784a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf98d5138a8528b99a8a77b4533784a4">&#9670;&nbsp;</a></span>writeTextLong()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb07d86f5e49e7cf9effbcfa7645b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb07d86f5e49e7cf9effbcfa7645b7ce">&#9670;&nbsp;</a></span>writeTextShort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classregina_1_1detail_1_1SimplexBase.html">regina::detail::SimplexBase</a>&lt; dim &gt;::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<dl class="section user"><dt>Python:\n Not present.</dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a830f8fd15be1fd552a1b44d4801d89e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830f8fd15be1fd552a1b44d4801d89e8">&#9670;&nbsp;</a></span>detail::TriangulationBase&lt; 3 &gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classregina_1_1detail_1_1TriangulationBase.html">detail::TriangulationBase</a>&lt; 3 &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow access to private members. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab1f62c40c2775c7d2d03412925c5a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f62c40c2775c7d2d03412925c5a2bf">&#9670;&nbsp;</a></span>face_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Face.html">Face</a>&lt;dim, subdim&gt;* <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::face_[<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The faces of the underlying triangulation that form the individual <em>subdim</em>-faces of this simplex. </p>

</div>
</div>
<a id="ad0b08af7c20829b137cd1840cc4f2022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b08af7c20829b137cd1840cc4f2022">&#9670;&nbsp;</a></span>mapping_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int subdim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1Perm.html">Perm</a>&lt;dim+1&gt; <a class="el" href="classregina_1_1detail_1_1SimplexFaces.html">regina::detail::SimplexFaces</a>&lt; dim, subdim &gt;::mapping_[<a class="el" href="classregina_1_1FaceNumbering.html">FaceNumbering</a>&lt; dim, subdim &gt;::nFaces]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each <em>subdim</em>-face of this simplex, maps vertices (0,1,...,<em>subdim</em>) of the underlying <em>subdim</em>-face of the triangulation to the corresponding vertices of this simplex, as described by <a class="el" href="classregina_1_1detail_1_1SimplexBase.html#ab5f66b0a702a6b374af4f0830d9b2fe0" title="Examines the given subdim-face of this simplex, and returns the mapping between the underlying subdim...">faceMapping()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>triangulation/dim3/<a class="el" href="tetrahedron3_8h.html">tetrahedron3.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2020, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
