<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>Regina Calculation Engine: regina::NScript Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Regina Calculation Engine
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceregina.html">regina</a></li><li class="navelem"><a class="el" href="classregina_1_1NScript.html">NScript</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classregina_1_1NScript-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">regina::NScript Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__packet.html">Basic Packet Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A packet representing a Python script that can be run.  
 <a href="classregina_1_1NScript.html#details">More...</a></p>

<p><code>#include &lt;packet/nscript.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for regina::NScript:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classregina_1_1NScript.png" usemap="#regina::NScript_map" alt=""/>
  <map id="regina::NScript_map" name="regina::NScript_map">
<area href="classregina_1_1NPacket.html" title="Represents a packet of information that may be individually edited or operated upon." alt="regina::NPacket" shape="rect" coords="231,56,452,80"/>
<area href="classregina_1_1NPacketListener.html" title="An object that can be registered to listen for packet events." alt="regina::NPacketListener" shape="rect" coords="462,56,683,80"/>
<area href="structregina_1_1Output.html" alt="regina::Output&lt; NPacket &gt;" shape="rect" coords="0,0,221,24"/>
<area href="classregina_1_1SafePointeeBase.html" alt="regina::SafePointeeBase&lt; NPacket &gt;" shape="rect" coords="231,0,452,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classregina_1_1NPacket.html">NPacket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td></tr>
<tr class="memdesc:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of object being pointed to.  <a href="#a2e4bacf91fc79a12ae3a02f4339ed034">More...</a><br/></td></tr>
<tr class="separator:a2e4bacf91fc79a12ae3a02f4339ed034"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a34b1a14249599521a259590eb21919b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a34b1a14249599521a259590eb21919b7">NScript</a> ()</td></tr>
<tr class="memdesc:a34b1a14249599521a259590eb21919b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises to a script with no text and no variables.  <a href="#a34b1a14249599521a259590eb21919b7">More...</a><br/></td></tr>
<tr class="separator:a34b1a14249599521a259590eb21919b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec52f5941f29b2019ff911129b2ea451"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#aec52f5941f29b2019ff911129b2ea451">text</a> () const </td></tr>
<tr class="memdesc:aec52f5941f29b2019ff911129b2ea451"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complete text of this script.  <a href="#aec52f5941f29b2019ff911129b2ea451">More...</a><br/></td></tr>
<tr class="separator:aec52f5941f29b2019ff911129b2ea451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d186b82b38d43a44d11dc0730b1950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#ab0d186b82b38d43a44d11dc0730b1950">getText</a> () const </td></tr>
<tr class="memdesc:ab0d186b82b38d43a44d11dc0730b1950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the complete text of this script.  <a href="#ab0d186b82b38d43a44d11dc0730b1950">More...</a><br/></td></tr>
<tr class="separator:ab0d186b82b38d43a44d11dc0730b1950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b790b965eea38caa1d103ec6213565a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a8b790b965eea38caa1d103ec6213565a">setText</a> (const std::string &amp;newText)</td></tr>
<tr class="memdesc:a8b790b965eea38caa1d103ec6213565a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the complete text of this script with the given string.  <a href="#a8b790b965eea38caa1d103ec6213565a">More...</a><br/></td></tr>
<tr class="separator:a8b790b965eea38caa1d103ec6213565a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f61ed8b5993b62ad6cef33f22ed2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#ac5f61ed8b5993b62ad6cef33f22ed2bd">append</a> (const std::string &amp;extraText)</td></tr>
<tr class="memdesc:ac5f61ed8b5993b62ad6cef33f22ed2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given text to the end of this script.  <a href="#ac5f61ed8b5993b62ad6cef33f22ed2bd">More...</a><br/></td></tr>
<tr class="separator:ac5f61ed8b5993b62ad6cef33f22ed2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5256367617decaaec86e576148377550"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550">countVariables</a> () const </td></tr>
<tr class="memdesc:a5256367617decaaec86e576148377550"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of variables associated with this script.  <a href="#a5256367617decaaec86e576148377550">More...</a><br/></td></tr>
<tr class="separator:a5256367617decaaec86e576148377550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f65b5f4279e63cd7d30885852212ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#ab4f65b5f4279e63cd7d30885852212ad">getNumberOfVariables</a> () const </td></tr>
<tr class="memdesc:ab4f65b5f4279e63cd7d30885852212ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of variables associated with this script.  <a href="#ab4f65b5f4279e63cd7d30885852212ad">More...</a><br/></td></tr>
<tr class="separator:ab4f65b5f4279e63cd7d30885852212ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9f6f0ca643276f6e534303f3e1d0a8"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#adc9f6f0ca643276f6e534303f3e1d0a8">variableName</a> (size_t index) const </td></tr>
<tr class="memdesc:adc9f6f0ca643276f6e534303f3e1d0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of the requested variable associated with this script.  <a href="#adc9f6f0ca643276f6e534303f3e1d0a8">More...</a><br/></td></tr>
<tr class="separator:adc9f6f0ca643276f6e534303f3e1d0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2ac72f3054a8426ddd1d39e03b0f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#abd2ac72f3054a8426ddd1d39e03b0f4e">getVariableName</a> (size_t index) const </td></tr>
<tr class="memdesc:abd2ac72f3054a8426ddd1d39e03b0f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the name of the requested variable associated with this script.  <a href="#abd2ac72f3054a8426ddd1d39e03b0f4e">More...</a><br/></td></tr>
<tr class="separator:abd2ac72f3054a8426ddd1d39e03b0f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc2b02d900a4c0ecb815656b110d9c4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#aadc2b02d900a4c0ecb815656b110d9c4">variableIndex</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:aadc2b02d900a4c0ecb815656b110d9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the variable stored with the given name.  <a href="#aadc2b02d900a4c0ecb815656b110d9c4">More...</a><br/></td></tr>
<tr class="separator:aadc2b02d900a4c0ecb815656b110d9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7f6a1b7f37eb1317556776e3be8b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a1d7f6a1b7f37eb1317556776e3be8b32">getVariableIndex</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a1d7f6a1b7f37eb1317556776e3be8b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the index of the variable stored with the given name.  <a href="#a1d7f6a1b7f37eb1317556776e3be8b32">More...</a><br/></td></tr>
<tr class="separator:a1d7f6a1b7f37eb1317556776e3be8b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a92f617943f045645f5ad24be523fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a37a92f617943f045645f5ad24be523fe">variableValue</a> (size_t index) const </td></tr>
<tr class="memdesc:a37a92f617943f045645f5ad24be523fe"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the requested variable associated with this script.  <a href="#a37a92f617943f045645f5ad24be523fe">More...</a><br/></td></tr>
<tr class="separator:a37a92f617943f045645f5ad24be523fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76679032607a9667b796828da1214ed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a76679032607a9667b796828da1214ed4">getVariableValue</a> (size_t index) const </td></tr>
<tr class="memdesc:a76679032607a9667b796828da1214ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the value of the requested variable associated with this script.  <a href="#a76679032607a9667b796828da1214ed4">More...</a><br/></td></tr>
<tr class="separator:a76679032607a9667b796828da1214ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c75ae8156d538aacabf16964cdc40b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a3c75ae8156d538aacabf16964cdc40b9">variableValue</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a3c75ae8156d538aacabf16964cdc40b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the variable stored with the given name.  <a href="#a3c75ae8156d538aacabf16964cdc40b9">More...</a><br/></td></tr>
<tr class="separator:a3c75ae8156d538aacabf16964cdc40b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe177e799190d06cceb6835e8e679f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#affe177e799190d06cceb6835e8e679f7">getVariableValue</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:affe177e799190d06cceb6835e8e679f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the value of the variable stored with the given name.  <a href="#affe177e799190d06cceb6835e8e679f7">More...</a><br/></td></tr>
<tr class="separator:affe177e799190d06cceb6835e8e679f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f699e6b062971e3f11c39dd2d275cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a8f699e6b062971e3f11c39dd2d275cbf">setVariableName</a> (size_t index, const std::string &amp;name)</td></tr>
<tr class="memdesc:a8f699e6b062971e3f11c39dd2d275cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name of an existing variable associated with this script.  <a href="#a8f699e6b062971e3f11c39dd2d275cbf">More...</a><br/></td></tr>
<tr class="separator:a8f699e6b062971e3f11c39dd2d275cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a15b43b45968180c51a110c860a5cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a8a15b43b45968180c51a110c860a5cbf">setVariableValue</a> (size_t index, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *value)</td></tr>
<tr class="memdesc:a8a15b43b45968180c51a110c860a5cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the value of an existing variable associated with this script.  <a href="#a8a15b43b45968180c51a110c860a5cbf">More...</a><br/></td></tr>
<tr class="separator:a8a15b43b45968180c51a110c860a5cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad34c67c09d44c818d420335b765c20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#abad34c67c09d44c818d420335b765c20">addVariable</a> (const std::string &amp;name, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *value)</td></tr>
<tr class="memdesc:abad34c67c09d44c818d420335b765c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new variable to be associated with this script.  <a href="#abad34c67c09d44c818d420335b765c20">More...</a><br/></td></tr>
<tr class="separator:abad34c67c09d44c818d420335b765c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3bc75dde3d4541b26292c1b6edaebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a9a3bc75dde3d4541b26292c1b6edaebf">removeVariable</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a9a3bc75dde3d4541b26292c1b6edaebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variable stored with the given name.  <a href="#a9a3bc75dde3d4541b26292c1b6edaebf">More...</a><br/></td></tr>
<tr class="separator:a9a3bc75dde3d4541b26292c1b6edaebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d05a79414057bad3dbd43afaebfd09d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a1d05a79414057bad3dbd43afaebfd09d">removeVariable</a> (size_t index)</td></tr>
<tr class="memdesc:a1d05a79414057bad3dbd43afaebfd09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variable stored at the given index.  <a href="#a1d05a79414057bad3dbd43afaebfd09d">More...</a><br/></td></tr>
<tr class="separator:a1d05a79414057bad3dbd43afaebfd09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfad9c173932b86d8408b49f63a5033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a0bfad9c173932b86d8408b49f63a5033">removeAllVariables</a> ()</td></tr>
<tr class="memdesc:a0bfad9c173932b86d8408b49f63a5033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all variables associated with this script.  <a href="#a0bfad9c173932b86d8408b49f63a5033">More...</a><br/></td></tr>
<tr class="separator:a0bfad9c173932b86d8408b49f63a5033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571f9404f5e923481f2a38195fc0582f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a571f9404f5e923481f2a38195fc0582f">writeTextShort</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a571f9404f5e923481f2a38195fc0582f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a short text representation of this object to the given output stream.  <a href="#a571f9404f5e923481f2a38195fc0582f">More...</a><br/></td></tr>
<tr class="separator:a571f9404f5e923481f2a38195fc0582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebf217ae9b99509f300b113525cf6b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a4ebf217ae9b99509f300b113525cf6b6">writeTextLong</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a4ebf217ae9b99509f300b113525cf6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a detailed text representation of this object to the given output stream.  <a href="#a4ebf217ae9b99509f300b113525cf6b6">More...</a><br/></td></tr>
<tr class="separator:a4ebf217ae9b99509f300b113525cf6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef86d443c1fc9aacd3e12fc3673ffefd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#aef86d443c1fc9aacd3e12fc3673ffefd">dependsOnParent</a> () const </td></tr>
<tr class="memdesc:aef86d443c1fc9aacd3e12fc3673ffefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet depends upon its parent.  <a href="#aef86d443c1fc9aacd3e12fc3673ffefd">More...</a><br/></td></tr>
<tr class="separator:aef86d443c1fc9aacd3e12fc3673ffefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc35bac12fca88767b9419793c69438f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#afc35bac12fca88767b9419793c69438f">packetWasRenamed</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:afc35bac12fca88767b9419793c69438f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the packet label or tags have been changed.  <a href="#afc35bac12fca88767b9419793c69438f">More...</a><br/></td></tr>
<tr class="separator:afc35bac12fca88767b9419793c69438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64a203987c3371ed09b0a58bf236da0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#ad64a203987c3371ed09b0a58bf236da0">packetToBeDestroyed</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:ad64a203987c3371ed09b0a58bf236da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet is about to be destroyed.  <a href="#ad64a203987c3371ed09b0a58bf236da0">More...</a><br/></td></tr>
<tr class="separator:ad64a203987c3371ed09b0a58bf236da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba25faf0d3ac4985638294c0b1373ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a4ba25faf0d3ac4985638294c0b1373ad">hasOwner</a> () const </td></tr>
<tr class="memdesc:a4ba25faf0d3ac4985638294c0b1373ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object.  <a href="#a4ba25faf0d3ac4985638294c0b1373ad">More...</a><br/></td></tr>
<tr class="separator:a4ba25faf0d3ac4985638294c0b1373ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a6f21792173936ce3a8da9c7e90ebcd49">str</a> () const</td></tr>
<tr class="memdesc:a6f21792173936ce3a8da9c7e90ebcd49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object.  <a href="#a6f21792173936ce3a8da9c7e90ebcd49">More...</a><br/></td></tr>
<tr class="separator:a6f21792173936ce3a8da9c7e90ebcd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#ae2c47d0d1d510c3b5aa5384ae31e2258">utf8</a> () const</td></tr>
<tr class="memdesc:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a short text representation of this object using unicode characters.  <a href="#ae2c47d0d1d510c3b5aa5384ae31e2258">More...</a><br/></td></tr>
<tr class="separator:ae2c47d0d1d510c3b5aa5384ae31e2258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32299f4324901625192bff989009f8ad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#a32299f4324901625192bff989009f8ad">detail</a> () const</td></tr>
<tr class="memdesc:a32299f4324901625192bff989009f8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a detailed text representation of this object.  <a href="#a32299f4324901625192bff989009f8ad">More...</a><br/></td></tr>
<tr class="separator:a32299f4324901625192bff989009f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0ab182c97fe654b8929d1fe41dc564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#aea0ab182c97fe654b8929d1fe41dc564">toString</a> () const</td></tr>
<tr class="memdesc:aea0ab182c97fe654b8929d1fe41dc564"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for str().  <a href="#aea0ab182c97fe654b8929d1fe41dc564">More...</a><br/></td></tr>
<tr class="separator:aea0ab182c97fe654b8929d1fe41dc564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32f5abced4d1365c34980741b564765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structregina_1_1Output.html#af32f5abced4d1365c34980741b564765">toStringLong</a> () const</td></tr>
<tr class="memdesc:af32f5abced4d1365c34980741b564765"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated alias for detail().  <a href="#af32f5abced4d1365c34980741b564765">More...</a><br/></td></tr>
<tr class="separator:af32f5abced4d1365c34980741b564765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Identification</div></td></tr>
<tr class="memitem:ad28b0f0a68dced31285645498ccb7c72"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ad28b0f0a68dced31285645498ccb7c72">type</a> () const =0</td></tr>
<tr class="memdesc:ad28b0f0a68dced31285645498ccb7c72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet.  <a href="#ad28b0f0a68dced31285645498ccb7c72">More...</a><br/></td></tr>
<tr class="separator:ad28b0f0a68dced31285645498ccb7c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524301515201a2d8b9d70f89c13c2d97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a524301515201a2d8b9d70f89c13c2d97">getPacketType</a> () const </td></tr>
<tr class="memdesc:a524301515201a2d8b9d70f89c13c2d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the unique integer ID representing this type of packet.  <a href="#a524301515201a2d8b9d70f89c13c2d97">More...</a><br/></td></tr>
<tr class="separator:a524301515201a2d8b9d70f89c13c2d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee185d31ded84f3e7246023fede9326"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a3ee185d31ded84f3e7246023fede9326">typeName</a> () const =0</td></tr>
<tr class="memdesc:a3ee185d31ded84f3e7246023fede9326"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet.  <a href="#a3ee185d31ded84f3e7246023fede9326">More...</a><br/></td></tr>
<tr class="separator:a3ee185d31ded84f3e7246023fede9326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcdbf61ec4119c7b3eb6225c55289c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a0bcdbf61ec4119c7b3eb6225c55289c0">getPacketTypeName</a> () const </td></tr>
<tr class="memdesc:a0bcdbf61ec4119c7b3eb6225c55289c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns an English name for this type of packet.  <a href="#a0bcdbf61ec4119c7b3eb6225c55289c0">More...</a><br/></td></tr>
<tr class="separator:a0bcdbf61ec4119c7b3eb6225c55289c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6812ba7b54606e23958b99504d70f75"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ad6812ba7b54606e23958b99504d70f75">label</a> () const </td></tr>
<tr class="memdesc:ad6812ba7b54606e23958b99504d70f75"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet.  <a href="#ad6812ba7b54606e23958b99504d70f75">More...</a><br/></td></tr>
<tr class="separator:ad6812ba7b54606e23958b99504d70f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20d0067e661345706c28fe0a1aea7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ae20d0067e661345706c28fe0a1aea7c7">getPacketLabel</a> () const </td></tr>
<tr class="memdesc:ae20d0067e661345706c28fe0a1aea7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the label associated with this individual packet.  <a href="#ae20d0067e661345706c28fe0a1aea7c7">More...</a><br/></td></tr>
<tr class="separator:ae20d0067e661345706c28fe0a1aea7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92807c5524cc215180d0ccf2ee35d5e4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a92807c5524cc215180d0ccf2ee35d5e4">humanLabel</a> () const </td></tr>
<tr class="memdesc:a92807c5524cc215180d0ccf2ee35d5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="#a92807c5524cc215180d0ccf2ee35d5e4">More...</a><br/></td></tr>
<tr class="separator:a92807c5524cc215180d0ccf2ee35d5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db06ba0ae66e7e8212a54bbf6edc31b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a1db06ba0ae66e7e8212a54bbf6edc31b">getHumanLabel</a> () const </td></tr>
<tr class="memdesc:a1db06ba0ae66e7e8212a54bbf6edc31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the label associated with this individual packet, adjusted if necessary for human-readable output.  <a href="#a1db06ba0ae66e7e8212a54bbf6edc31b">More...</a><br/></td></tr>
<tr class="separator:a1db06ba0ae66e7e8212a54bbf6edc31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4917da7d951cab95f76a758d1e136a3a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a4917da7d951cab95f76a758d1e136a3a">adornedLabel</a> (const std::string &amp;adornment) const </td></tr>
<tr class="memdesc:a4917da7d951cab95f76a758d1e136a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string.  <a href="#a4917da7d951cab95f76a758d1e136a3a">More...</a><br/></td></tr>
<tr class="separator:a4917da7d951cab95f76a758d1e136a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18670dfbd03cabf3404a580f740c7307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a18670dfbd03cabf3404a580f740c7307">setLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad6812ba7b54606e23958b99504d70f75">label</a>)</td></tr>
<tr class="memdesc:a18670dfbd03cabf3404a580f740c7307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the label associated with this individual packet.  <a href="#a18670dfbd03cabf3404a580f740c7307">More...</a><br/></td></tr>
<tr class="separator:a18670dfbd03cabf3404a580f740c7307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba7fe518f9651b8071c9f6755f41616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a0ba7fe518f9651b8071c9f6755f41616">setPacketLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad6812ba7b54606e23958b99504d70f75">label</a>)</td></tr>
<tr class="memdesc:a0ba7fe518f9651b8071c9f6755f41616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that sets the label associated with this individual packet.  <a href="#a0ba7fe518f9651b8071c9f6755f41616">More...</a><br/></td></tr>
<tr class="separator:a0ba7fe518f9651b8071c9f6755f41616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a96607c37a9a5979419577dbfc2e427"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a1a96607c37a9a5979419577dbfc2e427">fullName</a> () const </td></tr>
<tr class="memdesc:a1a96607c37a9a5979419577dbfc2e427"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet.  <a href="#a1a96607c37a9a5979419577dbfc2e427">More...</a><br/></td></tr>
<tr class="separator:a1a96607c37a9a5979419577dbfc2e427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c667fb13f6f6e899925f415deae5b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ab2c667fb13f6f6e899925f415deae5b4">getFullName</a> () const </td></tr>
<tr class="memdesc:ab2c667fb13f6f6e899925f415deae5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns a descriptive text string for the packet.  <a href="#ab2c667fb13f6f6e899925f415deae5b4">More...</a><br/></td></tr>
<tr class="separator:ab2c667fb13f6f6e899925f415deae5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2254e0d113513f54bce1f56a4c6823"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a5b2254e0d113513f54bce1f56a4c6823">makeUniqueLabel</a> (const std::string &amp;base) const </td></tr>
<tr class="memdesc:a5b2254e0d113513f54bce1f56a4c6823"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new label that cannot be found anywhere in the entire tree structure.  <a href="#a5b2254e0d113513f54bce1f56a4c6823">More...</a><br/></td></tr>
<tr class="separator:a5b2254e0d113513f54bce1f56a4c6823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedd6802aad09426e8dbc7d7f4534b45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aaedd6802aad09426e8dbc7d7f4534b45">makeUniqueLabels</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *reference)</td></tr>
<tr class="memdesc:aaedd6802aad09426e8dbc7d7f4534b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that all packet labels in both this and the given packet tree combined are distinct.  <a href="#aaedd6802aad09426e8dbc7d7f4534b45">More...</a><br/></td></tr>
<tr class="separator:aaedd6802aad09426e8dbc7d7f4534b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tags</div></td></tr>
<tr class="memitem:a3ce882d31d89c0e24145250f7f62c7dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a3ce882d31d89c0e24145250f7f62c7dc">hasTag</a> (const std::string &amp;tag) const </td></tr>
<tr class="memdesc:a3ce882d31d89c0e24145250f7f62c7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has the given associated tag.  <a href="#a3ce882d31d89c0e24145250f7f62c7dc">More...</a><br/></td></tr>
<tr class="separator:a3ce882d31d89c0e24145250f7f62c7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcb3f3580be7b65a85b072d0ea51fa2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a3bcb3f3580be7b65a85b072d0ea51fa2">hasTags</a> () const </td></tr>
<tr class="memdesc:a3bcb3f3580be7b65a85b072d0ea51fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet has any associated tags at all.  <a href="#a3bcb3f3580be7b65a85b072d0ea51fa2">More...</a><br/></td></tr>
<tr class="separator:a3bcb3f3580be7b65a85b072d0ea51fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0cb585d2797781e9046a0b7363037e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a5e0cb585d2797781e9046a0b7363037e">addTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a5e0cb585d2797781e9046a0b7363037e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associates the given tag with this packet.  <a href="#a5e0cb585d2797781e9046a0b7363037e">More...</a><br/></td></tr>
<tr class="separator:a5e0cb585d2797781e9046a0b7363037e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf11fa9bb6d364deb8d18f1eba9733d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aaf11fa9bb6d364deb8d18f1eba9733d4">removeTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:aaf11fa9bb6d364deb8d18f1eba9733d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the association of the given tag with this packet.  <a href="#aaf11fa9bb6d364deb8d18f1eba9733d4">More...</a><br/></td></tr>
<tr class="separator:aaf11fa9bb6d364deb8d18f1eba9733d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7901227fe61ee9c38f5711ae71bed75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#af7901227fe61ee9c38f5711ae71bed75">removeAllTags</a> ()</td></tr>
<tr class="memdesc:af7901227fe61ee9c38f5711ae71bed75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all associated tags from this packet.  <a href="#af7901227fe61ee9c38f5711ae71bed75">More...</a><br/></td></tr>
<tr class="separator:af7901227fe61ee9c38f5711ae71bed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54ddd1b295d93159fd7f370d5edff5d"><td class="memItemLeft" align="right" valign="top">const std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ae54ddd1b295d93159fd7f370d5edff5d">tags</a> () const </td></tr>
<tr class="memdesc:ae54ddd1b295d93159fd7f370d5edff5d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet.  <a href="#ae54ddd1b295d93159fd7f370d5edff5d">More...</a><br/></td></tr>
<tr class="separator:ae54ddd1b295d93159fd7f370d5edff5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc6a7ec715a14ce0f2411ba91b98b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> const <br class="typebreak"/>
std::set&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aabc6a7ec715a14ce0f2411ba91b98b66">getTags</a> () const </td></tr>
<tr class="memdesc:aabc6a7ec715a14ce0f2411ba91b98b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the set of all tags associated with this packet.  <a href="#aabc6a7ec715a14ce0f2411ba91b98b66">More...</a><br/></td></tr>
<tr class="separator:aabc6a7ec715a14ce0f2411ba91b98b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Event Handling</div></td></tr>
<tr class="memitem:abbb59f7b470a87e0cacb9cfe3baeebe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#abbb59f7b470a87e0cacb9cfe3baeebe4">listen</a> (<a class="el" href="classregina_1_1NPacketListener.html">NPacketListener</a> *listener)</td></tr>
<tr class="memdesc:abbb59f7b470a87e0cacb9cfe3baeebe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers the given packet listener to listen for events on this packet.  <a href="#abbb59f7b470a87e0cacb9cfe3baeebe4">More...</a><br/></td></tr>
<tr class="separator:abbb59f7b470a87e0cacb9cfe3baeebe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5002bc9d655d3290a5db551f1cc3d09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ad5002bc9d655d3290a5db551f1cc3d09">isListening</a> (<a class="el" href="classregina_1_1NPacketListener.html">NPacketListener</a> *listener)</td></tr>
<tr class="memdesc:ad5002bc9d655d3290a5db551f1cc3d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given packet listener is currently listening for events on this packet.  <a href="#ad5002bc9d655d3290a5db551f1cc3d09">More...</a><br/></td></tr>
<tr class="separator:ad5002bc9d655d3290a5db551f1cc3d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cf0e995a7e1afcdd94288e83c410d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ad2cf0e995a7e1afcdd94288e83c410d5">unlisten</a> (<a class="el" href="classregina_1_1NPacketListener.html">NPacketListener</a> *listener)</td></tr>
<tr class="memdesc:ad2cf0e995a7e1afcdd94288e83c410d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters the given packet listener so that it no longer listens for events on this packet.  <a href="#ad2cf0e995a7e1afcdd94288e83c410d5">More...</a><br/></td></tr>
<tr class="separator:ad2cf0e995a7e1afcdd94288e83c410d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Queries</div></td></tr>
<tr class="memitem:a856e7edef86f7dbd99470b01f632890f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a856e7edef86f7dbd99470b01f632890f">parent</a> () const </td></tr>
<tr class="memdesc:a856e7edef86f7dbd99470b01f632890f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the parent packet in the tree structure.  <a href="#a856e7edef86f7dbd99470b01f632890f">More...</a><br/></td></tr>
<tr class="separator:a856e7edef86f7dbd99470b01f632890f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5946d58d66677fb690f1288c0fb1e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a2e5946d58d66677fb690f1288c0fb1e0">getTreeParent</a> () const </td></tr>
<tr class="memdesc:a2e5946d58d66677fb690f1288c0fb1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines the parent packet in the tree structure.  <a href="#a2e5946d58d66677fb690f1288c0fb1e0">More...</a><br/></td></tr>
<tr class="separator:a2e5946d58d66677fb690f1288c0fb1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a96877b914831a3eddd13c599aac8e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a7a96877b914831a3eddd13c599aac8e9">firstChild</a> () const </td></tr>
<tr class="memdesc:a7a96877b914831a3eddd13c599aac8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first child of this packet in the tree structure.  <a href="#a7a96877b914831a3eddd13c599aac8e9">More...</a><br/></td></tr>
<tr class="separator:a7a96877b914831a3eddd13c599aac8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fbb3bad5370af279c2c25cd7a9f9ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a61fbb3bad5370af279c2c25cd7a9f9ce">getFirstTreeChild</a> () const </td></tr>
<tr class="memdesc:a61fbb3bad5370af279c2c25cd7a9f9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines the first child of this packet in the tree structure.  <a href="#a61fbb3bad5370af279c2c25cd7a9f9ce">More...</a><br/></td></tr>
<tr class="separator:a61fbb3bad5370af279c2c25cd7a9f9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771df6092ae6b9f10f16da825ce86c1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a771df6092ae6b9f10f16da825ce86c1e">lastChild</a> () const </td></tr>
<tr class="memdesc:a771df6092ae6b9f10f16da825ce86c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the last child of this packet in the tree structure.  <a href="#a771df6092ae6b9f10f16da825ce86c1e">More...</a><br/></td></tr>
<tr class="separator:a771df6092ae6b9f10f16da825ce86c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e63dd84107d122fb73b7507418d32e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a2e63dd84107d122fb73b7507418d32e5">getLastTreeChild</a> () const </td></tr>
<tr class="memdesc:a2e63dd84107d122fb73b7507418d32e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines the last child of this packet in the tree structure.  <a href="#a2e63dd84107d122fb73b7507418d32e5">More...</a><br/></td></tr>
<tr class="separator:a2e63dd84107d122fb73b7507418d32e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab35c406432a69d7d3e7a72f9309605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aaab35c406432a69d7d3e7a72f9309605">nextSibling</a> () const </td></tr>
<tr class="memdesc:aaab35c406432a69d7d3e7a72f9309605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next sibling of this packet in the tree structure.  <a href="#aaab35c406432a69d7d3e7a72f9309605">More...</a><br/></td></tr>
<tr class="separator:aaab35c406432a69d7d3e7a72f9309605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dfaeeafb4dde526b242edf85c3d639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a86dfaeeafb4dde526b242edf85c3d639">getNextTreeSibling</a> () const </td></tr>
<tr class="memdesc:a86dfaeeafb4dde526b242edf85c3d639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines the next sibling of this packet in the tree structure.  <a href="#a86dfaeeafb4dde526b242edf85c3d639">More...</a><br/></td></tr>
<tr class="separator:a86dfaeeafb4dde526b242edf85c3d639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964ca5a391da9ba97a28bf8ce09169fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a964ca5a391da9ba97a28bf8ce09169fd">prevSibling</a> () const </td></tr>
<tr class="memdesc:a964ca5a391da9ba97a28bf8ce09169fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the previous sibling of this packet in the tree structure.  <a href="#a964ca5a391da9ba97a28bf8ce09169fd">More...</a><br/></td></tr>
<tr class="separator:a964ca5a391da9ba97a28bf8ce09169fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992abb90683f101e998d21649293097c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a992abb90683f101e998d21649293097c">getPrevTreeSibling</a> () const </td></tr>
<tr class="memdesc:a992abb90683f101e998d21649293097c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines the previous sibling of this packet in the tree structure.  <a href="#a992abb90683f101e998d21649293097c">More...</a><br/></td></tr>
<tr class="separator:a992abb90683f101e998d21649293097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15190121c229f76772486137851f2df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ae15190121c229f76772486137851f2df">root</a> () const </td></tr>
<tr class="memdesc:ae15190121c229f76772486137851f2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the root of the tree to which this packet belongs.  <a href="#ae15190121c229f76772486137851f2df">More...</a><br/></td></tr>
<tr class="separator:ae15190121c229f76772486137851f2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3d69c4dc206299fc04d4679ebd44b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a9b3d69c4dc206299fc04d4679ebd44b2">getTreeMatriarch</a> () const </td></tr>
<tr class="memdesc:a9b3d69c4dc206299fc04d4679ebd44b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that determines the root of the tree to which this packet belongs.  <a href="#a9b3d69c4dc206299fc04d4679ebd44b2">More...</a><br/></td></tr>
<tr class="separator:a9b3d69c4dc206299fc04d4679ebd44b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59dfe7ee56c3161d74ede4bc372ff9a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aa59dfe7ee56c3161d74ede4bc372ff9a">levelsDownTo</a> (const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *descendant) const </td></tr>
<tr class="memdesc:aa59dfe7ee56c3161d74ede4bc372ff9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given descendant in the tree structure.  <a href="#aa59dfe7ee56c3161d74ede4bc372ff9a">More...</a><br/></td></tr>
<tr class="separator:aa59dfe7ee56c3161d74ede4bc372ff9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5d15832e3d2dd7c926e23012fd273e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a8f5d15832e3d2dd7c926e23012fd273e">levelsUpTo</a> (const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *ancestor) const </td></tr>
<tr class="memdesc:a8f5d15832e3d2dd7c926e23012fd273e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of levels between this packet and its given ancestor in the tree structure.  <a href="#a8f5d15832e3d2dd7c926e23012fd273e">More...</a><br/></td></tr>
<tr class="separator:a8f5d15832e3d2dd7c926e23012fd273e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76110767102577c503a4c51216da9f2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a76110767102577c503a4c51216da9f2b">isGrandparentOf</a> (const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *descendant) const </td></tr>
<tr class="memdesc:a76110767102577c503a4c51216da9f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this packet is equal to or an ancestor of the given packet in the tree structure.  <a href="#a76110767102577c503a4c51216da9f2b">More...</a><br/></td></tr>
<tr class="separator:a76110767102577c503a4c51216da9f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6339c4befbc2d0af0afbde58a647e3d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ad6339c4befbc2d0af0afbde58a647e3d">countChildren</a> () const </td></tr>
<tr class="memdesc:ad6339c4befbc2d0af0afbde58a647e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet.  <a href="#ad6339c4befbc2d0af0afbde58a647e3d">More...</a><br/></td></tr>
<tr class="separator:ad6339c4befbc2d0af0afbde58a647e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1542ecdb7e1839352d7590f227960532"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a1542ecdb7e1839352d7590f227960532">getNumberOfChildren</a> () const </td></tr>
<tr class="memdesc:a1542ecdb7e1839352d7590f227960532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the number of immediate children of this packet.  <a href="#a1542ecdb7e1839352d7590f227960532">More...</a><br/></td></tr>
<tr class="separator:a1542ecdb7e1839352d7590f227960532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa644bb246d322bd7dac4f4d2cf724e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#afa644bb246d322bd7dac4f4d2cf724e2">countDescendants</a> () const </td></tr>
<tr class="memdesc:afa644bb246d322bd7dac4f4d2cf724e2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of descendants of this packet.  <a href="#afa644bb246d322bd7dac4f4d2cf724e2">More...</a><br/></td></tr>
<tr class="separator:afa644bb246d322bd7dac4f4d2cf724e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7599793aa002286457bf189eac7d86f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ae7599793aa002286457bf189eac7d86f">getNumberOfDescendants</a> () const </td></tr>
<tr class="memdesc:ae7599793aa002286457bf189eac7d86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the total number of descendants of this packet.  <a href="#ae7599793aa002286457bf189eac7d86f">More...</a><br/></td></tr>
<tr class="separator:ae7599793aa002286457bf189eac7d86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb680541a4021ebdf7877c3f31c6fda"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a6eb680541a4021ebdf7877c3f31c6fda">totalTreeSize</a> () const </td></tr>
<tr class="memdesc:a6eb680541a4021ebdf7877c3f31c6fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="#a6eb680541a4021ebdf7877c3f31c6fda">More...</a><br/></td></tr>
<tr class="separator:a6eb680541a4021ebdf7877c3f31c6fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2edae1d3931f5f8f42d7f5799032b9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#af2edae1d3931f5f8f42d7f5799032b9f">getTotalTreeSize</a> () const </td></tr>
<tr class="memdesc:af2edae1d3931f5f8f42d7f5799032b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated routine that returns the total number of packets in the tree or subtree for which this packet is matriarch.  <a href="#af2edae1d3931f5f8f42d7f5799032b9f">More...</a><br/></td></tr>
<tr class="separator:af2edae1d3931f5f8f42d7f5799032b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Manipulation</div></td></tr>
<tr class="memitem:a277d303fc31e81df03e809bb46249ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a277d303fc31e81df03e809bb46249ae4">insertChildFirst</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child)</td></tr>
<tr class="memdesc:a277d303fc31e81df03e809bb46249ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the first child of this packet.  <a href="#a277d303fc31e81df03e809bb46249ae4">More...</a><br/></td></tr>
<tr class="separator:a277d303fc31e81df03e809bb46249ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ff2c517431624443b47b542f319a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a65ff2c517431624443b47b542f319a97">insertChildLast</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child)</td></tr>
<tr class="memdesc:a65ff2c517431624443b47b542f319a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as the last child of this packet.  <a href="#a65ff2c517431624443b47b542f319a97">More...</a><br/></td></tr>
<tr class="separator:a65ff2c517431624443b47b542f319a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9091622a408e6497e407898197870b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#acd9091622a408e6497e407898197870b">insertChildAfter</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *newChild, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *prevChild)</td></tr>
<tr class="memdesc:acd9091622a408e6497e407898197870b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the given packet as a child of this packet at the given location in this packet's child list.  <a href="#acd9091622a408e6497e407898197870b">More...</a><br/></td></tr>
<tr class="separator:acd9091622a408e6497e407898197870b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdd6fcc326b3ee2e322d8efb229a933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a6bdd6fcc326b3ee2e322d8efb229a933">makeOrphan</a> ()</td></tr>
<tr class="memdesc:a6bdd6fcc326b3ee2e322d8efb229a933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree.  <a href="#a6bdd6fcc326b3ee2e322d8efb229a933">More...</a><br/></td></tr>
<tr class="separator:a6bdd6fcc326b3ee2e322d8efb229a933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac194ef0daec9167e940e508cc821fec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ac194ef0daec9167e940e508cc821fec3">reparent</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *newParent, bool first=false)</td></tr>
<tr class="memdesc:ac194ef0daec9167e940e508cc821fec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead.  <a href="#ac194ef0daec9167e940e508cc821fec3">More...</a><br/></td></tr>
<tr class="separator:ac194ef0daec9167e940e508cc821fec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e217abe1bb4c24efba56980b687103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ad7e217abe1bb4c24efba56980b687103">transferChildren</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *newParent)</td></tr>
<tr class="memdesc:ad7e217abe1bb4c24efba56980b687103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead.  <a href="#ad7e217abe1bb4c24efba56980b687103">More...</a><br/></td></tr>
<tr class="separator:ad7e217abe1bb4c24efba56980b687103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8f44cda2066838aaeae36d1128870d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a8b8f44cda2066838aaeae36d1128870d">swapWithNextSibling</a> ()</td></tr>
<tr class="memdesc:a8b8f44cda2066838aaeae36d1128870d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps this packet with its next sibling in the sequence of children beneath their common parent packet.  <a href="#a8b8f44cda2066838aaeae36d1128870d">More...</a><br/></td></tr>
<tr class="separator:a8b8f44cda2066838aaeae36d1128870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac4f9b12b0e61f360208f976d6d763d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a9ac4f9b12b0e61f360208f976d6d763d">moveUp</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:a9ac4f9b12b0e61f360208f976d6d763d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the beginning of its sibling list.  <a href="#a9ac4f9b12b0e61f360208f976d6d763d">More...</a><br/></td></tr>
<tr class="separator:a9ac4f9b12b0e61f360208f976d6d763d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e07adb86d0338f6f8627481d9693783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a3e07adb86d0338f6f8627481d9693783">moveDown</a> (unsigned steps=1)</td></tr>
<tr class="memdesc:a3e07adb86d0338f6f8627481d9693783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet the given number of steps towards the end of its sibling list.  <a href="#a3e07adb86d0338f6f8627481d9693783">More...</a><br/></td></tr>
<tr class="separator:a3e07adb86d0338f6f8627481d9693783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8dfd5040948775414d47cc33bd9b0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aac8dfd5040948775414d47cc33bd9b0c">moveToFirst</a> ()</td></tr>
<tr class="memdesc:aac8dfd5040948775414d47cc33bd9b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the first in its sibling list.  <a href="#aac8dfd5040948775414d47cc33bd9b0c">More...</a><br/></td></tr>
<tr class="separator:aac8dfd5040948775414d47cc33bd9b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9986615a783903c5b96aa00302d4b9fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a9986615a783903c5b96aa00302d4b9fd">moveToLast</a> ()</td></tr>
<tr class="memdesc:a9986615a783903c5b96aa00302d4b9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves this packet to be the last in its sibling list.  <a href="#a9986615a783903c5b96aa00302d4b9fd">More...</a><br/></td></tr>
<tr class="separator:a9986615a783903c5b96aa00302d4b9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c48b6ee979b5ac3add40d4ed3e9ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ab6c48b6ee979b5ac3add40d4ed3e9ec9">sortChildren</a> ()</td></tr>
<tr class="memdesc:ab6c48b6ee979b5ac3add40d4ed3e9ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the immediate children of this packet according to their packet labels.  <a href="#ab6c48b6ee979b5ac3add40d4ed3e9ec9">More...</a><br/></td></tr>
<tr class="separator:ab6c48b6ee979b5ac3add40d4ed3e9ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Searching and Iterating</div></td></tr>
<tr class="memitem:a64a119d2fe5ba78443b60bae54b5f24b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a64a119d2fe5ba78443b60bae54b5f24b">nextTreePacket</a> ()</td></tr>
<tr class="memdesc:a64a119d2fe5ba78443b60bae54b5f24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="#a64a119d2fe5ba78443b60bae54b5f24b">More...</a><br/></td></tr>
<tr class="separator:a64a119d2fe5ba78443b60bae54b5f24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b1427eef08ea4baedd39e6601a9e72"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a28b1427eef08ea4baedd39e6601a9e72">nextTreePacket</a> () const </td></tr>
<tr class="memdesc:a28b1427eef08ea4baedd39e6601a9e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs.  <a href="#a28b1427eef08ea4baedd39e6601a9e72">More...</a><br/></td></tr>
<tr class="separator:a28b1427eef08ea4baedd39e6601a9e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0aec78b65154d490bef565f10f9ffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a5a0aec78b65154d490bef565f10f9ffe">nextTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad28b0f0a68dced31285645498ccb7c72">type</a>)</td></tr>
<tr class="memdesc:a5a0aec78b65154d490bef565f10f9ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="#a5a0aec78b65154d490bef565f10f9ffe">More...</a><br/></td></tr>
<tr class="separator:a5a0aec78b65154d490bef565f10f9ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529d18cddcfd9d3596f24d084bb6c179"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a529d18cddcfd9d3596f24d084bb6c179">nextTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad28b0f0a68dced31285645498ccb7c72">type</a>) const </td></tr>
<tr class="memdesc:a529d18cddcfd9d3596f24d084bb6c179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure.  <a href="#a529d18cddcfd9d3596f24d084bb6c179">More...</a><br/></td></tr>
<tr class="separator:a529d18cddcfd9d3596f24d084bb6c179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6022063291c8044eef5758d976b4e7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ac6022063291c8044eef5758d976b4e7e">firstTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad28b0f0a68dced31285645498ccb7c72">type</a>)</td></tr>
<tr class="memdesc:ac6022063291c8044eef5758d976b4e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="#ac6022063291c8044eef5758d976b4e7e">More...</a><br/></td></tr>
<tr class="separator:ac6022063291c8044eef5758d976b4e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010846115ef964b4dc0a04f10b86099c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a010846115ef964b4dc0a04f10b86099c">firstTreePacket</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad28b0f0a68dced31285645498ccb7c72">type</a>) const </td></tr>
<tr class="memdesc:a010846115ef964b4dc0a04f10b86099c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the first packet of the requested type in a complete depth-first iteration of the tree structure.  <a href="#a010846115ef964b4dc0a04f10b86099c">More...</a><br/></td></tr>
<tr class="separator:a010846115ef964b4dc0a04f10b86099c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee7d9515989d0cae606417e0dc7977b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aeee7d9515989d0cae606417e0dc7977b">findPacketLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad6812ba7b54606e23958b99504d70f75">label</a>)</td></tr>
<tr class="memdesc:aeee7d9515989d0cae606417e0dc7977b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="#aeee7d9515989d0cae606417e0dc7977b">More...</a><br/></td></tr>
<tr class="separator:aeee7d9515989d0cae606417e0dc7977b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739735e7e14210bfe6bfae73462b61d8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a739735e7e14210bfe6bfae73462b61d8">findPacketLabel</a> (const std::string &amp;<a class="el" href="classregina_1_1NPacket.html#ad6812ba7b54606e23958b99504d70f75">label</a>) const </td></tr>
<tr class="memdesc:a739735e7e14210bfe6bfae73462b61d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the packet with the requested label in the tree or subtree for which this packet is matriarch.  <a href="#a739735e7e14210bfe6bfae73462b61d8">More...</a><br/></td></tr>
<tr class="separator:a739735e7e14210bfe6bfae73462b61d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Dependencies</div></td></tr>
<tr class="memitem:a57ed80a20a1f787078cb49fe578e219b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a57ed80a20a1f787078cb49fe578e219b">isPacketEditable</a> () const </td></tr>
<tr class="memdesc:a57ed80a20a1f787078cb49fe578e219b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children.  <a href="#a57ed80a20a1f787078cb49fe578e219b">More...</a><br/></td></tr>
<tr class="separator:a57ed80a20a1f787078cb49fe578e219b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cloning</div></td></tr>
<tr class="memitem:aa5710fe602185e8373137fa4cd384497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aa5710fe602185e8373137fa4cd384497">clone</a> (bool cloneDescendants=false, bool end=true) const </td></tr>
<tr class="memdesc:aa5710fe602185e8373137fa4cd384497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet.  <a href="#aa5710fe602185e8373137fa4cd384497">More...</a><br/></td></tr>
<tr class="separator:aa5710fe602185e8373137fa4cd384497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File I/O</div></td></tr>
<tr class="memitem:aa174541f04c1fcb251134e22f20010ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#aa174541f04c1fcb251134e22f20010ab">save</a> (const char *filename, bool compressed=true) const </td></tr>
<tr class="memdesc:aa174541f04c1fcb251134e22f20010ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format.  <a href="#aa174541f04c1fcb251134e22f20010ab">More...</a><br/></td></tr>
<tr class="separator:aa174541f04c1fcb251134e22f20010ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f48894741c5c4ed5e1ddc20a922589d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a8f48894741c5c4ed5e1ddc20a922589d">save</a> (std::ostream &amp;s, bool compressed=true) const </td></tr>
<tr class="memdesc:a8f48894741c5c4ed5e1ddc20a922589d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file.  <a href="#a8f48894741c5c4ed5e1ddc20a922589d">More...</a><br/></td></tr>
<tr class="separator:a8f48894741c5c4ed5e1ddc20a922589d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9becec8fc636e6729caddf7dd8cb9393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a9becec8fc636e6729caddf7dd8cb9393">writeXMLFile</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a9becec8fc636e6729caddf7dd8cb9393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format.  <a href="#a9becec8fc636e6729caddf7dd8cb9393">More...</a><br/></td></tr>
<tr class="separator:a9becec8fc636e6729caddf7dd8cb9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4610a242eaa65affcbf6d36fadae4469"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a4610a242eaa65affcbf6d36fadae4469">internalID</a> () const </td></tr>
<tr class="memdesc:a4610a242eaa65affcbf6d36fadae4469"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet.  <a href="#a4610a242eaa65affcbf6d36fadae4469">More...</a><br/></td></tr>
<tr class="separator:a4610a242eaa65affcbf6d36fadae4469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packet Listener Interface</div></td></tr>
<tr class="memitem:abe86b7cab396f34fd62351f8fd300868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#abe86b7cab396f34fd62351f8fd300868">unregisterFromAllPackets</a> ()</td></tr>
<tr class="memdesc:abe86b7cab396f34fd62351f8fd300868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters this listener from any packets to which it is currently listening.  <a href="#abe86b7cab396f34fd62351f8fd300868">More...</a><br/></td></tr>
<tr class="separator:abe86b7cab396f34fd62351f8fd300868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708c4e6c2d763c24ca4b2d3f88fcf07f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a708c4e6c2d763c24ca4b2d3f88fcf07f">packetToBeChanged</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:a708c4e6c2d763c24ca4b2d3f88fcf07f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the contents of the packet are to be changed.  <a href="#a708c4e6c2d763c24ca4b2d3f88fcf07f">More...</a><br/></td></tr>
<tr class="separator:a708c4e6c2d763c24ca4b2d3f88fcf07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d9467da604c2bb0597aea1919893db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#af3d9467da604c2bb0597aea1919893db">packetWasChanged</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:af3d9467da604c2bb0597aea1919893db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the contents of the packet have been changed.  <a href="#af3d9467da604c2bb0597aea1919893db">More...</a><br/></td></tr>
<tr class="separator:af3d9467da604c2bb0597aea1919893db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960599d63ebd88e2832a5cf24d6870e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a960599d63ebd88e2832a5cf24d6870e2">packetToBeRenamed</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:a960599d63ebd88e2832a5cf24d6870e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the packet label or tags are to be changed.  <a href="#a960599d63ebd88e2832a5cf24d6870e2">More...</a><br/></td></tr>
<tr class="separator:a960599d63ebd88e2832a5cf24d6870e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89183b3ae551965e76283e778e50ffb9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a89183b3ae551965e76283e778e50ffb9">childToBeAdded</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child)</td></tr>
<tr class="memdesc:a89183b3ae551965e76283e778e50ffb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be inserted directly beneath the packet.  <a href="#a89183b3ae551965e76283e778e50ffb9">More...</a><br/></td></tr>
<tr class="separator:a89183b3ae551965e76283e778e50ffb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ebb1a70eaa6c480384e7279f05be7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a141ebb1a70eaa6c480384e7279f05be7">childWasAdded</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child)</td></tr>
<tr class="memdesc:a141ebb1a70eaa6c480384e7279f05be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been inserted directly beneath the packet.  <a href="#a141ebb1a70eaa6c480384e7279f05be7">More...</a><br/></td></tr>
<tr class="separator:a141ebb1a70eaa6c480384e7279f05be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52776d58f609476ba7edf815b655c66f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a52776d58f609476ba7edf815b655c66f">childToBeRemoved</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child, bool inParentDestructor)</td></tr>
<tr class="memdesc:a52776d58f609476ba7edf815b655c66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before a child packet is to be removed from directly beneath the packet.  <a href="#a52776d58f609476ba7edf815b655c66f">More...</a><br/></td></tr>
<tr class="separator:a52776d58f609476ba7edf815b655c66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1041557579bc597bffa71f439a3715d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#af1041557579bc597bffa71f439a3715d">childWasRemoved</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child, bool inParentDestructor)</td></tr>
<tr class="memdesc:af1041557579bc597bffa71f439a3715d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after a child packet has been removed from directly beneath the packet.  <a href="#af1041557579bc597bffa71f439a3715d">More...</a><br/></td></tr>
<tr class="separator:af1041557579bc597bffa71f439a3715d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9d1dbbbf461a83ed5462ca8ccbf3d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a7c9d1dbbbf461a83ed5462ca8ccbf3d3">childrenToBeReordered</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:a7c9d1dbbbf461a83ed5462ca8ccbf3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before the child packets directly beneath the packet are to be reordered.  <a href="#a7c9d1dbbbf461a83ed5462ca8ccbf3d3">More...</a><br/></td></tr>
<tr class="separator:a7c9d1dbbbf461a83ed5462ca8ccbf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa1208d006f04ed5af5b66e8071ce52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a6aa1208d006f04ed5af5b66e8071ce52">childrenWereReordered</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet)</td></tr>
<tr class="memdesc:a6aa1208d006f04ed5af5b66e8071ce52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after the child packets directly beneath the packet have been reordered.  <a href="#a6aa1208d006f04ed5af5b66e8071ce52">More...</a><br/></td></tr>
<tr class="separator:a6aa1208d006f04ed5af5b66e8071ce52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eda2c859b77584a42a27dc2d78f757"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#a53eda2c859b77584a42a27dc2d78f757">childToBeRenamed</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child)</td></tr>
<tr class="memdesc:a53eda2c859b77584a42a27dc2d78f757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before one of this packet's immediate children has its label or tags changed.  <a href="#a53eda2c859b77584a42a27dc2d78f757">More...</a><br/></td></tr>
<tr class="separator:a53eda2c859b77584a42a27dc2d78f757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0257f935e799ef8d31e5a78125b6b56"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacketListener.html#aa0257f935e799ef8d31e5a78125b6b56">childWasRenamed</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *packet, <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *child)</td></tr>
<tr class="memdesc:aa0257f935e799ef8d31e5a78125b6b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after one of this packet's immediate children has its label or tags changed.  <a href="#aa0257f935e799ef8d31e5a78125b6b56">More...</a><br/></td></tr>
<tr class="separator:aa0257f935e799ef8d31e5a78125b6b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad8cad8d6a4287c07d7749ee5beea8571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8cad8d6a4287c07d7749ee5beea8571"></a>
static <a class="el" href="classregina_1_1NXMLPacketReader.html">NXMLPacketReader</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>xmlReader</b> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *<a class="el" href="classregina_1_1NPacket.html#a856e7edef86f7dbd99470b01f632890f">parent</a>, <a class="el" href="classregina_1_1NXMLTreeResolver.html">NXMLTreeResolver</a> &amp;resolver)</td></tr>
<tr class="separator:ad8cad8d6a4287c07d7749ee5beea8571"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab5650a99566b9f27183154f96b65f2cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> typedef <br class="typebreak"/>
<a class="el" href="classregina_1_1NPacket_1_1ChangeEventSpan.html">ChangeEventSpan</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#ab5650a99566b9f27183154f96b65f2cb">ChangeEventBlock</a></td></tr>
<tr class="memdesc:ab5650a99566b9f27183154f96b65f2cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deprecated typedef for <a class="el" href="classregina_1_1NPacket_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a>.  <a href="#ab5650a99566b9f27183154f96b65f2cb">More...</a><br/></td></tr>
<tr class="separator:ab5650a99566b9f27183154f96b65f2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a55d6d4b71ba3dbf0c5ab0a5330c04364"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a55d6d4b71ba3dbf0c5ab0a5330c04364">internalClonePacket</a> (<a class="el" href="classregina_1_1NPacket.html">NPacket</a> *<a class="el" href="classregina_1_1NPacket.html#a856e7edef86f7dbd99470b01f632890f">parent</a>) const </td></tr>
<tr class="memdesc:a55d6d4b71ba3dbf0c5ab0a5330c04364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a newly allocated copy of this packet.  <a href="#a55d6d4b71ba3dbf0c5ab0a5330c04364">More...</a><br/></td></tr>
<tr class="separator:a55d6d4b71ba3dbf0c5ab0a5330c04364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e43efc5e7aa3d21ea07bdd722c397d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NScript.html#a5e43efc5e7aa3d21ea07bdd722c397d9">writeXMLPacketData</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a5e43efc5e7aa3d21ea07bdd722c397d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the data for this packet only.  <a href="#a5e43efc5e7aa3d21ea07bdd722c397d9">More...</a><br/></td></tr>
<tr class="separator:a5e43efc5e7aa3d21ea07bdd722c397d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf0a826a791331503e2aaa8566a36f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classregina_1_1NPacket.html#a7bf0a826a791331503e2aaa8566a36f7">writeXMLPacketTree</a> (std::ostream &amp;out) const </td></tr>
<tr class="memdesc:a7bf0a826a791331503e2aaa8566a36f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a chunk of XML containing the subtree with this packet as matriarch.  <a href="#a7bf0a826a791331503e2aaa8566a36f7">More...</a><br/></td></tr>
<tr class="separator:a7bf0a826a791331503e2aaa8566a36f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A packet representing a Python script that can be run. </p>
<p>A script consists of two parts: (i) the <em>text</em>, which contains the Python code; and (ii) a set of <em>variables</em>, which refer to packets in your packet tree. When running a script, the variables should be instantiated in the default namespace before the script is run.</p>
<p>The values of variables are given by pointers to packets (not packet labels, as in some old versions of Regina). This affects how variables react to changes in the packets that they point to. In particular, if a variable <em>V</em> points to some packet <em>P</em>, then:</p>
<ul>
<li>if <em>P</em> is renamed then <em>V</em> will still point to it and the script will notify listeners that the script has changed;</li>
<li>if <em>P</em> is deleted then <em>V</em> will take the value <code>None</code>, and the script will likewise notify listeners of the change. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a2e4bacf91fc79a12ae3a02f4339ed034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classregina_1_1NPacket.html">NPacket</a>  <a class="el" href="classregina_1_1SafePointeeBase.html">regina::SafePointeeBase</a>&lt; <a class="el" href="classregina_1_1NPacket.html">NPacket</a>  &gt;::<a class="el" href="classregina_1_1SafePointeeBase.html#a2e4bacf91fc79a12ae3a02f4339ed034">SafePointeeType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of object being pointed to. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a34b1a14249599521a259590eb21919b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">regina::NScript::NScript </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialises to a script with no text and no variables. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5e0cb585d2797781e9046a0b7363037e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::addTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associates the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given tag is not the empty string.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was successfully added, or <code>false</code> if the given tag was already present beforehand. </dd></dl>

</div>
</div>
<a class="anchor" id="abad34c67c09d44c818d420335b765c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NScript::addVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new variable to be associated with this script. </p>
<p>If a variable with the given name is already stored, this routine will do nothing.</p>
<dl class="section warning"><dt>Warning</dt><dd>The index of the new variable might not be <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a>-1, and this operation may change the indices of other variables also. This is because (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the new variable. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the new variable; this is allowed to be <code>null</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the variable was successfully added, or <code>false</code> if a variable with the given name was already stored. </dd></dl>

</div>
</div>
<a class="anchor" id="a4917da7d951cab95f76a758d1e136a3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NPacket::adornedLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>adornment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label of this packet adorned with the given string. </p>
<p>An adornment typically shows how a packet has been created and/or modified. For instance, the <em>adornment</em> argument might be "Filled", or "Summand #1".</p>
<p>The way in which the packet label is adorned depends upon the label itself (in particular, an empty packet label will be handled in a sensible way). The way in which the packet label is adorned is subject to change in future versions of Regina.</p>
<p>Note that, whilst this routine returns a modified version of the packet label, the label itself will not be permamently changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adornment</td><td>the string that will be used to adorn this packet label. The adornment should just be a piece of English, ideally beginning with an upper-case letter. It should not contain any surrounding punctuation such as brackets or a dash (this will be added automatically by this routine as required). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the packet label with the given adornment. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5f61ed8b5993b62ad6cef33f22ed2bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>extraText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the given text to the end of this script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraText</td><td>the text to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c9d1dbbbf461a83ed5462ca8ccbf3d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childrenToBeReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the child packets directly beneath the packet are to be reordered. </p>
<p>Once the reordering is done, <a class="el" href="classregina_1_1NPacketListener.html#a6aa1208d006f04ed5af5b66e8071ce52" title="Called after the child packets directly beneath the packet have been reordered.">childrenWereReordered()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6aa1208d006f04ed5af5b66e8071ce52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childrenWereReordered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the child packets directly beneath the packet have been reordered. </p>
<p>Before this reordering is done, <a class="el" href="classregina_1_1NPacketListener.html#a7c9d1dbbbf461a83ed5462ca8ccbf3d3" title="Called before the child packets directly beneath the packet are to be reordered.">childrenToBeReordered()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89183b3ae551965e76283e778e50ffb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childToBeAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be inserted directly beneath the packet. </p>
<p>Once the child is removed, <a class="el" href="classregina_1_1NPacketListener.html#a141ebb1a70eaa6c480384e7279f05be7" title="Called after a child packet has been inserted directly beneath the packet.">childWasAdded()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52776d58f609476ba7edf815b655c66f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childToBeRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inParentDestructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before a child packet is to be removed from directly beneath the packet. </p>
<p>Note that the child packet may be about to be destroyed (although this destruction will not have happened yet). Once the child is removed, <a class="el" href="classregina_1_1NPacketListener.html#af1041557579bc597bffa71f439a3715d" title="Called after a child packet has been removed from directly beneath the packet.">childWasRemoved()</a> will be called also.</p>
<p>Note also that this packet (the parent) may have already entered its destructor (which removes and destroys all child packets as a matter of course). In this situation it may be unsafe to query or update this packet, and so the third argument <em>inParentDestructor</em> is provided to indicate such a situation.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be removed. </td></tr>
    <tr><td class="paramname">inParentDestructor</td><td>set to <code>true</code> if the parent packet is in fact being destroyed, and the child was simply removed as part of the standard subtree destruction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53eda2c859b77584a42a27dc2d78f757"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before one of this packet's immediate children has its label or tags changed. </p>
<p>Before this change, <a class="el" href="classregina_1_1NPacketListener.html#a53eda2c859b77584a42a27dc2d78f757" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet to be renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classregina_1_1NPacketListener.html#a960599d63ebd88e2832a5cf24d6870e2" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a141ebb1a70eaa6c480384e7279f05be7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childWasAdded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been inserted directly beneath the packet. </p>
<p>Before this child is added, <a class="el" href="classregina_1_1NPacketListener.html#a89183b3ae551965e76283e778e50ffb9" title="Called before a child packet is to be inserted directly beneath the packet.">childToBeAdded()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1041557579bc597bffa71f439a3715d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childWasRemoved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inParentDestructor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after a child packet has been removed from directly beneath the packet. </p>
<p>Note that the child packet may be about to be destroyed (although this destruction will not have happened yet). Before this child is removed, <a class="el" href="classregina_1_1NPacketListener.html#a52776d58f609476ba7edf815b655c66f" title="Called before a child packet is to be removed from directly beneath the packet.">childToBeRemoved()</a> will be called also.</p>
<p>Note also that this packet (the parent) may have already entered its destructor (which removes and destroys all child packets as a matter of course). In this situation it may be unsafe to query or update this packet, and so the third argument <em>inParentDestructor</em> is provided to indicate such a situation.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was removed. </td></tr>
    <tr><td class="paramname">inParentDestructor</td><td>set to <code>true</code> if the parent packet is in fact being destroyed, and the child was simply removed as part of the standard subtree destruction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0257f935e799ef8d31e5a78125b6b56"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::childWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after one of this packet's immediate children has its label or tags changed. </p>
<p>Before this change, <a class="el" href="classregina_1_1NPacketListener.html#a53eda2c859b77584a42a27dc2d78f757" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
    <tr><td class="paramname">child</td><td>the child packet that was renamed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classregina_1_1NPacketListener.html#aa24fb84cc5748e601f6c6933e3170427" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5710fe602185e8373137fa4cd384497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cloneDescendants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clones this packet (and possibly its descendants), assigns to it a suitable unused label and inserts the clone into the tree as a sibling of this packet. </p>
<p>Note that any string tags associated with this packet will <em>not</em> be cloned.</p>
<p>If this packet has no parent in the tree structure, no clone will be created and 0 will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cloneDescendants</td><td><code>true</code> if the descendants of this packet should also be cloned and inserted as descendants of the new packet. If this is passed as <code>false</code> (the default), only this packet will be cloned. </td></tr>
    <tr><td class="paramname">end</td><td><code>true</code> if the new packet should be inserted at the end of the parent's list of children (the default), or <code>false</code> if the new packet should be inserted as the sibling immediately after this packet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly inserted packet, or 0 if this packet has no parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6339c4befbc2d0af0afbde58a647e3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NPacket::countChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of immediate children of this packet. </p>
<p>Grandchildren and so on are not counted.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of immediate children. </dd></dl>

</div>
</div>
<a class="anchor" id="afa644bb246d322bd7dac4f4d2cf724e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NPacket::countDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the total number of descendants of this packet. </p>
<p>This includes children, grandchildren and so on. This packet is not included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total number of descendants. </dd></dl>

</div>
</div>
<a class="anchor" id="a5256367617decaaec86e576148377550"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NScript::countVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the number of variables associated with this script. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of variables. </dd></dl>

</div>
</div>
<a class="anchor" id="aef86d443c1fc9aacd3e12fc3673ffefd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NScript::dependsOnParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet depends upon its parent. </p>
<p>This is true if the parent cannot be altered without invalidating or otherwise upsetting this packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet depends on its parent. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NPacket.html#aa618b9e7c41ba71c08e0c7541016b34c">regina::NPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a32299f4324901625192bff989009f8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NPacket.html">NPacket</a> , false  &gt;::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a detailed text representation of this object. </p>
<p>This text may span many lines, and should provide the user with all the information they could want. It should be human-readable, should not contain extremely long lines (which cause problems for users reading the output in a terminal), and should end with a final newline. There are no restrictions on the underlying character set.</p>
<dl class="section return"><dt>Returns</dt><dd>a detailed text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aeee7d9515989d0cae606417e0dc7977b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a739735e7e14210bfe6bfae73462b61d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::findPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the packet with the requested label in the tree or subtree for which this packet is matriarch. </p>
<p>Note that label comparisons are case sensitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the label to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet with the requested label, or 0 if there is no such packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a7a96877b914831a3eddd13c599aac8e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::firstChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the first child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the first child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6022063291c8044eef5758d976b4e7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1NPacket.html#a3ee185d31ded84f3e7246023fede9326" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a class="anchor" id="a010846115ef964b4dc0a04f10b86099c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::firstTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the first packet of the requested type in a complete depth-first iteration of the tree structure. </p>
<p>Note that this packet <b>must</b> be the matriarch of the entire tree.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1NPacket.html#a3ee185d31ded84f3e7246023fede9326" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first such packet, or 0 if there are no packets of the requested type. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a96607c37a9a5979419577dbfc2e427"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NPacket::fullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a descriptive text string for the packet. </p>
<p>The string is of the form <em>label (packet-type)</em>.</p>
<p>The packet label will be adjusted for human-readable output according to the behaviour of <a class="el" href="classregina_1_1NPacket.html#a92807c5524cc215180d0ccf2ee35d5e4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">humanLabel()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the descriptive text string. </dd></dl>

</div>
</div>
<a class="anchor" id="a61fbb3bad5370af279c2c25cd7a9f9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::getFirstTreeChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines the first child of this packet in the tree structure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000265">Deprecated:</a></b></dt><dd>This routine has been renamed as <a class="el" href="classregina_1_1NPacket.html#a7a96877b914831a3eddd13c599aac8e9" title="Determines the first child of this packet in the tree structure.">firstChild()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a7a96877b914831a3eddd13c599aac8e9" title="Determines the first child of this packet in the tree structure.">firstChild()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c667fb13f6f6e899925f415deae5b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NPacket::getFullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns a descriptive text string for the packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000260">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#a1a96607c37a9a5979419577dbfc2e427" title="Returns a descriptive text string for the packet.">fullName()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a1a96607c37a9a5979419577dbfc2e427" title="Returns a descriptive text string for the packet.">fullName()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a1db06ba0ae66e7e8212a54bbf6edc31b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NPacket::getHumanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000258">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#a92807c5524cc215180d0ccf2ee35d5e4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">humanLabel()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a92807c5524cc215180d0ccf2ee35d5e4" title="Returns the label associated with this individual packet, adjusted if necessary for human-readable ou...">humanLabel()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e63dd84107d122fb73b7507418d32e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::getLastTreeChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines the last child of this packet in the tree structure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000266">Deprecated:</a></b></dt><dd>This routine has been renamed as <a class="el" href="classregina_1_1NPacket.html#a771df6092ae6b9f10f16da825ce86c1e" title="Determines the last child of this packet in the tree structure.">lastChild()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a771df6092ae6b9f10f16da825ce86c1e" title="Determines the last child of this packet in the tree structure.">lastChild()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a86dfaeeafb4dde526b242edf85c3d639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::getNextTreeSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines the next sibling of this packet in the tree structure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000267">Deprecated:</a></b></dt><dd>This routine has been renamed as <a class="el" href="classregina_1_1NPacket.html#aaab35c406432a69d7d3e7a72f9309605" title="Determines the next sibling of this packet in the tree structure.">nextSibling()</a>. See the <a class="el" href="classregina_1_1NPacket.html#aaab35c406432a69d7d3e7a72f9309605" title="Determines the next sibling of this packet in the tree structure.">nextSibling()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a1542ecdb7e1839352d7590f227960532"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NPacket::getNumberOfChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of immediate children of this packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000270">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#ad6339c4befbc2d0af0afbde58a647e3d" title="Returns the number of immediate children of this packet.">countChildren()</a>. See the <a class="el" href="classregina_1_1NPacket.html#ad6339c4befbc2d0af0afbde58a647e3d" title="Returns the number of immediate children of this packet.">countChildren()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7599793aa002286457bf189eac7d86f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NPacket::getNumberOfDescendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the total number of descendants of this packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000271">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#afa644bb246d322bd7dac4f4d2cf724e2" title="Returns the total number of descendants of this packet.">countDescendants()</a>. See the <a class="el" href="classregina_1_1NPacket.html#afa644bb246d322bd7dac4f4d2cf724e2" title="Returns the total number of descendants of this packet.">countDescendants()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4f65b5f4279e63cd7d30885852212ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NScript::getNumberOfVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the number of variables associated with this script. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000275">Deprecated:</a></b></dt><dd>Simply call <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ae20d0067e661345706c28fe0a1aea7c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NPacket::getPacketLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the label associated with this individual packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000257">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#ad6812ba7b54606e23958b99504d70f75" title="Returns the label associated with this individual packet.">label()</a>. See the <a class="el" href="classregina_1_1NPacket.html#ad6812ba7b54606e23958b99504d70f75" title="Returns the label associated with this individual packet.">label()</a> documentation for further information. </dd></dl>

</div>
</div>
<a class="anchor" id="a524301515201a2d8b9d70f89c13c2d97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::NPacket::getPacketType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the unique integer ID representing this type of packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000255">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#ad28b0f0a68dced31285645498ccb7c72" title="Returns the unique integer ID representing this type of packet.">type()</a>. See the <a class="el" href="classregina_1_1NPacket.html#ad28b0f0a68dced31285645498ccb7c72" title="Returns the unique integer ID representing this type of packet.">type()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bcdbf61ec4119c7b3eb6225c55289c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NPacket::getPacketTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns an English name for this type of packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000256">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#a3ee185d31ded84f3e7246023fede9326" title="Returns an English name for this type of packet.">typeName()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a3ee185d31ded84f3e7246023fede9326" title="Returns an English name for this type of packet.">typeName()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a992abb90683f101e998d21649293097c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::getPrevTreeSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines the previous sibling of this packet in the tree structure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000268">Deprecated:</a></b></dt><dd>This routine has been renamed as <a class="el" href="classregina_1_1NPacket.html#a964ca5a391da9ba97a28bf8ce09169fd" title="Determines the previous sibling of this packet in the tree structure.">prevSibling()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a964ca5a391da9ba97a28bf8ce09169fd" title="Determines the previous sibling of this packet in the tree structure.">prevSibling()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="aabc6a7ec715a14ce0f2411ba91b98b66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::NPacket::getTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the set of all tags associated with this packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000263">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#ae54ddd1b295d93159fd7f370d5edff5d" title="Returns the set of all tags associated with this packet.">tags()</a>. See the <a class="el" href="classregina_1_1NPacket.html#ae54ddd1b295d93159fd7f370d5edff5d" title="Returns the set of all tags associated with this packet.">tags()</a> documentation for further information. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0d186b82b38d43a44d11dc0730b1950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NScript::getText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the complete text of this script. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000274">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NScript.html#aec52f5941f29b2019ff911129b2ea451" title="Returns the complete text of this script.">text()</a>. See the <a class="el" href="classregina_1_1NScript.html#aec52f5941f29b2019ff911129b2ea451" title="Returns the complete text of this script.">text()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="af2edae1d3931f5f8f42d7f5799032b9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NPacket::getTotalTreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the total number of packets in the tree or subtree for which this packet is matriarch. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000272">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#a6eb680541a4021ebdf7877c3f31c6fda" title="Determines the total number of packets in the tree or subtree for which this packet is matriarch...">totalTreeSize()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a6eb680541a4021ebdf7877c3f31c6fda" title="Determines the total number of packets in the tree or subtree for which this packet is matriarch...">totalTreeSize()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3d69c4dc206299fc04d4679ebd44b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::getTreeMatriarch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines the root of the tree to which this packet belongs. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000269">Deprecated:</a></b></dt><dd>This routine has been renamed as <a class="el" href="classregina_1_1NPacket.html#ae15190121c229f76772486137851f2df" title="Determines the root of the tree to which this packet belongs.">root()</a>. See the <a class="el" href="classregina_1_1NPacket.html#ae15190121c229f76772486137851f2df" title="Determines the root of the tree to which this packet belongs.">root()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e5946d58d66677fb690f1288c0fb1e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::getTreeParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that determines the parent packet in the tree structure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000264">Deprecated:</a></b></dt><dd>This routine has been renamed as <a class="el" href="classregina_1_1NPacket.html#a856e7edef86f7dbd99470b01f632890f" title="Determines the parent packet in the tree structure.">parent()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a856e7edef86f7dbd99470b01f632890f" title="Determines the parent packet in the tree structure.">parent()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7f6a1b7f37eb1317556776e3be8b32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long regina::NScript::getVariableIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the index of the variable stored with the given name. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000277">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NScript.html#aadc2b02d900a4c0ecb815656b110d9c4" title="Returns the index of the variable stored with the given name.">variableIndex()</a>. See the <a class="el" href="classregina_1_1NScript.html#aadc2b02d900a4c0ecb815656b110d9c4" title="Returns the index of the variable stored with the given name.">variableIndex()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="abd2ac72f3054a8426ddd1d39e03b0f4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NScript::getVariableName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the name of the requested variable associated with this script. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000276">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NScript.html#adc9f6f0ca643276f6e534303f3e1d0a8" title="Returns the name of the requested variable associated with this script.">variableName()</a>. See the <a class="el" href="classregina_1_1NScript.html#adc9f6f0ca643276f6e534303f3e1d0a8" title="Returns the name of the requested variable associated with this script.">variableName()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a76679032607a9667b796828da1214ed4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NScript::getVariableValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the value of the requested variable associated with this script. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000278">Deprecated:</a></b></dt><dd>This routine has been renamed to variableValue(size_t). See the variableValue(size_t) documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="affe177e799190d06cceb6835e8e679f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NScript::getVariableValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that returns the value of the variable stored with the given name. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000279">Deprecated:</a></b></dt><dd>This routine has been renamed to variableValue(const std::string&amp;). See the variableValue(const std::string&amp;) documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ba25faf0d3ac4985638294c0b1373ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::hasOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether some other object in the calculation engine is responsible for ultimately destroying this object. </p>
<p>For packets, this returns <code>true</code> if and only if this packet has a parent in the packet tree (i.e., is not the root).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if some other object owns this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ce882d31d89c0e24145250f7f62c7dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::hasTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has the given associated tag. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag is found, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bcb3f3580be7b65a85b072d0ea51fa2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::hasTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet has any associated tags at all. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this packet has any tags, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a92807c5524cc215180d0ccf2ee35d5e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NPacket::humanLabel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet, adjusted if necessary for human-readable output. </p>
<p>In particular, if the packet has no label assigned then this routine will return "(no label)", not the empty string.</p>
<dl class="section warning"><dt>Warning</dt><dd>The method by which this routine adjusts packet labels is subject to change in future versions of Regina.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a class="anchor" id="acd9091622a408e6497e407898197870b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::insertChildAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>newChild</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>prevChild</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as a child of this packet at the given location in this packet's child list. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Parameter <em>newChild</em> has no parent packet. </dd>
<dd>
Parameter <em>prevChild</em> is already a child of this packet. </dd>
<dd>
This packet is not a descendant of <em>newChild</em>.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="classregina_1_1NPacket.html#ac194ef0daec9167e940e508cc821fec3" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newChild</td><td>the child to insert. </td></tr>
    <tr><td class="paramname">prevChild</td><td>the preexisting child of this packet after which <em>newChild</em> will be inserted, or 0 if <em>newChild</em> is to be the first child of this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a277d303fc31e81df03e809bb46249ae4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::insertChildFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as the first child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="classregina_1_1NPacket.html#ac194ef0daec9167e940e508cc821fec3" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65ff2c517431624443b47b542f319a97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::insertChildLast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts the given packet as the last child of this packet. </p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given child has no parent packet. </dd>
<dd>
This packet is not a descendant of the given child.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Since this packet takes ownership of the given child packet, the python object containing the given child packet becomes a null object and should no longer be used. See <a class="el" href="classregina_1_1NPacket.html#ac194ef0daec9167e940e508cc821fec3" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> for a way of avoiding these problems in some cases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the child to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55d6d4b71ba3dbf0c5ab0a5330c04364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NScript::internalClonePacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a newly allocated copy of this packet. </p>
<p>This routine should <b>not</b> insert the new packet into the tree structure, clone the packet's associated tags or give the packet a label. It should also not clone any descendants of this packet.</p>
<p>You may assume that the new packet will eventually be inserted into the tree beneath either the same parent as this packet or a clone of that parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>the parent beneath which the new packet will eventually be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly allocated packet. </dd></dl>

<p>Implements <a class="el" href="classregina_1_1NPacket.html#a4bdd767363de0f316247d347286d3724">regina::NPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a4610a242eaa65affcbf6d36fadae4469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string regina::NPacket::internalID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a unique string ID that identifies this packet. </p>
<p>The user has no control over this ID, and it is not human readable. It is guaranteed to remain fixed throughout the lifetime of the program for a given packet, and it is guaranteed not to clash with the ID of any other packet.</p>
<p>If you change the contents of a packet, its ID will not change.</p>
<p>If you clone a packet, the new clone will receive a different ID. If you save and then load a packet to/from file, the ID will change. These behaviours are necessary to ensure that IDs remain unique (since, for instance, you could load several copies of the same data file into memory simultaneously).</p>
<p>The ID is implemented as an encoding of the underlying C++ pointer. This encoding is subject to change in later versions of Regina.</p>
<dl class="section return"><dt>Returns</dt><dd>a unique ID that identifies this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a76110767102577c503a4c51216da9f2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::isGrandparentOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this packet is equal to or an ancestor of the given packet in the tree structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the other packet whose relationships we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet is equal to or an ancestor of <code>descendant</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5002bc9d655d3290a5db551f1cc3d09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::isListening </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacketListener.html">NPacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the given packet listener is currently listening for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1NPacketListener.html" title="An object that can be registered to listen for packet events.">NPacketListener</a> class notes for details.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener is currently registered with this packet, or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a57ed80a20a1f787078cb49fe578e219b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::isPacketEditable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether this packet can be altered without invalidating or otherwise upsetting any of its immediate children. </p>
<p>Descendants further down the packet tree are not (and should not need to be) considered.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if this packet may be edited. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6812ba7b54606e23958b99504d70f75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NPacket::label </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the label associated with this individual packet. </p>
<p>An example is <code>MyTriangulation</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>this individual packet's label. </dd></dl>

</div>
</div>
<a class="anchor" id="a771df6092ae6b9f10f16da825ce86c1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::lastChild </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the last child of this packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the last child packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="aa59dfe7ee56c3161d74ede4bc372ff9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NPacket::levelsDownTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given descendant in the tree structure. </p>
<p>If <code>descendant</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>descendant</code>, or can be obtained from <code>descendant</code> using only child-to-parent steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f5d15832e3d2dd7c926e23012fd273e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned regina::NPacket::levelsUpTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>ancestor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of levels between this packet and its given ancestor in the tree structure. </p>
<p>If <code>ancestor</code> is this packet, the number of levels is zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet is equal to <code>ancestor</code>, or can be obtained from <code>ancestor</code> using only parent-to-child steps.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ancestor</td><td>the packet whose relationship with this packet we are examining. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of levels difference. </dd></dl>

</div>
</div>
<a class="anchor" id="abbb59f7b470a87e0cacb9cfe3baeebe4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::listen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacketListener.html">NPacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers the given packet listener to listen for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1NPacketListener.html" title="An object that can be registered to listen for packet events.">NPacketListener</a> class notes for details.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to register. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully registered, or <code>false</code> if the given listener was already registered beforehand. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bdd6fcc326b3ee2e322d8efb229a933"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::makeOrphan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own tree. </p>
<p>The tree information for both this packet and its parent will be updated.</p>
<p>This routine takes small constant time.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet has a parent. </dd>
<dd>
This packet does not depend on its parent; see <a class="el" href="classregina_1_1NPacket.html#aa618b9e7c41ba71c08e0c7541016b34c" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>After <a class="el" href="classregina_1_1NPacket.html#a6bdd6fcc326b3ee2e322d8efb229a933" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> is called, this packet will become the root of a new packet tree that is owned by Python. In particular, if you call <a class="el" href="classregina_1_1NPacket.html#a6bdd6fcc326b3ee2e322d8efb229a933" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and then delete all Python references to this packet, the entire packet subtree will be automatically destroyed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b2254e0d113513f54bce1f56a4c6823"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string regina::NPacket::makeUniqueLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> a new label that cannot be found anywhere in the entire tree structure. </p>
<p>This packet need not be the tree matriarch; this routine will search the entire tree to which this packet belongs.</p>
<p>The new label will consist of the given base, possibly followed by a space and a number.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000261">Deprecated:</a></b></dt><dd>This routine is deprecated, since (as of Regina 4.95) packet labels in a data file are no longer required to be distinct.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>a string upon which the new label will be based. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new unique label. </dd></dl>

</div>
</div>
<a class="anchor" id="aaedd6802aad09426e8dbc7d7f4534b45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> bool regina::NPacket::makeUniqueLabels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that all packet labels in both this and the given packet tree combined are distinct. </p>
<p>If two packets have the same label, one will be renamed by adding a space and a number.</p>
<p>Packets in the given packet tree will be given priority over the labels; that is, if a packet in this tree has the same label as a packet in the given tree, it will be the packet in this tree that is renamed.</p>
<p>The given packet tree may be <code>null</code>, in which case only this tree will be examined.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000262">Deprecated:</a></b></dt><dd>This routine is deprecated, since (as of Regina 4.95) packet labels in a data file are no longer required to be distinct.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>This and the given packet belong to different packet trees, and are each matriarchs in their respective trees.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>the packet tree with which to compare this tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if any of the packets were relabelled. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e07adb86d0338f6f8627481d9693783"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::moveDown </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the end of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very end of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a class="anchor" id="aac8dfd5040948775414d47cc33bd9b0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::moveToFirst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet to be the first in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a class="anchor" id="a9986615a783903c5b96aa00302d4b9fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::moveToLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet to be the last in its sibling list. </p>
<p>This routine takes small constant time. </p>

</div>
</div>
<a class="anchor" id="a9ac4f9b12b0e61f360208f976d6d763d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::moveUp </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>steps</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves this packet the given number of steps towards the beginning of its sibling list. </p>
<p>If the number of steps is larger than the greatest possible movement, the packet will be moved to the very beginning of its sibling list.</p>
<p>This routine takes time proportional to the number of steps.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given number of steps is strictly positive. </dd></dl>

</div>
</div>
<a class="anchor" id="aaab35c406432a69d7d3e7a72f9309605"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::nextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the next sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that follows this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the next sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="a64a119d2fe5ba78443b60bae54b5f24b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="a28b1427eef08ea4baedd39e6601a9e72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::nextTreePacket </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this in a complete depth-first iteration of the entire tree structure to which this packet belongs. </p>
<p>Note that this packet need not be the tree matriarch.</p>
<p>A parent packet is always reached before its children. The tree matriarch will be the first packet visited in a complete depth-first iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>the next packet, or 0 if this is the last packet in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a0aec78b65154d490bef565f10f9ffe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="classregina_1_1NPacket.html#ac6022063291c8044eef5758d976b4e7e" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1NPacket.html#a3ee185d31ded84f3e7246023fede9326" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="a529d18cddcfd9d3596f24d084bb6c179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::nextTreePacket </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the next packet after this of the requested type in a complete depth-first iteration of the entire tree structure. </p>
<p>Note that this packet need not be the tree matriarch. The order of tree searching is described in <a class="el" href="classregina_1_1NPacket.html#ac6022063291c8044eef5758d976b4e7e" title="Finds the first packet of the requested type in a complete depth-first iteration of the tree structur...">firstTreePacket()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of packet to search for, as returned by <a class="el" href="classregina_1_1NPacket.html#a3ee185d31ded84f3e7246023fede9326" title="Returns an English name for this type of packet.">typeName()</a>. Note that string comparisons are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next such packet, or 0 if this is the last packet of the requested type in such an iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="a708c4e6c2d763c24ca4b2d3f88fcf07f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::packetToBeChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the contents of the packet are to be changed. </p>
<p>Once the contents are changed, <a class="el" href="classregina_1_1NPacketListener.html#af3d9467da604c2bb0597aea1919893db" title="Called after the contents of the packet have been changed.">packetWasChanged()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad64a203987c3371ed09b0a58bf236da0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NScript::packetToBeDestroyed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet is about to be destroyed. </p>
<p>Note that there is no matching function called <em>after</em> the packet is destroyed, since the set of listeners will no longer be available at that stage.</p>
<p>When an entire packet subtree is to be destroyed, child packets will notify their listeners of the impending destruction before parent packets will.</p>
<p>Note that the packet will forcibly unregister this listener immediately <em>before</em> <a class="el" href="classregina_1_1NScript.html#ad64a203987c3371ed09b0a58bf236da0" title="Called before the packet is about to be destroyed.">packetToBeDestroyed()</a> is called, to avoid any unpleasant consequences if this listener should also try to unregister itself. This means that, by the time this routine is called, this listener will no longer be registered with the packet in question (and any attempt to unregister it again will be harmless).</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NPacketListener.html#a693f0ef2feaf7a5456436a9c6c803fd5">regina::NPacketListener</a>.</p>

</div>
</div>
<a class="anchor" id="a960599d63ebd88e2832a5cf24d6870e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::packetToBeRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called before the packet label or tags are to be changed. </p>
<p>Once the label or tags are changed, <a class="el" href="classregina_1_1NPacketListener.html#aa24fb84cc5748e601f6c6933e3170427" title="Called after the packet label or tags have been changed.">packetWasRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classregina_1_1NPacketListener.html#a53eda2c859b77584a42a27dc2d78f757" title="Called before one of this packet&#39;s immediate children has its label or tags changed.">childToBeRenamed()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3d9467da604c2bb0597aea1919893db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::packetWasChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the contents of the packet have been changed. </p>
<p>Before the contents are changed, <a class="el" href="classregina_1_1NPacketListener.html#a708c4e6c2d763c24ca4b2d3f88fcf07f" title="Called before the contents of the packet are to be changed.">packetToBeChanged()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classregina_1_1NSnapPeaTriangulation.html#a4759b10f75e0eedf47346a816ca9f639">regina::NSnapPeaTriangulation</a>.</p>

</div>
</div>
<a class="anchor" id="afc35bac12fca88767b9419793c69438f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NScript::packetWasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>packet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called after the packet label or tags have been changed. </p>
<p>Before the label or tags are changed, <a class="el" href="classregina_1_1NPacketListener.html#a960599d63ebd88e2832a5cf24d6870e2" title="Called before the packet label or tags are to be changed.">packetToBeRenamed()</a> will be called also.</p>
<p>The default implementation of this routine is to do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>the packet being listened to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classregina_1_1NPacketListener.html#aa0257f935e799ef8d31e5a78125b6b56" title="Called after one of this packet&#39;s immediate children has its label or tags changed.">childWasRenamed()</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NPacketListener.html#aa24fb84cc5748e601f6c6933e3170427">regina::NPacketListener</a>.</p>

</div>
</div>
<a class="anchor" id="a856e7edef86f7dbd99470b01f632890f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the parent packet in the tree structure. </p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the parent packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="a964ca5a391da9ba97a28bf8ce09169fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> * regina::NPacket::prevSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the previous sibling of this packet in the tree structure. </p>
<p>This is the child of the parent that precedes this packet.</p>
<p>This routine takes small constant time.</p>
<dl class="section return"><dt>Returns</dt><dd>the previous sibling of this packet, or 0 if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="af7901227fe61ee9c38f5711ae71bed75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::removeAllTags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all associated tags from this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet. </p>

</div>
</div>
<a class="anchor" id="a0bfad9c173932b86d8408b49f63a5033"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::removeAllVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all variables associated with this script. </p>

</div>
</div>
<a class="anchor" id="aaf11fa9bb6d364deb8d18f1eba9733d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::removeTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the association of the given tag with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given tag was removed, or <code>false</code> if the given tag was not actually associated with this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a3bc75dde3d4541b26292c1b6edaebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::removeVariable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the variable stored with the given name. </p>
<p>If no variable is stored with the given name, this routine will do nothing.</p>
<dl class="section warning"><dt>Warning</dt><dd>This may change the indices of other variables, since (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the variable to remove; note that names are case sensitive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d05a79414057bad3dbd43afaebfd09d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::removeVariable </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the variable stored at the given index. </p>
<dl class="section warning"><dt>Warning</dt><dd>This may change the indices of other variables, since (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable to remove; this must be between 0 and <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac194ef0daec9167e940e508cc821fec3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::reparent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>newParent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given packet instead. </p>
<p>This routine is essentially a combination of <a class="el" href="classregina_1_1NPacket.html#a6bdd6fcc326b3ee2e322d8efb229a933" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> followed by either <a class="el" href="classregina_1_1NPacket.html#a277d303fc31e81df03e809bb46249ae4" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> or <a class="el" href="classregina_1_1NPacket.html#a65ff2c517431624443b47b542f319a97" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>.</p>
<p>This routine takes small constant time. It is safe to use regardless of whether this packet has a parent or not.</p>
<p>If you wish to reparent <em>all</em> of the children of a given packet, see <a class="el" href="classregina_1_1NPacket.html#ad7e217abe1bb4c24efba56980b687103" title="Cuts all of this packet&#39;s children out of the packet tree, and reinserts them as children of the give...">transferChildren()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend on its parent; see <a class="el" href="classregina_1_1NPacket.html#aa618b9e7c41ba71c08e0c7541016b34c" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>This routine is much simpler than combinations of <a class="el" href="classregina_1_1NPacket.html#a6bdd6fcc326b3ee2e322d8efb229a933" title="Cuts this packet away from its parent in the tree structure and instead makes it matriarch of its own...">makeOrphan()</a> and <a class="el" href="classregina_1_1NPacket.html#a277d303fc31e81df03e809bb46249ae4" title="Inserts the given packet as the first child of this packet.">insertChildFirst()</a> / <a class="el" href="classregina_1_1NPacket.html#a65ff2c517431624443b47b542f319a97" title="Inserts the given packet as the last child of this packet.">insertChildLast()</a>, since there are no unpleasant ownership issues to deal with. However, if this packet currently has no parent then the ownership issues are unavoidable; in this case <a class="el" href="classregina_1_1NPacket.html#ac194ef0daec9167e940e508cc821fec3" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> will do nothing, and one of the insertChild...() routines must be used instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent of this packet, i.e., the packet beneath which this packet will be inserted. </td></tr>
    <tr><td class="paramname">first</td><td><code>true</code> if this packet should be inserted as the first child of the given parent, or <code>false</code> (the default) if it should be inserted as the last child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae15190121c229f76772486137851f2df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NPacket::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the root of the tree to which this packet belongs. </p>
<dl class="section return"><dt>Returns</dt><dd>the matriarch of the packet tree. </dd></dl>

</div>
</div>
<a class="anchor" id="aa174541f04c1fcb251134e22f20010ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::save </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the subtree rooted at this packet to the given Regina data file, using Regina's native XML file format. </p>
<p>The XML file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>This is the preferred way of saving a Regina data file. Typically this will be called from the root of the packet tree, which will save the entire packet tree to file.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Internationalisation:</dt><dd>This routine makes no assumptions about the <a class="el" href="i18n.html">character encoding</a> used in the given file <em>name</em>, and simply passes it through unchanged to low-level C/C++ file I/O routines. The <em>contents</em> of the file will be written using UTF-8.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the pathname of the file to write to. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the file was successfully written. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f48894741c5c4ed5e1ddc20a922589d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream, in the format of a Regina XML data file. </p>
<p>The data file may be optionally compressed (Regina can happily read both compressed and uncompressed XML).</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the given output stream.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The given stream is open for writing. </dd>
<dd>
The given packet does not depend on its parent.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>the output stream to which to write. </td></tr>
    <tr><td class="paramname">compressed</td><td><code>true</code> if the XML data should be compressed, or <code>false</code> if it should be written as plain text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if and only if the data was successfully written. </dd></dl>

</div>
</div>
<a class="anchor" id="a18670dfbd03cabf3404a580f740c7307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::setLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the label associated with this individual packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">label</td><td>the new label to give this packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ba7fe518f9651b8071c9f6755f41616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::setPacketLabel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated routine that sets the label associated with this individual packet. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000259">Deprecated:</a></b></dt><dd>This routine has been renamed to <a class="el" href="classregina_1_1NPacket.html#a18670dfbd03cabf3404a580f740c7307" title="Sets the label associated with this individual packet.">setLabel()</a>. See the <a class="el" href="classregina_1_1NPacket.html#a18670dfbd03cabf3404a580f740c7307" title="Sets the label associated with this individual packet.">setLabel()</a> documentation for further details. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b790b965eea38caa1d103ec6213565a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::setText </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the complete text of this script with the given string. </p>
<p>Variables are not considered part of the text; you can get and set them through other member functions (see below).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>the new text for this script. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f699e6b062971e3f11c39dd2d275cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::setVariableName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the name of an existing variable associated with this script. </p>
<dl class="section warning"><dt>Warning</dt><dd>This may change the indices of this and other variables, since (at present) variables are kept stored in sorted order by name.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable whose name should change; this must be between 0 and <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">name</td><td>the new name to assign to the variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a15b43b45968180c51a110c860a5cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::setVariableValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the value of an existing variable associated with this script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the variable whose value should change; this must be between 0 and <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
    <tr><td class="paramname">value</td><td>the new value to assign to the variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c48b6ee979b5ac3add40d4ed3e9ec9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::sortChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the immediate children of this packet according to their packet labels. </p>
<p>Note that this routine is not recursive (for instance, grandchildren will not be sorted within each child packet).</p>
<p>This routine takes quadratic time in the number of immediate children (and it's slow quadratic at that). </p>

</div>
</div>
<a class="anchor" id="a6f21792173936ce3a8da9c7e90ebcd49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NPacket.html">NPacket</a> , false  &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object. </p>
<p>This text should be human-readable, should fit on a single line, and should not end with a newline. Where possible, it should use plain ASCII characters.</p>
<dl class="section user"><dt>Python:</dt><dd>In addition to str(), this is also used as the Python "stringification" function <code>__str__()</code>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8f44cda2066838aaeae36d1128870d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::swapWithNextSibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps this packet with its next sibling in the sequence of children beneath their common parent packet. </p>
<p>Calling this routine is equivalent to calling <a class="el" href="classregina_1_1NPacket.html#a3e07adb86d0338f6f8627481d9693783" title="Moves this packet the given number of steps towards the end of its sibling list.">moveDown()</a>.</p>
<p>This routine takes small constant time.</p>
<p>If this packet has no next sibling then this routine does nothing. </p>

</div>
</div>
<a class="anchor" id="ae54ddd1b295d93159fd7f370d5edff5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; std::string &gt; &amp; regina::NPacket::tags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the set of all tags associated with this packet. </p>
<p>Each packet can have an arbitrary set of string tags associated with it. The tags are not used by this calculation engine; the feature is provided for whatever use a developer or user chooses to make of it.</p>
<p>Tags are case-sensitive. Tags associated with a single packet must be distinct, i.e., a particular tag cannot be associated more than once with the same packet.</p>
<dl class="section user"><dt>Python:</dt><dd>This routine returns a python list of strings.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the set of all tags associated with this packet. </dd></dl>

</div>
</div>
<a class="anchor" id="aec52f5941f29b2019ff911129b2ea451"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; regina::NScript::text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the complete text of this script. </p>
<p>Variables are not considered part of the text; you can get and set them through other member functions (see below).</p>
<dl class="section return"><dt>Returns</dt><dd>the complete text of this script. </dd></dl>

</div>
</div>
<a class="anchor" id="aea0ab182c97fe654b8929d1fe41dc564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NPacket.html">NPacket</a> , false  &gt;::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for str(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000253">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type str() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="af32f5abced4d1365c34980741b564765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NPacket.html">NPacket</a> , false  &gt;::toStringLong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated alias for detail(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000254">Deprecated:</a></b></dt><dd>This routine has (at long last) been deprecated; use the simpler-to-type detail() instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a long text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb680541a4021ebdf7877c3f31c6fda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t regina::NPacket::totalTreeSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the total number of packets in the tree or subtree for which this packet is matriarch. </p>
<p>This packet is included in the count.</p>
<dl class="section return"><dt>Returns</dt><dd>the total tree or subtree size. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7e217abe1bb4c24efba56980b687103"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::transferChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacket.html">NPacket</a> *&#160;</td>
          <td class="paramname"><em>newParent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuts all of this packet's children out of the packet tree, and reinserts them as children of the given packet instead. </p>
<p>The children of this packet will be appended to the end of the new parent's child list, in the same order as they were previously.</p>
<p>This is equivalent to calling <a class="el" href="classregina_1_1NPacket.html#ac194ef0daec9167e940e508cc821fec3" title="Cuts this packet away from its parent in the tree structure, and inserts it as a child of the given p...">reparent()</a> on each child, but should be somewhat faster if there are many children to move.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None of the children of this packet depend on their current parent; see <a class="el" href="classregina_1_1NPacket.html#aa618b9e7c41ba71c08e0c7541016b34c" title="Determines if this packet depends upon its parent.">dependsOnParent()</a> for details. </dd>
<dd>
The given parent is not a descendant of this packet.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newParent</td><td>the new parent beneath which the children will be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad28b0f0a68dced31285645498ccb7c72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__packet.html#ga982f45957b093a38120119066dc4cfef">PacketType</a> regina::NPacket::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the unique integer ID representing this type of packet. </p>
<p>This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type ID. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ee185d31ded84f3e7246023fede9326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string regina::NPacket::typeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> an English name for this type of packet. </p>
<p>An example is <code>NTriangulation</code>. This is the same for all packets of this class.</p>
<dl class="section return"><dt>Returns</dt><dd>the packet type name. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2cf0e995a7e1afcdd94288e83c410d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool regina::NPacket::unlisten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classregina_1_1NPacketListener.html">NPacketListener</a> *&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters the given packet listener so that it no longer listens for events on this packet. </p>
<p>See the <a class="el" href="classregina_1_1NPacketListener.html" title="An object that can be registered to listen for packet events.">NPacketListener</a> class notes for details.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the listener to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given listener was successfully unregistered, or <code>false</code> if the given listener was not registered in the first place. </dd></dl>

</div>
</div>
<a class="anchor" id="abe86b7cab396f34fd62351f8fd300868"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacketListener::unregisterFromAllPackets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters this listener from any packets to which it is currently listening. </p>

</div>
</div>
<a class="anchor" id="ae2c47d0d1d510c3b5aa5384ae31e2258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structregina_1_1Output.html">regina::Output</a>&lt; <a class="el" href="classregina_1_1NPacket.html">NPacket</a> , false  &gt;::utf8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a short text representation of this object using unicode characters. </p>
<p>Like str(), this text should be human-readable, should fit on a single line, and should not end with a newline. In addition, it may use unicode characters to make the output more pleasant to read. This string will be encoded in UTF-8.</p>
<dl class="section return"><dt>Returns</dt><dd>a short text representation of this object. </dd></dl>

</div>
</div>
<a class="anchor" id="aadc2b02d900a4c0ecb815656b110d9c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long regina::NScript::variableIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the index of the variable stored with the given name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the requested variable; note that names are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the requested variable as an integer between 0 and <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive, or -1 if there is no variable with the given name. </dd></dl>

</div>
</div>
<a class="anchor" id="adc9f6f0ca643276f6e534303f3e1d0a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; regina::NScript::variableName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the name of the requested variable associated with this script. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested variable; this must be between 0 and <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the requested variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a37a92f617943f045645f5ad24be523fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NScript::variableValue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the requested variable associated with this script. </p>
<p>Variables may take the value <code>null</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index of the requested variable; this must be between 0 and <a class="el" href="classregina_1_1NScript.html#a5256367617decaaec86e576148377550" title="Returns the number of variables associated with this script.">countVariables()</a>-1 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the requested variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c75ae8156d538aacabf16964cdc40b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classregina_1_1NPacket.html">NPacket</a>* regina::NScript::variableValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structregina_1_1Returns.html" title="A convenience base class for a non-void function object, which does nothing beyond provide a ReturnTy...">Returns</a> the value of the variable stored with the given name. </p>
<p>Variables may take the value <code>null</code>.</p>
<p>If no variable is stored with the given name, then <code>null</code> will likewise be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the name of the requested variable; note that names are case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the requested variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ebf217ae9b99509f300b113525cf6b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NScript::writeTextLong </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a detailed text representation of this object to the given output stream. </p>
<p>This may be reimplemented by subclasses, but the parent <a class="el" href="classregina_1_1NPacket.html" title="Represents a packet of information that may be individually edited or operated upon.">NPacket</a> class offers a reasonable default implementation.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classregina_1_1NPacket.html#a782a34fedd83c6331d04bd0b4f36414d">regina::NPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a571f9404f5e923481f2a38195fc0582f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NScript::writeTextShort </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a short text representation of this object to the given output stream. </p>
<p>This must be reimplemented by subclasses.</p>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which to write. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1NPacket.html#a6f4f28eee6c2594a3149c7f8c3353c86">regina::NPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a9becec8fc636e6729caddf7dd8cb9393"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::writeXMLFile </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes the subtree rooted at this packet to the given output stream in Regina's native XML file format. </p>
<p>Ths is similar to calling <a class="el" href="classregina_1_1NPacket.html#aa174541f04c1fcb251134e22f20010ab" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a>, except that (i) the user has a more flexible choice of output stream, and (ii) the XML will always be written in plain text (i.e., it will not be compressed).</p>
<p>If you simply wish to save your data to a file on the filesystem, you should call <a class="el" href="classregina_1_1NPacket.html#aa174541f04c1fcb251134e22f20010ab" title="Saves the subtree rooted at this packet to the given Regina data file, using Regina&#39;s native XML file...">save()</a> instead.</p>
<p>Typically this will be called from the root of the packet tree, which will write the entire packet tree to the output stream.</p>
<p>The output from this routine cannot be used as a piece of an XML file; it must be the entire XML file. For a piece of an XML file, see routine <a class="el" href="classregina_1_1NPacket.html#a7bf0a826a791331503e2aaa8566a36f7" title="Writes a chunk of XML containing the subtree with this packet as matriarch.">writeXMLPacketTree()</a> instead.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This packet does not depend upon its parent.</dd></dl>
<dl class="section user"><dt>Python:</dt><dd>Not present.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML data file should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e43efc5e7aa3d21ea07bdd722c397d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void regina::NScript::writeXMLPacketData </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the data for this packet only. </p>
<p>You may assume that the packet opening tag (including the packet type and label) has already been written, and that all child packets followed by the corresponding packet closing tag will be written immediately after this routine is called. This routine need only write the internal data stored in this specific packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classregina_1_1NPacket.html#a04ce3ed81545395ddf43167788cf086b">regina::NPacket</a>.</p>

</div>
</div>
<a class="anchor" id="a7bf0a826a791331503e2aaa8566a36f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void regina::NPacket::writeXMLPacketTree </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a chunk of XML containing the subtree with this packet as matriarch. </p>
<p>This is the preferred way of writing a packet tree to file.</p>
<p>The output from this routine is only a piece of XML; it should not be used as a complete XML file. For a complete XML file, see routine <a class="el" href="classregina_1_1NPacket.html#a9becec8fc636e6729caddf7dd8cb9393" title="Writes the subtree rooted at this packet to the given output stream in Regina&#39;s native XML file forma...">writeXMLFile()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>the output stream to which the XML should be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab5650a99566b9f27183154f96b65f2cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structregina_1_1FacetSpec.html">REGINA_DEPRECATED</a> typedef <a class="el" href="classregina_1_1NPacket_1_1ChangeEventSpan.html">ChangeEventSpan</a> regina::NPacket::ChangeEventBlock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A deprecated typedef for <a class="el" href="classregina_1_1NPacket_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a>. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000273">Deprecated:</a></b></dt><dd><a class="el" href="classregina_1_1NPacket_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a> is now the correct way to fire a "packet changed" event. The class <a class="el" href="classregina_1_1NPacket_1_1ChangeEventSpan.html" title="An object that facilitates firing packetToBeChanged() and packetWasChanged() events.">ChangeEventSpan</a> is similar to the old ChangeEventBlock except that it fires both <a class="el" href="classregina_1_1NPacketListener.html#a708c4e6c2d763c24ca4b2d3f88fcf07f" title="Called before the contents of the packet are to be changed.">NPacketListener::packetToBeChanged()</a> and <a class="el" href="classregina_1_1NPacketListener.html#af3d9467da604c2bb0597aea1919893db" title="Called after the contents of the packet have been changed.">NPacketListener::packetWasChanged()</a> (on construction and destruction respectively), and the old boolean argument <em>fireOnDestruction</em> is gone (events are now fired always). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>packet/<a class="el" href="nscript_8h.html">nscript.h</a></li>
</ul>
</div><!-- contents -->
<hr>
Copyright &copy; 1999-2016, The Regina development team
<br>
This software is released under the GNU General Public License,
with some additional permissions; see the source code for details.
<br>
For further information, or to submit a bug or other problem, please contact
Ben Burton (<a href="mailto:bab@maths.uq.edu.au">bab@maths.uq.edu.au</a>).
</body>
</html>
